diff --git a/herwigpp/2.4.2/Looptools/util/cache.c b/herwigpp/2.4.2/Looptools/util/cache.c
index 656f44c..ea6d7ca 100644
--- a/herwigpp/2.4.2/Looptools/util/cache.c
+++ b/herwigpp/2.4.2/Looptools/util/cache.c
@@ -24,6 +24,7 @@ static long PtrDiff(const void *a, const void *b)
   return (char *)a - (char *)b;
 }
 
+static const long one = 1;
 
 long cachelookup_(const double *para, double *base,
   void (*calc)(const double *, Complex *, const long *),
@@ -32,8 +33,8 @@ long cachelookup_(const double *para, double *base,
   typedef struct node {
     struct node *next[2], *succ;
     long serial;
-    double para[*npara];
-    Complex val[*nval];
+    double *para;
+    Complex *val;
   } Node;
 
 #define base_valid (long *)&base[0]
@@ -49,7 +50,8 @@ long cachelookup_(const double *para, double *base,
 
   while( (node = *next) && node->serial < valid ) {
     const int i = memcmp(para, node->para, sizeof(node->para));
-    if( i == 0 ) goto found;
+    if( i == 0 ) 
+	return PtrDiff(node->val, base)/sizeof(Complex);
     next = &node->next[SignBit(i)];
   }
 
@@ -59,6 +61,9 @@ long cachelookup_(const double *para, double *base,
 	/* MUST have extra Complex for alignment so that node
 	   can be reached with an integer index into base */
     node = malloc(sizeof(Node) + sizeof(Complex));
+    node->para = malloc(sizeof(double)* *npara);
+    node->val = malloc(sizeof(Complex)* *nval);
+
     if( node == NULL ) {
       fputs("Out of memory for LoopTools cache.\n", stderr);
       exit(1);
@@ -78,10 +83,8 @@ long cachelookup_(const double *para, double *base,
   node->next[1] = NULL;
 
   memcpy(node->para, para, sizeof(node->para));
-  static const long one = 1;
   calc(node->para, node->val, &one);
 
-found:
   return PtrDiff(node->val, base)/sizeof(Complex);
 }
 
