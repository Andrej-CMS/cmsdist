diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/core/base/inc/TVirtualPadPainter.h root/core/base/inc/TVirtualPadPainter.h
--- root-old/core/base/inc/TVirtualPadPainter.h	2010-04-12 19:15:22.000000000 +0200
+++ root/core/base/inc/TVirtualPadPainter.h	2010-04-12 19:24:27.000000000 +0200
@@ -87,6 +87,10 @@
    virtual void     DrawText(Double_t x, Double_t y, const char *text, ETextMode mode) = 0;
    virtual void     DrawTextNDC(Double_t u, Double_t v, const char *text, ETextMode mode) = 0;
    
+   //gif, jpg, png, bmp output.
+   virtual void     SaveImage(TVirtualPad *pad, const char *fileName, Int_t type) const = 0;
+
+   
    static TVirtualPadPainter *PadPainter(Option_t *opt = "");
 
    ClassDef(TVirtualPadPainter, 0)//Painter interface for pad.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/core/base/inc/TVirtualX.h root/core/base/inc/TVirtualX.h
--- root-old/core/base/inc/TVirtualX.h	2010-04-12 19:15:22.000000000 +0200
+++ root/core/base/inc/TVirtualX.h	2010-04-12 19:24:50.000000000 +0200
@@ -157,6 +157,7 @@
    virtual Int_t     WriteGIF(char *name);
    virtual void      WritePixmap(Int_t wid, UInt_t w, UInt_t h, char *pxname);
    virtual Window_t  GetCurrentWindow() const;
+   virtual Int_t     SupportsExtension(const char *ext) const;
 
    //---- Methods used for GUI -----
    virtual void         GetWindowAttributes(Window_t id, WindowAttributes_t &attr);
@@ -327,6 +328,7 @@
    virtual Bool_t       IsDNDAware(Window_t win, Atom_t *typelist);
 
    virtual Bool_t       IsCmdThread() const { return kTRUE; }
+
    static TVirtualX    *&Instance();
 
    ClassDef(TVirtualX,0)  //ABC defining a generic interface to graphics system
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/core/base/src/TVirtualX.cxx root/core/base/src/TVirtualX.cxx
--- root-old/core/base/src/TVirtualX.cxx	2010-04-12 19:15:21.000000000 +0200
+++ root/core/base/src/TVirtualX.cxx	2010-04-12 19:24:50.000000000 +0200
@@ -374,7 +374,7 @@
 Int_t   TVirtualX::GetFontAscent() const
 {
    // Returns the ascent of the current font (in pixels).
-   // The ascent of a font is the distance from the baseline 
+   // The ascent of a font is the distance from the baseline
    // to the highest position characters extend to
    return 0;
 }
@@ -382,7 +382,7 @@
 Int_t   TVirtualX::GetFontDescent() const
 {
   // Returns the descent of the current font (in pixels.
-  // The descent is the distance from the base line 
+  // The descent is the distance from the base line
   // to the lowest point characters extend to.
    return 0;
 }
@@ -922,20 +922,20 @@
 //______________________________________________________________________________
 Bool_t TVirtualX::NeedRedraw(ULong_t /*tgwindow*/, Bool_t /*force*/)
 {
-   // Notify the low level GUI layer ROOT requires "tgwindow" to be 
+   // Notify the low level GUI layer ROOT requires "tgwindow" to be
    // updated
    //
    // Returns kTRUE if the notification was desirable and it was sent
    //
    // At the moment only Qt4 layer needs that
    //
-   // One needs explicitly cast the first parameter to TGWindow to make 
+   // One needs explicitly cast the first parameter to TGWindow to make
    // it working in the implementation.
    //
    // One needs to process the notification to confine
    // all paint operations within "expose" / "paint" like low level event
    // or equivalent
-   
+
    return kFALSE;
 }
 
@@ -2063,10 +2063,10 @@
 }
 
 //______________________________________________________________________________
-unsigned char *TVirtualX::GetColorBits(Drawable_t /*wid*/, Int_t /*x*/, Int_t /*y*/, 
+unsigned char *TVirtualX::GetColorBits(Drawable_t /*wid*/, Int_t /*x*/, Int_t /*y*/,
                                        UInt_t /*w*/, UInt_t /*h*/)
 {
-   // Returns an array of pixels created from a part of drawable (defined by x, y, w, h) 
+   // Returns an array of pixels created from a part of drawable (defined by x, y, w, h)
    // in format:
    // b1, g1, r1, 0,  b2, g2, r2, 0 ... bn, gn, rn, 0 ..
    //
@@ -2079,7 +2079,7 @@
 }
 
 //______________________________________________________________________________
-Pixmap_t TVirtualX::CreatePixmapFromData(unsigned char * /*bits*/, UInt_t /*width*/, 
+Pixmap_t TVirtualX::CreatePixmapFromData(unsigned char * /*bits*/, UInt_t /*width*/,
                                        UInt_t /*height*/)
 {
    // create pixmap from RGB data. RGB data is in format :
@@ -2111,8 +2111,8 @@
 //______________________________________________________________________________
 void TVirtualX::DeleteProperty(Window_t, Atom_t&)
 {
-   // Deletes the specified property only if the property was defined on the 
-   // specified window and causes the X server to generate a PropertyNotify 
+   // Deletes the specified property only if the property was defined on the
+   // specified window and causes the X server to generate a PropertyNotify
    // event on the window unless the property does not exist.
 
 }
@@ -2121,9 +2121,9 @@
 Int_t TVirtualX::GetProperty(Window_t, Atom_t, Long_t, Long_t, Bool_t, Atom_t,
                              Atom_t*, Int_t*, ULong_t*, ULong_t*, unsigned char**)
 {
-   // Returns the actual type of the property; the actual format of the property; 
-   // the number of 8-bit, 16-bit, or 32-bit items transferred; the number of 
-   // bytes remaining to be read in the property; and a pointer to the data 
+   // Returns the actual type of the property; the actual format of the property;
+   // the number of 8-bit, 16-bit, or 32-bit items transferred; the number of
+   // bytes remaining to be read in the property; and a pointer to the data
    // actually returned.
 
    return 0;
@@ -2132,8 +2132,8 @@
 //______________________________________________________________________________
 void TVirtualX::ChangeActivePointerGrab(Window_t, UInt_t, Cursor_t)
 {
-   // Changes the specified dynamic parameters if the pointer is actively 
-   // grabbed by the client and if the specified time is no earlier than the 
+   // Changes the specified dynamic parameters if the pointer is actively
+   // grabbed by the client and if the specified time is no earlier than the
    // last-pointer-grab time and no later than the current X server time.
 
 }
@@ -2141,7 +2141,7 @@
 //______________________________________________________________________________
 void TVirtualX::ConvertSelection(Window_t, Atom_t&, Atom_t&, Atom_t&, Time_t&)
 {
-   // Requests that the specified selection be converted to the specified 
+   // Requests that the specified selection be converted to the specified
    // target type.
 
 }
@@ -2157,7 +2157,7 @@
 //______________________________________________________________________________
 void TVirtualX::ChangeProperties(Window_t, Atom_t, Atom_t, Int_t, UChar_t *, Int_t)
 {
-   // Alters the property for the specified window and causes the X server 
+   // Alters the property for the specified window and causes the X server
    // to generate a PropertyNotify event on that window.
 
 }
@@ -2165,7 +2165,7 @@
 //______________________________________________________________________________
 void TVirtualX::SetDNDAware(Window_t, Atom_t *)
 {
-   // Add XdndAware property and the list of drag and drop types to the 
+   // Add XdndAware property and the list of drag and drop types to the
    // Window win.
 
 }
@@ -2180,7 +2180,7 @@
 //______________________________________________________________________________
 Window_t TVirtualX::FindRWindow(Window_t, Window_t, Window_t, int, int, int)
 {
-   // Recursively search in the children of Window for a Window which is at 
+   // Recursively search in the children of Window for a Window which is at
    // location x, y and is DND aware, with a maximum depth of maxd.
 
    return kNone;
@@ -2195,4 +2195,12 @@
    return kFALSE;
 }
 
+//______________________________________________________________________________
+Int_t TVirtualX::SupportsExtension(const char *) const
+{
+   // Returns 1 if window system server supports extension given by the
+   // argument, returns 0 in case extension is not supported and returns -1
+   // in case of error (like server not initialized).
 
+   return -1;
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geom/inc/TGeoBoolNode.h root/geom/geom/inc/TGeoBoolNode.h
--- root-old/geom/geom/inc/TGeoBoolNode.h	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geom/inc/TGeoBoolNode.h	2010-04-12 19:25:46.000000000 +0200
@@ -48,6 +48,8 @@
    TGeoShape        *fRight;          // shape on the right branch
    TGeoMatrix       *fLeftMat;        // transformation that applies to the left branch
    TGeoMatrix       *fRightMat;       // transformation that applies to the right branch
+   Int_t             fNpoints;        //! number of points on the mesh
+   Double_t         *fPoints;         //! array of mesh points
 // methods
    Bool_t            MakeBranch(const char *expr, Bool_t left);
 public:
@@ -68,7 +70,7 @@
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const = 0;
    virtual EGeoBoolType GetBooleanOperator() const = 0;
-   virtual Int_t     GetNpoints() const = 0;
+   virtual Int_t     GetNpoints() = 0;
    TGeoMatrix       *GetLeftMatrix() const {return fLeftMat;}
    TGeoMatrix       *GetRightMatrix() const {return fRightMat;}
    TGeoShape        *GetLeftShape() const {return fLeft;}
@@ -77,8 +79,8 @@
    void              RegisterMatrices();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const = 0;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const = 0;
-   virtual void      SetPoints(Float_t *points)  const = 0;
+   virtual void      SetPoints(Double_t *points) const;
+   virtual void      SetPoints(Float_t *points)  const;
    void              SetSelected(Int_t sel) {fSelected = sel;}
    virtual void      Sizeof3D() const;
 
@@ -111,11 +113,9 @@
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const;
    virtual EGeoBoolType GetBooleanOperator() const {return kGeoUnion;}
-   virtual Int_t     GetNpoints() const;
+   virtual Int_t     GetNpoints();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const;
-   virtual void      SetPoints(Float_t *points)  const;
    virtual void      Sizeof3D() const;
 
    //CS specific
@@ -151,11 +151,9 @@
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const;
    virtual EGeoBoolType GetBooleanOperator() const {return kGeoIntersection;}
-   virtual Int_t     GetNpoints() const;
+   virtual Int_t     GetNpoints();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const;
-   virtual void      SetPoints(Float_t *points)  const;
    virtual void      Sizeof3D() const;
 
    //CS specific
@@ -190,11 +188,9 @@
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const;
    virtual EGeoBoolType GetBooleanOperator() const {return kGeoSubtraction;}
-   virtual Int_t     GetNpoints() const;
+   virtual Int_t     GetNpoints();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const;
-   virtual void      SetPoints(Float_t *points)  const;
    virtual void      Sizeof3D() const;
 
    //CS specific
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geom/inc/TGeoCompositeShape.h root/geom/geom/inc/TGeoCompositeShape.h
--- root-old/geom/geom/inc/TGeoCompositeShape.h	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geom/inc/TGeoCompositeShape.h	2010-04-12 19:25:46.000000000 +0200
@@ -51,6 +51,7 @@
    virtual void          ComputeBBox();
    virtual void          ComputeNormal(Double_t *point, Double_t *dir, Double_t *norm);
    virtual Bool_t        Contains(Double_t *point) const;
+   virtual Int_t         DistancetoPrimitive(Int_t px, Int_t py);
    virtual Double_t      DistFromInside(Double_t *point, Double_t *dir, Int_t iact=1, 
                                    Double_t step=TGeoShape::Big(), Double_t *safe=0) const;
    virtual Double_t      DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1, 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geom/src/TGeoBoolNode.cxx root/geom/geom/src/TGeoBoolNode.cxx
--- root-old/geom/geom/src/TGeoBoolNode.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geom/src/TGeoBoolNode.cxx	2010-04-12 19:25:46.000000000 +0200
@@ -50,7 +50,7 @@
 
 ClassImp(TGeoBoolNode)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoBoolNode::TGeoBoolNode()
 {
 // Default constructor
@@ -59,8 +59,11 @@
    fLeftMat  = 0;
    fRightMat = 0;
    fSelected = 0;
+   fNpoints  = 0;
+   fPoints   = 0;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 TGeoBoolNode::TGeoBoolNode(const char *expr1, const char *expr2)
 {
 // Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches.
@@ -69,6 +72,8 @@
    fLeftMat  = 0;
    fRightMat = 0;
    fSelected = 0;
+   fNpoints  = 0;
+   fPoints   = 0;
    if (!MakeBranch(expr1, kTRUE)) {
       return;
    }
@@ -77,7 +82,7 @@
    }
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoBoolNode::TGeoBoolNode(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
 {
 // Constructor providing left and right shapes and matrices (in the Boolean operation).
@@ -85,6 +90,8 @@
    fLeft = left;
    fRight = right;
    fLeftMat = lmat;
+   fNpoints  = 0;
+   fPoints   = 0;
    if (!fLeftMat) fLeftMat = gGeoIdentity;
    else fLeftMat->RegisterYourself();
    fRightMat = rmat;
@@ -100,13 +107,15 @@
    }   
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoBoolNode::~TGeoBoolNode()
 {
 // Destructor.
 // --- deletion of components handled by TGeoManager class.
+   if (fPoints) delete [] fPoints;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Bool_t TGeoBoolNode::MakeBranch(const char *expr, Bool_t left)
 {
 // Expands the boolean expression either on left or right branch, creating
@@ -175,7 +184,8 @@
    }
    return kTRUE;                  
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoBoolNode::Paint(Option_t * option)
 {
 // Special schema for feeding the 3D buffers to the painter client.
@@ -216,6 +226,7 @@
 
    *glmat = &mat;   
 }
+
 //_____________________________________________________________________________
 void TGeoBoolNode::RegisterMatrices()
 {
@@ -225,6 +236,7 @@
    if (fLeft->IsComposite()) ((TGeoCompositeShape*)fLeft)->GetBoolNode()->RegisterMatrices();
    if (fRight->IsComposite()) ((TGeoCompositeShape*)fRight)->GetBoolNode()->RegisterMatrices();
 }
+
 //_____________________________________________________________________________
 void TGeoBoolNode::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 {
@@ -240,7 +252,26 @@
       fRightMat->SavePrimitive(out,option);
    }      
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
+void TGeoBoolNode::SetPoints(Double_t *points) const
+{
+// Fill buffer with shape vertices.
+   TGeoBoolNode *bn = (TGeoBoolNode*)this;
+   Int_t npoints = bn->GetNpoints();
+   memcpy(points, fPoints, 3*npoints*sizeof(Double_t));
+}
+
+//______________________________________________________________________________
+void TGeoBoolNode::SetPoints(Float_t *points) const
+{
+// Fill buffer with shape vertices.
+   TGeoBoolNode *bn = (TGeoBoolNode*)this;
+   Int_t npoints = bn->GetNpoints();
+   for (Int_t i=0; i<3*npoints; i++) points[i] = fPoints[i];
+}
+
+//______________________________________________________________________________
 void TGeoBoolNode::Sizeof3D() const
 {
 // Register size of this 3D object
@@ -249,7 +280,7 @@
 }
 ClassImp(TGeoUnion)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoUnion::Paint(Option_t *option)
 {
 // Paint method.
@@ -265,19 +296,20 @@
    TGeoBoolNode::Paint(option);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoUnion::TGeoUnion()
 {
 // Default constructor
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 TGeoUnion::TGeoUnion(const char *expr1, const char *expr2)
           :TGeoBoolNode(expr1, expr2)
 {
 // Constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoUnion::TGeoUnion(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
           :TGeoBoolNode(left,right,lmat,rmat)
 {
@@ -287,13 +319,14 @@
    }
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoUnion::~TGeoUnion()
 {
 // Destructor
 // --- deletion of components handled by TGeoManager class.
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoUnion::ComputeBBox(Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin)
 {
 // Compute bounding box corresponding to a union of two shapes.
@@ -332,7 +365,8 @@
    dz = 0.5*(zmax-zmin);
    origin[2] = 0.5*(zmin+zmax);
 }   
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Bool_t TGeoUnion::Contains(Double_t *point) const
 {
 // Find if a union of two shapes contains a given point
@@ -400,13 +434,14 @@
    ComputeNormal(local,dir,norm);   
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Int_t TGeoUnion::DistanceToPrimitive(Int_t /*px*/, Int_t /*py*/)
 {
 // Compute minimum distance to shape vertices.
    return 9999;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoUnion::DistFromInside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -497,7 +532,8 @@
    }      
    return snxt;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoUnion::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -526,19 +562,46 @@
    }      
    return snxt;
 }
-//-----------------------------------------------------------------------------
-Int_t TGeoUnion::GetNpoints() const
+
+//______________________________________________________________________________
+Int_t TGeoUnion::GetNpoints()
 {
 // Returns number of vertices for the composite shape described by this union.
-   return 0;
-}
-//-----------------------------------------------------------------------------
-void TGeoUnion::SetPoints(Double_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
+   Int_t itot=0;
+   Double_t point[3];
+   Double_t tolerance = TGeoShape::Tolerance();
+   if (fNpoints) return fNpoints;
+   // Local points for the left shape
+   Int_t nleft = fLeft->GetNmeshVertices();
+   Double_t *points1 = new Double_t[3*nleft];
+   fLeft->SetPoints(points1);
+   // Local points for the right shape
+   Int_t nright = fRight->GetNmeshVertices();
+   Double_t *points2 = new Double_t[3*nright];
+   fRight->SetPoints(points2);
+   Double_t *points = new Double_t[3*(nleft+nright)];
+   for (Int_t i=0; i<nleft; i++) {
+      if (TMath::Abs(points1[3*i])<tolerance && TMath::Abs(points1[3*i+1])<tolerance) continue;
+      fLeftMat->LocalToMaster(&points1[3*i], &points[3*itot]);
+      fRightMat->MasterToLocal(&points[3*itot], point);
+      if (!fRight->Contains(point)) itot++;
+   }
+   for (Int_t i=0; i<nright; i++) {
+      if (TMath::Abs(points2[3*i])<tolerance && TMath::Abs(points2[3*i+1])<tolerance) continue;
+      fRightMat->LocalToMaster(&points2[3*i], &points[3*itot]);
+      fLeftMat->MasterToLocal(&points[3*itot], point);
+      if (!fLeft->Contains(point)) itot++;
+   }
+   fNpoints = itot;
+   fPoints = new Double_t[3*fNpoints];
+   memcpy(fPoints, points, 3*fNpoints*sizeof(Double_t));
+   delete [] points1;
+   delete [] points2;
+   delete [] points;
+   return fNpoints;         
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Double_t TGeoUnion::Safety(Double_t *point, Bool_t in) const
 {
 // Compute safety distance for a union node;
@@ -571,12 +634,7 @@
    else                         out << "0);" << endl;
 }   
 
-//-----------------------------------------------------------------------------
-void TGeoUnion::SetPoints(Float_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoUnion::Sizeof3D() const
 {
 // Register 3D size of this shape.
@@ -586,7 +644,7 @@
 
 ClassImp(TGeoSubtraction)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoSubtraction::Paint(Option_t *option)
 {
 // Paint method.
@@ -602,20 +660,20 @@
    TGeoBoolNode::Paint(option);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::TGeoSubtraction()
 {
 // Default constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::TGeoSubtraction(const char *expr1, const char *expr2)
           :TGeoBoolNode(expr1, expr2)
 {
 // Constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::TGeoSubtraction(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
                 :TGeoBoolNode(left,right,lmat,rmat)
 {
@@ -625,14 +683,14 @@
    }
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::~TGeoSubtraction()
 {
 // Destructor
 // --- deletion of components handled by TGeoManager class.
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoSubtraction::ComputeBBox(Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin)
 {
 // Compute bounding box corresponding to a subtraction of two shapes.
@@ -710,7 +768,7 @@
    ComputeNormal(local,dir,norm);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Bool_t TGeoSubtraction::Contains(Double_t *point) const
 {
 // Find if a subtraction of two shapes contains a given point
@@ -725,13 +783,15 @@
    if (!inside) node->SetSelected(2);
    return inside;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Int_t TGeoSubtraction::DistanceToPrimitive(Int_t /*px*/, Int_t /*py*/)
 {
 // Compute minimum distance to shape vertices
    return 9999;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoSubtraction::DistFromInside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -760,7 +820,8 @@
    }      
    return snxt;
 }   
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoSubtraction::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -815,13 +876,44 @@
       inside = kTRUE;
    }
 }
-//-----------------------------------------------------------------------------
-Int_t TGeoSubtraction::GetNpoints() const
+
+//______________________________________________________________________________
+Int_t TGeoSubtraction::GetNpoints()
 {
 // Returns number of vertices for the composite shape described by this subtraction.
-   return 0;
+   Int_t itot=0;
+   Double_t point[3];
+   Double_t tolerance = TGeoShape::Tolerance();
+   if (fNpoints) return fNpoints;
+   Int_t nleft = fLeft->GetNmeshVertices();
+   Int_t nright = fRight->GetNmeshVertices();
+   Double_t *points = new Double_t[3*(nleft+nright)];
+   Double_t *points1 = new Double_t[3*nleft];
+   fLeft->SetPoints(points1);
+   for (Int_t i=0; i<nleft; i++) {
+      if (TMath::Abs(points1[3*i])<tolerance && TMath::Abs(points1[3*i+1])<tolerance) continue;
+      fLeftMat->LocalToMaster(&points1[3*i], &points[3*itot]);
+      fRightMat->MasterToLocal(&points[3*itot], point);
+      if (!fRight->Contains(point)) itot++;
+   }
+   Double_t *points2 = new Double_t[3*nright];
+   fRight->SetPoints(points2);
+   for (Int_t i=0; i<nright; i++) {
+      if (TMath::Abs(points2[3*i])<tolerance && TMath::Abs(points2[3*i+1])<tolerance) continue;
+      fRightMat->LocalToMaster(&points2[3*i], &points[3*itot]);
+      fLeftMat->MasterToLocal(&points[3*itot], point);
+      if (fLeft->Contains(point)) itot++;
+   }
+   fNpoints = itot;
+   fPoints = new Double_t[3*fNpoints];
+   memcpy(fPoints, points, 3*fNpoints*sizeof(Double_t));
+   delete [] points1;
+   delete [] points2;
+   delete [] points;
+   return fNpoints;         
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoSubtraction::Safety(Double_t *point, Bool_t in) const
 {
 // Compute safety distance for a union node;
@@ -839,6 +931,7 @@
    if (in2)        return TMath::Max(saf1,saf2);
    return saf1;
 }   
+
 //_____________________________________________________________________________
 void TGeoSubtraction::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 {
@@ -852,28 +945,17 @@
    if (!fRightMat->IsIdentity()) out << fRightMat->GetPointerName() << ");" << endl;
    else                         out << "0);" << endl;
 }   
-//-----------------------------------------------------------------------------
-void TGeoSubtraction::SetPoints(Double_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
-void TGeoSubtraction::SetPoints(Float_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoSubtraction::Sizeof3D() const
 {
 // Register 3D size of this shape.
    TGeoBoolNode::Sizeof3D();
 }
-   
-
 
 ClassImp(TGeoIntersection)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoIntersection::Paint(Option_t *option)
 {
 // Paint method.
@@ -889,20 +971,20 @@
    TGeoBoolNode::Paint(option);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::TGeoIntersection()
 {
 // Default constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::TGeoIntersection(const char *expr1, const char *expr2)
           :TGeoBoolNode(expr1, expr2)
 {
 // Constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::TGeoIntersection(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
                  :TGeoBoolNode(left,right,lmat,rmat)
 {
@@ -912,14 +994,14 @@
    if (hs1 && hs2) Fatal("ctor", "cannot intersect two half-spaces: %s * %s", left->GetName(), right->GetName());
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::~TGeoIntersection()
 {
 // Destructor
 // --- deletion of components handled by TGeoManager class.
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoIntersection::ComputeBBox(Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin)
 {
 // Compute bounding box corresponding to a intersection of two shapes.
@@ -1067,7 +1149,7 @@
    ComputeNormal(local,dir,norm);   
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Bool_t TGeoIntersection::Contains(Double_t *point) const
 {
 // Find if a intersection of two shapes contains a given point
@@ -1079,13 +1161,15 @@
    inside = fRight->Contains(&local[0]);
    return inside;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Int_t TGeoIntersection::DistanceToPrimitive(Int_t /*px*/, Int_t /*py*/)
 {
 // Compute minimum distance to shape vertices
    return 9999;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoIntersection::DistFromInside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -1114,7 +1198,8 @@
    }      
    return snxt;
 }   
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoIntersection::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -1179,13 +1264,43 @@
    return snext;
 }      
 
-//-----------------------------------------------------------------------------
-Int_t TGeoIntersection::GetNpoints() const
+//______________________________________________________________________________
+Int_t TGeoIntersection::GetNpoints()
 {
 // Returns number of vertices for the composite shape described by this intersection.
-   return 0;
+   Int_t itot=0;
+   Double_t point[3];
+   Double_t tolerance = TGeoShape::Tolerance();
+   if (fNpoints) return fNpoints;
+   Int_t nleft = fLeft->GetNmeshVertices();
+   Int_t nright = fRight->GetNmeshVertices();
+   Double_t *points = new Double_t[3*(nleft+nright)];
+   Double_t *points1 = new Double_t[3*nleft];
+   fLeft->SetPoints(points1);
+   for (Int_t i=0; i<nleft; i++) {
+      if (TMath::Abs(points1[3*i])<tolerance && TMath::Abs(points1[3*i+1])<tolerance) continue;
+      fLeftMat->LocalToMaster(&points1[3*i], &points[3*itot]);
+      fRightMat->MasterToLocal(&points[3*itot], point);
+      if (fRight->Contains(point)) itot++;
+   }
+   Double_t *points2 = new Double_t[3*nright];
+   fRight->SetPoints(points2);
+   for (Int_t i=0; i<nright; i++) {
+      if (TMath::Abs(points2[3*i])<tolerance && TMath::Abs(points2[3*i+1])<tolerance) continue;
+      fRightMat->LocalToMaster(&points2[3*i], &points[3*itot]);
+      fLeftMat->MasterToLocal(&points[3*itot], point);
+      if (fLeft->Contains(point)) itot++;
+   }
+   fNpoints = itot;
+   fPoints = new Double_t[3*fNpoints];
+   memcpy(fPoints, points, 3*fNpoints*sizeof(Double_t));
+   delete [] points1;
+   delete [] points2;
+   delete [] points;
+   return fNpoints;         
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoIntersection::Safety(Double_t *point, Bool_t in) const
 {
 // Compute safety distance for a union node;
@@ -1203,6 +1318,7 @@
    if (in2)        return saf1;
    return TMath::Max(saf1,saf2);
 }   
+
 //_____________________________________________________________________________
 void TGeoIntersection::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 {
@@ -1216,17 +1332,8 @@
    if (!fRightMat->IsIdentity()) out << fRightMat->GetPointerName() << ");" << endl;
    else                         out << "0);" << endl;
 }   
-//-----------------------------------------------------------------------------
-void TGeoIntersection::SetPoints(Double_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
-void TGeoIntersection::SetPoints(Float_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoIntersection::Sizeof3D() const
 {
 // Register 3D size of this shape.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geom/src/TGeoCompositeShape.cxx root/geom/geom/src/TGeoCompositeShape.cxx
--- root-old/geom/geom/src/TGeoCompositeShape.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geom/src/TGeoCompositeShape.cxx	2010-04-12 19:25:46.000000000 +0200
@@ -265,6 +265,14 @@
 }
 
 //_____________________________________________________________________________
+Int_t TGeoCompositeShape::DistancetoPrimitive(Int_t px, Int_t py)
+{
+// Compute closest distance from point px,py to each corner.
+   const Int_t numPoints = GetNmeshVertices();
+   return ShapeDistancetoPrimitive(numPoints, px, py);
+}
+
+//_____________________________________________________________________________
 Double_t TGeoCompositeShape::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                                       Double_t step, Double_t *safe) const
 {
@@ -298,7 +306,7 @@
 void TGeoCompositeShape::GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const
 {
 // Returns numbers of vertices, segments and polygons composing the shape mesh.
-   nvert = 0;
+   nvert = GetNmeshVertices();
    nsegs = 0;
    npols = 0;
 }
@@ -456,14 +464,14 @@
 void TGeoCompositeShape::SetPoints(Double_t *points) const
 {
 // create points for a composite shape
-   TGeoBBox::SetPoints(points);
+   if (fNode) fNode->SetPoints(points);
 }
 
 //_____________________________________________________________________________
 void TGeoCompositeShape::SetPoints(Float_t *points) const
 {
 // create points for a composite shape
-   TGeoBBox::SetPoints(points);
+   if (fNode) fNode->SetPoints(points);
 }
 
 //_____________________________________________________________________________
@@ -478,6 +486,6 @@
 {
 // Return number of vertices of the mesh representation
    if (!fNode) return 0;
-   return 8;
+   return fNode->GetNpoints();
 }      
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geom/src/TGeoMaterial.cxx root/geom/geom/src/TGeoMaterial.cxx
--- root-old/geom/geom/src/TGeoMaterial.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geom/src/TGeoMaterial.cxx	2010-04-12 19:25:46.000000000 +0200
@@ -625,7 +625,7 @@
 // add an element to the mixture using fraction by weight
    TGeoElement *elemold;
    TGeoElementTable *table = gGeoManager->GetElementTable();
-   if (!fElements) fElements = new TObjArray(10);
+   if (!fElements) fElements = new TObjArray(128);
    Bool_t exist = kFALSE;
    // If previous elements were defined by A/Z, add corresponding TGeoElements
    for (Int_t i=0; i<fNelements; i++) {
@@ -645,7 +645,7 @@
    Double_t amol;
    TGeoElement *elemold;
    TGeoElementTable *table = gGeoManager->GetElementTable();
-   if (!fElements) fElements = new TObjArray(10);
+   if (!fElements) fElements = new TObjArray(128);
    // Check if the element is already defined
    for (i=0; i<fNelements; i++) {
       elemold = (TGeoElement*)fElements->At(i);
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geombuilder/inc/TGeoMaterialEditor.h root/geom/geombuilder/inc/TGeoMaterialEditor.h
--- root-old/geom/geombuilder/inc/TGeoMaterialEditor.h	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geombuilder/inc/TGeoMaterialEditor.h	2010-04-12 19:25:50.000000000 +0200
@@ -115,7 +115,7 @@
    TGCheckButton       *fChkNatoms;         // Check button for number of atoms
    TGNumberEntry       *fNENatoms;          // Number entry for number of atoms
    TGTextButton        *fBAddElem;          // Buttom for adding element as component
-   TGCanvas            *fCan;               // Canvas with components
+   TGCompositeFrame    *fComps;             // Frame with components
 
    virtual void ConnectSignals2Slots();     // Connect the signals to the slots
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geombuilder/src/TGeoMaterialEditor.cxx root/geom/geombuilder/src/TGeoMaterialEditor.cxx
--- root-old/geom/geombuilder/src/TGeoMaterialEditor.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geombuilder/src/TGeoMaterialEditor.cxx	2010-04-12 19:25:50.000000000 +0200
@@ -64,27 +64,27 @@
    // TextEntry for material name
    MakeTitle("Name");
    fMaterialName = new TGTextEntry(this, new TGTextBuffer(50), kMATERIAL_NAME);
-   fMaterialName->Resize(135, fMaterialName->GetDefaultHeight());
+   fMaterialName->SetDefaultSize(135, fMaterialName->GetDefaultHeight());
    fMaterialName->SetToolTipText("Enter the material name");
    fMaterialName->Associate(this);
-   AddFrame(fMaterialName, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 5));
+   AddFrame(fMaterialName, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 1, 1, 2, 5));
 
    TGTextEntry *nef;
    MakeTitle("Material properties");
    TGCompositeFrame *f1 = new TGCompositeFrame(this, 118, 10, kHorizontalFrame |
                                  kFixedWidth | kOwnBackground);
    f1->AddFrame(new TGLabel(f1, "A"), new TGLayoutHints(kLHintsLeft, 1, 1, 6, 0));
-   fMatA = new TGNumberEntry(f1, 0., 5, kMATERIAL_A, TGNumberFormat::kNESRealThree);
+   fMatA = new TGNumberEntry(f1, 0., 6, kMATERIAL_A, TGNumberFormat::kNESRealThree);
    nef = (TGTextEntry*)fMatA->GetNumberEntry();
    nef->SetToolTipText("Enter the atomic mass");
    fMatA->Associate(this);
-   f1->AddFrame(fMatA, new TGLayoutHints(kLHintsLeft , 2, 2, 4, 4));
+   f1->AddFrame(fMatA, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 4));
    f1->AddFrame(new TGLabel(f1, "Z"), new TGLayoutHints(kLHintsLeft, 1, 1, 6, 0));
-   fMatZ = new TGNumberEntry(f1, 0., 5, kMATERIAL_Z, TGNumberFormat::kNESInteger);
+   fMatZ = new TGNumberEntry(f1, 0., 4, kMATERIAL_Z, TGNumberFormat::kNESInteger);
    nef = (TGTextEntry*)fMatZ->GetNumberEntry();
    nef->SetToolTipText("Enter the atomic charge");
    fMatZ->Associate(this);
-   f1->AddFrame(fMatZ, new TGLayoutHints(kLHintsLeft , 2, 2, 4, 4));
+   f1->AddFrame(fMatZ, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 4));
    f1->Resize(150,30);
    AddFrame(f1, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
    
@@ -428,7 +428,7 @@
                              kLHintsExpandX | kFixedWidth | kOwnBackground);
    fChkNatoms = new TGCheckButton(f1, "N. atoms");
    fChkNatoms->SetDown(kFALSE);
-   f1->AddFrame(fChkNatoms, new TGLayoutHints(kLHintsLeft , 2, 2, 6, 1));
+   f1->AddFrame(fChkNatoms, new TGLayoutHints(kLHintsLeft, 2, 2, 6, 1));
    fNENatoms = new TGNumberEntry(f1, 0., 5, kMIX_NATOMS);
    fNENatoms->SetFormat(TGNumberFormat::kNESInteger, TGNumberFormat::kNEANonNegative);
    fNENatoms->Resize(65, fMaterialName->GetDefaultHeight());
@@ -442,16 +442,14 @@
    // Button for adding the element
    fBAddElem = new TGTextButton(compxyz, "Add component");
    fBAddElem->Associate(this);
-   compxyz->AddFrame(fBAddElem, new TGLayoutHints(kLHintsRight , 2, 2, 1, 1));
+   compxyz->AddFrame(fBAddElem, new TGLayoutHints(kLHintsRight , 2, 2, 2, 0));
 
    compxyz->Resize(150,30);
    AddFrame(compxyz, new TGLayoutHints(kLHintsLeft, 0, 0, 1, 1));
    
    // List view with all components
-   fCan = new TGCanvas(this, 145, 100);
-   TGCompositeFrame *cont = new TGCompositeFrame(fCan->GetViewPort(), 100, 100, kVerticalFrame | kLHintsExpandX);
-   fCan->SetContainer(cont);
-   AddFrame(fCan, new TGLayoutHints(kLHintsLeft, 2, 2, 1, 1));
+   fComps = new TGCompositeFrame(this, 150, 100, kVerticalFrame | kSunkenFrame);
+   AddFrame(fComps, new TGLayoutHints(kLHintsLeft | kLHintsExpandX | kLHintsExpandY, 0, 2, 1, 2));
 
    TGeoTabManager::MoveFrame(f23, this);
 }   
@@ -561,13 +559,7 @@
    if (!el) return;
    if (byfraction) fMixture->AddElement(el, frac);
    else            fMixture->AddElement(el, natoms);   
-   fMatA->SetNumber(fMaterial->GetA());
-   fMatZ->SetNumber(fMaterial->GetZ());
-   fMatRadLen->SetNumber(fMaterial->GetRadLen());
-   fMatAbsLen->SetNumber(fMaterial->GetIntLen());
-   TString nelem = Form("Number of elements: %d", fMixture->GetNelements());
-   fNelem->SetText(nelem.Data());
-   UpdateElements();
+   fTabMgr->GetMaterialEditor(fMixture);
 }
 
 //______________________________________________________________________________
@@ -612,31 +604,21 @@
 void TGeoMixtureEditor::UpdateElements()
 {
 // Update the list of elements in the TGCanvas.
+   fComps->RemoveAll();
    Int_t nelem = fMixture->GetNelements();
-   if (!nelem) return;
-   TGCompositeFrame *cont = (TGCompositeFrame*)fCan->GetContainer();
-   TList *list = cont->GetList();
-   TGLabel *label;
-   TGFrameElement *el;
-   TString s;
    for (Int_t i=0; i<nelem; i++) {
+      TString s;
       Bool_t byfrac = (fMixture->GetNmixt())?kFALSE:kTRUE;
       if (byfrac) 
-         s = Form("%d-%s-%d: Wmass = %g %%", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
-                  (Int_t)fMixture->GetAmixt()[i],fMixture->GetWmixt()[i]);
+         s.Form("%d-%s-%d: Wmass = %g %%", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
+                (Int_t)fMixture->GetAmixt()[i],fMixture->GetWmixt()[i]);
       else
-         s = Form("%d-%s-%d: Natoms = %d", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
-                  (Int_t)fMixture->GetAmixt()[i],fMixture->GetNmixt()[i]);
+         s.Form("%d-%s-%d: Natoms = %d", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
+                (Int_t)fMixture->GetAmixt()[i],fMixture->GetNmixt()[i]);
                      
-      el = (TGFrameElement*)list->At(i);
-      if (el) {
-         label = (TGLabel*)el->fFrame;
-         label->SetText(s.Data());
-      } else {
-         label = new TGLabel(cont, s.Data());
-         cont->AddFrame(label, new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
-         fCan->MapSubwindows();
-      }   
+      TGLabel *label = new TGLabel(fComps, s);
+      label->SetTextJustify(kTextLeft | kTextCenterY);
+      fComps->AddFrame(label, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 1, 1, 0, 0));
    }   
-//   fCan->Layout();
+   fComps->MapSubwindows();
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geombuilder/src/TGeoMediumEditor.cxx root/geom/geombuilder/src/TGeoMediumEditor.cxx
--- root-old/geom/geombuilder/src/TGeoMediumEditor.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geombuilder/src/TGeoMediumEditor.cxx	2010-04-12 19:25:50.000000000 +0200
@@ -53,50 +53,50 @@
       
    // TextEntry for medium name
    MakeTitle("Name");
-   fMedName = new TGTextEntry(this, new TGTextBuffer(50), kMED_NAME);
-   fMedName->Resize(135, fMedName->GetDefaultHeight());
+   fMedName = new TGTextEntry(this, "", kMED_NAME);
+   fMedName->SetDefaultSize(135, fMedName->GetDefaultHeight());
    fMedName->SetToolTipText("Enter the medium name");
    fMedName->Associate(this);
-   AddFrame(fMedName, new TGLayoutHints(kLHintsLeft, 3, 1, 2, 2));
+   AddFrame(fMedName, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 3, 1, 2, 2));
 
    TGTextEntry *nef;
 
 // Composite frame for medium ID and sensitivity
    TGCompositeFrame *f1 = new TGCompositeFrame(this, 120, 30, kHorizontalFrame | kRaisedFrame);
-   f1->AddFrame(new TGLabel(f1, "ID"), new TGLayoutHints(kLHintsLeft, 1, 1, 6, 0));
+   f1->AddFrame(new TGLabel(f1, "ID"), new TGLayoutHints(kLHintsLeft, 4, 1, 6, 0));
    fMedId = new TGNumberEntry(f1, 0., 1, kMED_ID);
    nef = (TGTextEntry*)fMedId->GetNumberEntry();
    nef->SetToolTipText("Enter the medium ID");
    fMedId->Associate(this);
-   f1->AddFrame(fMedId, new TGLayoutHints(kLHintsLeft | kLHintsExpandX , 2, 2, 4, 4));
+   f1->AddFrame(fMedId, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 4, 4));
    fMedSensitive = new TGCheckButton(f1, "&Sens", kMED_SENS);
    fMedSensitive->Associate(this);
-   f1->AddFrame(fMedSensitive, new TGLayoutHints(kLHintsRight | kLHintsExpandX , 2, 2, 4, 4));
+   f1->AddFrame(fMedSensitive, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 4));
    AddFrame(f1, new TGLayoutHints(kLHintsLeft, 3, 3, 2, 2));
 
    // Current material
-   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
+   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kFixedWidth | kOwnBackground);
    f1->AddFrame(label = new TGLabel(f1, "Current material"), new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
    f1->AddFrame(new TGHorizontal3DLine(f1), new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 7));
    gClient->GetColorByName("#ff0000", color);
    label->SetTextColor(color);
    AddFrame(f1, new TGLayoutHints(kLHintsTop, 0, 0, 2, 0));
-   f1 = new TGCompositeFrame(this, 155, 30, kHorizontalFrame | kFixedWidth);
+   f1 = new TGCompositeFrame(this, 155, 30, kHorizontalFrame);
    fSelectedMaterial = 0;
    fLSelMaterial = new TGLabel(f1, "Select material");
    gClient->GetColorByName("#0000ff", color);
    fLSelMaterial->SetTextColor(color);
-   fLSelMaterial->ChangeOptions(kSunkenFrame | kDoubleBorder);
+   fLSelMaterial->ChangeOptions(kChildFrame | kSunkenFrame | kDoubleBorder);
    f1->AddFrame(fLSelMaterial, new TGLayoutHints(kLHintsLeft | kLHintsExpandX | kLHintsExpandY, 1, 1, 2, 2));
    fBSelMaterial = new TGPictureButton(f1, fClient->GetPicture("rootdb_t.xpm"), kMED_MATSEL);
    fBSelMaterial->SetToolTipText("Replace with one of the existing materials");
    fBSelMaterial->Associate(this);
    f1->AddFrame(fBSelMaterial, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMaterial = new TGTextButton(f1, "Edit");
-   f1->AddFrame(fEditMaterial, new TGLayoutHints(kLHintsRight, 1, 1, 2, 2));
+   f1->AddFrame(fEditMaterial, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMaterial->SetToolTipText("Edit selected material");
    fEditMaterial->Associate(this);   
-   AddFrame(f1, new TGLayoutHints(kLHintsLeft, 2, 2, 0, 0));
+   AddFrame(f1, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 0, 0));
    
 // Combo box for magnetic field option
    f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
@@ -111,7 +111,7 @@
 
 
 // Number entries for other settings
-   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
+   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kFixedWidth | kOwnBackground);
    f1->AddFrame(label = new TGLabel(f1, "Medium cuts"), new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
    f1->AddFrame(new TGHorizontal3DLine(f1), new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 7));
    gClient->GetColorByName("#ff0000", color);
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geombuilder/src/TGeoTabManager.cxx root/geom/geombuilder/src/TGeoTabManager.cxx
--- root-old/geom/geombuilder/src/TGeoTabManager.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geombuilder/src/TGeoTabManager.cxx	2010-04-12 19:25:50.000000000 +0200
@@ -139,6 +139,7 @@
    else {
       fMediumPanel->SetModel(medium);
       fMediumPanel->Show();
+      fMediumPanel->RaiseWindow();
    }   
 }
 
@@ -153,6 +154,7 @@
    else {
       fMaterialPanel->SetModel(material);
       fMaterialPanel->Show();
+      fMaterialPanel->RaiseWindow();
    }   
 }
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geombuilder/src/TGeoVolumeEditor.cxx root/geom/geombuilder/src/TGeoVolumeEditor.cxx
--- root-old/geom/geombuilder/src/TGeoVolumeEditor.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geombuilder/src/TGeoVolumeEditor.cxx	2010-04-12 19:25:50.000000000 +0200
@@ -82,7 +82,7 @@
    fIsDivided = kFALSE;
    
    // TGShutter for categories
-   fCategories = new TGShutter(this, kSunkenFrame | kFixedHeight);
+   fCategories = new TGShutter(this, kSunkenFrame);
    TGCompositeFrame *container, *f1;
    Pixel_t color;
    TGLabel *label;
@@ -92,7 +92,7 @@
    container = (TGCompositeFrame*)si->GetContainer();
    container->SetBackgroundColor(GetDefaultFrameBackground());
    fCategories->AddItem(si);
-   
+
    // TextEntry for volume name
    f1 = new TGCompositeFrame(container, 155, 10, kHorizontalFrame | kFixedWidth);
    f1->AddFrame(label = new TGLabel(f1, "Volume name"), new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
@@ -100,10 +100,10 @@
    gClient->GetColorByName("#ff0000", color);
    label->SetTextColor(color);
    container->AddFrame(f1, new TGLayoutHints(kLHintsTop, 0, 0, 2, 0));
-   fVolumeName = new TGTextEntry(container, new TGTextBuffer(50), kVOL_NAME);
-   fVolumeName->Resize(135, fVolumeName->GetDefaultHeight());
+   fVolumeName = new TGTextEntry(container, "", kVOL_NAME);
+   fVolumeName->SetDefaultSize(135, fVolumeName->GetDefaultHeight());
    fVolumeName->SetToolTipText("Enter the volume name");
-   container->AddFrame(fVolumeName, new TGLayoutHints(kLHintsLeft, 3, 1, 2, 5));
+   container->AddFrame(fVolumeName, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 3, 1, 2, 5));
 
    // Current shape
    f1 = new TGCompositeFrame(container, 155, 10, kHorizontalFrame | kFixedWidth);
@@ -112,7 +112,7 @@
    gClient->GetColorByName("#ff0000", color);
    label->SetTextColor(color);
    container->AddFrame(f1, new TGLayoutHints(kLHintsTop, 0, 0, 10, 0));
-   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame | kFixedWidth);
+   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame);
    fSelectedShape = 0;
    fLSelShape = new TGLabel(f1, "Select shape");
    gClient->GetColorByName("#0000ff", color);
@@ -124,13 +124,13 @@
    fBSelShape->Associate(this);
    f1->AddFrame(fBSelShape, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditShape = new TGTextButton(f1, "Edit");
-   f1->AddFrame(fEditShape, new TGLayoutHints(kLHintsRight, 1, 1, 2, 2));
+   f1->AddFrame(fEditShape, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditShape->SetToolTipText("Edit selected shape");
    fEditShape->Associate(this);   
-   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft, 2, 2, 0, 0));
+   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 0, 0));
    
    // Current medium
-   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame | kFixedWidth);
+   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame);
    fSelectedMedium = 0;
    fLSelMedium = new TGLabel(f1, "Select medium");
    gClient->GetColorByName("#0000ff", color);
@@ -142,11 +142,11 @@
    fBSelMedium->Associate(this);
    f1->AddFrame(fBSelMedium, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMedium = new TGTextButton(f1, "Edit");
-   f1->AddFrame(fEditMedium, new TGLayoutHints(kLHintsRight, 1, 1, 2, 2));
+   f1->AddFrame(fEditMedium, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMedium->SetToolTipText("Edit selected medium");
    fEditMedium->Associate(this);
-   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft, 2, 2, 0, 0));
-   
+   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 0, 0));
+
    // List of daughters
    si = new TGShutterItem(fCategories, new TGHotString("Daughters"),kCAT_DAUGHTERS);
    container = (TGCompositeFrame*)si->GetContainer();
@@ -365,7 +365,10 @@
 
 
    fCategories->Resize(163,340);
-   AddFrame(fCategories, new TGLayoutHints(kLHintsLeft, 0, 0, 4, 4));
+   AddFrame(fCategories, new TGLayoutHints(kLHintsLeft | kLHintsExpandX | kLHintsExpandY, 0, 0, 4, 4));
+
+   fCategories->Layout();
+   fCategories->SetDefaultSize(GetDefaultWidth(), GetDefaultHeight());
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/geom/geompainter/src/TGeoChecker.cxx root/geom/geompainter/src/TGeoChecker.cxx
--- root-old/geom/geompainter/src/TGeoChecker.cxx	2010-04-12 19:15:57.000000000 +0200
+++ root/geom/geompainter/src/TGeoChecker.cxx	2010-04-12 19:25:46.000000000 +0200
@@ -967,13 +967,13 @@
    Double_t local[3], local1[3];
    Double_t point[3];
    Double_t safety = TGeoShape::Big();
+   Double_t tolerance = TGeoShape::Tolerance();
    if (vol1->IsAssembly() || vol2->IsAssembly()) return nodeovlp;
    TGeoShape *shape1 = vol1->GetShape();
    TGeoShape *shape2 = vol2->GetShape();
    OpProgress("refresh", 0,0,NULL,kFALSE,kTRUE);   
    shape1->GetMeshNumbers(numPoints1, numSegs1, numPols1);
-   if (!shape1->IsComposite() && 
-       fBuff1->fID != (TObject*)shape1) {
+   if (fBuff1->fID != (TObject*)shape1) {
       // Fill first buffer.
       fBuff1->SetRawSizes(TMath::Max(numPoints1,fNmeshPoints), 3*TMath::Max(numPoints1,fNmeshPoints), 0, 0, 0, 0);
       points1 = fBuff1->fPnts;
@@ -989,8 +989,7 @@
       fBuff1->fID = shape1;
    }   
    shape2->GetMeshNumbers(numPoints2, numSegs2, numPols2);
-   if (!shape2->IsComposite() && 
-       fBuff2->fID != (TObject*)shape2) {
+   if (fBuff2->fID != (TObject*)shape2) {
       // Fill second buffer.
       fBuff2->SetRawSizes(TMath::Max(numPoints2,fNmeshPoints), 3*TMath::Max(numPoints2,fNmeshPoints), 0, 0, 0,0);
       points2 = fBuff2->fPnts;
@@ -1010,117 +1009,109 @@
    // Extrusion case. Test vol2 extrude vol1.
       isextrusion=kFALSE;
       // loop all points of the daughter
-      if (!shape2->IsComposite()) {
-         for (ip=0; ip<numPoints2; ip++) {
-            memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
-            if (local[0]<1e-10 && local[1]<1e-10) continue;
-            mat2->LocalToMaster(local, point);
-            mat1->MasterToLocal(point, local);
-            extrude = !shape1->Contains(local);
-            if (extrude) {
-               safety = shape1->Safety(local, kFALSE);
-               if (safety<ovlp) extrude=kFALSE;
-            }    
-            if (extrude) {
-               if (!isextrusion) {
-                  isextrusion = kTRUE;
-                  nodeovlp = new TGeoOverlap(name, vol1, vol2, mat1,mat2,kFALSE,safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-                  fGeoManager->AddOverlap(nodeovlp);
-               } else {
-                  if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-               }   
-            }
-         }
-      }                
-      // loop all points of the mother
-      if (!shape1->IsComposite()) {
-         for (ip=0; ip<numPoints1; ip++) {
-            memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
-            if (local[0]<1e-10 && local[1]<1e-10) continue;
-            mat1->LocalToMaster(local, point);
-            mat2->MasterToLocal(point, local1);
-            extrude = shape2->Contains(local1);
-            if (extrude) {
-               // skip points on mother mesh that have no neghbourhood ouside mother
-               safety = shape1->Safety(local,kTRUE);
-               if (safety>1E-6) {
-                  extrude = kFALSE;
-               } else {   
-                  safety = shape2->Safety(local1,kTRUE);
-                  if (safety<ovlp) extrude=kFALSE;
-               }   
-            }   
-            if (extrude) {
-               if (!isextrusion) {
-                  isextrusion = kTRUE;
-                  nodeovlp = new TGeoOverlap(name, vol1,vol2,mat1,mat2,kFALSE,safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-                  fGeoManager->AddOverlap(nodeovlp);
-               } else {
-                  if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-               }   
-            }
-         }
-      }
-      return nodeovlp;
-   }            
-   // Check overlap
-   Bool_t overlap;
-   overlap = kFALSE;
-   isoverlapping = kFALSE;
-   if (!shape1->IsComposite()) {
-      // loop all points of first candidate
-      for (ip=0; ip<numPoints1; ip++) {
-         memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
-         if (local[0]<1e-10 && local[1]<1e-10) continue;
-         mat1->LocalToMaster(local, point);
-         mat2->MasterToLocal(point, local); // now point in local reference of second
-         overlap = shape2->Contains(local);
-         if (overlap) {
-            safety = shape2->Safety(local, kTRUE);
-            if (safety<ovlp) overlap=kFALSE;
+      for (ip=0; ip<numPoints2; ip++) {
+         memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
+         if (TMath::Abs(local[0])<tolerance && TMath::Abs(local[1])<tolerance) continue;
+         mat2->LocalToMaster(local, point);
+         mat1->MasterToLocal(point, local);
+         extrude = !shape1->Contains(local);
+         if (extrude) {
+            safety = shape1->Safety(local, kFALSE);
+            if (safety<ovlp) extrude=kFALSE;
          }    
-         if (overlap) {
-            if (!isoverlapping) {
-               isoverlapping = kTRUE;
-               nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+         if (extrude) {
+            if (!isextrusion) {
+               isextrusion = kTRUE;
+               nodeovlp = new TGeoOverlap(name, vol1, vol2, mat1,mat2,kFALSE,safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
                fGeoManager->AddOverlap(nodeovlp);
             } else {
                if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-            }     
+           }   
          }
       }
-   }   
-   // loop all points of second candidate
-   if (!shape2->IsComposite()) {
-      for (ip=0; ip<numPoints2; ip++) {
-         memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
+      // loop all points of the mother
+      for (ip=0; ip<numPoints1; ip++) {
+         memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
          if (local[0]<1e-10 && local[1]<1e-10) continue;
-         mat2->LocalToMaster(local, point);
-         mat1->MasterToLocal(point, local); // now point in local reference of first
-         overlap = shape1->Contains(local);
-         if (overlap) {
-            safety = shape1->Safety(local, kTRUE);
-            if (safety<ovlp) overlap=kFALSE;
-         }    
-         if (overlap) {
-            if (!isoverlapping) {
-               isoverlapping = kTRUE;
-               nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+         mat1->LocalToMaster(local, point);
+         mat2->MasterToLocal(point, local1);
+         extrude = shape2->Contains(local1);
+         if (extrude) {
+            // skip points on mother mesh that have no neghbourhood ouside mother
+            safety = shape1->Safety(local,kTRUE);
+            if (safety>1E-6) {
+               extrude = kFALSE;
+            } else {   
+               safety = shape2->Safety(local1,kTRUE);
+               if (safety<ovlp) extrude=kFALSE;
+            }   
+         }   
+         if (extrude) {
+            if (!isextrusion) {
+               isextrusion = kTRUE;
+               nodeovlp = new TGeoOverlap(name, vol1,vol2,mat1,mat2,kFALSE,safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
                fGeoManager->AddOverlap(nodeovlp);
             } else {
                if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-            }     
+            }   
          }
       }
-   } 
+      return nodeovlp;
+   }            
+   // Check overlap
+   Bool_t overlap;
+   overlap = kFALSE;
+   isoverlapping = kFALSE;
+   // loop all points of first candidate
+   for (ip=0; ip<numPoints1; ip++) {
+      memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
+      if (local[0]<1e-10 && local[1]<1e-10) continue;
+      mat1->LocalToMaster(local, point);
+      mat2->MasterToLocal(point, local); // now point in local reference of second
+      overlap = shape2->Contains(local);
+      if (overlap) {
+         safety = shape2->Safety(local, kTRUE);
+         if (safety<ovlp) overlap=kFALSE;
+      }    
+      if (overlap) {
+         if (!isoverlapping) {
+            isoverlapping = kTRUE;
+            nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+            fGeoManager->AddOverlap(nodeovlp);
+         } else {
+            if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+         }     
+      }
+   }
+   // loop all points of second candidate
+   for (ip=0; ip<numPoints2; ip++) {
+      memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
+      if (local[0]<1e-10 && local[1]<1e-10) continue;
+      mat2->LocalToMaster(local, point);
+      mat1->MasterToLocal(point, local); // now point in local reference of first
+      overlap = shape1->Contains(local);
+      if (overlap) {
+         safety = shape1->Safety(local, kTRUE);
+         if (safety<ovlp) overlap=kFALSE;
+      }    
+      if (overlap) {
+         if (!isoverlapping) {
+            isoverlapping = kTRUE;
+            nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+            fGeoManager->AddOverlap(nodeovlp);
+         } else {
+            if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+         }     
+      }
+   }
    return nodeovlp;  
 }
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf2d/gpad/inc/TPadPainter.h root/graf2d/gpad/inc/TPadPainter.h
--- root-old/graf2d/gpad/inc/TPadPainter.h	2010-04-12 19:16:07.000000000 +0200
+++ root/graf2d/gpad/inc/TPadPainter.h	2010-04-12 19:24:28.000000000 +0200
@@ -75,6 +75,10 @@
    
    void     DrawText(Double_t x, Double_t y, const char *text, ETextMode mode);
    void     DrawTextNDC(Double_t u, Double_t v, const char *text, ETextMode mode);
+   
+   //jpg, png, bmp, gif output.
+   void     SaveImage(TVirtualPad *pad, const char *fileName, Int_t type) const;
+
 private:
    TPadPainter(const TPadPainter &rhs);
    TPadPainter & operator = (const TPadPainter &rhs);
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf2d/gpad/src/TPad.cxx root/graf2d/gpad/src/TPad.cxx
--- root-old/graf2d/gpad/src/TPad.cxx	2010-04-12 19:16:07.000000000 +0200
+++ root/graf2d/gpad/src/TPad.cxx	2010-04-12 19:24:28.000000000 +0200
@@ -4249,10 +4249,9 @@
          gPad->Modified();
          gPad->Update();
          GetPainter()->SelectDrawable(wid);
-         if (gVirtualX->WriteGIF((char*)psname.Data())) {
-            if (!gSystem->AccessPathName(psname.Data())) {
-               Info("Print", "GIF file %s has been created", psname.Data());
-            }
+         GetPainter()->SaveImage(this, psname.Data(), gtype);
+         if (!gSystem->AccessPathName(psname.Data())) {
+            Info("Print", "GIF file %s has been created", psname.Data());
          }
          gPad->GetCanvas()->SetHighLightColor(hc);
          return;
@@ -4270,11 +4269,8 @@
             gErrorIgnoreLevel = kFatal;
             gVirtualX->Update(1);
             gSystem->Sleep(30); // syncronize
-            TImage *img = TImage::Create();
-            img->FromPad(this);
-            img->WriteImage(psname, gtype);
+            GetPainter()->SaveImage(this, psname, gtype);
             gErrorIgnoreLevel = saver;
-            delete img;
          }
          if (!gSystem->AccessPathName(psname)) {
             Info("Print", "file %s has been created", psname.Data());
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf2d/gpad/src/TPadPainter.cxx root/graf2d/gpad/src/TPadPainter.cxx
--- root-old/graf2d/gpad/src/TPadPainter.cxx	2010-04-12 19:16:07.000000000 +0200
+++ root/graf2d/gpad/src/TPadPainter.cxx	2010-04-12 19:24:28.000000000 +0200
@@ -2,6 +2,7 @@
 #include "TPoint.h"
 #include "TPadPainter.h"
 #include "TVirtualX.h"
+#include "TImage.h"
 
 // Local scratch buffer for screen points, faster than allocating buffer on heap
 const Int_t kPXY = 1002;
@@ -484,3 +485,20 @@
    Double_t mgn = GetTextMagnitude();
    gVirtualX->DrawText(px, py, angle, mgn, text, (TVirtualX::ETextMode)mode);
 }
+
+
+//______________________________________________________________________________
+void TPadPainter::SaveImage(TVirtualPad *pad, const char *fileName, Int_t type) const
+{
+   // Save the image displayed in the canvas pointed by "pad" into a 
+   // binary file.
+
+   if (type == TImage::kGif) {
+      gVirtualX->WriteGIF((char*)fileName);
+   } else {
+      TImage *img = TImage::Create();
+      img->FromPad(pad);
+      img->WriteImage(fileName, (TImage::EImageFileTypes)type);
+      delete img;
+   }
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf2d/x11/inc/TGX11.h root/graf2d/x11/inc/TGX11.h
--- root-old/graf2d/x11/inc/TGX11.h	2010-04-12 19:16:07.000000000 +0200
+++ root/graf2d/x11/inc/TGX11.h	2010-04-12 19:24:50.000000000 +0200
@@ -237,6 +237,7 @@
    Int_t     WriteGIF(char *name);
    void      WritePixmap(Int_t wid, UInt_t w, UInt_t h, char *pxname);
    Window_t  GetCurrentWindow() const;
+   Int_t     SupportsExtension(const char *ext) const;
 
    //---- Methods used for GUI -----
    void         GetWindowAttributes(Window_t id, WindowAttributes_t &attr);
@@ -408,4 +409,3 @@
 };
 
 #endif
-
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf2d/x11/src/TGX11.cxx root/graf2d/x11/src/TGX11.cxx
--- root-old/graf2d/x11/src/TGX11.cxx	2010-04-12 19:16:07.000000000 +0200
+++ root/graf2d/x11/src/TGX11.cxx	2010-04-12 19:24:50.000000000 +0200
@@ -3315,3 +3315,20 @@
 
    return wid;
 }
+
+//______________________________________________________________________________
+Int_t TGX11::SupportsExtension(const char *ext) const
+{
+   // Returns 1 if window system server supports extension given by the
+   // argument, returns 0 in case extension is not supported and returns -1
+   // in case of error (like server not initialized).
+   // Examples:
+   //   "Apple-WM" - does server run on MacOS X;
+   //   "XINERAMA" - does server support Xinerama.
+   // See also the output of xdpyinfo.
+
+   Int_t major_opcode, first_event, first_error;
+   if (!fDisplay)
+      return -1;
+   return XQueryExtension(fDisplay, ext, &major_opcode, &first_event, &first_error);
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/Module.mk root/graf3d/eve/Module.mk
--- root-old/graf3d/eve/Module.mk	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/Module.mk	2010-04-12 19:25:12.000000000 +0200
@@ -32,9 +32,9 @@
              TEveProjections TEveScene TEveSelection TEveTrans TEveTreeTools \
              TEveUtil TEveVector TEveVSD TEveViewer TEveWindow
 
-EVEH2     := TEveArrow TEveBoxSet TEveCalo \
+EVEH2     := TEveArrow TEveBox TEveCalo \
              TEveDigitSet TEveFrameBox TEveGeo \
-             TEveGridStepper TEveLegoEventHandler \
+             TEveGridStepper TEveLegoEventHandler TEveShape \
              TEveLine TEvePointSet TEvePolygonSetProjected TEveQuadSet \
              TEveRGBAPalette TEveScalableStraightLineSet TEveStraightLineSet \
              TEveText TEveTrack TEveTriangleSet TEveJetCone \
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/LinkDef1.h root/graf3d/eve/inc/LinkDef1.h
--- root-old/graf3d/eve/inc/LinkDef1.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/LinkDef1.h	2010-04-12 19:25:20.000000000 +0200
@@ -45,6 +45,7 @@
 // TEveVector
 #pragma link C++ class TEveVector+;
 #pragma link C++ class TEveVector4+;
+#pragma link C++ class TEvePoint+;
 #pragma link C++ class TEvePathMark+;
 
 // TEveTrans
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/LinkDef2.h root/graf3d/eve/inc/LinkDef2.h
--- root-old/graf3d/eve/inc/LinkDef2.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/LinkDef2.h	2010-04-12 19:25:20.000000000 +0200
@@ -84,9 +84,16 @@
 // Arbitrary-tesselation TGeoShape.
 #pragma link C++ class TEveGeoPolyShape+;
 
+// Various shapes
+#pragma link C++ class TEveShape+;
+#pragma link C++ class TEveShapeEditor+;
+#pragma link C++ class TEveBox+;
+#pragma link C++ class TEveBoxGL+;
+#pragma link C++ class TEveBoxProjected+;
+#pragma link C++ class TEveBoxProjectedGL+;
+
 // TEvePolygonSetProjected
 #pragma link C++ class TEvePolygonSetProjected+;
-#pragma link C++ class TEvePolygonSetProjectedEditor+;
 #pragma link C++ class TEvePolygonSetProjectedGL+;
 
 // TEveTrianlgeSet
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveBox.h root/graf3d/eve/inc/TEveBox.h
--- root-old/graf3d/eve/inc/TEveBox.h	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/inc/TEveBox.h	2010-04-12 19:25:20.000000000 +0200
@@ -0,0 +1,86 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveBox
+#define ROOT_TEveBox
+
+#include "TEveShape.h"
+
+//------------------------------------------------------------------------------
+// TEveBox
+//------------------------------------------------------------------------------
+
+class TEveBox : public TEveShape
+{
+   friend class TEveBoxGL;
+
+private:
+   TEveBox(const TEveBox&);            // Not implemented
+   TEveBox& operator=(const TEveBox&); // Not implemented
+
+protected:
+   Float_t fVertices[8][3];
+
+public:
+   TEveBox(const char* n="TEveBox", const char* t="");
+   virtual ~TEveBox();
+
+   void SetVertex(Int_t i, Float_t x, Float_t y, Float_t z);
+   void SetVertex(Int_t i, const Float_t* v);
+   void SetVertices(const Float_t* vs);
+
+   const Float_t* GetVertex(Int_t i) const { return fVertices[i]; }
+
+   // For TAttBBox:
+   virtual void ComputeBBox();
+
+   // Projectable:
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
+
+   ClassDef(TEveBox, 0); // 3D box with arbitrary vertices.
+};
+
+
+//------------------------------------------------------------------------------
+// TEveBoxProjected
+//------------------------------------------------------------------------------
+
+class TEveBoxProjected : public TEveShape,
+                         public TEveProjected
+{
+   friend class TEveBoxProjectedGL;
+
+private:
+   TEveBoxProjected(const TEveBoxProjected&);            // Not implemented
+   TEveBoxProjected& operator=(const TEveBoxProjected&); // Not implemented
+
+protected:
+   vPoint_t     fPoints;
+   Int_t        fBreakIdx;
+   vPoint_t     fDebugPoints;
+
+   virtual void SetDepthLocal(Float_t d);
+
+public:
+   TEveBoxProjected(const char* n="TEveBoxProjected", const char* t="");
+   virtual ~TEveBoxProjected();
+
+   // For TAttBBox:
+   virtual void ComputeBBox();
+
+   // Projected:
+   virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
+   virtual void UpdateProjection();
+
+   ClassDef(TEveBoxProjected, 0); // 3D box with arbitrary vertices.
+};
+
+#endif
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveBoxGL.h root/graf3d/eve/inc/TEveBoxGL.h
--- root-old/graf3d/eve/inc/TEveBoxGL.h	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/inc/TEveBoxGL.h	2010-04-12 19:25:20.000000000 +0200
@@ -0,0 +1,90 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveBoxGL
+#define ROOT_TEveBoxGL
+
+#include "TGLObject.h"
+
+class TGLViewer;
+class TGLScene;
+
+class TEveBox;
+class TEveBoxProjected;
+
+//------------------------------------------------------------------------------
+// TEveBoxGL
+//------------------------------------------------------------------------------
+
+class TEveBoxGL : public TGLObject
+{
+private:
+   TEveBoxGL(const TEveBoxGL&);            // Not implemented
+   TEveBoxGL& operator=(const TEveBoxGL&); // Not implemented
+
+protected:
+   TEveBox             *fM;  // Model object.
+
+   void RenderOutline    (const Float_t p[8][3]) const;
+   void RenderBoxStdNorm (const Float_t p[8][3]) const;
+   void RenderBoxAutoNorm(const Float_t p[8][3]) const;
+
+public:
+   TEveBoxGL();
+   virtual ~TEveBoxGL() {}
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void Draw(TGLRnrCtx& rnrCtx) const;
+   virtual void DirectDraw(TGLRnrCtx& rnrCtx) const;
+
+   // To support two-level selection
+   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+
+   ClassDef(TEveBoxGL, 0); // GL renderer class for TEveBox.
+};
+
+
+//------------------------------------------------------------------------------
+// TEveBoxProjectedGL
+//------------------------------------------------------------------------------
+
+class TEveBoxProjectedGL : public TGLObject
+{
+private:
+   TEveBoxProjectedGL(const TEveBoxProjectedGL&);            // Not implemented
+   TEveBoxProjectedGL& operator=(const TEveBoxProjectedGL&); // Not implemented
+
+protected:
+   TEveBoxProjected             *fM;  // Model object.
+
+   void RenderPoints(Int_t mode) const;
+
+public:
+   TEveBoxProjectedGL();
+   virtual ~TEveBoxProjectedGL() {}
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void Draw(TGLRnrCtx& rnrCtx) const;
+   virtual void DirectDraw(TGLRnrCtx& rnrCtx) const;
+
+   // To support two-level selection
+   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+
+   ClassDef(TEveBoxProjectedGL, 0); // GL renderer class for TEveBoxProjected.
+};
+
+#endif
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveCalo.h root/graf3d/eve/inc/TEveCalo.h
--- root-old/graf3d/eve/inc/TEveCalo.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveCalo.h	2010-04-12 19:26:10.000000000 +0200
@@ -82,9 +82,10 @@
 
    TEveCaloData* GetData() const { return fData; }
    void    SetData(TEveCaloData* d);
-   void    DataChanged();   Float_t GetMaxVal() const;
+   void    DataChanged();
+   Float_t GetMaxVal() const;
 
-   void    AssertCellIdCache() const;
+   Bool_t  AssertCellIdCache() const;
    void    InvalidateCellIdCache() { fCellIdCacheOK=kFALSE; ResetBBox(); };
 
    Float_t GetDataSliceThreshold(Int_t slice) const;
@@ -261,8 +262,6 @@
    Bool_t                  fDrawHPlane;
    Float_t                 fHPlaneVal;
 
-   Int_t                   fBinStep;
-
    Int_t                   fDrawNumberCellPixels;
    Int_t                   fCellPixelFontSize;
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveCaloData.h root/graf3d/eve/inc/TEveCaloData.h
--- root-old/graf3d/eve/inc/TEveCaloData.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveCaloData.h	2010-04-12 19:26:01.000000000 +0200
@@ -118,6 +118,12 @@
       std::vector<Int_t>   fBinData;
 
       Float_t* GetSliceVals(Int_t bin);
+
+      void Clear()
+      {
+         fSliceData.clear();
+         fBinData.clear();
+      }
    };
 
    /**************************************************************************/
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveCaloLegoGL.h root/graf3d/eve/inc/TEveCaloLegoGL.h
--- root-old/graf3d/eve/inc/TEveCaloLegoGL.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveCaloLegoGL.h	2010-04-12 19:26:08.000000000 +0200
@@ -25,6 +25,8 @@
 
 class TEveCaloLegoGL : public TGLObject
 {
+   friend class TEveCaloLegoOverlay;
+
 private:
    struct Cell2D_t
    {
@@ -80,13 +82,15 @@
    mutable vCell2D_t                 fCells2D;
 
    mutable TEveCaloData::RebinData_t fRebinData;
-   mutable Float_t                   fMaxValRebin;
+   mutable Float_t                   fMaxVal;
    mutable Float_t                   fValToPixel; // top logaritmic viewview
    mutable Int_t                     fCurrentPixelsPerBin;
 
    mutable SliceDLMap_t              fDLMap;
    mutable Bool_t                    fCells3D;
 
+   mutable Int_t                     fBinStep;
+
    TEveCaloLegoGL(const TEveCaloLegoGL&);            // Stop default
    TEveCaloLegoGL& operator=(const TEveCaloLegoGL&); // Stop default
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveDigitSet.h root/graf3d/eve/inc/TEveDigitSet.h
--- root-old/graf3d/eve/inc/TEveDigitSet.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveDigitSet.h	2010-04-12 19:24:48.000000000 +0200
@@ -54,10 +54,12 @@
 
    Int_t             fDefaultValue;   //  Default signal value.
    Bool_t            fValueIsColor;   //  Interpret signal value as RGBA color.
-   Bool_t            fOwnIds;         //  Flag specifying if id-objects are owned by the TEveDigitSet
+   Bool_t            fSingleColor;    //  Use the same color for all digits.
+   Bool_t            fOwnIds;         //  Flag specifying if id-objects are owned by the TEveDigitSet.
    TEveChunkManager  fPlex;           //  Container of digit data.
    DigitBase_t*      fLastDigit;      //! The last digit added to collection.
 
+   Color_t           fColor;          //  Color used for frame
    TEveFrameBox*     fFrame;          //  Pointer to frame structure.
    TEveRGBAPalette*  fPalette;        //  Pointer to signal-color palette.
    ERenderMode_e     fRenderMode;     //  Render mode: as-is / line / filled.
@@ -74,6 +76,8 @@
    TEveDigitSet(const char* n="TEveDigitSet", const char* t="");
    virtual ~TEveDigitSet();
 
+   void UseSingleColor();
+
    virtual Bool_t CanEditMainColor() const { return kTRUE; }
    virtual void   SetMainColor(Color_t color);
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveElement.h root/graf3d/eve/inc/TEveElement.h
--- root-old/graf3d/eve/inc/TEveElement.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveElement.h	2010-04-12 19:25:20.000000000 +0200
@@ -60,7 +60,7 @@
    };
 
    static const TGPicture*                      fgRnrIcons[4];
-   static const TGPicture*                      fgListTreeIcons[8];
+   static const TGPicture*                      fgListTreeIcons[9];
 
    typedef std::set<TEveListTreeInfo>           sLTI_t;
    typedef sLTI_t::iterator                     sLTI_i;
@@ -185,6 +185,7 @@
    void   DecParentIgnoreCnt();
 
    virtual void PadPaint(Option_t* option);
+   virtual void PaintStandard(TObject* id);
 
    virtual TObject* GetObject      (const TEveException& eh="TEveElement::GetObject ") const;
    virtual TObject* GetEditorObject(const TEveException& eh="TEveElement::GetEditorObject ") const { return GetObject(eh); }
@@ -229,6 +230,8 @@
    virtual void RemoveElements();
    virtual void RemoveElementsLocal();
 
+   virtual void ProjectChild(TEveElement* el, Bool_t same_depth=kTRUE);
+
    virtual void Destroy();                      // *MENU*
    virtual void DestroyOrWarn();
    virtual void DestroyElements();              // *MENU*
@@ -267,7 +270,7 @@
 
    virtual Bool_t     CanEditMainTrans() const { return fCanEditMainTrans; }
    virtual Bool_t     HasMainTrans()     const { return fMainTrans != 0;   }
-   virtual TEveTrans* PtrMainTrans();
+   virtual TEveTrans* PtrMainTrans(Bool_t create=kTRUE);
    virtual TEveTrans& RefMainTrans();
    virtual void       InitMainTrans(Bool_t can_edit=kTRUE);
    virtual void       DestroyMainTrans();
@@ -317,6 +320,8 @@
 
    virtual UChar_t GetSelectedLevel() const;
 
+   void RecheckImpliedSelections();
+
    // Change-stamping and change bits
    //---------------------------------
 
@@ -436,9 +441,9 @@
    virtual Bool_t CanEditMainColor() const { return fDoColor; }
 
    TClass* GetChildClass() const { return fChildClass; }
-   void SetChildClass(TClass* c) { fChildClass = c; }
+   void    SetChildClass(TClass* c) { fChildClass = c; }
 
-   virtual Bool_t AcceptElement(TEveElement* el);
+   virtual Bool_t  AcceptElement(TEveElement* el);
 
    virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveGedEditor.h root/graf3d/eve/inc/TEveGedEditor.h
--- root-old/graf3d/eve/inc/TEveGedEditor.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveGedEditor.h	2010-04-12 19:24:18.000000000 +0200
@@ -103,6 +103,10 @@
 
 class TEveGedNameTextButton : public TGTextButton
 {
+private:
+   TEveGedNameTextButton(const TEveGedNameTextButton&);            // Not implemented
+   TEveGedNameTextButton& operator=(const TEveGedNameTextButton&); // Not implemented
+
    TEveGedNameFrame *fFrame;
 
 public:
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveGeoShape.h root/graf3d/eve/inc/TEveGeoShape.h
--- root-old/graf3d/eve/inc/TEveGeoShape.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveGeoShape.h	2010-04-12 19:25:20.000000000 +0200
@@ -18,6 +18,7 @@
 
 class TGeoShape;
 class TEveGeoShapeExtract;
+class TBuffer3D;
 
 class TEveGeoShape : public TEveElement,
                      public TNamed,
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveLine.h root/graf3d/eve/inc/TEveLine.h
--- root-old/graf3d/eve/inc/TEveLine.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveLine.h	2010-04-12 19:24:55.000000000 +0200
@@ -61,13 +61,15 @@
    TEveVector GetLineStart() const;
    TEveVector GetLineEnd()   const;
 
+   virtual const TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
+
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
    virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
-   static Bool_t GetDefaultSmooth()       { return fgDefaultSmooth; }
-   static void SetDefaultSmooth(Bool_t r) { fgDefaultSmooth = r;    }
+   static Bool_t GetDefaultSmooth();
+   static void   SetDefaultSmooth(Bool_t r);
 
    ClassDef(TEveLine, 0); // An arbitrary polyline with fixed line and marker attributes.
 };
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEvePlot3D.h root/graf3d/eve/inc/TEvePlot3D.h
--- root-old/graf3d/eve/inc/TEvePlot3D.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEvePlot3D.h	2010-04-12 19:25:07.000000000 +0200
@@ -15,7 +15,7 @@
 #include "TEveElement.h"
 #include "TAttBBox.h"
 
-class TEvePlot3D : public TEveElementList // , public TAttBBox
+class TEvePlot3D : public TEveElementList
 {
    friend class TEvePlot3DGL;
 
@@ -35,9 +35,6 @@
    TEvePlot3D(const char* n="TEvePlot3D", const char* t="");
    virtual ~TEvePlot3D() {}
 
-   // For TAttBBox:
-   // virtual void ComputeBBox();
-
    void SetPlot(TObject* obj, const TString& opt) { fPlot = obj; fPlotOption = opt; }
 
    TObject* GetPlot()       const { return fPlot;   }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEvePolygonSetProjected.h root/graf3d/eve/inc/TEvePolygonSetProjected.h
--- root-old/graf3d/eve/inc/TEvePolygonSetProjected.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEvePolygonSetProjected.h	2010-04-12 19:25:07.000000000 +0200
@@ -12,25 +12,19 @@
 #ifndef ROOT_TEvePolygonSetProjected
 #define ROOT_TEvePolygonSetProjected
 
-#include "TEveElement.h"
+#include "TEveShape.h"
 #include "TEveProjectionBases.h"
 
-#include "TNamed.h"
-#include "TAtt3D.h"
-#include "TAttBBox.h"
-#include "TColor.h"
-
 class TBuffer3D;
 
 class TEveVector;
 
-class TEvePolygonSetProjected :  public TEveElementList,
-                                 public TEveProjected,
-                                 public TAtt3D,
-                                 public TAttBBox
+class TEvePolygonSetProjected : public TEveShape,
+                                public TEveProjected
 {
    friend class TEvePolygonSetProjectedGL;
    friend class TEvePolygonSetProjectedEditor;
+
 private:
    TEvePolygonSetProjected(const TEvePolygonSetProjected&);            // Not implemented
    TEvePolygonSetProjected& operator=(const TEvePolygonSetProjected&); // Not implemented
@@ -42,7 +36,7 @@
       Int_t*    fPnts;   // point indices
 
       Polygon_t() : fNPnts(0), fPnts(0) {}
-     virtual ~Polygon_t() { delete [] fPnts; fNPnts=0; fPnts=0;}
+      virtual ~Polygon_t() { delete [] fPnts; fNPnts=0; fPnts=0; }
 
       Polygon_t& operator=(const Polygon_t& x)
       { fNPnts = x.fNPnts; fPnts = x.fPnts; return *this; }
@@ -73,45 +67,22 @@
    Int_t        fNPnts;    // number of reduced and projected points
    TEveVector*  fPnts;     // reduced and projected points
 
-   Color_t      fFillColor; // fill color of polygons
-   Color_t      fLineColor; // outline color of polygons
-   Float_t      fLineWidth; // outline width of polygons
-
-   Bool_t       fHighlightFrame; // higlight mode
-
    virtual void SetDepthLocal(Float_t d);
 
 public:
    TEvePolygonSetProjected(const char* n="TEvePolygonSetProjected", const char* t="");
    virtual ~TEvePolygonSetProjected();
 
+   virtual void    ComputeBBox();
+
    virtual void    SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void    UpdateProjection();
 
    void            ProjectBuffer3D();
 
-   virtual void    ComputeBBox();
-   virtual void    Paint(Option_t* option = "");
-
    virtual void    DumpPolys() const;
    void            DumpBuffer3D();
 
-   // Rendering parameters.
-   virtual Bool_t  CanEditMainColor() const { return kTRUE; }
-   virtual void    SetMainColor(Color_t color);
-
-   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
-
-   virtual Color_t GetFillColor() const { return fFillColor; }
-   virtual Color_t GetLineColor() const { return fLineColor; }
-   virtual Float_t GetLineWidth() const { return fLineWidth;}
-   virtual Bool_t  GetHighlightFrame() const { return fHighlightFrame; }
-
-   virtual void    SetFillColor(Color_t c)  { fFillColor = c; }
-   virtual void    SetLineColor(Color_t c)  { fLineColor = c; }
-   virtual void    SetLineWidth(Float_t lw) { fLineWidth = lw;}
-   virtual void    SetHighlightFrame(Bool_t f) { fHighlightFrame = f; }
-
    ClassDef(TEvePolygonSetProjected,0); // Set of projected polygons with outline; typically produced from a TBuffer3D.
 
 };
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h root/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h
--- root-old/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
-// Authors: Matevz Tadel & Alja Mrak-Tadel: 2006, 2007
-
-/*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
-
-#ifndef ROOT_TEvePolygonSetProjectedEditor
-#define ROOT_TEvePolygonSetProjectedEditor
-
-#include "TGedFrame.h"
-
-class TGNumberEntry;
-class TGColorSelect;
-
-class TEvePolygonSetProjected;
-
-class TEvePolygonSetProjectedEditor : public TGedFrame
-{
-   TEvePolygonSetProjectedEditor(const TEvePolygonSetProjectedEditor&);            // Not implemented
-   TEvePolygonSetProjectedEditor& operator=(const TEvePolygonSetProjectedEditor&); // Not implemented
-
-protected:
-   TEvePolygonSetProjected *fPS;         // Model object.
-
-   TGNumberEntry           *fLineWidth;  // TEveLine width widget.
-   TGColorSelect           *fLineColor;  // TEveLine color widget.
-
-public:
-   TEvePolygonSetProjectedEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30,
-                                 UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());
-   ~TEvePolygonSetProjectedEditor() {}
-
-   virtual void SetModel(TObject* obj);
-
-   virtual void DoLineWidth();
-   virtual void DoLineColor(Pixel_t color);
-
-   ClassDef(TEvePolygonSetProjectedEditor, 0); // Editor for TEvePolygonSetProjected class.
-};
-
-#endif
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveProjectionAxes.h root/graf3d/eve/inc/TEveProjectionAxes.h
--- root-old/graf3d/eve/inc/TEveProjectionAxes.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveProjectionAxes.h	2010-04-12 19:25:07.000000000 +0200
@@ -53,9 +53,7 @@
    TEveProjectionAxes(TEveProjectionManager* m, Bool_t useColorSet = kTRUE);
    virtual ~TEveProjectionAxes();
 
-   TEveProjectionManager* GetManager(){
-      return fManager;
-   }
+   TEveProjectionManager* GetManager()      { return fManager; }
 
    void            SetLabMode(ELabMode x)   { fLabMode = x; }
    ELabMode        GetLabMode()   const     { return fLabMode;}
@@ -69,6 +67,7 @@
 
    virtual void    Paint(Option_t* option="");
    virtual void    ComputeBBox();
+
    virtual const   TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
 
    ClassDef(TEveProjectionAxes, 1); // Class to draw scales in non-linear projections.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveProjectionBases.h root/graf3d/eve/inc/TEveProjectionBases.h
--- root-old/graf3d/eve/inc/TEveProjectionBases.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveProjectionBases.h	2010-04-12 19:25:20.000000000 +0200
@@ -12,16 +12,17 @@
 #ifndef ROOT_TEveProjectionBases
 #define ROOT_TEveProjectionBases
 
-#include "TEveUtil.h"
-
-class TBuffer3D;
+#include "Rtypes.h"
+#include <list>
+#include <set>
 
 class TEveElement;
-
 class TEveProjection;
 class TEveProjected;
 class TEveProjectionManager;
 
+class TClass;
+
 ////////////////////////////////////////////////////////////////
 //                                                            //
 // TEveProjectable                                            //
@@ -36,10 +37,11 @@
    TEveProjectable(const TEveProjectable&);            // Not implemented
    TEveProjectable& operator=(const TEveProjectable&); // Not implemented
 
-protected:
+public:
    typedef std::list<TEveProjected*>            ProjList_t;
    typedef std::list<TEveProjected*>::iterator  ProjList_i;
 
+protected:
    ProjList_t       fProjectedList; // references to projected instances.
 
 public:
@@ -50,6 +52,9 @@
 
    virtual Bool_t HasProjecteds() const { return ! fProjectedList.empty(); }
 
+   ProjList_i   BeginProjecteds()       { return  fProjectedList.begin(); }
+   ProjList_i   EndProjecteds()         { return  fProjectedList.end();   }
+
    virtual void AddProjected(TEveProjected* p)    { fProjectedList.push_back(p); }
    virtual void RemoveProjected(TEveProjected* p) { fProjectedList.remove(p);    }
 
@@ -89,7 +94,11 @@
    TEveProjected();
    virtual ~TEveProjected();
 
-   TEveProjectable* GetProjectable() const { return fProjectable; }
+   TEveProjectionManager* GetManager()     const { return fManager; }
+   TEveProjectable*       GetProjectable() const { return fProjectable; }
+   Float_t                GetDepth()       const { return fDepth; }
+
+   TEveElement*           GetProjectableAsElement() const;
 
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void UnRefProjectable(TEveProjectable* assumed_parent);
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveProjectionManager.h root/graf3d/eve/inc/TEveProjectionManager.h
--- root-old/graf3d/eve/inc/TEveProjectionManager.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveProjectionManager.h	2010-04-12 19:25:20.000000000 +0200
@@ -66,6 +66,8 @@
    virtual TEveElement* ImportElements(TEveElement* el,
                                        TEveElement* ext_list=0);
 
+   virtual TEveElement* SubImportElements(TEveElement* el, TEveElement* proj_parent);
+
    virtual void    ProjectChildren();
    virtual void    ProjectChildrenRecurse(TEveElement* el);
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveProjections.h root/graf3d/eve/inc/TEveProjections.h
--- root-old/graf3d/eve/inc/TEveProjections.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveProjections.h	2010-04-12 19:25:20.000000000 +0200
@@ -17,6 +17,7 @@
 
 #include <vector>
 
+class TEveTrans;
 
 //==============================================================================
 // TEveProjection
@@ -83,9 +84,14 @@
    virtual Bool_t      Is3D() const = 0;
 
    virtual void        ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e p = kPP_Full) = 0;
-   virtual void        ProjectPointfv(Float_t* v, Float_t d);
-   virtual void        ProjectPointdv(Double_t* v, Float_t d);
-   virtual void        ProjectVector(TEveVector& v, Float_t d);
+
+   void                ProjectPointfv(Float_t* v, Float_t d);
+   void                ProjectPointdv(Double_t* v, Float_t d);
+   void                ProjectVector(TEveVector& v, Float_t d);
+
+   void                ProjectPointfv(const TEveTrans* t, const Float_t*  p, Float_t* v, Float_t d);
+   void                ProjectPointdv(const TEveTrans* t, const Double_t* p, Double_t* v, Float_t d);
+   void                ProjectVector(const TEveTrans* t, TEveVector& v, Float_t d);
 
    const   Char_t*     GetName() const            { return fName.Data(); }
    void                SetName(const Char_t* txt) { fName = txt; }
@@ -123,7 +129,8 @@
    Float_t  GetMaxTrackStep() const    { return fMaxTrackStep; }
    void     SetMaxTrackStep(Float_t x) { fMaxTrackStep = TMath::Max(x, 1.0f); }
 
-   virtual   Bool_t    AcceptSegment(TEveVector&, TEveVector&, Float_t /*tolerance*/) { return kTRUE; }
+   virtual   Bool_t    AcceptSegment(TEveVector&, TEveVector&, Float_t /*tolerance*/) const { return kTRUE; }
+   virtual   Int_t     SubSpaceId(const TEveVector&) const { return 0; }
    virtual   void      SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
 
    // utils to draw axis
@@ -131,7 +138,8 @@
    virtual Float_t     GetScreenVal(Int_t ax, Float_t value);
    Float_t             GetLimit(Int_t i, Bool_t pos) { return pos ? fUpLimit[i] : fLowLimit[i]; }
 
-   static   Float_t    fgEps;  // resolution of projected points
+   static   Float_t    fgEps;    // resolution of projected points
+   static   Float_t    fgEpsSqr; // square of resolution of projected points
 
    ClassDef(TEveProjection, 0); // Base for specific classes that implement non-linear projections.
 };
@@ -153,14 +161,15 @@
    virtual Bool_t      Is2D() const { return kTRUE;  }
    virtual Bool_t      Is3D() const { return kFALSE; }
 
-   virtual   void      ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
+   virtual void        ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
 
-   virtual   void      SetCenter(TEveVector& center);
-   virtual   Float_t*  GetProjectedCenter() { return fProjectedCenter.Arr(); }
+   virtual void        SetCenter(TEveVector& center);
+   virtual Float_t*    GetProjectedCenter() { return fProjectedCenter.Arr(); }
 
    virtual   void      UpdateLimit();
 
-   virtual   Bool_t    AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance);
+   virtual   Bool_t    AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance) const;
+   virtual   Int_t     SubSpaceId(const TEveVector& v) const;
    virtual   void      SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
 
    ClassDef(TEveRhoZProjection, 0); // Rho/Z non-linear projection.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveSelection.h root/graf3d/eve/inc/TEveSelection.h
--- root-old/graf3d/eve/inc/TEveSelection.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveSelection.h	2010-04-12 19:25:03.000000000 +0200
@@ -53,6 +53,8 @@
    void DoElementSelect  (SelMap_i entry);
    void DoElementUnselect(SelMap_i entry);
 
+   void RecheckImpliedSet(SelMap_i smi);
+
 public:
    TEveSelection(const char* n="TEveSelection", const char* t="");
    virtual ~TEveSelection() {}
@@ -75,6 +77,8 @@
 
    virtual void RemoveImpliedSelected(TEveElement* el);
 
+   void RecheckImpliedSetForElement(TEveElement* el);
+
    void SelectionAdded(TEveElement* el);    // *SIGNAL*
    void SelectionRemoved(TEveElement* el);  // *SIGNAL*
    void SelectionCleared();                 // *SIGNAL*
@@ -82,7 +86,6 @@
 
    // ----------------------------------------------------------------
    // Interface to make selection active/non-active.
-   // Not used yet, assumed to be active all the time.
 
    virtual void ActivateSelection();
    virtual void DeactivateSelection();
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveShape.h root/graf3d/eve/inc/TEveShape.h
--- root-old/graf3d/eve/inc/TEveShape.h	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/inc/TEveShape.h	2010-04-12 19:25:25.000000000 +0200
@@ -0,0 +1,89 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveShape
+#define ROOT_TEveShape
+
+#include "TEveElement.h"
+#include "TEveVector.h"
+
+#include "TAtt3D.h"
+#include "TAttBBox.h"
+#include "TColor.h"
+
+class TEveShape : public TEveElementList,
+                  public TAtt3D,
+                  public TAttBBox
+{
+   friend class TEveShapeEditor;
+
+private:
+   TEveShape(const TEveShape&);            // Not implemented
+   TEveShape& operator=(const TEveShape&); // Not implemented
+
+public:
+   typedef std::vector<TEvePoint>           vPoint_t;
+   typedef std::vector<TEvePoint>::iterator vPoint_i;
+
+protected:
+   Color_t      fFillColor; // fill color of polygons
+   Color_t      fLineColor; // outline color of polygons
+   Float_t      fLineWidth; // outline width of polygons
+
+   Bool_t       fDrawFrame;      // draw frame
+   Bool_t       fHighlightFrame; // highlight frame / all shape
+
+public:
+   TEveShape(const char* n="TEveShape", const char* t="");
+   virtual ~TEveShape();
+
+   // Rendering parameters.
+   virtual Bool_t  CanEditMainColor() const { return kTRUE; }
+   virtual void    SetMainColor(Color_t color);
+
+   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+
+   virtual Color_t GetFillColor() const { return fFillColor; }
+   virtual Color_t GetLineColor() const { return fLineColor; }
+   virtual Float_t GetLineWidth() const { return fLineWidth;}
+   virtual Bool_t  GetDrawFrame()      const { return fDrawFrame; }
+   virtual Bool_t  GetHighlightFrame() const { return fHighlightFrame; }
+
+   virtual void    SetFillColor(Color_t c)  { fFillColor = c; }
+   virtual void    SetLineColor(Color_t c)  { fLineColor = c; }
+   virtual void    SetLineWidth(Float_t lw) { fLineWidth = lw;}
+   virtual void    SetDrawFrame(Bool_t f)      { fDrawFrame = f; }
+   virtual void    SetHighlightFrame(Bool_t f) { fHighlightFrame = f; }
+
+   // ----------------------------------------------------------------
+
+   virtual void CopyVizParams(const TEveElement* el);
+   virtual void WriteVizParams(ostream& out, const TString& var);
+
+   // ----------------------------------------------------------------
+
+   // Virtual from TObject
+   virtual void Paint(Option_t* option="");
+
+   // Abstract function from TAttBBox:
+   // virtual void ComputeBBox();
+
+   // Abstract from TEveProjectable, overriden in TEveElementList:
+   // virtual TClass* ProjectedClass(const TEveProjection* p) const;
+
+   // ----------------------------------------------------------------
+
+   static Int_t FindConvexHull(const vPoint_t& pin, vPoint_t& pout, TEveElement* caller=0);
+
+   ClassDef(TEveShape, 0); // Abstract base-class for 2D/3D shapes.
+};
+
+#endif
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveShapeEditor.h root/graf3d/eve/inc/TEveShapeEditor.h
--- root-old/graf3d/eve/inc/TEveShapeEditor.h	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/inc/TEveShapeEditor.h	2010-04-12 19:25:09.000000000 +0200
@@ -0,0 +1,53 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveShapeEditor
+#define ROOT_TEveShapeEditor
+
+#include "TGedFrame.h"
+
+class TGButton;
+class TGCheckButton;
+class TGNumberEntry;
+class TGColorSelect;
+
+class TEveShape;
+
+class TEveShapeEditor : public TGedFrame
+{
+private:
+   TEveShapeEditor(const TEveShapeEditor&);            // Not implemented
+   TEveShapeEditor& operator=(const TEveShapeEditor&); // Not implemented
+
+protected:
+   TEveShape        *fM; // Model object.
+
+   TGNumberEntry    *fLineWidth;  // Line width widget.
+   TGColorSelect    *fLineColor;  // Line color widget.
+   TGCheckButton    *fDrawFrame;       // Checkbox for frame rendering.
+   TGCheckButton    *fHighlightFrame;  // Checkbox for frame rendering.
+
+public:
+   TEveShapeEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30,
+         UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());
+   virtual ~TEveShapeEditor() {}
+
+   virtual void SetModel(TObject* obj);
+
+   void DoLineWidth();
+   void DoLineColor(Pixel_t color);
+   void DoDrawFrame();
+   void DoHighlightFrame();
+
+   ClassDef(TEveShapeEditor, 0); // GUI editor for TEveShape.
+};
+
+#endif
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrack.h root/graf3d/eve/inc/TEveTrack.h
--- root-old/graf3d/eve/inc/TEveTrack.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveTrack.h	2010-04-12 19:25:20.000000000 +0200
@@ -56,6 +56,7 @@
    Int_t              fStatus;     // Status-word, user-defined.
    Bool_t             fLockPoints; // Lock points that are currently in - do nothing in MakeTrack().
    vPathMark_t        fPathMarks;  // TEveVector of known points along the track
+   Int_t              fLastPMIdx;  //!Last path-mark index tried in track-propagation.
 
    TEveTrackPropagator *fPropagator;   // Pointer to shared render-style
 
@@ -79,8 +80,9 @@
    virtual void MakeTrack(Bool_t recurse=kTRUE);
 
    TEveTrackPropagator* GetPropagator() const  { return fPropagator; }
-   void SetPropagator(TEveTrackPropagator* prop);
-   void SetAttLineAttMarker(TEveTrackList* tl);
+   Int_t GetLastPMIdx() const { return fLastPMIdx; }
+   void  SetPropagator(TEveTrackPropagator* prop);
+   void  SetAttLineAttMarker(TEveTrackList* tl);
 
    const TEveVector& GetVertex()      const { return fV;    }
    const TEveVector& GetMomentum()    const { return fP;    }
@@ -123,8 +125,8 @@
    UChar_t GetBreakProjectedTracks() const     { return fBreakProjectedTracks; }
    void    SetBreakProjectedTracks(UChar_t bt) { fBreakProjectedTracks = bt;   }
 
-   static Bool_t GetDefaultBreakProjectedTracks()          { return fgDefaultBreakProjectedTracks; }
-   static void   SetDefaultBreakProjectedTracks(Bool_t bt) { fgDefaultBreakProjectedTracks = bt;   }
+   static Bool_t GetDefaultBreakProjectedTracks();
+   static void   SetDefaultBreakProjectedTracks(Bool_t bt);
 
    ClassDef(TEveTrack, 1); // Track with given vertex, momentum and optional referece-points (path-marks) along its path.
 };
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackGL.h root/graf3d/eve/inc/TEveTrackGL.h
--- root-old/graf3d/eve/inc/TEveTrackGL.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveTrackGL.h	2010-04-12 19:25:20.000000000 +0200
@@ -28,6 +28,8 @@
 protected:
    TEveTrack* fTrack; // Model object.
 
+   void RenderPathMarksAndFirstVertex(TGLRnrCtx& rnrCtx) const;
+
 public:
    TEveTrackGL();
    virtual ~TEveTrackGL() {}
@@ -36,7 +38,7 @@
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
 
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
-   virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+   virtual void   ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec);
 
    ClassDef(TEveTrackGL, 0); // GL-renderer for TEveTrack class.
 };
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackProjected.h root/graf3d/eve/inc/TEveTrackProjected.h
--- root-old/graf3d/eve/inc/TEveTrackProjected.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveTrackProjected.h	2010-04-12 19:25:20.000000000 +0200
@@ -15,7 +15,6 @@
 #include "TEveTrack.h"
 #include "TEveProjectionBases.h"
 
-class TEveProjection;
 
 class TEveTrackProjected : public TEveTrack,
                            public TEveProjected
@@ -33,7 +32,6 @@
 
 protected:
    std::vector<Int_t>   fBreakPoints; // indices of track break-points
-   TEveProjection      *fProjection;  // projection
 
    virtual void SetDepthLocal(Float_t d);
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackPropagator.h root/graf3d/eve/inc/TEveTrackPropagator.h
--- root-old/graf3d/eve/inc/TEveTrackPropagator.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveTrackPropagator.h	2010-04-12 19:25:26.000000000 +0200
@@ -45,6 +45,7 @@
 
    virtual TEveVector GetField(const TEveVector &v) const { return GetField(v.fX, v.fY, v.fZ);}
    virtual TEveVector GetField(Float_t x, Float_t y, Float_t z) const = 0;
+   virtual Float_t GetMaxFieldMag() const { return 4; } // not abstract because of backward compatibility
 
    ClassDef(TEveMagField, 0); // Abstract interface to magnetic field
 };
@@ -66,6 +67,7 @@
 
    using   TEveMagField::GetField;
    virtual TEveVector GetField(Float_t /*x*/, Float_t /*y*/, Float_t /*z*/) const { return fB; }
+   virtual Float_t GetMaxFieldMag() const { return fB.Mag(); };
 
    ClassDef(TEveMagFieldConst, 0); // Interface to constant magnetic field.
 };
@@ -93,6 +95,8 @@
    using   TEveMagField::GetField;
    virtual TEveVector GetField(Float_t x, Float_t y, Float_t /*z*/) const
    { return  ((x*x+y*y)<fR2) ? fBIn : fBOut; }
+   virtual Float_t GetMaxFieldMag() const
+   { Float_t b1 = fBIn.Mag(), b2 = fBOut.Mag(); return b1 > b2 ? b1 : b2; }
 
    ClassDef(TEveMagFieldDuo, 0); // Interface to magnetic field with two different values depending of radius.
 };
@@ -111,10 +115,9 @@
    struct Helix_t
    {
       Int_t   fCharge;   // Charge of tracked particle.
-      Float_t fMinAng;   // Minimal angular step between two helix points.
-      Float_t fDelta;    // Maximal error at the mid-point of the line connecting two helix points.
+      Float_t fMaxAng;   // Maximum step angle.
       Float_t fMaxStep;  // Maximum allowed step size.
-      Float_t fCurrentStep;
+      Float_t fDelta;    // Maximum error in the middle of the step.
 
       Float_t fPhi;      // Accumulated angle to check fMaxOrbs by propagator.
       Bool_t  fValid;    // Corner case pT~0 or B~0, possible in variable mag field.
@@ -127,6 +130,9 @@
       Float_t fPhiStep;     // Caluclated from fMinAng and fDelta.
       Float_t fSin, fCos;   // Current sin/cos(phistep).
 
+      // Runge-Kutta parameters
+      Float_t fRKStep;      // Step for Runge-Kutta.
+
       // cached
       TEveVector fB;        // Current magnetic field, cached.
       TEveVector fE1, fE2, fE3; // Base vectors: E1 -> B dir, E2->pT dir, E3 = E1xE2.
@@ -140,7 +146,7 @@
       Helix_t();
 
       void UpdateCommon(const TEveVector & p, const TEveVector& b);
-      void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t fullUpdate);
+      void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t full_update, Bool_t enforce_max_step);
       void UpdateRK   (const TEveVector & p, const TEveVector& b);
 
       void Step(const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut);
@@ -162,7 +168,7 @@
    // Track extrapolation limits
    Float_t                  fMaxR;          // Max radius for track extrapolation
    Float_t                  fMaxZ;          // Max z-coordinate for track extrapolation.
-   Int_t                    fNMax;          // max steps
+   Int_t                    fNMax;          // Max steps
    // Helix limits
    Float_t                  fMaxOrbs;       // Maximal angular path of tracks' orbits (1 ~ 2Pi).
 
@@ -188,7 +194,7 @@
    Helix_t                  fH;             // Helix.
 
    void    RebuildTracks();
-   void    Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update=kFALSE);
+   void    Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update=kFALSE, Bool_t enforce_max_step=kFALSE);
    void    Step(const TEveVector4 &v, const TEveVector &p, TEveVector4 &vOut, TEveVector &pOut);
 
    Bool_t  LoopToVertex(TEveVector& v, TEveVector& p);
@@ -197,7 +203,7 @@
    Bool_t  LineToVertex (TEveVector& v);
    void    LineToBounds (TEveVector& p);
 
-   void    OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
+   void    StepRungeKutta(Double_t step, Double_t* vect, Double_t* vout);
 
    Bool_t  HelixIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal,
                                TEveVector& itsect);
@@ -238,8 +244,9 @@
    void   SetMaxZ(Float_t x);
    void   SetMaxOrbs(Float_t x);
    void   SetMinAng(Float_t x);
-   void   SetDelta(Float_t x);
+   void   SetMaxAng(Float_t x);
    void   SetMaxStep(Float_t x);
+   void   SetDelta(Float_t x);
 
    void   SetEditPathMarks(Bool_t x) { fEditPathMarks = x; }
    void   SetRnrDaughters(Bool_t x);
@@ -260,9 +267,10 @@
    Float_t GetMaxR()     const { return fMaxR;     }
    Float_t GetMaxZ()     const { return fMaxZ;     }
    Float_t GetMaxOrbs()  const { return fMaxOrbs;  }
-   Float_t GetMinAng()   const { return fH.fMinAng;   }
-   Float_t GetDelta()    const { return fH.fDelta;    }
+   Float_t GetMinAng()   const;
+   Float_t GetMaxAng()   const { return fH.fMaxAng;   }
    Float_t GetMaxStep()  const { return fH.fMaxStep;  }
+   Float_t GetDelta()    const { return fH.fDelta;    }
 
    Bool_t  GetEditPathMarks() const { return fEditPathMarks; }
    Bool_t  GetRnrDaughters()  const { return fRnrDaughters;  }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackPropagatorEditor.h root/graf3d/eve/inc/TEveTrackPropagatorEditor.h
--- root-old/graf3d/eve/inc/TEveTrackPropagatorEditor.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveTrackPropagatorEditor.h	2010-04-12 19:25:26.000000000 +0200
@@ -45,7 +45,7 @@
    TEveGValuator      *fMaxR;
    TEveGValuator      *fMaxZ;
    TEveGValuator      *fMaxOrbits;
-   TEveGValuator      *fMinAng;
+   TEveGValuator      *fMaxAng;
    TEveGValuator      *fDelta;
 
    TGCheckButton      *fRnrFV;
@@ -76,7 +76,7 @@
    void DoMaxR();
    void DoMaxZ();
    void DoMaxOrbits();
-   void DoMinAng();
+   void DoMaxAng();
    void DoDelta();
 
    void DoFitPM();
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrans.h root/graf3d/eve/inc/TEveTrans.h
--- root-old/graf3d/eve/inc/TEveTrans.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveTrans.h	2010-04-12 19:25:20.000000000 +0200
@@ -154,7 +154,7 @@
    void     Multiply(const Double_t *vin, Double_t* vout, Double_t w=1) const;
    void     RotateIP(TVector3& v) const;
    void     RotateIP(Double_t* v) const;
-   void     RotateIP(TEveVector& v) const;
+   void     RotateIP(Float_t*  v) const;
    TVector3 Rotate(const TVector3& v) const;
 
    virtual void Print(Option_t* option = "") const;
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTriangleSet.h root/graf3d/eve/inc/TEveTriangleSet.h
--- root-old/graf3d/eve/inc/TEveTriangleSet.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveTriangleSet.h	2010-04-12 19:25:07.000000000 +0200
@@ -21,10 +21,9 @@
 
 class TGeoMatrix;
 
-class TEveTriangleSet : public TEveElement,
-                        public TNamed,
-                        public TAttBBox,
-                        public TAtt3D
+class TEveTriangleSet : public TEveElementList,
+                        public TAtt3D,
+                        public TAttBBox
 {
    friend class TEveTriangleSetEditor;
    friend class TEveTriangleSetGL;
@@ -43,16 +42,10 @@
    Float_t* fTringNorms;   //[3*fNTrings]
    UChar_t* fTringCols;    //[3*fNTrings]
 
-   // --------------------------------------------------------------
-
-   Color_t  fColor;
-   UShort_t fTransp;
-
 public:
    TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms=kFALSE, Bool_t cols=kFALSE);
    ~TEveTriangleSet();
 
-   virtual Bool_t CanEditMainColor()        const { return kTRUE; }
    virtual Bool_t CanEditMainTransparency() const { return kTRUE; }
 
    Int_t GetNVerts()  const { return fNVerts;  }
@@ -76,7 +69,7 @@
                               Bool_t interp=kFALSE, Bool_t wrap=kFALSE);
 
    virtual void ComputeBBox();
-   virtual void Paint(Option_t* = "");
+   virtual void Paint(Option_t* option="");
 
    void SetTransparency(UChar_t tr) { SetMainTransparency(tr); } // *MENU*
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveVector.h root/graf3d/eve/inc/TEveVector.h
--- root-old/graf3d/eve/inc/TEveVector.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveVector.h	2010-04-12 19:25:20.000000000 +0200
@@ -29,7 +29,7 @@
    TEveVector(const Float_t* v)  : fX(v[0]), fY(v[1]), fZ(v[2]) {}
    TEveVector(const Double_t* v) : fX(v[0]), fY(v[1]), fZ(v[2]) {}
    TEveVector(Float_t x, Float_t y, Float_t z) : fX(x), fY(y), fZ(z) {}
-   virtual ~TEveVector() {}
+   ~TEveVector() {}
 
    void Dump() const;
 
@@ -85,7 +85,7 @@
    TEveVector Orthogonal() const;
    void       OrthoNormBase(TEveVector& a, TEveVector& b) const;
 
-   ClassDef(TEveVector, 1); // Float three-vector; a minimal Float_t copy of TVector3 used to represent points and momenta (also used in VSD).
+   ClassDefNV(TEveVector, 1); // Float three-vector; a minimal Float_t copy of TVector3 used to represent points and momenta (also used in VSD).
 };
 
 //______________________________________________________________________________
@@ -182,7 +182,7 @@
    TEveVector4(const TEveVector& v) : TEveVector(v), fT(0) {}
    TEveVector4(Float_t x, Float_t y, Float_t z, Float_t t=0) :
       TEveVector(x, y, z), fT(t) {}
-   virtual ~TEveVector4() {}
+   ~TEveVector4() {}
 
    void Dump() const;
 
@@ -198,11 +198,133 @@
    TEveVector4& operator += (const TEveVector4 & b)
    { fX += b.fX; fY += b.fY; fZ += b.fZ; fT += b.fT; return *this; }
 
-   ClassDef(TEveVector4, 1); // Float four-vector.
+   ClassDefNV(TEveVector4, 1); // Float four-vector.
 };
 
 
 //==============================================================================
+// TEvePoint
+//==============================================================================
+
+class TEvePoint
+{
+public:
+   Float_t fX, fY; // Components of the point.
+
+   TEvePoint() : fX(0), fY(0) {}
+   TEvePoint(const Float_t* v)  : fX(v[0]), fY(v[1]) {}
+   TEvePoint(const Double_t* v) : fX(v[0]), fY(v[1]) {}
+   TEvePoint(Float_t x, Float_t y) : fX(x), fY(y)    {}
+   ~TEvePoint() {}
+
+   void Dump() const;
+
+   operator const Float_t*() const { return &fX; }
+   operator       Float_t*()       { return &fX; }
+
+   TEvePoint& operator *=(Float_t s)          { fX *= s;    fY *= s;    return *this; }
+   TEvePoint& operator +=(const TEvePoint& v) { fX += v.fX; fY += v.fY; return *this; }
+   TEvePoint& operator -=(const TEvePoint& v) { fX -= v.fX; fY -= v.fY; return *this; }
+
+   TEvePoint operator + (const TEvePoint &) const;
+   TEvePoint operator - (const TEvePoint &) const;
+   TEvePoint operator * (Float_t a) const;
+
+   Float_t& operator [] (Int_t indx);
+   Float_t  operator [] (Int_t indx) const;
+
+   const Float_t* Arr() const { return &fX; }
+   Float_t* Arr()       { return &fX; }
+
+   void Set(const Float_t*  v) { fX = v[0]; fY = v[1]; }
+   void Set(const Double_t* v) { fX = v[0]; fY = v[1]; }
+   void Set(Float_t  x, Float_t  y) { fX = x; fY = y; }
+   void Set(Double_t x, Double_t y) { fX = x; fY = y; }
+   void Set(const TEvePoint& v) { fX = v.fX;  fY = v.fY;  }
+
+   void NegateXY() { fX = - fX; fY = -fY; }
+   void Normalize(Float_t length=1);
+
+   Float_t Phi()  const;
+
+   Float_t Mag()  const { return TMath::Sqrt(fX*fX + fY*fY);}
+   Float_t Mag2() const { return fX*fX + fY*fY;}
+
+   Float_t Distance(const TEvePoint& v) const;
+   Float_t SquareDistance(const TEvePoint& v) const;
+
+   Float_t    Dot(const TEvePoint& a) const;
+   Float_t    Cross(const TEvePoint& a) const;
+
+   TEvePoint& Sub(const TEvePoint& p, const TEvePoint& q);
+
+   TEvePoint& Mult(const TEvePoint& a, Float_t af);
+
+   ClassDefNV(TEvePoint, 1); // Float two-vector.
+};
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Phi() const
+{
+   return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX);
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Distance( const TEvePoint& b) const
+{
+   return TMath::Sqrt((fX - b.fX)*(fX - b.fX) +
+                      (fY - b.fY)*(fY - b.fY));
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::SquareDistance(const TEvePoint& b) const
+{
+   return ((fX - b.fX) * (fX - b.fX) +
+           (fY - b.fY) * (fY - b.fY));
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Dot(const TEvePoint& a) const
+{
+   return a.fX*fX + a.fY*fY;
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Cross(const TEvePoint& a) const
+{
+   return fX * a.fY - fY * a.fX;
+}
+
+//______________________________________________________________________________
+inline TEvePoint& TEvePoint::Sub(const TEvePoint& p, const TEvePoint& q)
+{
+   fX = p.fX - q.fX;
+   fY = p.fY - q.fY;
+   return *this;
+}
+
+//______________________________________________________________________________
+inline TEvePoint& TEvePoint::Mult(const TEvePoint& a, Float_t af)
+{
+   fX = a.fX * af;
+   fY = a.fY * af;
+   return *this;
+}
+
+//______________________________________________________________________________
+inline Float_t& TEvePoint::operator [] (Int_t idx)
+{
+   return (&fX)[idx];
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::operator [] (Int_t idx) const
+{
+   return (&fX)[idx];
+}
+
+
+//==============================================================================
 // TEvePathMark
 //==============================================================================
 
@@ -229,11 +351,11 @@
    TEvePathMark(EType_e type, const TEveVector& v, const TEveVector& p, const TEveVector& e, Float_t time=0) :
       fType(type), fV(v), fP(p), fE(e), fTime(time) {}
 
-   virtual ~TEvePathMark() {}
+   ~TEvePathMark() {}
 
    const char* TypeName();
 
-   ClassDef(TEvePathMark, 1); // Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).
+   ClassDefNV(TEvePathMark, 1); // Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).
 };
 
 #endif
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveWindow.h root/graf3d/eve/inc/TEveWindow.h
--- root-old/graf3d/eve/inc/TEveWindow.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/eve/inc/TEveWindow.h	2010-04-12 19:24:30.000000000 +0200
@@ -241,7 +241,7 @@
    virtual Bool_t          CanMakeNewSlots() const { return kFALSE; }
    virtual TEveWindowSlot* NewSlot() { return 0; }
 
-   void PopulateEmptyFrame(TEveCompositeFrame* ef); 
+   void PopulateEmptyFrame(TEveCompositeFrame* ef);
 
    void SwapWindow(TEveWindow* w);
    void SwapWindowWithCurrent();        // *MENU*
@@ -280,15 +280,15 @@
 
    // Access to static data-members.
 
-   static UInt_t  GetMainFrameDefWidth()  { return fgMainFrameDefWidth;  }
-   static UInt_t  GetMainFrameDefHeight() { return fgMainFrameDefHeight; }
-   static void SetMainFrameDefWidth (UInt_t x) { fgMainFrameDefWidth  = x; }
-   static void SetMainFrameDefHeight(UInt_t x) { fgMainFrameDefHeight = x; }
-
-   static Pixel_t GetCurrentBackgroundColor() { return fgCurrentBackgroundColor; }
-   static Pixel_t GetMiniBarBackgroundColor() { return fgMiniBarBackgroundColor; }
-   static void SetCurrentBackgroundColor(Pixel_t p) { fgCurrentBackgroundColor = p; }
-   static void SetMiniBarBackgroundColor(Pixel_t p) { fgMiniBarBackgroundColor = p; }
+   static UInt_t  GetMainFrameDefWidth();
+   static UInt_t  GetMainFrameDefHeight();
+   static void    SetMainFrameDefWidth (UInt_t x);
+   static void    SetMainFrameDefHeight(UInt_t x);
+
+   static Pixel_t GetCurrentBackgroundColor();
+   static Pixel_t GetMiniBarBackgroundColor();
+   static void    SetCurrentBackgroundColor(Pixel_t p);
+   static void    SetMiniBarBackgroundColor(Pixel_t p);
 
    ClassDef(TEveWindow, 0); // Abstract base-class for eve-windows.
 };
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveArrow.cxx root/graf3d/eve/src/TEveArrow.cxx
--- root-old/graf3d/eve/src/TEveArrow.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveArrow.cxx	2010-04-12 19:25:07.000000000 +0200
@@ -12,10 +12,6 @@
 #include "TEveArrow.h"
 #include "TEveTrans.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 
 //______________________________________________________________________________
 //
@@ -63,26 +59,10 @@
 }
 
 //______________________________________________________________________________
-void TEveArrow::Paint(Option_t* /*option*/)
+void TEveArrow::Paint(Option_t*)
 {
    // Paint object.
    // This is for direct rendering (using TEveArrowGL class).
 
-   static const TEveException eh("TEveArrow::Paint ");
-
-   if (fRnrSelf == kFALSE) return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveBox.cxx root/graf3d/eve/src/TEveBox.cxx
--- root-old/graf3d/eve/src/TEveBox.cxx	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/src/TEveBox.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -0,0 +1,203 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveBox.h"
+#include "TEveProjectionManager.h"
+
+//==============================================================================
+// TEveBox
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// 3D box with arbitrary vertices (cuboid).
+// Vertices 0-3 specify the "bottom" rectangle in clockwise direction and
+// vertices 4-7 the "top" rectangle so that 4 is above 0, 5 above 1 and so on.
+//
+// If vertices are provided some local coordinates the transformation matrix
+// of the element should also be set (but then the memory usage is increased
+// by the size of the TEveTrans object).
+//
+// Currently only supports 3D -> 2D projections.
+
+ClassImp(TEveBox);
+
+//______________________________________________________________________________
+TEveBox::TEveBox(const char* n, const char* t) :
+   TEveShape(n, t)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+TEveBox::~TEveBox()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TEveBox::SetVertex(Int_t i, Float_t x, Float_t y, Float_t z)
+{
+   // Set vertex 'i'.
+
+   fVertices[i][0] = x;
+   fVertices[i][1] = y;
+   fVertices[i][2] = z;
+}
+
+//______________________________________________________________________________
+void TEveBox::SetVertex(Int_t i, const Float_t* v)
+{
+   // Set vertex 'i'.
+
+   fVertices[i][0] = v[0];
+   fVertices[i][1] = v[1];
+   fVertices[i][2] = v[2];
+}
+
+//______________________________________________________________________________
+void TEveBox::SetVertices(const Float_t* vs)
+{
+   // Set vertices.
+
+   memcpy(fVertices, vs, sizeof(fVertices));
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveBox::ComputeBBox()
+{
+   // Compute bounding-box of the data.
+
+   BBoxInit();
+   for (Int_t i=0; i<8; ++i)
+   {
+      BBoxCheckPoint(fVertices[i]);
+   }
+}
+
+//______________________________________________________________________________
+TClass* TEveBox::ProjectedClass(const TEveProjection*) const
+{
+   // Virtual from TEveProjectable, return TEveBoxProjected class.
+
+   return TEveBoxProjected::Class();
+}
+
+
+//==============================================================================
+// TEveBoxProjected
+//==============================================================================
+
+ClassImp(TEveBoxProjected);
+
+//______________________________________________________________________________
+TEveBoxProjected::TEveBoxProjected(const char* n, const char* t) :
+   TEveShape(n, t)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+TEveBoxProjected::~TEveBoxProjected()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::ComputeBBox()
+{
+   // Compute bounding-box, virtual from TAttBBox.
+
+   BBoxInit();
+   for (vPoint_i i = fPoints.begin(); i != fPoints.end(); ++i)
+   {
+      BBoxCheckPoint(i->fX, i->fY, fDepth);
+   }
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::SetDepthLocal(Float_t)
+{
+   // This is virtual method from base-class TEveProjected.
+   // Does nothing, must be implemented as it is abstract.
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::SetProjection(TEveProjectionManager* mng, TEveProjectable* model)
+{
+   // This is virtual method from base-class TEveProjected.
+
+   TEveProjected::SetProjection(mng, model);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::UpdateProjection()
+{
+   // Re-project the box. Projects all points and finds 2D convex-hull.
+   //
+   // The convex-hull calculation code could be extracted and put into
+   // TEveShape or TEveUtil. Maybe projection / hull-search could be put into
+   // two functions.
+   //
+   // The only issue is with making sure that initial conditions for
+   // hull-search are reasonable -- that is, there are no overlaps with the
+   // first point.
+
+   TEveBox *box = dynamic_cast<TEveBox*>(fProjectable);
+
+   fDebugPoints.clear();
+
+   // Project points in global CS, remove overlaps.
+   vPoint_t pp[2];
+   {
+      TEveProjection *projection = fManager->GetProjection();
+      TEveTrans      *trans      = box->PtrMainTrans(kFALSE);
+
+      TEveVector pbuf;
+      for (Int_t i = 0; i < 8; ++i)
+      {
+         projection->ProjectPointfv(trans, box->GetVertex(i), pbuf, fDepth);
+         vPoint_t& ppv = pp[projection->SubSpaceId(pbuf)];
+
+         TEvePoint p(pbuf);
+         Bool_t    overlap = kFALSE;
+         for (vPoint_i j = ppv.begin(); j != ppv.end(); ++j)
+         {
+            if (p.SquareDistance(*j) < TEveProjection::fgEpsSqr)
+            {
+               overlap = kTRUE;
+               break;
+            }
+         }
+         if (! overlap)
+         {
+            ppv.push_back(p);
+            fDebugPoints.push_back(p);
+         }
+      }
+   }
+
+   fPoints.clear();
+   fBreakIdx = 0;
+
+   if ( ! pp[0].empty())
+   {
+      FindConvexHull(pp[0], fPoints, this);
+   }
+   if ( ! pp[1].empty())
+   {
+      fBreakIdx = fPoints.size();
+      FindConvexHull(pp[1], fPoints, this);
+   }
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveBoxGL.cxx root/graf3d/eve/src/TEveBoxGL.cxx
--- root-old/graf3d/eve/src/TEveBoxGL.cxx	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/src/TEveBoxGL.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -0,0 +1,364 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveBoxGL.h"
+#include "TEveBox.h"
+
+#include "TGLRnrCtx.h"
+#include "TGLIncludes.h"
+
+#include "TMath.h"
+
+//==============================================================================
+// TEveBoxGL
+//==============================================================================
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEveBox.
+//
+
+ClassImp(TEveBoxGL);
+
+//______________________________________________________________________________
+TEveBoxGL::TEveBoxGL() :
+   TGLObject(), fM(0)
+{
+   // Constructor.
+
+   // fDLCache = kFALSE; // Disable display list.
+}
+
+//______________________________________________________________________________
+Bool_t TEveBoxGL::SetModel(TObject* obj, const Option_t* /*opt*/)
+{
+   // Set model object.
+
+   if (SetModelCheckClass(obj, TEveBox::Class())) {
+      fM = dynamic_cast<TEveBox*>(obj);
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::SetBBox()
+{
+   // Set bounding box.
+
+   // !! This ok if master sub-classed from TAttBBox
+   SetAxisAlignedBBox(((TEveBox*)fExternalObj)->AssertBBox());
+}
+
+//==============================================================================
+
+namespace
+{
+   void subtract_and_normalize(const Float_t a[3], const Float_t b[3],
+                               Float_t o[3])
+   {
+      // Calculate a - b and normalize the result.
+      o[0] = a[0] - b[0];
+      o[1] = a[1] - b[1];
+      o[2] = a[2] - b[2];
+      Float_t d = sqrtf(o[0]*o[0] + o[1]*o[1] + o[2]*o[2]);
+      if (d != 0)
+      {
+         d = 1.0f / d;
+         o[0] *= d;
+         o[1] *= d;
+         o[2] *= d;
+      }
+   }
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::RenderOutline(const Float_t p[8][3]) const
+{
+   // Render box with without normals.
+   // To be used with lightning off, for outline.
+
+   glBegin(GL_LINE_STRIP);
+   glVertex3fv(p[0]); glVertex3fv(p[1]);
+   glVertex3fv(p[5]); glVertex3fv(p[6]);
+   glVertex3fv(p[2]); glVertex3fv(p[3]);
+   glVertex3fv(p[7]); glVertex3fv(p[4]);
+   glVertex3fv(p[0]); glVertex3fv(p[3]);
+   glEnd();
+
+   glBegin(GL_LINES);
+   glVertex3fv(p[1]); glVertex3fv(p[2]);
+   glVertex3fv(p[4]); glVertex3fv(p[5]);
+   glVertex3fv(p[6]); glVertex3fv(p[7]);
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::RenderBoxStdNorm(const Float_t p[8][3]) const
+{
+   // Render box with "standard" normals.
+
+   glBegin(GL_QUADS);
+
+   // bottom: 0123
+   glNormal3f(0, 0, -1);
+   glVertex3fv(p[0]);  glVertex3fv(p[1]);
+   glVertex3fv(p[2]);  glVertex3fv(p[3]);
+   // top:    7654
+   glNormal3f(0, 0, 1);
+   glVertex3fv(p[7]); glVertex3fv(p[6]);
+   glVertex3fv(p[5]); glVertex3fv(p[4]);
+   // back:  0451
+   glNormal3f(0, 1, 0);
+   glVertex3fv(p[0]); glVertex3fv(p[4]);
+   glVertex3fv(p[5]); glVertex3fv(p[1]);
+   // front:   3267
+   glNormal3f(0, -1, 0);
+   glVertex3fv(p[3]); glVertex3fv(p[2]);
+   glVertex3fv(p[6]); glVertex3fv(p[7]);
+   // left:    0374
+   glNormal3f(-1, 0, 0);
+   glVertex3fv(p[0]); glVertex3fv(p[3]);
+   glVertex3fv(p[7]); glVertex3fv(p[4]);
+   // right:   1562
+   glNormal3f(1, 0, 0);
+   glVertex3fv(p[1]); glVertex3fv(p[5]);
+   glVertex3fv(p[6]); glVertex3fv(p[2]);
+
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::RenderBoxAutoNorm(const Float_t p[8][3]) const
+{
+   // Render box, calculate normals on the fly from first three points.
+
+   Float_t e[6][3], n[3];
+   subtract_and_normalize(p[1], p[0], e[0]);
+   subtract_and_normalize(p[3], p[0], e[1]);
+   subtract_and_normalize(p[4], p[0], e[2]);
+   subtract_and_normalize(p[5], p[6], e[3]);
+   subtract_and_normalize(p[4], p[6], e[4]);
+   subtract_and_normalize(p[2], p[6], e[5]);
+
+   glBegin(GL_QUADS);
+
+   // bottom: 0123
+   glNormal3fv(TMath::Cross(e[0], e[1], n));
+   glVertex3fv(p[0]); glVertex3fv(p[1]);
+   glVertex3fv(p[2]); glVertex3fv(p[3]);
+   // top:    7654
+   glNormal3fv(TMath::Cross(e[3], e[4], n));
+   glVertex3fv(p[7]); glVertex3fv(p[6]);
+   glVertex3fv(p[5]); glVertex3fv(p[4]);
+   // back:  0451
+   glNormal3fv(TMath::Cross(e[2], e[1], n));
+   glVertex3fv(p[0]); glVertex3fv(p[4]);
+   glVertex3fv(p[5]); glVertex3fv(p[1]);
+   // front:   3267
+   glNormal3fv(TMath::Cross(e[4], e[5], n));
+   glVertex3fv(p[3]); glVertex3fv(p[2]);
+   glVertex3fv(p[6]); glVertex3fv(p[7]);
+   // left:    0374
+   glNormal3fv(TMath::Cross(e[1], e[2], n));
+   glVertex3fv(p[0]); glVertex3fv(p[3]);
+   glVertex3fv(p[7]); glVertex3fv(p[4]);
+   // right:   1562
+   glNormal3fv(TMath::Cross(e[5], e[3], n));
+   glVertex3fv(p[1]); glVertex3fv(p[5]);
+   glVertex3fv(p[6]); glVertex3fv(p[2]);
+
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::Draw(TGLRnrCtx& rnrCtx) const
+{
+   // Render with OpenGL.
+
+   if (rnrCtx.IsDrawPassOutlineLine())
+      return;
+
+   if (fM->fHighlightFrame && rnrCtx.Highlight())
+   {
+      if (fM->fDrawFrame)
+      {
+         TGLUtil::LineWidth(fM->fLineWidth);
+         TGLUtil::Color(fM->fLineColor);
+      }
+      RenderOutline(fM->fVertices);
+   }
+   else
+   {
+      TGLObject::Draw(rnrCtx);
+   }
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::DirectDraw(TGLRnrCtx&) const
+{
+   // Render with OpenGL, create display-list.
+
+   fMultiColor = (fM->fDrawFrame && fM->fFillColor != fM->fLineColor);
+
+   glPushAttrib(GL_ENABLE_BIT);
+
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(1.0f, 1.0f);
+   RenderBoxAutoNorm(fM->fVertices);
+   glDisable(GL_POLYGON_OFFSET_FILL);
+
+   // Frame
+   if (fM->fDrawFrame)
+   {
+      TGLUtil::Color(fM->fLineColor);
+      TGLUtil::LineWidth(fM->fLineWidth);
+      glEnable(GL_LINE_SMOOTH);
+      RenderOutline(fM->fVertices);
+   }
+
+   glPopAttrib();
+}
+
+
+//==============================================================================
+// TEveBoxProjectedGL
+//==============================================================================
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEveBoxProjected.
+//
+
+ClassImp(TEveBoxProjectedGL);
+
+//______________________________________________________________________________
+TEveBoxProjectedGL::TEveBoxProjectedGL() :
+   TGLObject(), fM(0)
+{
+   // Constructor.
+
+   // fDLCache = kFALSE; // Disable display list.
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+Bool_t TEveBoxProjectedGL::SetModel(TObject* obj, const Option_t* /*opt*/)
+{
+   // Set model object.
+
+   if (SetModelCheckClass(obj, TEveBoxProjected::Class())) {
+      fM = dynamic_cast<TEveBoxProjected*>(obj);
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::SetBBox()
+{
+   // Set bounding box.
+
+   SetAxisAlignedBBox(((TEveBoxProjected*)fExternalObj)->AssertBBox());
+}
+
+//------------------------------------------------------------------------------
+
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::RenderPoints(Int_t mode) const
+{
+   // Render points with given GL mode.
+   // This is used for polygon and outline drawing.
+
+   Int_t B = fM->fBreakIdx;
+   Int_t N = fM->fPoints.size();
+   if (B != 0)
+   {
+      glBegin(mode);
+      for (Int_t i = 0; i < B; ++i)
+      {
+         glVertex2fv(fM->fPoints[i]);
+      }
+      glEnd();
+   }
+   glBegin(mode);
+   for (Int_t i = B; i < N; ++i)
+   {
+      glVertex2fv(fM->fPoints[i]);
+   }
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::Draw(TGLRnrCtx& rnrCtx) const
+{
+   // Render with OpenGL.
+
+   if (rnrCtx.IsDrawPassOutlineLine())
+      return;
+
+   glPushMatrix();
+   glTranslatef(0.0f, 0.0f, fM->fDepth);
+
+   if (fM->fHighlightFrame && rnrCtx.Highlight())
+   {
+      if (fM->fDrawFrame)
+      {
+         TGLUtil::LineWidth(fM->fLineWidth);
+         TGLUtil::Color(fM->fLineColor);
+      }
+      RenderPoints(GL_LINE_LOOP);
+   }
+   else
+   {
+      TGLObject::Draw(rnrCtx);
+   }
+
+   {
+      glColor3f(1,0,0);
+      Int_t N = fM->fDebugPoints.size();
+      glPointSize(4);
+      glBegin(GL_POINTS);
+      for (Int_t i = 0; i < N; ++i)
+      {
+         glVertex2fv(fM->fDebugPoints[i]);
+      }
+      glEnd();
+   }
+
+   glPopMatrix();
+}
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::DirectDraw(TGLRnrCtx&) const
+{
+   // Render with OpenGL, create display-list.
+
+   fMultiColor = (fM->fDrawFrame && fM->fFillColor != fM->fLineColor);
+
+   glPushAttrib(GL_ENABLE_BIT);
+
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(1.0f, 1.0f);
+   RenderPoints(GL_POLYGON);
+   glDisable(GL_POLYGON_OFFSET_FILL);
+
+   // Frame
+   if (fM->fDrawFrame)
+   {
+      TGLUtil::Color(fM->fLineColor);
+      TGLUtil::LineWidth(fM->fLineWidth);
+      glEnable(GL_LINE_SMOOTH);
+      RenderPoints(GL_LINE_LOOP);
+   }
+
+   glPopAttrib();
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveBoxSetGL.cxx root/graf3d/eve/src/TEveBoxSetGL.cxx
--- root-old/graf3d/eve/src/TEveBoxSetGL.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveBoxSetGL.cxx	2010-04-12 19:24:48.000000000 +0200
@@ -65,7 +65,11 @@
 {
    // Set GL color for given primitive.
 
-   if (fM->fValueIsColor)
+   if (fM->fSingleColor)
+   {
+      return kTRUE;
+   }
+   else if (fM->fValueIsColor)
    {
       TGLUtil::Color4ubv((UChar_t*) & q.fValue);
       return kTRUE;
@@ -75,7 +79,7 @@
       UChar_t c[4];
       Bool_t visible = fM->fPalette->ColorFromValue(q.fValue, fM->fDefaultValue, c);
       if (visible)
-         TGLUtil::Color3ubv(c);
+         TGLUtil::Color4ubv(c);
       return visible;
    }
 }
@@ -169,7 +173,6 @@
             glTranslatef(0, 0, 1);
             gluDisk(quad.Get(), 0, 1, nt, 1);
             glPopMatrix();
-
          }
       }
 
@@ -390,7 +393,7 @@
 
    if (mB.fPlex.Size() > 0)
    {
-      if ( ! mB.fValueIsColor && mB.fPalette == 0)
+      if (! mB.fSingleColor && ! mB.fValueIsColor && mB.fPalette == 0)
       {
          mB.AssertPalette();
       }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCalo.cxx root/graf3d/eve/src/TEveCalo.cxx
--- root-old/graf3d/eve/src/TEveCalo.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveCalo.cxx	2010-04-12 19:26:08.000000000 +0200
@@ -20,10 +20,6 @@
 #include "TClass.h"
 #include "TMathBase.h"
 #include "TMath.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 #include "TAxis.h"
 
 #include "TGLUtil.h"
@@ -154,7 +150,7 @@
 
    fPlotEt=isEt;
    if (fPalette)
-      fPalette->SetLimits(0, TMath::CeilNint(fData->GetMaxVal(fPlotEt)));
+      fPalette->SetLimits(0, TMath::CeilNint(GetMaxVal()));
 
    InvalidateCellIdCache();
 }
@@ -247,7 +243,7 @@
 
    if (fPalette)
    {
-      Int_t hlimit = TMath::CeilNint(fScaleAbs ? fMaxValAbs : fData->GetMaxVal(fPlotEt));
+      Int_t hlimit = TMath::CeilNint(GetMaxVal());
       fPalette->SetLimits(0, hlimit);
       fPalette->SetMin(0);
       fPalette->SetMax(hlimit);
@@ -257,13 +253,18 @@
 }
 
 //______________________________________________________________________________
-void TEveCaloViz::AssertCellIdCache() const
+Bool_t TEveCaloViz::AssertCellIdCache() const
 {
    // Assert cell id cache is ok.
+   // Returns true if the cache has been updated.
  
    TEveCaloViz* cv = const_cast<TEveCaloViz*>(this);
-   if (!fCellIdCacheOK)
+   if (!fCellIdCacheOK) {
       cv->BuildCellIdCache();
+      return kTRUE;
+   } else {
+      return kFALSE;
+   }
 }
 
 //______________________________________________________________________________
@@ -345,7 +346,7 @@
       fPalette = new TEveRGBAPalette;
       fPalette->SetDefaultColor((Color_t)4);
 
-      Int_t hlimit = TMath::CeilNint(fScaleAbs ? fMaxValAbs : fData->GetMaxVal(fPlotEt));
+      Int_t hlimit = TMath::CeilNint(GetMaxVal());
       fPalette->SetLimits(0, hlimit);
       fPalette->SetMin(0);
       fPalette->SetMax(hlimit);
@@ -359,24 +360,10 @@
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEvecaloViz::Paint ");
-
-   if (!fData)
-      return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   if (fData)
+   {
+      PaintStandard(this);
+   }
 }
 
 //______________________________________________________________________________
@@ -762,7 +749,7 @@
    fAutoRebin(kTRUE),
 
    fPixelsPerBin(12),
-   fNormalizeRebin(kTRUE),
+   fNormalizeRebin(kFALSE),
 
    fProjection(kAuto),
    f2DMode(kValSize),
@@ -771,7 +758,6 @@
    fDrawHPlane(kFALSE),
    fHPlaneVal(0),
 
-   fBinStep(-1),
    fDrawNumberCellPixels(18), // draw numbers on cell above 30 pixels
    fCellPixelFontSize(12) // size of cell fonts in pixels
 {
@@ -809,7 +795,7 @@
 
    BBoxZero();
 
-   Float_t ex = 1.2;
+   Float_t ex = 1.2*fMaxTowerH;
 
    Float_t a = 0.5*ex;
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCalo3DGL.cxx root/graf3d/eve/src/TEveCalo3DGL.cxx
--- root-old/graf3d/eve/src/TEveCalo3DGL.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveCalo3DGL.cxx	2010-04-12 19:25:57.000000000 +0200
@@ -265,13 +265,13 @@
 
    if (transparent_p)
    {
-      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fFrameTransparency);
-
       glPushAttrib(GL_ENABLE_BIT | GL_DEPTH_BUFFER_BIT);
 
       glDepthMask(GL_FALSE);
       glEnable(GL_BLEND);
       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fFrameTransparency);
    }
 
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
@@ -297,8 +297,6 @@
    if (transparent_p)
    {
       glPopAttrib();
-
-      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fMainTransparency);
    }
 }
 
@@ -533,8 +531,6 @@
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
    glEnable(GL_NORMALIZE);
 
-   RenderGrid(rnrCtx);
-
    TEveCaloData::CellData_t cellData;
    Float_t towerH;
    Int_t   tower = 0;
@@ -568,6 +564,9 @@
    }
 
    if (rnrCtx.SecSelection()) glPopName();
+
+   RenderGrid(rnrCtx);
+
    glPopAttrib();
 }
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCaloData.cxx root/graf3d/eve/src/TEveCaloData.cxx
--- root-old/graf3d/eve/src/TEveCaloData.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveCaloData.cxx	2010-04-12 19:26:00.000000000 +0200
@@ -395,7 +395,6 @@
    rdata.fBinData.assign((ax->GetNbins()+2)*(ay->GetNbins()+2), -1);
 
    CellData_t cd;
-   Float_t left, right, up, down; // cell corners
    for (vCellId_i it = ids.begin(); it != ids.end(); ++it)
    {
       GetCellData(*it, cd);
@@ -406,20 +405,17 @@
       for (Int_t i = iMin; i <= iMax; ++i)
       {
          if (i < 0 || i > ax->GetNbins()) continue;
-         left  = (i == iMin) ? cd.EtaMin() : ax->GetBinLowEdge(i);
-         right = (i == iMax) ? cd.EtaMax() : ax->GetBinUpEdge(i);
-
          for (Int_t j = jMin; j <= jMax; ++j)
          {
             if (j < 0 || j > ay->GetNbins()) continue;
-            down = (j == jMin) ? cd.PhiMin() : ay->GetBinLowEdge(j);
-            up   = (j == jMax) ? cd.PhiMax() : ay->GetBinUpEdge(j);
 
-            Float_t ratio = ((right-left)*(up-down))/(ax->GetBinWidth(i)*ay->GetBinWidth(j));
-            if (ratio > 1e-6)
+            Double_t ratio = TEveUtil::GetFraction(ax->GetBinLowEdge(i), ax->GetBinUpEdge(i), cd.EtaMin(), cd.EtaMax())
+                           * TEveUtil::GetFraction(ay->GetBinLowEdge(j), ay->GetBinUpEdge(j), cd.PhiMin(), cd.PhiMax());
+            
+            if (ratio > 1e-6f)
             {
-               Float_t* slices = rdata.GetSliceVals(i+j*(ax->GetNbins()+2));
-               slices[(*it).fSlice] += ratio* cd.Value(et);
+               Float_t* slices = rdata.GetSliceVals(i + j*(ax->GetNbins()+2));
+               slices[(*it).fSlice] += ratio * cd.Value(et);
             }
          }
       }
@@ -696,7 +692,9 @@
       biny = ay->FindBin(fPhiAxis->GetBinCenter(j));
       bin = biny*(ax->GetNbins()+2)+binx;
       val = rdata.GetSliceVals(bin);
-      Double_t ratio = (fEtaAxis->GetBinWidth(i)*fPhiAxis->GetBinWidth(j))/(ax->GetBinWidth(binx)*ay->GetBinWidth(biny));
+      Double_t ratio = TEveUtil::GetFraction(ax->GetBinLowEdge(binx), ax->GetBinUpEdge(binx), cd.EtaMin(), cd.EtaMax())
+                     * TEveUtil::GetFraction(ay->GetBinLowEdge(biny), ay->GetBinUpEdge(biny), cd.PhiMin(), cd.PhiMax());
+      
       val[(*it).fSlice] += cd.Value(et)*ratio;
    }
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCaloLegoGL.cxx root/graf3d/eve/src/TEveCaloLegoGL.cxx
--- root-old/graf3d/eve/src/TEveCaloLegoGL.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveCaloLegoGL.cxx	2010-04-12 19:26:08.000000000 +0200
@@ -51,7 +51,8 @@
    fZAxis(0),
    fM(0),
    fDLCacheOK(kFALSE),
-   fCells3D(kTRUE)
+   fCells3D(kTRUE),
+   fBinStep(-1)
 {
    // Constructor.
 
@@ -322,7 +323,7 @@
          idxLeft = i;
       }
    }
-   fZAxisTitlePos.Set(cornerX[idxLeft], cornerY[idxLeft], fDataMax* 1.05);
+   fZAxisTitlePos.Set(cornerX[idxLeft], cornerY[idxLeft], 1.05 * fDataMax);
 
 
    // XY axis location (closest to eye) first
@@ -573,6 +574,8 @@
 {
    // Draw XY axis.
 
+   TGLCamera& cam  = rnrCtx.RefCamera();
+
    TAxis ax;
    ax.SetAxisColor(fGridColor);
    ax.SetLabelColor(fFontColor);
@@ -600,6 +603,10 @@
                               + (up[1] - dn[1]) * (up[1] - dn[1])
                               + (up[2] - dn[2]) * (up[2] - dn[2]));
 
+   // lock upper limit to of relative font size relative to viewport diagonal
+   Double_t vpLimit = cam.RefViewport().Diagonal()*0.5/TMath::Sqrt2();
+   len = TMath::Min(len, vpLimit);
+
    // eta
    fAxisPainter.SetLabelPixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
    fAxisPainter.SetTitlePixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
@@ -608,7 +615,9 @@
    ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(fM->GetEtaMax(), -fM->GetPhiRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), 0 );
    fAxisPainter.RefDir().Set(1, 0, 0);
-   fAxisPainter.RefTMOff(0).Set(0,  -fM->GetPhiRng(), 0);
+
+   Float_t tmOffFrustX = cam.FrustumPlane(TGLCamera::kRight).D() + cam.FrustumPlane(TGLCamera::kLeft).D();
+   fAxisPainter.RefTMOff(0).Set(0,  -TMath::Min(fM->GetPhiRng(), tmOffFrustX), 0);
    fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
 
    glPushMatrix();
@@ -622,7 +631,8 @@
    ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(-fM->GetEtaRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), fM->GetPhiMax(), 0);
    fAxisPainter.RefDir().Set(0, 1, 0);
-   fAxisPainter.RefTMOff(0).Set(-fM->GetEtaRng(), 0, 0);
+   Float_t tmOffFrustY = cam.FrustumPlane(TGLCamera::kTop).D() + cam.FrustumPlane(TGLCamera::kBottom).D();
+   fAxisPainter.RefTMOff(0).Set(-TMath::Min(fM->GetEtaRng(), tmOffFrustY), 0, 0);
    fAxisPainter.SetLabelAlign(TGLFont::kRight, TGLFont::kCenterV);
 
    glPushMatrix();
@@ -679,18 +689,18 @@
    // Rebin eta, phi axis.
 
    Double_t center = 0.5 * (orig->GetXmin() + orig->GetXmax());
-   Int_t idx0 = orig->FindBin(center);
-   Double_t bc = orig->GetBinCenter(idx0);
-   if (bc > center) idx0--;
-
-   Int_t nbR = TMath::FloorNint(idx0/fM->fBinStep) + TMath::FloorNint((orig->GetNbins() - idx0)/fM->fBinStep);
-   Double_t *bins = new Double_t[nbR+1];
-   Int_t off = idx0 - TMath::FloorNint(idx0/fM->fBinStep)*fM->fBinStep;
-   for(Int_t i = 0; i <= nbR; i++)
-      bins[i] = orig->GetBinUpEdge(off + i*fM->fBinStep);
-
-   curr->Set(nbR, bins);
-   delete [] bins;
+   Int_t    idx0   = orig->FindBin(center);
+   Double_t bc     = orig->GetBinCenter(idx0);
+   if (bc > center) --idx0;
+
+   Int_t nbR = TMath::FloorNint(idx0/fBinStep) + TMath::FloorNint((orig->GetNbins() - idx0)/fBinStep);
+   Int_t off = idx0 - TMath::FloorNint(idx0/fBinStep)*fBinStep;
+   std::vector<Double_t> bins(nbR + 1);
+   for (Int_t i = 0; i <= nbR; ++i)
+   {
+      bins[i] = orig->GetBinUpEdge(off + i*fBinStep);
+   }
+   curr->Set(nbR, &bins[0]);
 }
 
 //______________________________________________________________________________
@@ -1063,7 +1073,7 @@
    Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
    Float_t sx = (eM - em) / fM->GetEtaRng();
    Float_t sy = (pM - pm) / fM->GetPhiRng();
-   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetValToHeight());
+   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetMaxTowerH() / fDataMax);
    glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
 
    // check eta&phi range of selected cells
@@ -1078,23 +1088,22 @@
 
    // prepare rebin for 2D or 3D if necessary
    TEveCaloData::RebinData_t rebinDataSelected;
-   if (fM->fBinStep > 1)
+   if (fBinStep > 1)
    {
       fM->fData->Rebin(fEtaAxis, fPhiAxis, cellsSelected, fM->fPlotEt, rebinDataSelected);
-      Float_t scale = fM->GetMaxVal() / fMaxValRebin;
       if (fM->fNormalizeRebin) {
+         Float_t scale = 1.f / (fBinStep * fBinStep);
          for (std::vector<Float_t>::iterator it = rebinDataSelected.fSliceData.begin(); it != rebinDataSelected.fSliceData.end(); it++)
             (*it) *= scale;
       }
    }
 
-
    if (fCells3D)
    {
       Int_t   prevTower = 0;
       Float_t offset    = 0;
       Int_t   nSlices   = fM->fData->GetNSlices();
-      if (fM->fBinStep == 1)
+      if (fBinStep == 1)
       {
          TEveCaloData::vCellId_i      j = cellsSelected.begin();
          for (TEveCaloData::vCellId_i i = fM->fCellList.begin(); i != fM->fCellList.end(); ++i) {
@@ -1155,7 +1164,7 @@
    else
    {
       vCell2D_t cells2DSelected;
-      if (fM->fBinStep == 1)
+      if (fBinStep == 1)
       {
          // could be exact and call
          // PrepareCell2DData( fM->fData->GetCellsSelected(), cells2DSelected);
@@ -1204,60 +1213,65 @@
    else if (fM->fProjection == TEveCaloLego::k3D)
       fCells3D = kTRUE;
 
-   // cache max val
-   fDataMax = fM->GetMaxVal();
-
-   // modelview matrix
-   Double_t em, eM, pm, pM;
-   fM->fData->GetEtaLimits(em, eM);
-   fM->fData->GetPhiLimits(pm, pM);
-   Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
-   glPushMatrix();
-   Float_t sx = (eM - em) / fM->GetEtaRng();
-   Float_t sy = (pM - pm) / fM->GetPhiRng();
-   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetValToHeight());
-   glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
-
    // rebin axsis , check limits, fix TwoPi cycling
-   Int_t oldBinStep = fM->fBinStep;
-   fM->fBinStep = GetGridStep(rnrCtx);
-   if (oldBinStep != fM->fBinStep) fDLCacheOK=kFALSE;
-
-   RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
-   RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
-
-   // cache ids
-   Bool_t idCacheChanged = kFALSE;
-   if (fM->fCellIdCacheOK == kFALSE) {
-      fM->BuildCellIdCache();
-      idCacheChanged = kTRUE;
-   }
+   Int_t new_bin_step = GetGridStep(rnrCtx);
 
    // rebin data
-   if (fDLCacheOK==kFALSE || idCacheChanged ) {
-      fRebinData.fSliceData.clear();
-      fRebinData.fSliceData.clear();
+   if (fM->AssertCellIdCache() || fBinStep != new_bin_step)
+   {
+      fBinStep = new_bin_step;
+      fDLCacheOK   = kFALSE;
+      fRebinData.Clear();
 
-      if (fM->fBinStep > 1) {
+      RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
+      RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
+
+      if (fBinStep > 1)
+      {
          fM->fData->Rebin(fEtaAxis, fPhiAxis, fM->fCellList, fM->fPlotEt, fRebinData);
-         if (fM->fNormalizeRebin) {
-            //  Double_t maxVal = 0;
-            fMaxValRebin = 0;
-            for (UInt_t i = 0; i < fRebinData.fSliceData.size(); i += fRebinData.fNSlices) {
-               Double_t sum = 0;
-               for (Int_t s = 0; s < fRebinData.fNSlices; s++)
-                  sum += fRebinData.fSliceData[i+s];
 
-               if (sum > fMaxValRebin) fMaxValRebin = sum;
+         fMaxVal = 0;
+         for (UInt_t i = 0; i < fRebinData.fSliceData.size(); i += fRebinData.fNSlices)
+         {
+            Double_t sum = 0;
+            for (Int_t s = 0; s < fRebinData.fNSlices; s++)
+            {
+               sum += fRebinData.fSliceData[i+s];
             }
+            if (sum > fMaxVal) fMaxVal = sum;
+         }
 
-            Float_t scale = fM->GetMaxVal() / fMaxValRebin;
+         if (fM->fNormalizeRebin)
+         {
+            Float_t scale = 1.f / (fBinStep * fBinStep);
             for (std::vector<Float_t>::iterator it = fRebinData.fSliceData.begin(); it != fRebinData.fSliceData.end(); it++)
+            {
                (*it) *= scale;
+            }
+            fMaxVal *= scale;
          }
       }
+      else
+      {
+         fMaxVal = fM->GetMaxVal();
+      }
    }
 
+   // cache max val
+   fDataMax = (fM->fScaleAbs) ? fM->fMaxValAbs : fMaxVal;
+
+   // modelview matrix
+   Double_t em, eM, pm, pM;
+   fM->fData->GetEtaLimits(em, eM);
+   fM->fData->GetPhiLimits(pm, pM);
+   Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
+   glPushMatrix();
+   Float_t sx = (eM - em) / fM->GetEtaRng();
+   Float_t sy = (pM - pm) / fM->GetPhiRng();
+   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetMaxTowerH() / fDataMax);
+   glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
+
+
    fFontColor = fM->fFontColor;
    fGridColor = fM->fGridColor;
    if (fGridColor < 0 || fFontColor < 0)
@@ -1283,13 +1297,15 @@
    TGLUtil::LineWidth(1);
    glEnable(GL_BLEND);
 
-   if (!fM->fData->Empty()){
+   if (!fM->fData->Empty())
+   {
       glPushName(0);
       glLoadName(0);
-      if (fCells3D) {
-         if (fDLCacheOK == kFALSE || idCacheChanged )
+      if (fCells3D)
+      {
+         if (fDLCacheOK == kFALSE)
          {
-            if (fM->fBinStep == 1)
+            if (fBinStep == 1)
                Make3DDisplayList(fM->fCellList, fDLMap, kTRUE);
             else
                Make3DDisplayListRebin(fRebinData, fDLMap, kTRUE);
@@ -1304,7 +1320,7 @@
          glDisable(GL_LIGHTING);
 
          fCells2D.clear();
-         if (fM->fBinStep == 1)
+         if (fBinStep == 1)
             PrepareCell2DData(fM->fCellList, fCells2D);
          else
             PrepareCell2DDataRebin(fRebinData, fCells2D);
@@ -1355,7 +1371,7 @@
       cellID = rec.GetItem(2);
       Int_t slice  = rec.GetItem(1);
 
-      if (fM->fBinStep == 1)
+      if (fBinStep == 1)
       {
          Int_t tower = fM->fCellList[cellID].fTower;
          while (cellID > 0 && tower == fM->fCellList[cellID].fTower)
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCaloLegoOverlay.cxx root/graf3d/eve/src/TEveCaloLegoOverlay.cxx
--- root-old/graf3d/eve/src/TEveCaloLegoOverlay.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveCaloLegoOverlay.cxx	2010-04-12 19:26:08.000000000 +0200
@@ -10,6 +10,7 @@
  *************************************************************************/
 
 #include "TEveCaloLegoOverlay.h"
+#include "TEveCaloLegoGL.h"
 
 #include "TAxis.h"
 #include "TColor.h"
@@ -20,6 +21,7 @@
 #include "TGLIncludes.h"
 #include "TGLSelectRecord.h"
 #include "TGLUtil.h"
+#include "TGLViewerBase.h"
 #include "TGLCamera.h"
 #include "TGLAxisPainter.h"
 #include "TGLFontManager.h"
@@ -624,7 +626,7 @@
 
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    TGLCamera& cam = rnrCtx.RefCamera();
-   Bool_t drawOverlayAxis = kFALSE;
+   Bool_t drawOverlayAxis = kTRUE;
 
    if (cam.IsOrthographic())
    {
@@ -634,11 +636,13 @@
       TGLVertex3 p;
       TGLVector3 res = cam.WorldDeltaToViewport(p, rng);
 
-      if (fShowScales)
+      TEveCaloLegoGL* lgl = dynamic_cast<TEveCaloLegoGL*>(rnrCtx.RefViewer().FindLogicalInScenes(fCalo));
+      if (fShowScales && lgl)
       {
+
          // get smallest bin
          Double_t sq = 1e4;
-         if (fCalo->fBinStep == 1)
+         if (lgl->fBinStep == 1)
          {
             TEveCaloData::CellData_t cellData;
             for ( TEveCaloData::vCellId_t::iterator i = fCalo->fCellList.begin(); i != fCalo->fCellList.end(); ++i)
@@ -666,7 +670,7 @@
                if (sq > a->GetBinWidth(i)) sq = a->GetBinWidth(i);
             }
 
-            sq *= fCalo->fBinStep;
+            sq *= lgl->fBinStep;
          }
          fCellX = (res.X()*sq)/(fCalo->GetEtaRng()*1.*cam.RefViewport().Width());
          fCellY = (res.Y()*sq)/(fCalo->GetPhiRng()*1.*cam.RefViewport().Height());
@@ -678,8 +682,10 @@
       }
 
       // draw camera overlay if projected lego bbox to large
-      if (res.X() > cam.RefViewport().Width()*0.8 || res.Y() > cam.RefViewport().Height()*0.8)
-         drawOverlayAxis = kTRUE;
+      SetFrustum(cam);
+      if (   fCalo->GetEtaMin() > fFrustum[0] && fCalo->GetEtaMax() < fFrustum[2]
+          && fCalo->GetPhiMin() > fFrustum[1] && fCalo->GetPhiMax() < fFrustum[3])
+            drawOverlayAxis = kFALSE;
    }
 
    if (cam.IsPerspective() && fShowPlane)
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCompound.cxx root/graf3d/eve/src/TEveCompound.cxx
--- root-old/graf3d/eve/src/TEveCompound.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveCompound.cxx	2010-04-12 19:25:01.000000000 +0200
@@ -57,6 +57,7 @@
    // Call base-class implementation.
    // If compund is open and compound of the new element is not set,
    // the el's compound is set to this.
+   // You might also want to call RecheckImpliedSelections().
 
    TEveElementList::AddElement(el);
    if (IsCompoundOpen() && el->GetCompound() == 0)
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveDigitSet.cxx root/graf3d/eve/src/TEveDigitSet.cxx
--- root-old/graf3d/eve/src/TEveDigitSet.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveDigitSet.cxx	2010-04-12 19:25:07.000000000 +0200
@@ -13,13 +13,8 @@
 #include "TEveManager.h"
 #include "TEveTrans.h"
 
-
 #include "TColor.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 
 //______________________________________________________________________________
 //
@@ -29,17 +24,31 @@
 //
 // Base-class for displaying a digit collection.
 // Provdies common services for:
-// - specifying signal / color per digit
-// - specifying object reference per digit
-// - controlling palette and thresholds (external object TEveRGBAPalette)
-// - showing a frame around the digits (external object TEveFrameBox)
-// - specifying transformation matrix for the whole collection
+// - specifying signal / color per digit;
+// - specifying object reference per digit;
+// - controlling palette and thresholds (external object TEveRGBAPalette);
+// - showing a frame around the digits (external object TEveFrameBox);
+// - specifying transformation matrix for the whole collection;
 //   by data-member of class TEveTrans.
 //
+// Use method DigitId(TObject* id) to assign additional identification
+// to the last created digit. By calling SetOwnIds(kTRUE) tje
+// digit-set becomes the owner of the assigned objects and deletes
+// them on destruction.
+// Note that TRef is used for referencing the objects and if you
+// instantiate the objects just to pass them to digit-set you should
+// also call  TProcessID::Get/SetObjectCount() at the beginning / end
+// of processing of an event. See documentation for class TRef, in
+// particular section 'ObjectNumber'.
+//
 // If you use value-is-color mode and want to use transparency, set
 // the transparency to non-zero value so that GL-renderer will be
 // properly informed.
 //
+// If you want to use single color for all elements call:
+//   UseSingleColor()
+// Palette controls will not work in this case.
+//
 // See also:
 //   TEveQuadSet: rectangle, hexagon or line per digit
 //   TEveBoxSet   a 3D box per digit
@@ -48,7 +57,7 @@
 
 //______________________________________________________________________________
 TEveDigitSet::TEveDigitSet(const char* n, const char* t) :
-   TEveElement     (),
+   TEveElement     (fColor),
    TNamed          (n, t),
 
    fDefaultValue   (kMinInt),
@@ -57,6 +66,7 @@
    fPlex           (),
    fLastDigit      (0),
 
+   fColor          (kWhite),
    fFrame          (0),
    fPalette        (0),
    fRenderMode     (kRM_AsIs),
@@ -114,11 +124,25 @@
 /******************************************************************************/
 
 //______________________________________________________________________________
+void TEveDigitSet::UseSingleColor()
+{
+   // Instruct digit-set to use single color for its digits.
+   // Call SetMainColor/Transparency to initialize it.
+
+   fSingleColor = kTRUE;
+}
+
+//______________________________________________________________________________
 void TEveDigitSet::SetMainColor(Color_t color)
 {
    // Override from TEveElement, forward to Frame.
 
-   if (fFrame) {
+   if (fSingleColor)
+   {
+      TEveElement::SetMainColor(color);
+   }
+   else if (fFrame)
+   {
       fFrame->SetFrameColor(color);
       fFrame->StampBackPtrElements(kCBColorSelection);
    }
@@ -218,24 +242,11 @@
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveDigitSet::Paint(Option_t* /*option*/)
+void TEveDigitSet::Paint(Option_t*)
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEveDigitSet::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = fFrame ? fFrame->GetFrameColor() : 1;
-   buff.fTransparency = GetMainTransparency();
-   RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
@@ -285,9 +296,11 @@
    fFrame = b;
    if (fFrame) {
       fFrame->IncRefCount(this);
-      SetMainColorPtr(fFrame->PtrFrameColor());
+      if (!fSingleColor) {
+         SetMainColorPtr(fFrame->PtrFrameColor());
+      }
    } else {
-      SetMainColorPtr(0);
+      SetMainColorPtr(&fColor);
    }
 }
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveElement.cxx root/graf3d/eve/src/TEveElement.cxx
--- root-old/graf3d/eve/src/TEveElement.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveElement.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -15,6 +15,12 @@
 #include "TEveManager.h"
 #include "TEveSelection.h"
 #include "TEveProjectionBases.h"
+#include "TEveProjectionManager.h"
+
+#include "TBuffer3D.h"
+#include "TBuffer3DTypes.h"
+#include "TVirtualPad.h"
+#include "TVirtualViewer3D.h"
 
 #include "TGeoMatrix.h"
 
@@ -57,7 +63,7 @@
 
 //______________________________________________________________________________
 const TGPicture* TEveElement::fgRnrIcons[4]      = { 0 };
-const TGPicture* TEveElement::fgListTreeIcons[8] = { 0 };
+const TGPicture* TEveElement::fgListTreeIcons[9] = { 0 };
 
 //______________________________________________________________________________
 TEveElement::TEveElement() :
@@ -726,7 +732,8 @@
                                              TGListTreeItem* parent_lti)
 {
    // Add this element into ltree to an already existing item
-   // parent_lti.
+   // parent_lti. Children, if any, are added as below the newly created item.
+   // Returns the newly created list-tree-item.
 
    static const TEveException eh("TEveElement::AddIntoListTree ");
 
@@ -737,6 +744,11 @@
    if (parent_lti == 0)
       ++fTopItemCnt;
 
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      (*i)->AddIntoListTree(ltree, item);
+   }
+
    ltree->ClearViewPort();
 
    return item;
@@ -995,6 +1007,34 @@
    }
 }
 
+//______________________________________________________________________________
+void TEveElement::PaintStandard(TObject* id)
+{
+   // Paint object -- a generic implementation for EVE elements.
+   // This supports direct rendering using a dedicated GL class.
+   // Override TObject::Paint() in sub-classes if different behaviour
+   // is required.
+
+   static const TEveException eh("TEveElement::PaintStandard ");
+
+   TBuffer3D buff(TBuffer3DTypes::kGeneric);
+
+   // Section kCore
+   buff.fID           = id;
+   buff.fColor        = GetMainColor();
+   buff.fTransparency = GetMainTransparency();
+   if (HasMainTrans())  RefMainTrans().SetBuffer3D(buff);
+
+   buff.SetSectionsValid(TBuffer3D::kCore);
+
+   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
+   if (reqSections != TBuffer3D::kNone)
+   {
+      Warning(eh, "IsA='%s'. Viewer3D requires more sections (%d). Only direct-rendering supported.",
+              id->ClassName(), reqSections);
+   }
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
@@ -1173,12 +1213,12 @@
 /******************************************************************************/
 
 //______________________________________________________________________________
-TEveTrans* TEveElement::PtrMainTrans()
+TEveTrans* TEveElement::PtrMainTrans(Bool_t create)
 {
-   // Return pointer to main transformation. It is created if not yet
-   // existing.
+   // Return pointer to main transformation. If 'create' flag is set (default)
+   // it is created if not yet existing.
 
-   if (!fMainTrans)
+   if (!fMainTrans && create)
       InitMainTrans();
 
    return fMainTrans;
@@ -1334,7 +1374,41 @@
    // See comment to RemoveElementlocal(TEveElement*).
 }
 
-/******************************************************************************/
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveElement::ProjectChild(TEveElement* el, Bool_t same_depth)
+{
+   // If this is a projectable, loop over all projected replicas and
+   // add the projected image of child 'el' there. This is supposed to
+   // be called after you add a child to a projectable after it has
+   // already been projected.
+   // You might also want to call RecheckImpliedSelections() on this
+   // element or 'el'.
+   //
+   // If 'same_depth' flag is true, the same depth as for parent object
+   // is used in every projection. Otherwise current depth of each
+   // relevant projection-manager is used.
+
+   TEveProjectable* pable = dynamic_cast<TEveProjectable*>(this);
+   if (pable && HasChild(el))
+   {
+      for (TEveProjectable::ProjList_i i = pable->BeginProjecteds(); i != pable->EndProjecteds(); ++i)
+      {
+         TEveProjectionManager *pmgr = (*i)->GetManager();
+         Float_t cd = pmgr->GetCurrentDepth();
+         if (same_depth) pmgr->SetCurrentDepth((*i)->GetDepth());
+
+         pmgr->SubImportElements(el, dynamic_cast<TEveElement*>(*i));
+
+         if (same_depth) pmgr->SetCurrentDepth(cd);
+      }
+
+      
+   }
+}
+
+//==============================================================================
 
 //______________________________________________________________________________
 Bool_t TEveElement::HasChild(TEveElement* el)
@@ -1764,6 +1838,24 @@
    return 0;
 }
 
+//______________________________________________________________________________
+void TEveElement::RecheckImpliedSelections()
+{
+   // Call this if it is possible that implied-selection or highlight
+   // has changed for this element or for implied-selection this
+   // element is member of and you want to maintain consistent
+   // selection state.
+   // This can happen if you add elements into compounds in response
+   // to user-interaction.
+
+   if (fSelected || fImpliedSelected)
+      gEve->GetSelection()->RecheckImpliedSetForElement(this);
+
+   if (fHighlighted || fImpliedHighlighted)
+      gEve->GetHighlight()->RecheckImpliedSetForElement(this);
+}
+
+
 /******************************************************************************/
 // Stamping
 /******************************************************************************/
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveJetCone.cxx root/graf3d/eve/src/TEveJetCone.cxx
--- root-old/graf3d/eve/src/TEveJetCone.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveJetCone.cxx	2010-04-12 19:25:07.000000000 +0200
@@ -12,11 +12,6 @@
 #include "TEveJetCone.h"
 #include "TEveTrans.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-
 #include "TMath.h"
 
 //______________________________________________________________________________
@@ -76,23 +71,7 @@
    // Paint object.
    // This is for direct rendering (using TEveJetConeGL class).
 
-   static const TEveException eh("TEveJetCone::Paint ");
-
-   if (fRnrSelf == kFALSE) return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveLine.cxx root/graf3d/eve/src/TEveLine.cxx
--- root-old/graf3d/eve/src/TEveLine.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveLine.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -52,6 +52,14 @@
 }
 
 //______________________________________________________________________________
+const TGPicture* TEveLine::GetListTreeIcon(Bool_t)
+{
+   // Returns list-tree icon for TEveLine.
+
+   return fgListTreeIcons[8];
+}
+
+//______________________________________________________________________________
 void TEveLine::SetMarkerColor(Color_t col)
 {
    // Set marker color. Propagate to projected lines.
@@ -272,6 +280,28 @@
    return TEveLineProjected::Class();
 }
 
+//------------------------------------------------------------------------------
+
+//______________________________________________________________________________
+Bool_t TEveLine::GetDefaultSmooth()
+{
+   // Get default value for smooth-line drawing flag.
+   // Static function.
+
+   return fgDefaultSmooth;
+}
+
+//______________________________________________________________________________
+void TEveLine::SetDefaultSmooth(Bool_t r)
+{
+   // Set default value for smooth-line drawing flag (default kFALSE).
+   // Static function.
+
+   fgDefaultSmooth = r;
+}
+
+
+
 //==============================================================================
 //==============================================================================
 // TEveLineProjected
@@ -323,7 +353,8 @@
    // Virtual from TEveProjected.
 
    TEveProjection& proj = * fManager->GetProjection();
-   TEveLine      & als   = * dynamic_cast<TEveLine*>(fProjectable);
+   TEveLine      & als  = * dynamic_cast<TEveLine*>(fProjectable);
+   TEveTrans      *tr   =   als.PtrMainTrans(kFALSE);
 
    Int_t n = als.Size();
    Reset(n);
@@ -331,7 +362,6 @@
    Float_t *o = als.GetP(), *p = GetP();
    for (Int_t i = 0; i < n; ++i, o+=3, p+=3)
    {
-      p[0] = o[0]; p[1] = o[1]; p[2] = o[2];
-      proj.ProjectPointfv(p, fDepth);
+      proj.ProjectPointfv(tr, o, p, fDepth);
    }
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEvePlot3D.cxx root/graf3d/eve/src/TEvePlot3D.cxx
--- root-old/graf3d/eve/src/TEvePlot3D.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEvePlot3D.cxx	2010-04-12 19:25:07.000000000 +0200
@@ -12,11 +12,6 @@
 #include "TEvePlot3D.h"
 #include "TEveTrans.h"
 
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-
 
 //______________________________________________________________________________
 // Description of TEvePlot3D
@@ -35,44 +30,10 @@
    InitMainTrans();
 }
 
-
-/******************************************************************************/
-
-/*
-// For now use true sizes of plots.
 //______________________________________________________________________________
-void TEvePlot3D::ComputeBBox()
+void TEvePlot3D::Paint(Option_t* )
 {
-   // Compute bounding-box of the data.
-
-   if (fPlot)
-      BBoxZero(); // should be BBoxZero(0.5); once the plots are stuffed into unit box.
-   else
-      BBoxZero();
-}
-*/
-
-//______________________________________________________________________________
-void TEvePlot3D::Paint(Option_t*)
-{
-   // Paint object.
-   // This is for direct rendering (using TEvePlot3DGL class).
-
-   static const TEveException eh("TEvePlot3D::Paint ");
-
-   if (fRnrSelf == kFALSE) return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
+   // Paint this object. Only direct rendering is supported.
 
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEvePointSet.cxx root/graf3d/eve/src/TEvePointSet.cxx
--- root-old/graf3d/eve/src/TEvePointSet.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEvePointSet.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -20,9 +20,7 @@
 #include "TF3.h"
 
 #include "TColor.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualViewer3D.h"
+
 
 //==============================================================================
 //==============================================================================
@@ -302,27 +300,11 @@
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEvePointSet::Paint(Option_t* /*option*/)
+void TEvePointSet::Paint(Option_t*)
 {
    // Paint point-set.
 
-   static const TEveException eh("TEvePointSet::Paint ");
-
-   if (fRnrSelf == kFALSE) return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 /******************************************************************************/
@@ -828,8 +810,9 @@
    // Re-apply the projection.
    // Virtual from TEveProjected.
 
-   TEveProjection& proj = * fManager->GetProjection();
-   TEvePointSet  & ps   = * dynamic_cast<TEvePointSet*>(fProjectable);
+   TEveProjection &proj = * fManager->GetProjection();
+   TEvePointSet   &ps   = * dynamic_cast<TEvePointSet*>(fProjectable);
+   TEveTrans      *tr   =   ps.PtrMainTrans(kFALSE);
 
    Int_t n = ps.Size();
    Reset(n);
@@ -837,8 +820,7 @@
    Float_t *o = ps.GetP(), *p = GetP();
    for (Int_t i = 0; i < n; ++i, o+=3, p+=3)
    {
-      p[0] = o[0]; p[1] = o[1]; p[2] = o[2];
-      proj.ProjectPoint(p[0], p[1], p[2], fDepth);
+      proj.ProjectPointfv(tr, o, p, fDepth);
    }
 }
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEvePolygonSetProjected.cxx root/graf3d/eve/src/TEvePolygonSetProjected.cxx
--- root-old/graf3d/eve/src/TEvePolygonSetProjected.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEvePolygonSetProjected.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -28,8 +28,10 @@
 
    Seg_t(Int_t i1=-1, Int_t i2=-1) : fV1(i1), fV2(i2) {}
 };
+
 typedef std::list<Seg_t>           LSeg_t;
 typedef std::list<Seg_t>::iterator LSegIt_t;
+
 }
 
 //==============================================================================
@@ -49,22 +51,12 @@
 
 //______________________________________________________________________________
 TEvePolygonSetProjected::TEvePolygonSetProjected(const char* n, const char* t) :
-   TEveElementList(n, t),
-
+   TEveShape(n, t),
    fBuff(0),
-
    fNPnts(0),
-   fPnts(0),
-
-   fFillColor(5),
-   fLineColor(3),
-   fLineWidth(1),
-
-   fHighlightFrame(kTRUE)
+   fPnts(0)
 {
    // Constructor.
-
-   SetMainColorPtr(&fFillColor);
 }
 
 //______________________________________________________________________________
@@ -78,6 +70,23 @@
 }
 
 //______________________________________________________________________________
+void TEvePolygonSetProjected::ComputeBBox()
+{
+   // Override of virtual method from TAttBBox.
+
+   if (fNPnts > 0) {
+      BBoxInit();
+      for (Int_t pi = 0; pi < fNPnts; ++pi)
+         BBoxCheckPoint(fPnts[pi].fX, fPnts[pi].fY, fPnts[pi].fZ);
+   } else {
+      BBoxZero();
+   }
+}
+
+
+//==============================================================================
+
+//______________________________________________________________________________
 void TEvePolygonSetProjected::SetProjection(TEveProjectionManager* mng,
                                             TEveProjectable* model)
 {
@@ -157,7 +166,7 @@
       idxMap[v] = -1;
       for (Int_t k = 0; k < fNPnts; ++k)
       {
-         if(pnts[v].SquareDistance(pnts[ra[k]]) < TEveProjection::fgEps*TEveProjection::fgEps)
+         if (pnts[v].SquareDistance(pnts[ra[k]]) < TEveProjection::fgEpsSqr)
          {
             idxMap[v] = k;
             break;
@@ -283,12 +292,12 @@
          Int_t mv2 = idxMap[(*it).fV2];
          accepted = projection->AcceptSegment(fPnts[mv1], fPnts[mv2], TEveProjection::fgEps);
 
-         if(accepted == kFALSE)
+         if (accepted == kFALSE)
          {
             pp.clear();
             break;
          }
-         if(tail != pp.back()) pp.push_back(tail);
+         if (tail != pp.back()) pp.push_back(tail);
          tail = (mv1 == tail) ? mv2 :mv1;
       }
       // DirectDraw() implementation: last and first vertices should not be equal
@@ -372,8 +381,6 @@
    return surf;
 }
 
-/******************************************************************************/
-
 //______________________________________________________________________________
 void  TEvePolygonSetProjected::ProjectBuffer3D()
 {
@@ -422,60 +429,6 @@
 }
 
 //______________________________________________________________________________
-void TEvePolygonSetProjected::ComputeBBox()
-{
-   // Override of virtual method from TAttBBox.
-
-   if (fNPnts > 0) {
-      BBoxInit();
-      for (Int_t pi = 0; pi < fNPnts; ++pi)
-         BBoxCheckPoint(fPnts[pi].fX, fPnts[pi].fY, fPnts[pi].fZ);
-   } else {
-      BBoxZero();
-   }
-}
-
-//______________________________________________________________________________
-void TEvePolygonSetProjected::SetMainColor(Color_t color)
-{
-   // Set main color.
-   // Override so that line-color can also be changed if it is equal
-   // to fill color (which is treated as main color).
-
-   if (fFillColor == fLineColor) {
-      fLineColor = color;
-      StampObjProps();
-   }
-   TEveElementList::SetMainColor(color);
-}
-
-//______________________________________________________________________________
-void TEvePolygonSetProjected::Paint(Option_t* )
-{
-   // Paint this object. Only direct rendering is supported.
-
-   static const TEveException eh("TEvePolygonSetProjected::Paint ");
-
-   if (fNPnts == 0) return;
-   TBuffer3D buffer(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buffer.fID           = this;
-   buffer.fColor        = GetMainColor();
-   buffer.fTransparency = GetMainTransparency();
-   buffer.fLocalFrame   = false;
-
-   buffer.SetSectionsValid(TBuffer3D::kCore);
-
-   // We fill kCore on first pass and try with viewer
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buffer);
-   if (reqSections != TBuffer3D::kNone)
-      Warning(eh, "Viewer3D requires more (%d).", reqSections);
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
 void TEvePolygonSetProjected::DumpPolys() const
 {
    // Dump information about built polygons.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx root/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx
--- root-old/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
-// Authors: Matevz Tadel & Alja Mrak-Tadel: 2006, 2007
-
-/*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
-
-#include "TEvePolygonSetProjectedEditor.h"
-#include "TEvePolygonSetProjected.h"
-
-#include "TColor.h"
-
-#include "TGLabel.h"
-#include "TGNumberEntry.h"
-#include "TGColorSelect.h"
-#include "TGColorDialog.h"
-
-//==============================================================================
-//==============================================================================
-// TEvePolygonSetProjectedEditor
-//==============================================================================
-
-//______________________________________________________________________________
-//
-// GUI editor for class TEvePolygonSetProjected.
-
-ClassImp(TEvePolygonSetProjectedEditor);
-
-//______________________________________________________________________________
-TEvePolygonSetProjectedEditor::TEvePolygonSetProjectedEditor(const TGWindow *p,
-                                                             Int_t width, Int_t height,
-                                                             UInt_t options, Pixel_t back) :
-   TGedFrame(p, width, height, options | kVerticalFrame, back),
-   fPS(0),
-   fLineWidth(0),
-   fLineColor(0)
-{
-   // Constructor.
-
-   MakeTitle("TEvePolygonSetProjected");
-
-   {
-      TGCompositeFrame *f = new TGCompositeFrame(this, 80, 20, kHorizontalFrame);
-
-      TGLabel *l = new TGLabel(f, "LineColor:");
-      f->AddFrame(l, new TGLayoutHints(kLHintsLeft, 2, 2, 1, 1));
-      fLineColor = new TGColorSelect(f, 0, -1);
-      fLineColor->Connect("ColorSelected(Pixel_t)", "TEvePolygonSetProjectedEditor", this, "DoLineColor(Pixel_t)");
-      f->AddFrame(fLineColor, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
-
-      fLineWidth = new TGNumberEntry(f, 0., 4, -1,
-                                     TGNumberFormat::kNESRealOne, TGNumberFormat::kNEAPositive,
-                                     TGNumberFormat::kNELLimitMinMax, 0.1, 20.0);
-      fLineWidth->GetNumberEntry()->SetToolTipText("Line width of outline.");
-      fLineWidth->Connect("ValueSet(Long_t)", "TEvePolygonSetProjectedEditor", this, "DoLineWidth()");
-      f->AddFrame(fLineWidth, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
-
-      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 0, 0));
-   }
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEvePolygonSetProjectedEditor::SetModel(TObject* obj)
-{
-   // Set model object.
-
-   fPS = dynamic_cast<TEvePolygonSetProjected*>(obj);
-   fLineWidth->SetNumber(fPS->fLineWidth);
-   fLineColor->SetColor(TColor::Number2Pixel(fPS->GetLineColor()), kFALSE);
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEvePolygonSetProjectedEditor::DoLineWidth()
-{
-   // Slot for setting line with of polygon outline.
-
-   fPS->fLineWidth = fLineWidth->GetNumber();
-   Update();
-}
-
-//______________________________________________________________________________
-void TEvePolygonSetProjectedEditor::DoLineColor(Pixel_t pixel)
-{
-   // Slot for setting line color of polygon outline.
-
-   fPS->SetLineColor(TColor::GetColor(pixel));
-   Update();
-}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx root/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
--- root-old/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx	2010-04-12 19:25:08.000000000 +0200
@@ -108,11 +108,11 @@
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glDisable(GL_CULL_FACE);
 
-   fMultiColor = (refPS.fFillColor != refPS.fLineColor);
+   fMultiColor = (refPS.fDrawFrame && refPS.fFillColor != refPS.fLineColor);
 
    // polygons
    glEnable(GL_POLYGON_OFFSET_FILL);
-   glPolygonOffset(1.,1.);
+   glPolygonOffset(1.0f,1.0f);
    GLUtesselator *tessObj = TGLUtil::GetDrawTesselator3fv();
 
    TEveVector* pnts = refPS.fPnts;
@@ -150,11 +150,14 @@
    }
    glDisable(GL_POLYGON_OFFSET_FILL);
 
-   // outline
-   TGLUtil::Color(refPS.fLineColor);
-   glEnable(GL_LINE_SMOOTH);
-   TGLUtil::LineWidth(refPS.fLineWidth);
-   DrawOutline();
+   // Outline
+   if (refPS.fDrawFrame)
+   {
+      TGLUtil::Color(refPS.fLineColor);
+      glEnable(GL_LINE_SMOOTH);
+      TGLUtil::LineWidth(refPS.fLineWidth);
+      DrawOutline();
+   }
 
    glPopAttrib();
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveProjectionAxes.cxx root/graf3d/eve/src/TEveProjectionAxes.cxx
--- root-old/graf3d/eve/src/TEveProjectionAxes.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveProjectionAxes.cxx	2010-04-12 19:25:07.000000000 +0200
@@ -13,13 +13,9 @@
 #include "TEveProjectionManager.h"
 #include "TMath.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-#include "TEveTrans.h"
-
 
+//______________________________________________________________________________
+//
 // Axes for non-linear projections. Show scale of TEveProjectionManager
 // children. With different step mode tick-marks can positioned
 // equidistant or placed with value monotonically increasing from lower left corner
@@ -64,26 +60,11 @@
 }
 
 //______________________________________________________________________________
-void TEveProjectionAxes::Paint(Option_t* )
+void TEveProjectionAxes::Paint(Option_t*)
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEveProjectionAxes::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveProjectionBases.cxx root/graf3d/eve/src/TEveProjectionBases.cxx
--- root-old/graf3d/eve/src/TEveProjectionBases.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveProjectionBases.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -153,6 +153,14 @@
 }
 
 //______________________________________________________________________________
+TEveElement* TEveProjected::GetProjectableAsElement() const
+{
+   // Returns fProjectable dynamic-casted to TEveElement.
+
+   return dynamic_cast<TEveElement*>(fProjectable);
+}
+
+//______________________________________________________________________________
 void TEveProjected::SetProjection(TEveProjectionManager* mng, TEveProjectable* model)
 {
    // Sets projection manager and reference in the projectable object. Method called
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveProjectionManager.cxx root/graf3d/eve/src/TEveProjectionManager.cxx
--- root-old/graf3d/eve/src/TEveProjectionManager.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveProjectionManager.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -282,6 +282,35 @@
 }
 
 //______________________________________________________________________________
+TEveElement* TEveProjectionManager::SubImportElements(TEveElement* el,
+                                                      TEveElement* proj_parent)
+{
+   // Recursively import elements and apply projection to the newly
+   // imported objects.
+   //
+   // The proj_parent argument should be a projected replica of parent
+   // of element 'el'. This allows to insert projected children of
+   // a given element when they are added after the projection has
+   // been already performed on the parent.
+   // This is called from TEveElement::ProjectChild().
+   //
+   // Returns the projected replica of el. Can be 0, if el and none of
+   // its children are projectable.
+
+   TEveElement* new_el = ImportElementsRecurse(el, proj_parent);
+   if (new_el)
+   {
+      AssertBBox();
+      ProjectChildrenRecurse(new_el);
+      AssertBBoxExtents(0.1);
+      StampTransBBox();
+
+      UpdateDependentElsAndScenes(new_el);
+   }
+   return new_el;
+}
+
+//______________________________________________________________________________
 void TEveProjectionManager::ProjectChildrenRecurse(TEveElement* el)
 {
    // Project el (via TEveProjected::UpdateProjection()) and recurse
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveProjections.cxx root/graf3d/eve/src/TEveProjections.cxx
--- root-old/graf3d/eve/src/TEveProjections.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveProjections.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -10,6 +10,7 @@
  *************************************************************************/
 
 #include "TEveProjections.h"
+#include "TEveTrans.h"
 #include "TEveUtil.h"
 
 #include <limits>
@@ -28,7 +29,8 @@
 
 ClassImp(TEveProjection);
 
-Float_t TEveProjection::fgEps = 0.005f;
+Float_t TEveProjection::fgEps    = 0.005f;
+Float_t TEveProjection::fgEpsSqr = 0.000025f;
 
 //______________________________________________________________________________
 TEveProjection::TEveProjection() :
@@ -82,6 +84,54 @@
 }
 
 //______________________________________________________________________________
+void TEveProjection::ProjectPointfv(const TEveTrans* t, const Float_t* p, Float_t* v, Float_t d)
+{
+   // Project float array, converting it to global coordinate system first if
+   // transformation matrix is set.
+
+   v[0] = p[0]; v[1] = p[1]; v[2] = p[2];
+   if (t)
+   {
+      t->MultiplyIP(v);
+   }
+   ProjectPoint(v[0], v[1], v[2], d);
+}
+
+//______________________________________________________________________________
+void TEveProjection::ProjectPointdv(const TEveTrans* t, const Double_t* p, Double_t* v, Float_t d)
+{
+   // Project double array, converting it to global coordinate system first if
+   // transformation matrix is set.
+   // This is a bit piggish as we convert the doubles to floats and back.
+
+   Float_t x, y, z;
+   if (t)
+   {
+      t->Multiply(p, v);
+      x = v[0]; y = v[1]; z = v[2];
+   }
+   else
+   {
+      x = p[0]; y = p[1]; z = p[2];
+   }
+   ProjectPoint(x, y, z, d);
+   v[0] = x; v[1] = y; v[2] = z;
+}
+
+//______________________________________________________________________________
+void TEveProjection::ProjectVector(const TEveTrans* t, TEveVector& v, Float_t d)
+{
+   // Project TEveVector, converting it to global coordinate system first if
+   // transformation matrix is set.
+
+   if (t)
+   {
+      t->MultiplyIP(v);
+   }
+   ProjectPoint(v.fX, v.fY, v.fZ, d);
+}
+
+//______________________________________________________________________________
 void TEveProjection::PreScaleVariable(Int_t dim, Float_t& v)
 {
    // Pre-scale single variable with pre-scale entry dim.
@@ -468,9 +518,12 @@
 }
 //______________________________________________________________________________
 Bool_t TEveRhoZProjection::AcceptSegment(TEveVector& v1, TEveVector& v2,
-                                         Float_t tolerance)
+                                         Float_t tolerance) const
 {
    // Check if segment of two projected points is valid.
+   //
+   // Move slightly one of the points if by shifting it by no more than
+   // tolearance the segment can become acceptable.
 
    Float_t a = fProjectedCenter.fY;
    Bool_t val = kTRUE;
@@ -493,6 +546,16 @@
    return val;
 }
 
+//______________________________________________________________________________
+Int_t TEveRhoZProjection::SubSpaceId(const TEveVector& v) const
+{
+   // Return sub-space id for the point.
+   // 0 - upper half-space
+   // 1 - lowwer half-space
+
+   return v.fY > fProjectedCenter.fY ? 0 : 1;
+}
+
 
 //==============================================================================
 //==============================================================================
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveQuadSetGL.cxx root/graf3d/eve/src/TEveQuadSetGL.cxx
--- root-old/graf3d/eve/src/TEveQuadSetGL.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveQuadSetGL.cxx	2010-04-12 19:24:48.000000000 +0200
@@ -66,7 +66,11 @@
 {
    // Set color for rendering of the specified quad.
 
-   if (fM->fValueIsColor)
+   if (fM->fSingleColor)
+   {
+      return kTRUE;
+   }
+   else if (fM->fValueIsColor)
    {
       TGLUtil::Color4ubv((UChar_t*) & q.fValue);
       return kTRUE;
@@ -107,7 +111,7 @@
 
    if (mQ.fPlex.Size() > 0)
    {
-      if ( ! mQ.fValueIsColor && mQ.fPalette == 0)
+      if (! mQ.fSingleColor && ! mQ.fValueIsColor && mQ.fPalette == 0)
       {
          mQ.AssertPalette();
       }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveSelection.cxx root/graf3d/eve/src/TEveSelection.cxx
--- root-old/graf3d/eve/src/TEveSelection.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveSelection.cxx	2010-04-12 19:25:03.000000000 +0200
@@ -37,6 +37,7 @@
    fDecImpSelElement = &TEveElement::DecImpliedSelected;
 }
 
+//______________________________________________________________________________
 void TEveSelection::SetHighlightMode()
 {
    // Set to 'highlight' mode.
@@ -189,6 +190,48 @@
    }
 }
 
+//______________________________________________________________________________
+void TEveSelection::RecheckImpliedSet(SelMap_i smi)
+{
+   // Recalculate implied-selected state for given selection entry.
+   // Add new elements to implied-selected set and increase their
+   // implied-selected count.
+
+   Set_t set;
+   smi->first->FillImpliedSelectedSet(set);
+   for (Set_i i = set.begin(); i != set.end(); ++i)
+   {
+      if (smi->second.find(*i) == smi->second.end())
+      {
+         smi->second.insert(*i);
+         ((*i)->*fIncImpSelElement)();
+      }
+   }
+}
+
+//______________________________________________________________________________
+void TEveSelection::RecheckImpliedSetForElement(TEveElement* el)
+{
+   // If given element is selected or implied-selected with this
+   // selection and recheck implied-set for given selection entry.
+
+   // Top-level selected.
+   {
+      SelMap_i i = fImpliedSelected.find(el);
+      if (i != fImpliedSelected.end())
+         RecheckImpliedSet(i);
+   }
+
+   // Implied selected, need to loop over all.
+   {
+      for (SelMap_i i = fImpliedSelected.begin(); i != fImpliedSelected.end(); ++ i)
+      {
+         if (i->second.find(el) != i->second.end())
+            RecheckImpliedSet(i);
+      }
+   }
+}
+
 
 //******************************************************************************
 // Signals
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveShape.cxx root/graf3d/eve/src/TEveShape.cxx
--- root-old/graf3d/eve/src/TEveShape.cxx	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/src/TEveShape.cxx	2010-04-12 19:25:22.000000000 +0200
@@ -0,0 +1,210 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveShape.h"
+#include "Riostream.h"
+
+//______________________________________________________________________________
+//
+// Abstract base-class for 2D/3D shapes.
+// It provides:
+// - fill color / transparency, accessible via Get/SetMainColor/Transparency;
+// - frame line color / width;
+// - flag if frame should be drawn;
+// - flag specifying whether frame or whole shape should be emphasised for
+//   highlight.
+
+ClassImp(TEveShape);
+
+//______________________________________________________________________________
+TEveShape::TEveShape(const char* n, const char* t) :
+   TEveElementList(n, t),
+   fFillColor(5),
+   fLineColor(3),
+   fLineWidth(1),
+   fDrawFrame(kTRUE),
+   fHighlightFrame(kTRUE)
+{
+   // Constructor.
+
+   SetMainColorPtr(&fFillColor);
+}
+
+//______________________________________________________________________________
+TEveShape::~TEveShape()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TEveShape::SetMainColor(Color_t color)
+{
+   // Set main color.
+   // Override so that line-color can also be changed if it is equal
+   // to fill color (which is treated as main color).
+
+   if (fFillColor == fLineColor) {
+      fLineColor = color;
+      StampObjProps();
+   }
+   TEveElementList::SetMainColor(color);
+}
+
+//______________________________________________________________________________
+void TEveShape::CopyVizParams(const TEveElement* el)
+{
+   // Copy visualization parameters from element el.
+
+   const TEveShape* m = dynamic_cast<const TEveShape*>(el);
+   if (m)
+   {
+      fFillColor = m->fFillColor;
+      fLineColor = m->fLineColor;
+      fLineWidth = m->fLineWidth;
+      fDrawFrame      = m->fDrawFrame;
+      fHighlightFrame = m->fHighlightFrame;
+   }
+
+   TEveElementList::CopyVizParams(el);
+}
+
+//______________________________________________________________________________
+void TEveShape::WriteVizParams(ostream& out, const TString& var)
+{
+   // Write visualization parameters.
+
+   TEveElementList::WriteVizParams(out, var);
+
+   TString t = "   " + var + "->";
+   out << t << "SetFillColor(" << fFillColor << ");\n";
+   out << t << "SetLineColor(" << fLineColor << ");\n";
+   out << t << "SetLineWidth(" << fLineWidth << ");\n";
+   out << t << "SetDrawFrame("      << ToString(fDrawFrame) << ");\n";
+   out << t << "SetHighlightFrame(" << ToString(fHighlightFrame) << ");\n";
+}
+
+//______________________________________________________________________________
+void TEveShape::Paint(Option_t*)
+{
+   // Paint this object. Only direct rendering is supported.
+
+   PaintStandard(this);
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+Int_t TEveShape::FindConvexHull(const vPoint_t& pin, vPoint_t& pout, TEveElement* caller)
+{
+   // Determines the convex-hull of points in pin.
+   //
+   // Adds the hull points to pout and returns the number of added points.
+   // If size of pout is less then 3 then either the number of input points
+   // was too low or they were degenerate so that the hull is actually a line
+   // segment or even a point.
+
+   Int_t N = pin.size();
+
+   // Find the minimum (bottom-left) point.
+   Int_t min_point = 0;
+   for (Int_t i = 1; i < N; ++i)
+   {
+      if (pin[i].fY < pin[min_point].fY || (pin[i].fY == pin[min_point].fY && pin[i].fX < pin[min_point].fX))
+         min_point = i;
+   }
+
+   // Calculate angles and sort.
+   std::vector<Float_t> angles(N);
+   for (Int_t i = 0; i < N; ++i)
+   {
+      angles[i] = (pin[i] - pin[min_point]).Phi();
+   }
+   std::vector<Int_t> idcs(N);
+   TMath::Sort(N, &angles[0], &idcs[0], kFALSE);
+
+   // Weed out points with the same angle -- keep the furthest only.
+   // The first point must stay.
+   if (N > 2)
+   {
+      std::vector<Int_t> new_idcs;
+      new_idcs.push_back(idcs[0]);
+      std::vector<Int_t>::iterator a, b;
+      a = idcs.begin(); ++a;
+      b = a; ++b;
+      while (b != idcs.end())
+      {
+         if (TMath::Abs(angles[*a] - angles[*b]) < 1e-5f)
+         {
+            if (pin[idcs[0]].SquareDistance(pin[*a]) < pin[idcs[0]].SquareDistance(pin[*b]))
+               a = b;
+         }
+         else
+         {
+            new_idcs.push_back(*a);
+            a = b;
+         }
+         ++b;
+      }
+      new_idcs.push_back(*a);
+      idcs.swap(new_idcs);
+   }
+
+   N = idcs.size();
+
+   // Find hull.
+   std::vector<Int_t> hull;
+   if (N > 2)
+   {
+      hull.push_back(idcs[0]);
+      hull.push_back(idcs[1]);
+      hull.push_back(idcs[2]);
+      {
+         Int_t i = 3;
+         while (i < N)
+         {
+            Int_t n = hull.size() - 1;
+            if ((pin[hull[n]] - pin[hull[n-1]]).Cross(pin[idcs[i]] - pin[hull[n]]) > 0)
+            {
+               hull.push_back(idcs[i]);
+               ++i;
+            }
+            else
+            {
+               hull.pop_back();
+            }
+         }
+      }
+   }
+   else
+   {
+      ::Warning("TEveShape::FindConvexHull()", "Polygon reduced to %d points. for '%s'.",
+              N, caller ? caller->GetElementName() : "unknown");
+      hull.swap(idcs);
+   }
+
+   // Add hull points into the output vector.
+   N = hull.size();
+   Int_t Nold = pout.size();
+   pout.resize(Nold + N);
+   for (Int_t i = 0; i < N; ++i)
+   {
+      pout[Nold + i] = pin[hull[i]];
+   }
+
+   // Print the hull.
+   // for (Int_t i = 0; i < N; ++i)
+   // {
+   //    const TEvePoint &p = pin[hull[i]];
+   //    printf("%d [%d] (%5.1f, %5.1f) %f\n", i, hull[i], p.fX, p.fY, angles[hull[i]]);
+   // }
+
+   return N;
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveShapeEditor.cxx root/graf3d/eve/src/TEveShapeEditor.cxx
--- root-old/graf3d/eve/src/TEveShapeEditor.cxx	1970-01-01 01:00:00.000000000 +0100
+++ root/graf3d/eve/src/TEveShapeEditor.cxx	2010-04-12 19:25:08.000000000 +0200
@@ -0,0 +1,129 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveShapeEditor.h"
+#include "TEveShape.h"
+
+#include "TColor.h"
+
+// Cleanup these includes:
+#include "TGLabel.h"
+#include "TGButton.h"
+#include "TGNumberEntry.h"
+#include "TGColorSelect.h"
+#include "TGColorDialog.h"
+
+
+//______________________________________________________________________________
+// GUI editor for TEveShape.
+//
+
+ClassImp(TEveShapeEditor);
+
+//______________________________________________________________________________
+TEveShapeEditor::TEveShapeEditor(const TGWindow *p, Int_t width, Int_t height,
+             UInt_t options, Pixel_t back) :
+   TGedFrame(p, width, height, options | kVerticalFrame, back),
+   fM(0),
+   fLineWidth(0),
+   fLineColor(0),
+   fDrawFrame(0),
+   fHighlightFrame(0)
+{
+   // Constructor.
+
+   MakeTitle("TEveShape");
+
+   {
+      TGCompositeFrame *f = new TGCompositeFrame(this, 80, 20, kHorizontalFrame);
+
+      TGLabel *l = new TGLabel(f, "LineColor:");
+      f->AddFrame(l, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 0));
+      fLineColor = new TGColorSelect(f, 0, -1);
+      fLineColor->Connect("ColorSelected(Pixel_t)", "TEveShapeEditor", this, "DoLineColor(Pixel_t)");
+      f->AddFrame(fLineColor, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
+
+      fLineWidth = new TGNumberEntry(f, 0., 4, -1,
+                                     TGNumberFormat::kNESRealOne, TGNumberFormat::kNEAPositive,
+                                     TGNumberFormat::kNELLimitMinMax, 0.1, 20.0);
+      fLineWidth->GetNumberEntry()->SetToolTipText("Line width of outline.");
+      fLineWidth->Connect("ValueSet(Long_t)", "TEveShapeEditor", this, "DoLineWidth()");
+      f->AddFrame(fLineWidth, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
+
+      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 0, 0));
+   }
+   {
+      TGHorizontalFrame* f = new TGHorizontalFrame(this);
+
+      fDrawFrame  = new TGCheckButton(f, "Draw Frame");
+      f->AddFrame(fDrawFrame, new TGLayoutHints(kLHintsLeft, 1,2,0,0));
+      fDrawFrame->Connect("Toggled(Bool_t)", "TEveShapeEditor", this, "DoDrawFrame()");
+
+      fHighlightFrame = new TGCheckButton(f, "Highlight Frame");
+      f->AddFrame(fHighlightFrame, new TGLayoutHints(kLHintsLeft, 2,1,0,0));
+      fHighlightFrame->Connect("Toggled(Bool_t)"," TEveShapeEditor", this, "DoHighlightFrame()");
+
+      AddFrame(f, new TGLayoutHints(kLHintsTop, 0,0,2,1));
+   }
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveShapeEditor::SetModel(TObject* obj)
+{
+   // Set model object.
+
+   fM = dynamic_cast<TEveShape*>(obj);
+
+   fLineWidth->SetNumber(fM->fLineWidth);
+   fLineColor->SetColor(TColor::Number2Pixel(fM->fLineColor), kFALSE);
+   fDrawFrame     ->SetState(fM->fDrawFrame      ? kButtonDown : kButtonUp);
+   fHighlightFrame->SetState(fM->fHighlightFrame ? kButtonDown : kButtonUp);
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoLineWidth()
+{
+   // Slot for setting line with of polygon outline.
+
+   fM->SetLineWidth(fLineWidth->GetNumber());
+   Update();
+}
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoLineColor(Pixel_t pixel)
+{
+   // Slot for setting line color of polygon outline.
+
+   fM->SetLineColor(TColor::GetColor(pixel));
+   Update();
+}
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoDrawFrame()
+{
+   // Slot for DrawFrame.
+
+   fM->SetDrawFrame(fDrawFrame->IsOn());
+   Update();
+}
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoHighlightFrame()
+{
+   // Slot for HighlightFrame.
+
+   fM->SetHighlightFrame(fHighlightFrame->IsOn());
+   Update();
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveStraightLineSet.cxx root/graf3d/eve/src/TEveStraightLineSet.cxx
--- root-old/graf3d/eve/src/TEveStraightLineSet.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveStraightLineSet.cxx	2010-04-12 19:25:27.000000000 +0200
@@ -11,11 +11,6 @@
 
 #include "TEveStraightLineSet.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-
 #include "TRandom.h"
 #include "TEveProjectionManager.h"
 
@@ -147,25 +142,11 @@
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveStraightLineSet::Paint(Option_t* /*option*/)
+void TEveStraightLineSet::Paint(Option_t*)
 {
    // Paint the line-set.
 
-   static const TEveException eH("TEveStraightLineSet::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   buff.fLocalFrame   = kFALSE;
-   RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 
@@ -227,6 +208,8 @@
    TEveProjection&      proj = * fManager->GetProjection();
    TEveStraightLineSet& orig = * dynamic_cast<TEveStraightLineSet*>(fProjectable);
 
+   TEveTrans *trans = orig.PtrMainTrans(kFALSE);
+
    BBoxClear();
 
    // Lines
@@ -246,14 +229,10 @@
    while (li.next())
    {
       Line_t* l = (Line_t*) li();
-      p1[0] = l->fV1[0]; p1[1] = l->fV1[1]; p1[2] = l->fV1[2];
-      p2[0] = l->fV2[0]; p2[1] = l->fV2[1]; p2[2] = l->fV2[2];
-      mx.MultiplyIP(p1);
-      mx.MultiplyIP(p2);
-      p1[0] += x; p1[1] += y; p1[2] += z;
-      p2[0] += x; p2[1] += y; p2[2] += z;
-      proj.ProjectPointfv(p1, fDepth);
-      proj.ProjectPointfv(p2, fDepth);
+
+      proj.ProjectPointfv(trans, l->fV1, p1, fDepth);
+      proj.ProjectPointfv(trans, l->fV2, p2, fDepth);
+
       AddLine(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
    }
 
@@ -269,7 +248,7 @@
       TEveVector t1, d, xx;
 
       t1.Set(lo->fV1); xx.Set(lo->fV2); xx -= t1; xx *= m->fPos; xx += t1;
-      proj.ProjectVector(xx, 0);
+      proj.ProjectVector(trans, xx, 0);
       t1.Set(lp->fV1); d.Set(lp->fV2); d -= t1; xx -= t1;
 
       AddMarker(m->fLineID, d.Dot(xx) / d.Mag2());
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveText.cxx root/graf3d/eve/src/TEveText.cxx
--- root-old/graf3d/eve/src/TEveText.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveText.cxx	2010-04-12 19:25:07.000000000 +0200
@@ -16,10 +16,6 @@
 #include "TObjArray.h"
 #include "TObjString.h"
 #include "TString.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 #include "TMath.h"
 
 //==============================================================================
@@ -118,25 +114,11 @@
 }
 
 //______________________________________________________________________________
-void TEveText::Paint(Option_t* )
+void TEveText::Paint(Option_t*)
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEveText::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrack.cxx root/graf3d/eve/src/TEveTrack.cxx
--- root-old/graf3d/eve/src/TEveTrack.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTrack.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -25,10 +25,11 @@
 #include "TEveBrowser.h"
 #include "TEveTrackProjected.h"
 
+#include "Riostream.h"
+
 #include <vector>
 #include <algorithm>
 #include <functional>
-#include <iostream>
 
 //==============================================================================
 //==============================================================================
@@ -59,6 +60,7 @@
    fStatus(0),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -80,6 +82,7 @@
    fStatus(t->GetStatusCode()),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -112,6 +115,7 @@
    fStatus(t->GetStatusCode()),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -144,6 +148,7 @@
    fStatus(t->fStatus),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -169,6 +174,7 @@
    fStatus(t.fStatus),
    fLockPoints(t.fLockPoints),
    fPathMarks(),
+   fLastPMIdx(t.fLastPMIdx),
    fPropagator(0),
    fBreakProjectedTracks(t.fBreakProjectedTracks)
 {
@@ -228,7 +234,7 @@
 //______________________________________________________________________________
 void TEveTrack::SetTrackParams(const TEveTrack& t)
 {
-   // Copy track parameters from t.
+   // Copy track parameters from t. Track-propagator is set, too.
    // PathMarks are cleared - you can copy them via SetPathMarks(t).
    // If track 't' is locked, you should probably clone its points
    // over - use TEvePointSet::ClonePoints(t);
@@ -312,18 +318,19 @@
    if (!fLockPoints)
    {
       Reset(0);
+      fLastPMIdx = 0;
 
       TEveTrackPropagator& rTP((fPropagator != 0) ? *fPropagator : TEveTrackPropagator::fgDefault);
 
       const Float_t maxRsq = rTP.GetMaxR() * rTP.GetMaxR();
       const Float_t maxZ   = rTP.GetMaxZ();
 
-      if (TMath::Abs(fV.fZ) < maxZ && fV.fX*fV.fX + fV.fY*fV.fY < maxRsq)
+      if ( ! TEveTrackPropagator::IsOutsideBounds(fV, maxRsq, maxZ))
       {
          TEveVector currP = fP;
          Bool_t decay = kFALSE;
          fPropagator->InitTrack(fV, fCharge);
-         for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
+         for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm, ++fLastPMIdx)
          {
             if (rTP.GetFitReferences() && pm->fType == TEvePathMark::kReference)
             {
@@ -357,12 +364,12 @@
                   break;
                // printf("%s fit decay \n", fName.Data());
                fPropagator->GoToVertex(pm->fV, currP);
-               decay = true;
+               decay = kTRUE;
+               ++fLastPMIdx;
                break;
             }
             else if (rTP.GetFitCluster2Ds() && pm->fType == TEvePathMark::kCluster2D)
             {
-               // This if should actually be done for corrected point.
                TEveVector itsect;
                if (fPropagator->IntersectPlane(currP, pm->fV, pm->fP, itsect))
                {
@@ -370,17 +377,22 @@
                   TEveVector vtopass = pm->fV + pm->fE*(pm->fE.Dot(delta));
                   if (TEveTrackPropagator::IsOutsideBounds(vtopass, maxRsq, maxZ))
                      break;
-                  fPropagator->GoToVertex(vtopass, currP);
+                  if ( ! fPropagator->GoToVertex(vtopass, currP))
+                     break;
                }
                else
                {
                   Warning("TEveTrack::MakeTrack", "Failed to intersect plane for Cluster2D. Ignoring path-mark.");
                }
-               break;
             }
+            else
+            {
+               if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
+                  break;
+            }            
          } // loop path-marks
 
-         if (!decay || rTP.GetFitDecay() == kFALSE)
+         if (!decay)
          {
             // printf("%s loop to bounds  \n",fName.Data() );
             fPropagator->GoToBounds(currP);
@@ -493,7 +505,7 @@
    }
 }
 
-/******************************************************************************/
+//------------------------------------------------------------------------------
 
 //______________________________________________________________________________
 void TEveTrack::SecSelected(TEveTrack* track)
@@ -504,6 +516,29 @@
    Emit("SecSelected(TEveTrack*)", (Long_t)track);
 }
 
+//------------------------------------------------------------------------------
+
+//______________________________________________________________________________
+Bool_t TEveTrack::GetDefaultBreakProjectedTracks()
+{
+   // Return true if tracks get broken into several segments when the
+   // projected space consists of separate domains (like Rho-Z).
+   // Static function.
+
+   return fgDefaultBreakProjectedTracks;
+}
+
+//______________________________________________________________________________
+void TEveTrack::SetDefaultBreakProjectedTracks(Bool_t bt)
+{
+   // Specify whether 2D projected tracks get broken into several
+   // segments when the projected space consists of separate domains
+   // (like Rho-Z). This is true by default.
+   // Static function.
+
+   fgDefaultBreakProjectedTracks = bt;
+}
+
 
 //==============================================================================
 //==============================================================================
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackGL.cxx root/graf3d/eve/src/TEveTrackGL.cxx
--- root-old/graf3d/eve/src/TEveTrackGL.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTrackGL.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -77,41 +77,32 @@
 
    TEveLineGL::DirectDraw(rnrCtx);
 
-   // path-marks
-   const TEveTrack::vPathMark_t& pms = fTrack->RefPathMarks();
-   TEveTrackPropagator& rTP = *fTrack->GetPropagator();
-   if (pms.size())
+   RenderPathMarksAndFirstVertex(rnrCtx);
+}
+
+//______________________________________________________________________________
+void TEveTrackGL::RenderPathMarksAndFirstVertex(TGLRnrCtx& rnrCtx) const
+{
+   // Render path-marks and the first vertex, if required.
+
+   TEveTrackPropagator          &rTP = *fTrack->GetPropagator();
+   const TEveTrack::vPathMark_t &pms =  fTrack->RefPathMarks();
+   if ( ! pms.empty())
    {
-      Float_t* pnts = new Float_t[3*pms.size()]; // maximum
-      Int_t n = 0;
-      Bool_t accept;
-      for (TEveTrack::vPathMark_ci pm = pms.begin(); pm != pms.end(); ++pm)
+      Float_t *pnts = new Float_t[3*pms.size()]; // maximum
+      Int_t    n    = 0;
+      for (Int_t i = 0; i < fTrack->fLastPMIdx; ++i)
       {
-         accept = kFALSE;
-         switch (pm->fType)
-         {
-            case TEvePathMark::kDaughter:
-               if (rTP.GetRnrDaughters())  accept = kTRUE;
-               break;
-            case TEvePathMark::kReference:
-               if (rTP.GetRnrReferences()) accept = kTRUE;
-               break;
-            case TEvePathMark::kDecay:
-               if (rTP.GetRnrDecay())      accept = kTRUE;
-               break;
-            case TEvePathMark::kCluster2D:
-               if (rTP.GetRnrCluster2Ds()) accept = kTRUE;
-               break;
-         }
-         if (accept)
+         const TEvePathMark &pm = pms[i];
+         if ((pm.fType == TEvePathMark::kDaughter  && rTP.GetRnrDaughters())  ||
+             (pm.fType == TEvePathMark::kReference && rTP.GetRnrReferences()) ||
+             (pm.fType == TEvePathMark::kDecay     && rTP.GetRnrDecay())      ||
+             (pm.fType == TEvePathMark::kCluster2D && rTP.GetRnrCluster2Ds()))
          {
-            if ((TMath::Abs(pm->fV.fZ) < rTP.GetMaxZ()) && (pm->fV.Perp() < rTP.GetMaxR()))
-            {
-               pnts[3*n  ] = pm->fV.fX;
-               pnts[3*n+1] = pm->fV.fY;
-               pnts[3*n+2] = pm->fV.fZ;
-               ++n;
-            }
+            pnts[3*n  ] = pm.fV.fX;
+            pnts[3*n+1] = pm.fV.fY;
+            pnts[3*n+2] = pm.fV.fZ;
+            ++n;
          }
       }
       TGLUtil::RenderPolyMarkers(rTP.RefPMAtt(), pnts, n,
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackProjected.cxx root/graf3d/eve/src/TEveTrackProjected.cxx
--- root-old/graf3d/eve/src/TEveTrackProjected.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTrackProjected.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -12,6 +12,7 @@
 #include "TEveTrackProjected.h"
 #include "TEveTrackPropagator.h"
 #include "TEveProjectionManager.h"
+#include "TEveTrans.h"
 
 //==============================================================================
 //==============================================================================
@@ -26,9 +27,8 @@
 
 //______________________________________________________________________________
 TEveTrackProjected::TEveTrackProjected() :
-   TEveTrack  (),
-   fOrigPnts  (0),
-   fProjection(0)
+   TEveTrack (),
+   fOrigPnts (0)
 {
    // Default constructor.
 }
@@ -41,12 +41,10 @@
    // This is virtual method from base-class TEveProjected.
 
    TEveProjected::SetProjection(mng, model);
-   TEveTrack* origTrack = dynamic_cast<TEveTrack*>(fProjectable);
 
-   SetTrackParams(*origTrack);
-   SetPathMarks  (*origTrack);
-
-   SetLockPoints(origTrack->GetLockPoints());
+   TEveTrack* otrack = dynamic_cast<TEveTrack*>(fProjectable);
+   SetTrackParams(*otrack);
+   SetLockPoints(otrack->GetLockPoints());
 }
 
 /******************************************************************************/
@@ -61,9 +59,14 @@
    Int_t    n = Size();
    Float_t *p = GetP() + 2;
    for (Int_t i = 0; i < n; ++i, p+=3)
+   {
       *p = fDepth;
+   }
 
-   // !!!! Missing path-marks move. But they are not projected anyway
+   for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
+   {
+      pm->fV.fZ = fDepth;
+   }
 }
 
 //______________________________________________________________________________
@@ -71,7 +74,6 @@
 {
    // Virtual method from base-class TEveProjected.
 
-   fProjection = fManager->GetProjection();
    MakeTrack(kFALSE); // TEveProjectionManager makes recursive calls
 }
 
@@ -81,15 +83,17 @@
 {
    // With bisection calculate break-point vertex.
 
+   TEveProjection *projection = fManager->GetProjection();
+
    TEveVector vL = fOrigPnts[idx];
    TEveVector vR = fOrigPnts[idx+1];
    TEveVector vM, vLP, vMP;
    while ((vL-vR).Mag() > 0.01)
    {
       vM.Mult(vL+vR, 0.5f);
-      vLP.Set(vL); fProjection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
-      vMP.Set(vM); fProjection->ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
-      if (fProjection->AcceptSegment(vLP, vMP, 0.0f))
+      vLP.Set(vL); projection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
+      vMP.Set(vM); projection->ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
+      if (projection->AcceptSegment(vLP, vMP, 0.0f))
       {
          vL.Set(vM);
       }
@@ -104,7 +108,7 @@
    } else {
       x = vR.fX; y = vR.fY; z = vR.fZ;
    }
-   fProjection->ProjectPoint(x, y, z, fDepth);
+   projection->ProjectPoint(x, y, z, fDepth);
 }
 
 //______________________________________________________________________________
@@ -115,6 +119,8 @@
    // For example, rho-z projection separates upper and lower hemisphere
    // and tracks break into two lines when crossing the y=0 plane.
 
+   TEveProjection *projection = fManager->GetProjection();
+
    Int_t val = fLastPoint;
 
    TEveVector v1, v2;
@@ -125,7 +131,7 @@
       {
          GetPoint(i,   v1.fX, v1.fY, v1.fZ);
          GetPoint(i+1, v2.fX, v2.fY, v2.fZ);
-         if(fProjection->AcceptSegment(v1, v2, fPropagator->GetDelta()) == kFALSE)
+         if(projection->AcceptSegment(v1, v2, fPropagator->GetDelta()) == kFALSE)
          {
             val = i;
             break;
@@ -145,11 +151,18 @@
    // Call base-class, project, find break-points and insert points
    // required for full representation.
 
+   TEveTrack      *otrack     = dynamic_cast<TEveTrack*>(fProjectable);
+   TEveTrans      *trans      = otrack->PtrMainTrans(kFALSE);
+   TEveProjection *projection = fManager->GetProjection();
+
    fBreakPoints.clear();
 
-   if (GetLockPoints())
+   fPathMarks.clear();
+   SetPathMarks(*otrack);
+   if (GetLockPoints() || otrack->Size() > 0)
    {
-      ClonePoints(*dynamic_cast<TEveTrack*>(fProjectable));
+      ClonePoints(*otrack);
+      fLastPMIdx = otrack->GetLastPMIdx();
    }
    else
    {
@@ -158,15 +171,16 @@
    if (Size() == 0) return; // All points can be outside of MaxR / MaxZ limits.
 
    // Break segments additionally if required by the projection.
-   ReduceSegmentLengths(fProjection->GetMaxTrackStep());
+   ReduceSegmentLengths(projection->GetMaxTrackStep());
 
    // Project points, store originals (needed for break-points).
    Float_t *p = GetP();
    fOrigPnts  = new TEveVector[Size()];
    for (Int_t i = 0; i < Size(); ++i, p+=3)
    {
+      if (trans) trans->MultiplyIP(p);
       fOrigPnts[i].Set(p);
-      fProjection->ProjectPoint(p[0], p[1], p[2], fDepth);
+      projection->ProjectPointfv(p, fDepth);
    }
 
    Float_t x, y, z;
@@ -201,8 +215,16 @@
 
    Reset((Int_t)vvec.size());
    for (std::vector<TEveVector>::iterator i=vvec.begin(); i!=vvec.end(); ++i)
+   {
       SetNextPoint((*i).fX, (*i).fY, (*i).fZ);
+   }
    delete [] fOrigPnts;
+
+   // Project path-marks
+   for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
+   {
+      projection->ProjectVector(trans, pm->fV, fDepth);
+   }
 }
 
 /******************************************************************************/
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackProjectedGL.cxx root/graf3d/eve/src/TEveTrackProjectedGL.cxx
--- root-old/graf3d/eve/src/TEveTrackProjectedGL.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTrackProjectedGL.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -88,55 +88,5 @@
                                  rnrCtx.Selection());
    }
 
-   // path-marks
-   const TEveTrack::vPathMark_t& pms = fTrack->RefPathMarks();
-   TEveTrackPropagator& rTP = *fM->GetPropagator();
-   if (pms.size())
-   {
-      Float_t* pnts = new Float_t[3*pms.size()]; // maximum
-      Float_t*  pnt = pnts;
-      Int_t   pntsN = 0;
-      Bool_t accept;
-      for (TEveTrack::vPathMark_ci pm = pms.begin(); pm != pms.end(); ++pm)
-      {
-         accept = kFALSE;
-         switch (pm->fType)
-         {
-            case TEvePathMark::kDaughter:
-               if (rTP.GetRnrDaughters())  accept = kTRUE;
-               break;
-            case TEvePathMark::kReference:
-               if (rTP.GetRnrReferences()) accept = kTRUE;
-               break;
-            case TEvePathMark::kDecay:
-               if (rTP.GetRnrDecay())      accept = kTRUE;
-               break;
-            case TEvePathMark::kCluster2D:
-               if (rTP.GetRnrCluster2Ds()) accept = kTRUE;
-               break;
-         }
-         if (accept)
-         {
-            if ((TMath::Abs(pm->fV.fZ) < rTP.GetMaxZ()) && (pm->fV.Perp() < rTP.GetMaxR()))
-            {
-               pnt[0] = pm->fV.fX;
-               pnt[1] = pm->fV.fY;
-               pnt[2] = pm->fV.fZ;
-               fM->fProjection->ProjectPointfv(pnt, fM->fDepth);
-               pnt += 3;
-               ++pntsN;
-            }
-         }
-      }
-      TGLUtil::RenderPolyMarkers(rTP.RefPMAtt(), pnts, pntsN,
-                                 rnrCtx.GetPickRadius(),
-                                 rnrCtx.Selection());
-      delete [] pnts;
-   }
-
-   // fist vertex
-   if (rTP.GetRnrFV() && fTrack->GetLastPoint())
-      TGLUtil::RenderPolyMarkers(rTP.RefFVAtt(), fTrack->GetP(), 1,
-                                 rnrCtx.GetPickRadius(),
-                                 rnrCtx.Selection());
+   RenderPathMarksAndFirstVertex(rnrCtx);
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackPropagator.cxx root/graf3d/eve/src/TEveTrackPropagator.cxx
--- root-old/graf3d/eve/src/TEveTrackPropagator.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTrackPropagator.cxx	2010-04-12 19:25:26.000000000 +0200
@@ -28,17 +28,18 @@
 
 //______________________________________________________________________________
 TEveTrackPropagator::Helix_t::Helix_t() :
-   fCharge(0), fMinAng(45), fDelta(0.1),
-   fMaxStep(20.f), fCurrentStep(20.f),
+   fCharge(0),
+   fMaxAng(45), fMaxStep(20.f), fDelta(0.1),
    fPhi(0), fValid(kFALSE),
    fLam(-1), fR(-1), fPhiStep(-1), fSin(-1), fCos(-1),
+   fRKStep(20.0f),
    fPtMag(-1), fPlMag(-1), fLStep(-1)
 {
    // Default constructor.
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVector & p, const TEveVector& b)
+void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVector& p, const TEveVector& b)
 {
    // Common update code for helix and RK propagation.
 
@@ -57,7 +58,8 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b, Bool_t fullUpdate)
+void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b,
+                                               Bool_t full_update, Bool_t enforce_max_step)
 {
    // Update helix parameters.
 
@@ -67,7 +69,7 @@
    TMath::Cross(fE1.Arr(), fE2.Arr(), fE3.Arr());
    if (fCharge < 0) fE3.NegateXYZ();
 
-   if (fullUpdate)
+   if (full_update)
    {
       using namespace TMath;
       Float_t a = fgkB2C * b.Mag() * Abs(fCharge);
@@ -76,23 +78,23 @@
          fValid = kTRUE;
 
          fR   = Abs(fPtMag / a);
-         fLam = fPl.Mag() / fPtMag;
-         if (fPlMag < 0) fLam = - fLam;
+         fLam = fPlMag / fPtMag;
 
-         // get phi step, compare fMinAng with fDelta
-         fPhiStep = fMinAng * DegToRad();
-         if (fDelta < fR)
+         // get phi step, compare fMaxAng with fDelta
+         fPhiStep = fMaxAng * DegToRad();
+         if (fR > fDelta)
          {
-            Float_t ang  = 2*ACos(1 - fDelta/fR);
-            if (ang < fPhiStep) fPhiStep = ang;
+            Float_t ang  = 2.0 * ACos(1.0f - fDelta/fR);
+            if (ang < fPhiStep)
+               fPhiStep = ang;
          }
 
          // check max step size
-         fCurrentStep = fR*fPhiStep*(1 + fLam*fLam);
-         if (fCurrentStep > fMaxStep)
-            fPhiStep *= (fMaxStep/fCurrentStep);
+         Float_t curr_step = fR * fPhiStep * Sqrt(1.0f + fLam*fLam);
+         if (curr_step > fMaxStep || enforce_max_step)
+            fPhiStep *= fMaxStep / curr_step;
 
-         fLStep = fR*fPhiStep*fLam;
+         fLStep = fR * fPhiStep * fLam;
          fSin   = Sin(fPhiStep);
          fCos   = Cos(fPhiStep);
       }
@@ -188,8 +190,8 @@
    fMaxR    (350),
    fMaxZ    (450),
 
-   fNMax     (4096),
-   fMaxOrbs  (0.5),
+   fNMax    (4096),
+   fMaxOrbs (0.5),
 
    fEditPathMarks (kTRUE),
    fFitDaughters  (kTRUE),
@@ -303,10 +305,7 @@
 {
    // Propagate particle with momentum p to vertex v.
 
-   if (fStepper == kHelix)
-      fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
-   else
-      fH.UpdateRK(p, fMagFieldObj->GetField(fV));
+   Update(fV, p, kTRUE);
 
    if ((v-fV).Mag() < kStepEps)
    {
@@ -323,26 +322,49 @@
    // Propagate particle to bounds.
    // Return TRUE if hit bounds.
 
-   if (fStepper == kHelix)
-      fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
-   else
-      fH.UpdateRK(p, fMagFieldObj->GetField(fV));
+   Update(fV, p, kTRUE);
 
    fH.fValid ? LoopToBounds(p): LineToBounds(p);
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update)
+void TEveTrackPropagator::Update(const TEveVector4& v, const TEveVector& p,
+                                 Bool_t full_update, Bool_t enforce_max_step)
 {
    // Update helix / B-field projection state.
 
    if (fStepper == kHelix)
    {
-      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst() || full_update);
+      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst() || full_update, enforce_max_step);
    }
    else
    {
       fH.UpdateRK(p, fMagFieldObj->GetField(v));
+
+      if (full_update)
+      {
+         using namespace TMath;
+
+         Float_t a = fgkB2C * fMagFieldObj->GetMaxFieldMag() * Abs(fH.fCharge);
+         fH.fR = p.Mag() / a;
+
+         // get phi step, compare fDelta with MaxAng
+         fH.fPhiStep = fH.fMaxAng * DegToRad();
+         if (fH.fR > fH.fDelta )
+         {
+            Float_t ang  = 2.0 * ACos(1.0f - fH.fDelta/fH.fR);
+            if (ang < fH.fPhiStep)
+               fH.fPhiStep = ang;
+         }
+
+         // check against maximum step-size
+         fH.fRKStep = fH.fR * fH.fPhiStep * Sqrt(1 + fH.fLam*fH.fLam);
+         if (fH.fRKStep > fH.fMaxStep || enforce_max_step)
+         {
+            fH.fPhiStep *= fH.fMaxStep / fH.fRKStep;
+            fH.fRKStep   = fH.fMaxStep;
+         }
+      }
    }
 }
 
@@ -361,20 +383,21 @@
       vecRKIn[0] = v.fX;
       vecRKIn[1] = v.fY;
       vecRKIn[2] = v.fZ;
-      Float_t nm = 1/p.Mag();
+      Double_t pm = p.Mag();
+      Double_t nm = 1.0 / pm;
       vecRKIn[3] = p.fX*nm;
       vecRKIn[4] = p.fY*nm;
       vecRKIn[5] = p.fZ*nm;
       vecRKIn[6] = p.Mag();
 
       Double_t vecRKOut[7];
-      OneStepRungeKutta(fH.fCharge, fH.fMaxStep, vecRKIn, vecRKOut);
+      StepRungeKutta(fH.fRKStep, vecRKIn, vecRKOut);
 
       vOut.fX = vecRKOut[0];
       vOut.fY = vecRKOut[1];
       vOut.fZ = vecRKOut[2];
-      vOut.fT = v.fT + fH.fMaxStep;
-      Double_t pm = vecRKOut[6];
+      vOut.fT = v.fT + fH.fRKStep;
+      pm = vecRKOut[6];
       pOut.fX = vecRKOut[3]*pm;
       pOut.fY = vecRKOut[4]*pm;
       pOut.fZ = vecRKOut[5]*pm;
@@ -385,6 +408,7 @@
 void TEveTrackPropagator::LoopToBounds(TEveVector& p)
 {
    // Propagate charged particle with momentum p to bounds.
+   // It is expected that Update() with full-update was called before.
 
    const Float_t maxRsq = fMaxR*fMaxR;
 
@@ -397,7 +421,6 @@
 
    while (fH.fPhi < maxPhi && np<fNMax)
    {
-      Update(currV, p);
       Step(currV, p, forwV, forwP);
 
       // cross R
@@ -406,10 +429,8 @@
          Float_t t = (fMaxR - currV.R()) / (forwV.R() - currV.R());
          if (t < 0 || t > 1)
          {
-            Warning("TEveTrackPropagator::HelixToBounds",
-                    "In MaxR crossing expected t>=0 && t<=1: t=%f, r1=%f, r2=%f, MaxR=%f.",
+            Warning("HelixToBounds", "In MaxR crossing expected t>=0 && t<=1: t=%f, r1=%f, r2=%f, MaxR=%f.",
                     t, currV.R(), forwV.R(), fMaxR);
-
             return;
          }
          TEveVector d(forwV);
@@ -426,8 +447,7 @@
          Float_t t = (fMaxZ - TMath::Abs(currV.fZ)) / TMath::Abs((forwV.fZ - currV.fZ));
          if (t < 0 || t > 1)
          {
-            Warning("TEveTrackPropagator::HelixToBounds",
-                    "In MaxZ crossing expected t>=0 && t<=1: t=%f, z1=%f, z2=%f, MaxZ=%f.",
+            Warning("HelixToBounds", "In MaxZ crossing expected t>=0 && t<=1: t=%f, z1=%f, z2=%f, MaxZ=%f.",
                     t, currV.fZ, forwV.fZ, fMaxZ);
             return;
          }
@@ -439,9 +459,11 @@
       }
 
       currV = forwV;
-      p =  forwP;
+      p     = forwP;
+      Update(currV, p);
+
       fPoints.push_back(currV);
-      np++;
+      ++np;
    }
 }
 
@@ -449,6 +471,7 @@
 Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
 {
    // Propagate charged particle with momentum p to vertex v.
+   // It is expected that Update() with full-update was called before.
 
    const Float_t maxRsq = fMaxR * fMaxR;
 
@@ -461,7 +484,6 @@
 
    Float_t prod0=0, prod1;
 
-   Update(currV, p);
    do
    {
       Step(currV, p, forwV, forwP);
@@ -497,18 +519,16 @@
          if (step_frac > 0)
          {
             // Step for fraction of previous step size.
-            // !!! This does not work well for helix stepper - need a way to
-            // !!! enforce it.
-            // !! Maybe special Update() method, taking fraction as argument.
-            Float_t origMaxStep = fH.fMaxStep;
+            // We pass 'enforce_max_step' flag to Update().
+            Float_t orig_max_step = fH.fMaxStep;
             fH.fMaxStep *= step_frac;
-            Update(currV, p, kTRUE);
+            Update(currV, p, kTRUE, kTRUE);
             Step(currV, p, forwV, forwP);
             p     = forwP;
             currV = forwV;
             fPoints.push_back(currV);
             ++np;
-            fH.fMaxStep = origMaxStep;
+            fH.fMaxStep = orig_max_step;
          }
 
          // Distribute offset to desired crossing point over all segment.
@@ -575,29 +595,27 @@
    Float_t tZ = 0, tR = 0, tB = 0;
 
    // time where particle intersect +/- fMaxZ
-   if (p.fZ > 0) {
-      tZ = (fMaxZ - fV.fZ)/p.fZ;
-   }
-   else  if (p.fZ < 0 ) {
-      tZ = (-1)*(fMaxZ + fV.fZ)/p.fZ;
-   }
+   if (p.fZ > 0)
+      tZ = (fMaxZ - fV.fZ) / p.fZ;
+   else if (p.fZ < 0)
+      tZ = - (fMaxZ + fV.fZ) / p.fZ;
 
    // time where particle intersects cylinder
    Double_t a = p.fX*p.fX + p.fY*p.fY;
-   Double_t b = 2*(fV.fX*p.fX + fV.fY*p.fY);
+   Double_t b = 2.0 * (fV.fX*p.fX + fV.fY*p.fY);
    Double_t c = fV.fX*fV.fX + fV.fY*fV.fY - fMaxR*fMaxR;
-   Double_t d = b*b - 4*a*c;
+   Double_t d = b*b - 4.0*a*c;
    if (d >= 0) {
-      Double_t sqrtD=TMath::Sqrt(d);
-      tR = ( -b - sqrtD )/(2*a);
+      Double_t sqrtD = TMath::Sqrt(d);
+      tR = (-b - sqrtD) / (2.0 * a);
       if (tR < 0) {
-         tR = ( -b + sqrtD )/(2*a);
+         tR = (-b + sqrtD) / (2.0 * a);
       }
       tB = tR < tZ ? tR : tZ; // compare the two times
    } else {
       tB = tZ;
    }
-   TEveVector nv(fV.fX + p.fX*tB, fV.fY + p.fY*tB, fV.fZ+ p.fZ*tB);
+   TEveVector nv(fV.fX + p.fX*tB, fV.fY + p.fY*tB, fV.fZ + p.fZ*tB);
    LineToVertex(nv);
 }
 
@@ -613,7 +631,7 @@
    TEveVector pos(fV);
    TEveVector mom(p);
    if (fMagFieldObj->IsConst())
-      fH.UpdateHelix(mom, fMagFieldObj->GetField(pos), kFALSE);
+      fH.UpdateHelix(mom, fMagFieldObj->GetField(pos), kFALSE, kFALSE);
 
    TEveVector n(normal);
    TEveVector delta = pos - point;
@@ -634,7 +652,7 @@
       if (new_d < d)
       {
          // We are going further away ... fail intersect.
-         Warning("TEveTrackPropagator::HelixIntersectPlane", "going away from the plane.");
+         Warning("HelixIntersectPlane", "going away from the plane.");
          return kFALSE;
       }
       if (new_d > 0)
@@ -788,9 +806,37 @@
 //______________________________________________________________________________
 void TEveTrackPropagator::SetMinAng(Float_t x)
 {
-   // Set minimum step angle and rebuild tracks.
+   // Set maximum step angle and rebuild tracks.
+   // WARNING -- this method / variable was mis-named.
+
+   Warning("SetMinAng", "This method was mis-named, use SetMaxAng() instead!");
+   SetMaxAng(x);
+}
+//______________________________________________________________________________
+Float_t TEveTrackPropagator::GetMinAng() const
+{
+   // Get maximum step angle.
+   // WARNING -- this method / variable was mis-named.
+
+   Warning("GetMinAng", "This method was mis-named, use GetMaxAng() instead!");
+   return GetMaxAng();
+}
 
-   fH.fMinAng = x;
+//______________________________________________________________________________
+void TEveTrackPropagator::SetMaxAng(Float_t x)
+{
+   // Set maximum step angle and rebuild tracks.
+
+   fH.fMaxAng = x;
+   RebuildTracks();
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::SetMaxStep(Float_t x)
+{
+   // Set maximum step-size and rebuild tracks.
+
+   fH.fMaxStep = x;
    RebuildTracks();
 }
 
@@ -876,19 +922,9 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMaxStep(Float_t x)
-{
-   // Set maximum radius and rebuild tracks.
-
-   fH.fMaxStep = x;
-   RebuildTracks();
-}
-
-//______________________________________________________________________________
-void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
-                                            Double_t* vect, Double_t* vout)
+void TEveTrackPropagator::StepRungeKutta(Double_t step,
+                                         Double_t* vect, Double_t* vout)
 {
-
   // Wrapper to step with method RungeKutta.
 
   ///	******************************************************************
@@ -957,9 +993,9 @@
   for(Int_t j = 0; j < 7; j++)
     vout[j] = vect[j];
 
-  Double_t pinv   = kec * charge / vect[6];
-  Double_t tl = 0.;
-  Double_t h = step;
+  Double_t pinv   = kec * fH.fCharge / vect[6];
+  Double_t tl     = 0.;
+  Double_t h      = step;
   Double_t rest;
 
   do {
@@ -1089,7 +1125,12 @@
     vout[5] = cba*c;
     rest = step - tl;
     if (step < 0.) rest = -rest;
-    if (rest < 1.e-5*TMath::Abs(step)) return;
+    if (rest < 1.e-5*TMath::Abs(step))
+    {
+       Float_t dot = (vout[3]*vect[3] + vout[4]*vect[4] + vout[5]*vect[5]);
+       fH.fPhi += TMath::ACos(dot);
+       return;
+    }
 
   } while(1);
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackPropagatorEditor.cxx root/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
--- root-old/graf3d/eve/src/TEveTrackPropagatorEditor.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTrackPropagatorEditor.cxx	2010-04-12 19:25:26.000000000 +0200
@@ -43,7 +43,7 @@
    fMaxR(0),
    fMaxZ(0),
    fMaxOrbits(0),
-   fMinAng(0),
+   fMaxAng(0),
    fDelta(0),
 
    fRnrFV(0),
@@ -94,14 +94,14 @@
    fMaxOrbits->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMaxOrbits()");
    AddFrame(fMaxOrbits, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
 
-   fMinAng = new TEveGValuator(this, "Angle:", 90, 0);
-   fMinAng->SetLabelWidth(labelW);
-   fMinAng->SetNELength(6);
-   fMinAng->Build();
-   fMinAng->SetLimits(1, 160, 81, TGNumberFormat::kNESRealOne);
-   fMinAng->SetToolTip("Minimal angular step between two helix points.");
-   fMinAng->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMinAng()");
-   AddFrame(fMinAng, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
+   fMaxAng = new TEveGValuator(this, "Angle:", 90, 0);
+   fMaxAng->SetLabelWidth(labelW);
+   fMaxAng->SetNELength(6);
+   fMaxAng->Build();
+   fMaxAng->SetLimits(1, 160, 81, TGNumberFormat::kNESRealOne);
+   fMaxAng->SetToolTip("Maximal angular step between two helix points.");
+   fMaxAng->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMaxAng()");
+   AddFrame(fMaxAng, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
 
    fDelta = new TEveGValuator(this, "Delta:", 90, 0);
    fDelta->SetLabelWidth(labelW);
@@ -215,7 +215,7 @@
    fMaxR->SetValue(fM->fMaxR);
    fMaxZ->SetValue(fM->fMaxZ);
    fMaxOrbits->SetValue(fM->fMaxOrbs);
-   fMinAng->SetValue(fM->GetMinAng());
+   fMaxAng->SetValue(fM->GetMaxAng());
    fDelta->SetValue(fM->GetDelta());
 
    if(fM->fEditPathMarks)
@@ -282,11 +282,11 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagatorSubEditor::DoMinAng()
+void TEveTrackPropagatorSubEditor::DoMaxAng()
 {
-   // Slot for MinAng.
+   // Slot for MaxAng.
 
-   fM->SetMinAng(fMinAng->GetValue());
+   fM->SetMaxAng(fMaxAng->GetValue());
    Changed();
 }
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrans.cxx root/graf3d/eve/src/TEveTrans.cxx
--- root-old/graf3d/eve/src/TEveTrans.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTrans.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -15,8 +15,9 @@
 #include "TMath.h"
 #include "TClass.h"
 
-#include <ctype.h>
-#include <iostream>
+#include "Riostream.h"
+
+#include <cctype>
 
 #define F00  0
 #define F01  4
@@ -831,15 +832,15 @@
 }
 
 //______________________________________________________________________________
-void TEveTrans::RotateIP(TEveVector& v) const
+void TEveTrans::RotateIP(Float_t* v) const
 {
    // Rotate vector in-place. Translation is NOT applied.
 
-   Double_t t[3] = { v.fX, v.fY, v.fZ };
+   Double_t t[3] = { v[0], v[1], v[2] };
 
-   v.Set(fM[F00]*t[0] + fM[F01]*t[1] + fM[F02]*t[2],
-         fM[F10]*t[0] + fM[F11]*t[1] + fM[F12]*t[2],
-         fM[F20]*t[0] + fM[F21]*t[1] + fM[F22]*t[2]);
+   v[0] = fM[F00]*t[0] + fM[F01]*t[1] + fM[F02]*t[2];
+   v[1] = fM[F10]*t[0] + fM[F11]*t[1] + fM[F12]*t[2];
+   v[2] = fM[F20]*t[0] + fM[F21]*t[1] + fM[F22]*t[2];
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTriangleSet.cxx root/graf3d/eve/src/TEveTriangleSet.cxx
--- root-old/graf3d/eve/src/TEveTriangleSet.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveTriangleSet.cxx	2010-04-12 19:25:07.000000000 +0200
@@ -16,10 +16,7 @@
 #include "TMath.h"
 #include "TVector3.h"
 #include "TRandom3.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
+
 
 //______________________________________________________________________________
 //
@@ -35,11 +32,9 @@
 
 //______________________________________________________________________________
 TEveTriangleSet::TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms, Bool_t cols) :
-   TEveElement(fColor),
-   TNamed("TEveTriangleSet", 0),
+   TEveElementList("TEveTriangleSet", "", kTRUE),
    fNVerts  (nv), fVerts(0),
-   fNTrings (nt), fTrings(0), fTringNorms(0), fTringCols(0),
-   fColor   (2),  fTransp(0)
+   fNTrings (nt), fTrings(0), fTringNorms(0), fTringCols(0)
 {
    // Constructor.
 
@@ -146,26 +141,11 @@
 }
 
 //______________________________________________________________________________
-void TEveTriangleSet::Paint(Option_t* )
+void TEveTriangleSet::Paint(Option_t*)
 {
-   // Paint the object.
-
-   TBuffer3D buffer(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buffer.fID           = this;
-   buffer.fColor        = GetMainColor();
-   buffer.fTransparency = GetMainTransparency();
-   RefMainTrans().SetBuffer3D(buffer);
-   buffer.SetSectionsValid(TBuffer3D::kCore);
-
-   // We fill kCore on first pass and try with viewer
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buffer);
-   if (reqSections == TBuffer3D::kNone) {
-      return;
-   }
+   // Paint this object. Only direct rendering is supported.
 
-   Error("TEveTriangleSet::Paint", "only direct OpenGL rendering supported.");
+   PaintStandard(this);
 }
 
 /******************************************************************************/
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveUtil.cxx root/graf3d/eve/src/TEveUtil.cxx
--- root-old/graf3d/eve/src/TEveUtil.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveUtil.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -28,9 +28,10 @@
 #include "TGClient.h"
 #include "TGMimeTypes.h"
 
+#include "Riostream.h"
+
 #include <list>
 #include <algorithm>
-#include <iostream>
 #include <string>
 
 //==============================================================================
@@ -110,6 +111,7 @@
    TEveElement::fgListTreeIcons[5] = gClient->GetPicture("eve_text.gif");
    TEveElement::fgListTreeIcons[6] = gClient->GetPicture("eve_axes.xpm");
    TEveElement::fgListTreeIcons[7] = gClient->GetPicture("ofolder_t.xpm");
+   TEveElement::fgListTreeIcons[8] = gClient->GetPicture("eve_line.xpm");
 
    gClient->GetMimeTypeList()->AddType("root/tmacro", "TEveMacro",
                                        "tmacro_s.xpm", "tmacro_t.xpm", "");
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveVector.cxx root/graf3d/eve/src/TEveVector.cxx
--- root-old/graf3d/eve/src/TEveVector.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveVector.cxx	2010-04-12 19:25:20.000000000 +0200
@@ -135,6 +135,62 @@
 
 
 //==============================================================================
+// TEvePoint
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Float two-vector.
+
+ClassImp(TEvePoint);
+
+//______________________________________________________________________________
+void TEvePoint::Normalize(Float_t length)
+{
+   // Normalize the vector to length if current length is non-zero.
+
+   Float_t m = Mag();
+   if (m != 0)
+   {
+      m = length / m;
+      fX *= m; fY *= m;
+   }
+}
+
+//______________________________________________________________________________
+TEvePoint TEvePoint::operator + (const TEvePoint & b) const
+{
+   // Vector addition.
+
+   return TEvePoint(fX + b.fX, fY + b.fY);
+}
+
+//______________________________________________________________________________
+TEvePoint TEvePoint::operator - (const TEvePoint & b) const
+{
+   // Vector subtraction.
+
+   return TEvePoint(fX - b.fX, fY - b.fY);
+}
+
+//______________________________________________________________________________
+TEvePoint TEvePoint::operator * (Float_t a) const
+{
+   // Multiplication with scalar.
+
+   return TEvePoint(a*fX, a*fY);
+}
+
+//______________________________________________________________________________
+void TEvePoint::Dump() const
+{
+   // Dump to stdout as "(x, y)\n".
+
+   printf("(%f, %f)\n", fX, fY);
+}
+
+
+//==============================================================================
 // TEvePathMark
 //==============================================================================
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveViewer.cxx root/graf3d/eve/src/TEveViewer.cxx
--- root-old/graf3d/eve/src/TEveViewer.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveViewer.cxx	2010-04-12 19:24:56.000000000 +0200
@@ -91,14 +91,8 @@
    // Initialize static data-members according to running conditions.
 
    // Determine if display is running on a mac.
-   // This is also works for ssh connection mac->linux.
-#ifndef WIN32
-   TString s = gSystem->GetFromPipe("xdpyinfo");
-   if (s.Index("Apple-WM") != kNPOS)
-   {
-      fgRecreateGlOnDockOps = kTRUE;
-   }
-#endif
+   // This also works for ssh connection mac->linux.
+   fgRecreateGlOnDockOps = (gVirtualX->SupportsExtension("Apple-WM") == 1);
 
    fgInitInternal = kTRUE;
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveWindow.cxx root/graf3d/eve/src/TEveWindow.cxx
--- root-old/graf3d/eve/src/TEveWindow.cxx	2010-04-12 19:15:43.000000000 +0200
+++ root/graf3d/eve/src/TEveWindow.cxx	2010-04-12 19:24:30.000000000 +0200
@@ -37,7 +37,7 @@
 //==============================================================================
 
 //______________________________________________________________________________
-// 
+//
 // Abstract base-class for frame-slots that encompass EVE-windows
 // (sub-classes of TEveWindow).
 //
@@ -683,7 +683,7 @@
 // Abstract base-class for representing eve-windows.
 // Sub-classes define a particular GUI frame that gets show
 // in the window.
-// 
+//
 
 ClassImp(TEveWindow);
 
@@ -1111,6 +1111,72 @@
    f1->Layout(); f2->Layout();
 }
 
+//==============================================================================
+
+//______________________________________________________________________________
+UInt_t TEveWindow::GetMainFrameDefWidth()
+{
+   // Get default width for new main-frame windows. Static.
+
+   return fgMainFrameDefWidth;
+}
+
+//______________________________________________________________________________
+UInt_t TEveWindow::GetMainFrameDefHeight()
+{
+   // Get default heigth for new main-frame windows. Static.
+
+   return fgMainFrameDefHeight;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetMainFrameDefWidth (UInt_t x)
+{
+   // Set default width for new main-frame windows. Static.
+
+   fgMainFrameDefWidth  = x;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetMainFrameDefHeight(UInt_t x)
+{
+   // Set default height for new main-frame windows. Static.
+
+   fgMainFrameDefHeight = x;
+}
+
+//______________________________________________________________________________
+Pixel_t TEveWindow::GetCurrentBackgroundColor()
+{
+   // Get background-color for marking the title-bar of current window. Static.
+
+   return fgCurrentBackgroundColor;
+}
+
+//______________________________________________________________________________
+Pixel_t TEveWindow::GetMiniBarBackgroundColor()
+{
+   // Get background-color for mini-bar (collapsed title-bar). Static.
+
+   return fgMiniBarBackgroundColor;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetCurrentBackgroundColor(Pixel_t p)
+{
+   // Set background-color for marking the title-bar of current window. Static.
+
+   fgCurrentBackgroundColor = p;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetMiniBarBackgroundColor(Pixel_t p)
+{
+   // Set background-color for mini-bar (collapsed title-bar). Static.
+
+   fgMiniBarBackgroundColor = p;
+}
+
 
 //==============================================================================
 // TEveWindowSlot
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/inc/FTFont.h root/graf3d/ftgl/inc/FTFont.h
--- root-old/graf3d/ftgl/inc/FTFont.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/inc/FTFont.h	2010-04-12 19:25:52.000000000 +0200
@@ -195,6 +195,16 @@
          */
         float Advance( const char* string);
 
+	/**
+         * Prepare for rendering
+         */
+        virtual void PreRender() { preRenderCalled = true; }
+
+	/**
+         * Cleanup after rendering
+         */
+        virtual void PostRender() { preRenderCalled = false; }
+
         /**
          * Render a string of characters
          * 
@@ -205,6 +215,15 @@
         /**
          * Render a string of characters
          * 
+         * @param string    'C' style string to be output.   
+	 * @param w_max     maximum width of text
+	 * @param w_fade    width at which text starts to fade
+         */
+        virtual void Render( const char* string, float w_max, float w_fade );
+
+        /**
+         * Render a string of characters
+         * 
          * @param string    wchar_t string to be output.     
          */
         virtual void Render( const wchar_t* string );
@@ -260,6 +279,13 @@
         inline bool CheckGlyph( const unsigned int chr);
 
         /**
+         * PreRender() was called from outside. Do not call it again
+         * from Render(), nor call PostRender().
+         * User has to call it himself.
+         */
+        bool preRenderCalled;
+
+        /**
          * An object that holds a list of glyphs
          */
         FTGlyphContainer* glyphList;
@@ -268,7 +294,6 @@
          * Current pen or cursor position;
          */
         FTPoint pen;
-        
 };
 
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/inc/FTGLBitmapFont.h root/graf3d/ftgl/inc/FTGLBitmapFont.h
--- root-old/graf3d/ftgl/inc/FTGLBitmapFont.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/inc/FTGLBitmapFont.h	2010-04-12 19:25:52.000000000 +0200
@@ -36,22 +36,16 @@
          */
         ~FTGLBitmapFont();
         
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        void Render( const char* string);
+        virtual void PreRender();
 
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style wide string to be output.  
+	/**
+         * Cleanup after rendering
          */
-        void Render( const wchar_t* string);
+        virtual void PostRender();
 
-        // attributes
-        
     private:
         /**
          * Construct a FTBitmapGlyph.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/inc/FTGLOutlineFont.h root/graf3d/ftgl/inc/FTGLOutlineFont.h
--- root-old/graf3d/ftgl/inc/FTGLOutlineFont.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/inc/FTGLOutlineFont.h	2010-04-12 19:25:52.000000000 +0200
@@ -37,19 +37,15 @@
          */
         ~FTGLOutlineFont();
         
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        void Render( const char* string);
-        
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    wchar_t string to be output.     
+        virtual void PreRender();
+
+	/**
+         * Cleanup after rendering
          */
-        void Render( const wchar_t* string);
+        virtual void PostRender();
 
     private:
         /**
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/inc/FTGLPixmapFont.h root/graf3d/ftgl/inc/FTGLPixmapFont.h
--- root-old/graf3d/ftgl/inc/FTGLPixmapFont.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/inc/FTGLPixmapFont.h	2010-04-12 19:25:52.000000000 +0200
@@ -38,19 +38,15 @@
          */
         ~FTGLPixmapFont();
         
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        void Render( const char* string);
-        
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    wchar_t string to be output.     
+        virtual void PreRender();
+
+	/**
+         * Cleanup after rendering
          */
-        void Render( const wchar_t* string);
+        virtual void PostRender();
 
     private:
         /**
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/inc/FTGLTextureFont.h root/graf3d/ftgl/inc/FTGLTextureFont.h
--- root-old/graf3d/ftgl/inc/FTGLTextureFont.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/inc/FTGLTextureFont.h	2010-04-12 19:25:52.000000000 +0200
@@ -46,20 +46,15 @@
          */
         virtual bool FaceSize( const unsigned int size, const unsigned int res = 72);
 
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        virtual void Render( const char* string);
-        
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    wchar_t string to be output.     
-         */
-        virtual void Render( const wchar_t* string);
+        virtual void PreRender();
 
+	/**
+         * Cleanup after rendering
+         */
+        virtual void PostRender();
         
     private:
         /**
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/src/FTFont.cxx root/graf3d/ftgl/src/FTFont.cxx
--- root-old/graf3d/ftgl/src/FTFont.cxx	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/src/FTFont.cxx	2010-04-12 19:25:51.000000000 +0200
@@ -7,6 +7,7 @@
 FTFont::FTFont( const char* fontFilePath)
 :   face( fontFilePath),
     useDisplayLists(true),
+    preRenderCalled(false),
     glyphList(0)
 {
     err = face.Error();
@@ -244,6 +245,35 @@
 
 void FTFont::Render( const char* string )
 {
+    bool pre_post = ! preRenderCalled;
+    if (pre_post) PreRender();
+
+    const unsigned char* c = (unsigned char*)string;
+    pen.X(0); pen.Y(0);
+
+    while( *c)
+    {
+        if(CheckGlyph( *c))
+        {
+            pen = glyphList->Render( *c, *(c + 1), pen);
+        }
+        ++c;
+    }
+
+    if (pre_post) PostRender();
+}
+
+
+void FTFont::Render( const char* string, float w_max, float w_fade )
+{
+    bool pre_post = ! preRenderCalled;
+    if (pre_post) PreRender();
+
+    float col[4];
+    glGetFloatv(GL_CURRENT_COLOR, col);
+    float alpha_fac = col[3] / (w_max - w_fade);
+    float w = 0;
+
     const unsigned char* c = (unsigned char*)string;
     pen.X(0); pen.Y(0);
 
@@ -252,14 +282,27 @@
         if(CheckGlyph( *c))
         {
             pen = glyphList->Render( *c, *(c + 1), pen);
+            w += pen.X();
+	    if(w > w_max)
+	        break;
+	    if(w > w_fade)
+	    {
+	        col[3] = alpha_fac * (w_max - w);
+	        glColor4fv(col);
+	    }
         }
         ++c;
     }
+
+    if (pre_post) PostRender();
 }
 
 
 void FTFont::Render( const wchar_t* string )
 {
+    bool pre_post = ! preRenderCalled;
+    if (pre_post) PreRender();
+
     const wchar_t* c = string;
     pen.X(0); pen.Y(0);
 
@@ -271,6 +314,8 @@
         }
         ++c;
     }
+
+    if (pre_post) PostRender();
 }
 
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/src/FTGLBitmapFont.cxx root/graf3d/ftgl/src/FTGLBitmapFont.cxx
--- root-old/graf3d/ftgl/src/FTGLBitmapFont.cxx	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/src/FTGLBitmapFont.cxx	2010-04-12 19:25:51.000000000 +0200
@@ -31,8 +31,9 @@
 }
 
 
-void FTGLBitmapFont::Render( const char* string)
-{   
+void FTGLBitmapFont::PreRender()
+{
+    FTFont::PreRender();
     glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
     glPushAttrib( GL_ENABLE_BIT);
     
@@ -40,27 +41,12 @@
     glPixelStorei( GL_UNPACK_ALIGNMENT, 1);
 
     glDisable( GL_BLEND);
-
-    FTFont::Render( string);
-
-    glPopAttrib();
-    glPopClientAttrib();
 }
 
 
-void FTGLBitmapFont::Render( const wchar_t* string)
-{   
-    glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
-    glPushAttrib( GL_ENABLE_BIT);
-    
-    glPixelStorei( GL_UNPACK_LSB_FIRST, GL_FALSE);
-    glPixelStorei( GL_UNPACK_ALIGNMENT, 1);
-    
-    glDisable( GL_BLEND);
-
-    FTFont::Render( string);
-
+void FTGLBitmapFont::PostRender()
+{
     glPopAttrib();
     glPopClientAttrib();
+    FTFont::PostRender();
 }
-
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/src/FTGLOutlineFont.cxx root/graf3d/ftgl/src/FTGLOutlineFont.cxx
--- root-old/graf3d/ftgl/src/FTGLOutlineFont.cxx	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/src/FTGLOutlineFont.cxx	2010-04-12 19:25:51.000000000 +0200
@@ -31,8 +31,9 @@
 }
 
 
-void FTGLOutlineFont::Render( const char* string)
-{   
+void FTGLOutlineFont::PreRender()
+{
+    FTFont::PreRender();
     glPushAttrib( GL_ENABLE_BIT | GL_HINT_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT);
     
     glDisable( GL_TEXTURE_2D);
@@ -41,26 +42,11 @@
     glHint( GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
     glEnable(GL_BLEND);
     glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
-
-    FTFont::Render( string);
-
-    glPopAttrib();
 }
 
 
-void FTGLOutlineFont::Render( const wchar_t* string)
-{   
-    glPushAttrib( GL_ENABLE_BIT | GL_HINT_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT);
-    
-    glDisable( GL_TEXTURE_2D);
-    
-    glEnable( GL_LINE_SMOOTH);
-    glHint( GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
-    glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
-
-    FTFont::Render( string);
-
+void FTGLOutlineFont::PostRender()
+{
     glPopAttrib();
+    FTFont::PostRender();
 }
-
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/src/FTGLPixmapFont.cxx root/graf3d/ftgl/src/FTGLPixmapFont.cxx
--- root-old/graf3d/ftgl/src/FTGLPixmapFont.cxx	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/src/FTGLPixmapFont.cxx	2010-04-12 19:25:51.000000000 +0200
@@ -31,15 +31,18 @@
 }
 
 
-void FTGLPixmapFont::Render( const char* string)
-{   
+void FTGLPixmapFont::PreRender()
+{
+    FTFont::PreRender();
     glPushAttrib( GL_ENABLE_BIT | GL_PIXEL_MODE_BIT | GL_COLOR_BUFFER_BIT);
     glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
 
     glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glEnable(GL_ALPHA_TEST);
+    glAlphaFunc(GL_GEQUAL, 0.0625);
 
-    glDisable( GL_TEXTURE_2D);
+    glDisable(GL_TEXTURE_2D);
 
     GLfloat ftglColour[4];
     glGetFloatv( GL_CURRENT_RASTER_COLOR, ftglColour);
@@ -48,36 +51,12 @@
     glPixelTransferf(GL_GREEN_SCALE, ftglColour[1]);
     glPixelTransferf(GL_BLUE_SCALE, ftglColour[2]);
     glPixelTransferf(GL_ALPHA_SCALE, ftglColour[3]);
-
-    FTFont::Render( string);
-
-    glPopClientAttrib();
-    glPopAttrib();
 }
 
 
-void FTGLPixmapFont::Render( const wchar_t* string)
-{   
-    glPushAttrib( GL_ENABLE_BIT | GL_PIXEL_MODE_BIT | GL_COLOR_BUFFER_BIT);
-    glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
-        
-    glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    
-    glDisable( GL_TEXTURE_2D);
-
-    GLfloat ftglColour[4];
-    glGetFloatv( GL_CURRENT_RASTER_COLOR, ftglColour);
-
-    glPixelTransferf(GL_RED_SCALE, ftglColour[0]);
-    glPixelTransferf(GL_GREEN_SCALE, ftglColour[1]);
-    glPixelTransferf(GL_BLUE_SCALE, ftglColour[2]);
-    glPixelTransferf(GL_ALPHA_SCALE, ftglColour[3]);
-
-    FTFont::Render( string);
-
+void FTGLPixmapFont::PostRender()
+{
     glPopClientAttrib();
     glPopAttrib();
+    FTFont::PostRender();
 }
-
-
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/ftgl/src/FTGLTextureFont.cxx root/graf3d/ftgl/src/FTGLTextureFont.cxx
--- root-old/graf3d/ftgl/src/FTGLTextureFont.cxx	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/ftgl/src/FTGLTextureFont.cxx	2010-04-12 19:25:51.000000000 +0200
@@ -151,32 +151,22 @@
 }
 
 
-void FTGLTextureFont::Render( const char* string)
-{   
+void FTGLTextureFont::PreRender()
+{
+    FTFont::PreRender();
     glPushAttrib( GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT);
     
     glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
+    glEnable(GL_ALPHA_TEST);
+    glAlphaFunc(GL_GEQUAL, 0.0625);
 
     FTTextureGlyph::ResetActiveTexture();
-    
-    FTFont::Render( string);
-
-    glPopAttrib();
 }
 
 
-void FTGLTextureFont::Render( const wchar_t* string)
-{   
-    glPushAttrib( GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT);
-    
-    glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
-    
-    FTTextureGlyph::ResetActiveTexture();
-    
-    FTFont::Render( string);
-    
+void FTGLTextureFont::PostRender()
+{
     glPopAttrib();
+    FTFont::PostRender();
 }
-
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLAnnotation.h root/graf3d/gl/inc/TGLAnnotation.h
--- root-old/graf3d/gl/inc/TGLAnnotation.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLAnnotation.h	2010-04-12 19:25:31.000000000 +0200
@@ -28,16 +28,22 @@
    TGLAnnotation(const TGLAnnotation&);            // Not implemented
    TGLAnnotation& operator=(const TGLAnnotation&); // Not implemented
 
-   void MakeEditor();
+protected:
+   enum EDrag        { kMove, kResize, kNone };
+   enum ENameStack   { kMoveID, kEditID, kDeleteID, kResizeID };
 
+   void MakeEditor();
+   Char_t GetLineTransparency() const;
 
    Float_t           fPosX;           // x position [0, 1]
    Float_t           fPosY;           // y position [0, 1]
+   Float_t           fWidth;
+   Float_t           fHeight;
 
    Int_t             fMouseX, fMouseY; //! last mouse position
-   Bool_t            fInDrag;          //!
-   Float_t           fDrawW, fDrawH;   //! width/height of drawn annotation
-   Float_t           fDrawY;           //! y-position of annotation box
+   EDrag             fDrag;            //!
+   Float_t           fDrawW,  fDrawH;  //! width and height when drawing
+   Float_t           fTextSizeDrag;    //! text-size at start of drag
 
    TGLVector3        fPointer;         // picked location in 3D space
    Bool_t            fActive;          // active item identifier
@@ -48,7 +54,6 @@
    static Color_t    fgBackColor;
    static Color_t    fgTextColor;
 
-protected:
    TGLViewer        *fParent;
 
    TString           fText;           // annotation text
@@ -63,22 +68,25 @@
 
    Bool_t            fDrawRefLine;    // draw 3D refrence line
    Bool_t            fUseColorSet;    // use color set from rnrCtx
+   Bool_t            fAllowClose;     // allow closing via 'X' button
 
 public:
    TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy);
    TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref);
    virtual ~TGLAnnotation();
 
-   void SetTransparency(Char_t x) { fTransparency = x;}
-   Char_t GetTransparency() const { return fTransparency;}
+   void SetTransparency(Char_t x) { fTransparency = x; }
+   Char_t GetTransparency() const { return fTransparency; }
    void SetUseColorSet(Bool_t x)  { fUseColorSet = x; }
-   Bool_t GetUseColorSet() const  { return fUseColorSet;}
-   void SetBackColor(Color_t x)   { fBackColor = x;}
-   Color_t GetBackColor() const   { return fBackColor;}
-   void SetTextColor(Color_t x)   { fTextColor = x;   }
-   Color_t GetTextColor() const   { return fTextColor;}
-   void SetTextSize(Float_t x)    { fTextSize = x;   }
-   Float_t GetTextSize() const    { return fTextSize;}
+   Bool_t GetUseColorSet() const  { return fUseColorSet; }
+   void SetBackColor(Color_t x)   { fBackColor = x; }
+   Color_t GetBackColor() const   { return fBackColor; }
+   void SetTextColor(Color_t x)   { fTextColor = x; }
+   Color_t GetTextColor() const   { return fTextColor; }
+   void SetTextSize(Float_t x)    { fTextSize = x; }
+   Float_t GetTextSize() const    { return fTextSize; }
+   void SetAllowClose(Bool_t x)   { fAllowClose = x; }
+   Bool_t GetAllowClose() const   { return fAllowClose;}
    TGLFont::ETextAlignH_e GetTextAlign() const { return fTextAlign; }
    void SetTextAlign(TGLFont::ETextAlignH_e a) { fTextAlign = a; }
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLAxisPainter.h root/graf3d/gl/inc/TGLAxisPainter.h
--- root-old/graf3d/gl/inc/TGLAxisPainter.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/gl/inc/TGLAxisPainter.h	2010-04-12 19:26:03.000000000 +0200
@@ -18,6 +18,7 @@
 class TAttAxis;
 class TAxis;
 class TH1;
+class TPMERegexp;
 class TGLRnrCtx;
 
 
@@ -75,7 +76,8 @@
    // Labels options. Allready exist in TAttAxis, but can't be set.
    TGLFont::ETextAlignH_e fLabelAlignH;
    TGLFont::ETextAlignV_e fLabelAlignV;
-   TGLVector3 fTitlePos;
+   TGLVector3  fTitlePos;
+   TPMERegexp *fAllZeroesRE;
 
 public:
    TGLAxisPainter();
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLCameraOverlay.h root/graf3d/gl/inc/TGLCameraOverlay.h
--- root-old/graf3d/gl/inc/TGLCameraOverlay.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLCameraOverlay.h	2010-04-12 19:26:05.000000000 +0200
@@ -31,8 +31,6 @@
    TGLCameraOverlay(const TGLCameraOverlay&);            // Not implemented
    TGLCameraOverlay& operator=(const TGLCameraOverlay&); // Not implemented
 
-   Double_t       fFrustum[4];
-
 protected:
    Bool_t         fShowOrthographic;
    Bool_t         fShowPerspective;
@@ -48,6 +46,9 @@
    TGLPlane       fExternalRefPlane;
    Bool_t         fUseExternalRefPlane;
 
+   Double_t       fFrustum[4];
+
+
    void    RenderPlaneIntersect(TGLRnrCtx& rnrCtx);
    void    RenderAxis(TGLRnrCtx& rnrCtx, Bool_t drawGrid);
    void    RenderGrid(TGLRnrCtx& rnrCtx);
@@ -73,6 +74,8 @@
    Bool_t   GetShowPerspective() const { return fShowPerspective; }
    void     SetShowPerspective(Bool_t x) {fShowPerspective =x;}
 
+   void     SetFrustum(TGLCamera& cam);
+
    TAttAxis* GetAttAxis();
 
    ClassDef(TGLCameraOverlay, 1); // Show coorinates of current camera frustum.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLClip.h root/graf3d/gl/inc/TGLClip.h
--- root-old/graf3d/gl/inc/TGLClip.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLClip.h	2010-04-12 19:25:05.000000000 +0200
@@ -130,11 +130,16 @@
 
 class TGLClipSet : public TGLOverlayElement
 {
+private:
+   TGLClipSet(const TGLClipSet&);            // Not implemented
+   TGLClipSet& operator=(const TGLClipSet&); // Not implemented
+
 protected:
    TGLClipPlane          *fClipPlane;
    TGLClipBox            *fClipBox;
    TGLClip               *fCurrentClip;  //! the current clipping shape
 
+   Bool_t                 fAutoUpdate;
    Bool_t                 fShowClip;
    Bool_t                 fShowManip;
    TGLManipSet           *fManip;
@@ -171,7 +176,9 @@
    EClipType GetClipType() const;
    void      SetClipType(EClipType type);
 
-   // Editor only supports combined flag so far.
+   // Clip control flags
+   Bool_t GetAutoUpdate()     const { return fAutoUpdate; }
+   void   SetAutoUpdate(Bool_t aup) { fAutoUpdate = aup;  }
    Bool_t GetShowManip()      const { return fShowManip; }
    void   SetShowManip(Bool_t show) { fShowManip = show; }
    Bool_t GetShowClip()       const { return fShowClip; }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLClipSetEditor.h root/graf3d/gl/inc/TGLClipSetEditor.h
--- root-old/graf3d/gl/inc/TGLClipSetEditor.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLClipSetEditor.h	2010-04-12 19:24:38.000000000 +0200
@@ -44,6 +44,7 @@
    TGCompositeFrame *fBoxPropFrame;
    TGNumberEntry    *fBoxProp[6];
    TGCheckButton    *fClipInside;
+   TGCheckButton    *fAutoUpdate;
    TGCheckButton    *fClipEdit;
    TGCheckButton    *fClipShow;
    TGButton         *fApplyButton;
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLLockable.h root/graf3d/gl/inc/TGLLockable.h
--- root-old/graf3d/gl/inc/TGLLockable.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLLockable.h	2010-04-12 19:25:05.000000000 +0200
@@ -31,6 +31,24 @@
    // Locking - can take/release via const handle
    mutable ELock     fLock;        // Lock state.
 
+   // Ensures unlocking in view of exceptions.
+   class TUnlocker
+   {
+   private:
+      TUnlocker(const TUnlocker&);            // Not implemented
+      TUnlocker& operator=(const TUnlocker&); // Not implemented
+
+      const TGLLockable *fLockable;
+
+   public:
+      TUnlocker(const TGLLockable* l) : fLockable(l) {}
+      ~TUnlocker()
+      {
+         if (fLockable->IsLocked())
+            fLockable->ReleaseLock(fLockable->CurrentLock());
+      }
+   };
+
 public:
    TGLLockable();
    virtual ~TGLLockable() {}
@@ -47,7 +65,7 @@
    static const char * LockName(ELock lock);
    static Bool_t       LockValid(ELock lock);
 
-   ClassDef(TGLLockable, 0) // Lock for viewers and scenes.
+   ClassDef(TGLLockable, 0); // Lock for viewers and scenes.
 }; // endclass TGLLockable
 
 #endif
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLMarchingCubes.h root/graf3d/gl/inc/TGLMarchingCubes.h
--- root-old/graf3d/gl/inc/TGLMarchingCubes.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLMarchingCubes.h	2010-04-12 19:25:23.000000000 +0200
@@ -401,7 +401,8 @@
    using DataSourceBase_t::GetH;
    using DataSourceBase_t::GetD;
    using DataSourceBase_t::GetData;
-   
+   using SplitterBase_t::SplitEdge;
+
    typedef typename DataSourceBase_t::ElementType_t ElementType_t;
 
    typedef TCell<ElementType_t>  CellType_t;
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLPadPainter.h root/graf3d/gl/inc/TGLPadPainter.h
--- root-old/graf3d/gl/inc/TGLPadPainter.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLPadPainter.h	2010-04-12 19:24:28.000000000 +0200
@@ -105,6 +105,9 @@
    void     DrawText(Double_t x, Double_t y, const char *text, ETextMode mode);
    void     DrawTextNDC(Double_t x, Double_t y, const char *text, ETextMode mode);
                      
+   //jpg, png, gif and bmp output.
+   void     SaveImage(TVirtualPad *pad, const char *fileName, Int_t type) const;
+
 private:
    
    //Attention! GL_PROJECTION will become 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLPhysicalShape.h root/graf3d/gl/inc/TGLPhysicalShape.h
--- root-old/graf3d/gl/inc/TGLPhysicalShape.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLPhysicalShape.h	2010-04-12 19:25:05.000000000 +0200
@@ -34,6 +34,10 @@
 {
    friend class TGLLogicalShape; // for replica-list management
 
+private:
+   TGLPhysicalShape(const TGLPhysicalShape&);            // Not implemented
+   TGLPhysicalShape& operator=(const TGLPhysicalShape&); // Not implemented
+
 public:
    // Flags for permitted manipulation of object
    enum EManip  { kTranslateX   = 1 << 0,
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLRnrCtx.h root/graf3d/gl/inc/TGLRnrCtx.h
--- root-old/graf3d/gl/inc/TGLRnrCtx.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/gl/inc/TGLRnrCtx.h	2010-04-12 19:25:57.000000000 +0200
@@ -94,8 +94,9 @@
 
    Short_t         fViewerLOD;
    Short_t         fSceneLOD;
-   Short_t         fCombiLOD; // Combined viewer/scene lod
-   Short_t         fShapeLOD;
+   Short_t         fCombiLOD;     // Combined viewer/scene lod.
+   Short_t         fShapeLOD;     // LOD calculated for current shape.
+   Float_t         fShapePixSize; // Only relevant when not using display lists.
 
    Short_t         fViewerStyle;
    Short_t         fSceneStyle;
@@ -172,6 +173,8 @@
    void    SetCombiLOD(Short_t LOD)    { fCombiLOD = LOD;  }
    Short_t ShapeLOD()    const         { return fShapeLOD; }
    void    SetShapeLOD(Short_t LOD)    { fShapeLOD = LOD;  }
+   Float_t ShapePixSize() const        { return fShapePixSize; }
+   void    SetShapePixSize(Float_t ps) { fShapePixSize = ps; }
 
    Short_t ViewerStyle() const         { return fViewerStyle; }
    void    SetViewerStyle(Short_t sty) { fViewerStyle = sty;  }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLSAViewer.h root/graf3d/gl/inc/TGLSAViewer.h
--- root-old/graf3d/gl/inc/TGLSAViewer.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLSAViewer.h	2010-04-12 19:25:54.000000000 +0200
@@ -67,8 +67,15 @@
    TGMenuBar         *fMenuBar;
    TGButton          *fMenuBut;
    Bool_t             fHideMenuBar;
+   TTimer            *fMenuHidingTimer;
+   Bool_t             fMenuHidingShowMenu;
+
    Bool_t             fDeleteMenuBar;
 
+   static Long_t      fgMenuHidingTimeout;
+
+   void ResetMenuHidingTimer(Bool_t show_menu);
+
    // Initial window positioning
    static const Int_t fgInitX;
    static const Int_t fgInitY;
@@ -103,6 +110,8 @@
    void   DeleteMenuBar();
    void   DisableCloseMenuEntries();
    void   EnableMenuBarHiding();
+   void   DisableMenuBarHiding();
+   void   MenuHidingTimeout();
 
    void   HandleMenuBarHiding(Event_t* ev);
 
@@ -118,6 +127,8 @@
    void ToggleOrthoRotate();
    void ToggleOrthoDolly();
 
+   static void SetMenuHidingTimeout(Long_t timeout);
+
    ClassDef(TGLSAViewer, 0); // Standalone GL viewer.
 };
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLScene.h root/graf3d/gl/inc/TGLScene.h
--- root-old/graf3d/gl/inc/TGLScene.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/gl/inc/TGLScene.h	2010-04-12 19:24:35.000000000 +0200
@@ -189,7 +189,7 @@
    // Basic physical shape management
    virtual void              AdoptPhysical(TGLPhysicalShape& shape);
    virtual Bool_t            DestroyPhysical(UInt_t phid);
-   virtual Int_t             DestroyPhysicals(Bool_t incModified, const TGLCamera* camera=0);
+   virtual Int_t             DestroyPhysicals();
    virtual TGLPhysicalShape* FindPhysical(UInt_t phid) const;
 
    virtual UInt_t            GetMaxPhysicalID();
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLSceneBase.h root/graf3d/gl/inc/TGLSceneBase.h
--- root-old/graf3d/gl/inc/TGLSceneBase.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/gl/inc/TGLSceneBase.h	2010-04-12 19:26:07.000000000 +0200
@@ -23,6 +23,7 @@
 class TGLSceneInfo;
 class TGLClip;
 class TGLRnrCtx;
+class TGLLogicalShape;
 class TGLSelectRecord;
 
 // Avoid TObject inheritance due to clash with TObject::Draw as well
@@ -99,6 +100,8 @@
    virtual void PostRender(TGLRnrCtx & rnrCtx);
    virtual void PostDraw  (TGLRnrCtx & rnrCtx);
 
+   virtual TGLLogicalShape* FindLogical(TObject*) const { return 0; }
+
    // Selection interface
    virtual Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx);
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLUtil.h root/graf3d/gl/inc/TGLUtil.h
--- root-old/graf3d/gl/inc/TGLUtil.h	2010-04-12 19:15:45.000000000 +0200
+++ root/graf3d/gl/inc/TGLUtil.h	2010-04-12 19:25:58.000000000 +0200
@@ -513,41 +513,9 @@
 }
 
 //______________________________________________________________________________
-inline void TGLRect::Expand(Int_t x, Int_t y)
-{
-   // Expand the rect to encompass point (x,y)
-   Int_t delX = x - fX;
-   Int_t delY = y - fY;
-
-   if (delX>static_cast<Int_t>(fWidth)) {
-      fWidth = delX;
-   }
-   if (delY>static_cast<Int_t>(fHeight)) {
-      fHeight = delY;
-   }
-
-   if (delX<0) {
-      fX = x;
-      fWidth += -delX;
-   }
-   if (delY<0) {
-      fY = y;
-      fHeight += -delY;
-   }
-}
-
-//______________________________________________________________________________
-inline Int_t TGLRect::Diagonal() const
-{
-   const Double_t w = static_cast<Double_t>(fWidth);
-   const Double_t h = static_cast<Double_t>(fHeight);
-   return static_cast<Int_t>(std::sqrt(w*w + h*h));
-}
-
-//______________________________________________________________________________
 inline Int_t TGLRect::Longest() const
 {
-   return fWidth > fHeight ? fWidth:fHeight;
+   return fWidth > fHeight ? fWidth : fHeight;
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLViewer.h root/graf3d/gl/inc/TGLViewer.h
--- root-old/graf3d/gl/inc/TGLViewer.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLViewer.h	2010-04-12 19:25:58.000000000 +0200
@@ -21,6 +21,7 @@
 
 #include "TGLPerspectiveCamera.h"
 #include "TGLOrthoCamera.h"
+#include "TGLClip.h"
 
 #include "TTimer.h"
 #include "TPoint.h"
@@ -98,7 +99,6 @@
    TGLLightSet         *fLightSet;             //!
    // Clipping
    TGLClipSet          *fClipSet;              //!
-   Bool_t               fClipAutoUpdate;       //!
    // Selected physical
    TGLSelectRecord      fCurrentSelRec;        //! select record in use as selected
    TGLSelectRecord      fSelRec;               //! select record from last select (should go to context)
@@ -158,6 +158,9 @@
    ///////////////////////////////////////////////////////////////////////
    // Methods
    ///////////////////////////////////////////////////////////////////////
+
+   virtual void SetupClipObject();
+
    // Drawing - can tidy up/remove lots when TGLManager added
    void InitGL();
    void PreDraw();
@@ -238,6 +241,9 @@
    static void         UseDefaultColorSetForNewViewers(Bool_t x);
    static Bool_t       IsUsingDefaultColorSetForNewViewers();
 
+   const TGLRect& RefViewport()      const { return fViewport; }
+   Int_t          ViewportDiagonal() const { return fViewport.Diagonal(); }
+
    Float_t GetPointScale()    const { return fPointScale; }
    Float_t GetLineScale()     const { return fLineScale; }
    void    SetPointScale(Float_t s) { fPointScale = s; }
@@ -249,8 +255,8 @@
 
    TGLLightSet* GetLightSet() const { return fLightSet; }
    TGLClipSet * GetClipSet()  const { return fClipSet; }
-   Bool_t GetClipAutoUpdate() const   { return fClipAutoUpdate; }
-   void   SetClipAutoUpdate(Bool_t x) { fClipAutoUpdate = x; }
+   Bool_t GetClipAutoUpdate() const   { return fClipSet->GetAutoUpdate(); }
+   void   SetClipAutoUpdate(Bool_t x) { fClipSet->SetAutoUpdate(x); }
 
    // External GUI component interface
    TGLCamera & CurrentCamera() const { return *fCurrentCamera; }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLViewerBase.h root/graf3d/gl/inc/TGLViewerBase.h
--- root-old/graf3d/gl/inc/TGLViewerBase.h	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/inc/TGLViewerBase.h	2010-04-12 19:26:07.000000000 +0200
@@ -26,6 +26,7 @@
 class TGLCamera;
 class TGLClip;
 class TGLRnrCtx;
+class TGLLogicalShape;
 class TGLSelectRecord;
 class TGLOvlSelectRecord;
 class TGLOverlayElement;
@@ -54,6 +55,8 @@
 
    void SubRenderScenes(SubRender_foo render_foo);
 
+   virtual void SetupClipObject();
+
    // Members
 
    TGLRnrCtx         *fRnrCtx;
@@ -91,6 +94,8 @@
 
    TGLSceneInfo* GetSceneInfo(TGLSceneBase* scene);
 
+   TGLLogicalShape* FindLogicalInScenes(TObject* id);
+
    virtual void AddOverlayElement(TGLOverlayElement* el);
    virtual void RemoveOverlayElement(TGLOverlayElement* el);
    virtual void DeleteOverlayAnnotations();
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLAnnotation.cxx root/graf3d/gl/src/TGLAnnotation.cxx
--- root-old/graf3d/gl/src/TGLAnnotation.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLAnnotation.cxx	2010-04-12 19:25:32.000000000 +0200
@@ -47,20 +47,22 @@
 
    fPosX(posx), fPosY(posy),
    fMouseX(0),  fMouseY(0),
-   fInDrag(kFALSE),
+   fDrag(kNone),
+   fDrawW(0), fDrawH(0), fTextSizeDrag(0),
    fActive(kFALSE),
    fMainFrame(0), fTextEdit(0),
 
    fParent(0),
 
    fText(text),
-   fTextSize(0.02),
+   fTextSize(0.03),
    fTextAlign(TGLFont::kLeft),
    fBackColor(fgBackColor),
    fTextColor(fgTextColor),
    fTransparency(100),
    fDrawRefLine(kFALSE),
-   fUseColorSet(kTRUE)
+   fUseColorSet(kTRUE),
+   fAllowClose(kTRUE)
 {
    // Constructor.
    // Create annotation as plain text
@@ -74,20 +76,22 @@
    TGLOverlayElement(TGLOverlayElement::kAnnotation),
    fPosX(posx), fPosY(posy),
    fMouseX(0),  fMouseY(0),
-   fInDrag(kFALSE),
+   fDrag(kNone),
+   fDrawW(0), fDrawH(0), fTextSizeDrag(0),
    fActive(kFALSE),
    fMainFrame(0), fTextEdit(0),
 
    fParent(0),
 
    fText(text),
-   fTextSize(0.02),
+   fTextSize(0.03),
    fTextAlign(TGLFont::kLeft),
    fBackColor(fgBackColor),
    fTextColor(fgTextColor),
    fTransparency(40),
    fDrawRefLine(kTRUE),
-   fUseColorSet(kFALSE)
+   fUseColorSet(kTRUE),
+   fAllowClose(kTRUE)
 {
    // Constructor.
    // Create annotaton by picking an object.
@@ -116,39 +120,38 @@
 
    if (selRec.GetN() < 2) return kFALSE;
    Int_t recID = selRec.GetItem(1);
-
    switch (event->fType)
    {
       case kButtonPress:
       {
          fMouseX = event->fX;
          fMouseY = event->fY;
-         fInDrag = kTRUE;
-
+         fDrag = (recID == kResizeID) ? kResize : kMove;
+         fTextSizeDrag = fTextSize;
          return kTRUE;
       }
       case kButtonRelease:
       {
-         fInDrag = kFALSE;
-
-         if (recID == 2)
+         fDrag = kNone;
+         if (recID == kDeleteID)
          {
             TGLViewer *v = fParent;
             delete this;
             v->RequestDraw(rnrCtx.ViewerLOD());
          }
-         else if (recID == 3)
+         else if (recID == kEditID)
          {
             MakeEditor();
          }
-
          return kTRUE;
       }
       case kMotionNotify:
       {
-         if (fInDrag)
+         const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+         if (vp.Width() == 0 || vp.Height() == 0) return kFALSE;
+
+         if (fDrag == kMove)
          {
-            const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
             fPosX += (Float_t)(event->fX - fMouseX) / vp.Width();
             fPosY -= (Float_t)(event->fY - fMouseY) / vp.Height();
             fMouseX = event->fX;
@@ -158,10 +161,23 @@
                fPosX = 0;
             else if (fPosX + fDrawW > 1.0f)
                fPosX = 1.0f - fDrawW;
-            if (fPosY - fDrawH + fDrawY < 0)
-               fPosY = fDrawH - fDrawY;
-            else if (fPosY + fDrawY > 1.0f)
-               fPosY = 1.0f - fDrawY;
+            if (fPosY < fDrawH)
+               fPosY = fDrawH;
+            else if (fPosY > 1.0f)
+               fPosY = 1.0f;
+         }
+         else if (fDrag == kResize)
+         {
+            using namespace TMath;
+            Float_t oovpw = 1.0f / vp.Width(), oovph = 1.0f / vp.Height();
+
+            Float_t xw = oovpw * Min(Max(0, event->fX), vp.Width());
+            Float_t yw = oovph * Min(Max(0, vp.Height() - event->fY), vp.Height());
+
+            Float_t rx = Max((xw - fPosX) / (oovpw * fMouseX - fPosX), 0.0f);
+            Float_t ry = Max((yw - fPosY) / (oovph*(vp.Height() - fMouseY) - fPosY), 0.0f);
+
+            fTextSize  = Max(fTextSizeDrag * Min(rx, ry), 0.01f);
          }
          return kTRUE;
       }
@@ -194,19 +210,22 @@
 {
    // Render the annotation.
 
+   const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+   if (vp.Width() == 0 && vp.Height() == 0)
+      return;
+
    Float_t old_depth_range[2];
    glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
    glDepthRange(0, 0.001);
 
-   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT );
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glDisable(GL_CULL_FACE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-   const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
-
    // prepare colors
    Color_t bgCol, fgCol;
    if (fUseColorSet)
@@ -220,22 +239,12 @@
                                c1->GetGreen()*f1  + c2->GetGreen()*f2,
                                c1->GetBlue() *f1  + c2->GetBlue() *f2);
    }
-   else {
+   else
+   {
       fgCol = fTextColor;
       bgCol = fBackColor;
    }
 
-   if (fDrawRefLine)
-   {
-      TGLUtil::ColorTransparency(bgCol, fTransparency);
-      TGLUtil::LineWidth(2);
-      glBegin(GL_LINES);
-      TGLVertex3 v = rnrCtx.RefCamera().ViewportToWorld(TGLVertex3(fPosX*vp.Width(), fPosY*vp.Height(), 0));
-      glVertex3dv(v.Arr());
-      glVertex3dv(fPointer.Arr());
-      glEnd();
-   }
-
    // reset matrix
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
@@ -247,153 +256,219 @@
       gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
                     (Int_t*) rnrCtx.GetCamera()->RefViewport().CArr());
    }
-   glOrtho(vp.X(), vp.Width(), vp.Y(), vp.Height(), 0, 1);
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
+   // set ortho camera to [0,1] [0.1]
    glLoadIdentity();
+   glTranslatef(-1.0f, -1.0f, 0.0f);
+   glScalef(2.0f, 2.0f, 1.0f);
 
    glEnable(GL_POLYGON_OFFSET_FILL);
-   glPolygonOffset(0.1, 1);
+   glPolygonOffset(0.1f, 1.0f);
 
-   TGLUtil::LineWidth(1);
+   glPushMatrix();
+
+   TGLUtil::LineWidth(1.0f);
 
    // move to pos
-   Float_t posX = vp.Width()  * fPosX;
-   Float_t posY = vp.Height() * fPosY;
-   glTranslatef(posX, posY, -0.99);
-
-
-   // get size of bg area, look at font attributes
-   rnrCtx.RegisterFontNoScale(TMath::Nint(fTextSize*vp.Width()), "arial",  TGLFont::kPixmap, fFont);
-   Float_t ascent, descent, line_height;
-   fFont.MeasureBaseLineParams(ascent, descent, line_height);
-   TObjArray* lines = fText.Tokenize("\n");
-   Float_t width  = 0;
-   Float_t height = 0;
-   TIter  lit(lines);
-   TObjString* osl;
-   Float_t llx, lly, llz, urx, ury, urz;
-   while ((osl = (TObjString*) lit()) != 0)
+   glTranslatef(fPosX, fPosY, 0.0f);
+
+   TObjArray  *lines = fText.Tokenize("\n");
+   TIter       line_iter(lines);
+   TObjString *osl;
+
+   Float_t widthTxt, heightTxt, sx, sy, descent, line_height;
    {
-      fFont.BBox(osl->GetString().Data(), llx, lly, llz, urx, ury, urz);
-      width = TMath::Max(width, urx);
-      height -= (line_height + descent);
+      // get unscaled text size
+      Int_t fs = TGLFontManager::GetFontSize(TMath::Nint(vp.Height()*fTextSize), 12, 64);
+      rnrCtx.RegisterFontNoScale(fs, "arial", TGLFont::kTexture, fFont);
+      descent     = fFont.GetDescent();
+      line_height = fFont.GetLineHeight();
+
+      Float_t llx, lly, llz, urx, ury, urz;
+      widthTxt = heightTxt = 0;
+      while ((osl = (TObjString*) line_iter()) != 0)
+      {
+         fFont.BBox(osl->GetString().Data(), llx, lly, llz, urx, ury, urz);
+         widthTxt   = TMath::Max(widthTxt, urx);
+         heightTxt += line_height;
+      }
+      widthTxt  += 2.0f * descent;
+      heightTxt += 2.0f * descent;
+
+      // keep proportions
+      sy = fTextSize / (line_height + descent);
+      sx = sy / vp.Aspect();
+      fDrawW = sx*widthTxt;
+      fDrawH = sy*heightTxt;
    }
-   width  += 2 * descent;
-   height -= 2 * descent;
+   glScalef(sx, sy, 1.0f);
+
+   glPushName(kMoveID);
 
-   // Store variables needed for border check when box is dragged.
-   fDrawW = (Float_t) width / vp.Width();
-   fDrawH = (Float_t) - height / vp.Height();
-   fDrawY = line_height / vp.Height();
-
-   // polygon background
-   Float_t padT =  2;
-   Int_t   padF = 10;
-   Float_t padM = padF + 2 * padT;
-
-   glPushName(0);
-
-   // bg plain
-   Float_t y = line_height;
-   Float_t x = 0;
-   glLoadName(1);
+   Float_t x1, x2, y1, y2;
+   Float_t z3 =  0.0f;  // main background
+   Float_t z2 = -0.01f; // outlines and text
+   Float_t z1 = -0.02f; // button on top of text
+   Float_t z0 = -0.03f; // button on top of text
+
+   // main background
+   glLoadName(kMoveID);
+   x1 =  0.0f;
+   x2 =  widthTxt;
+   y1 = -heightTxt;
+   y2 =  0.0f;
    TGLUtil::ColorTransparency(bgCol, fTransparency);
    glBegin(GL_QUADS);
-   glVertex2f(x, y);
-   glVertex2f(x, y + height);
-   glVertex2f(x+width, y + height);
-   glVertex2f(x+width, y);
+   glVertex3f(x1, y1, z3);
+   glVertex3f(x2, y1, z3);
+   glVertex3f(x2, y2, z3);
+   glVertex3f(x1, y2, z3);
    glEnd();
-
-   // outline
-   TGLUtil::ColorTransparency(fgCol, fTransparency);
+   // main polygon outline
+   TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
    glBegin(GL_LINE_LOOP);
-   glVertex2f(x, y);
-   glVertex2f(x, y + height);
-   glVertex2f(x+width, y + height);
-   glVertex2f(x+width, y);
+   glVertex3f(x1, y1, z2);
+   glVertex3f(x2, y1, z2);
+   glVertex3f(x2, y2, z2);
+   glVertex3f(x1, y2, z2);
    glEnd();
 
-   if (fActive && fTransparency < 100)
-   {  // edit area
-
-      TGLUtil::ColorTransparency(bgCol, fTransparency);
-      // edit button
-      glLoadName(2);
-      glBegin(GL_QUADS);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd();
-      // close button
-      glLoadName(3);
-      x = padM;
-      glBegin(GL_QUADS);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd();
-
-      // outlines
-      TGLUtil::ColorTransparency(fgCol, fTransparency);
-      x = 0; // left
-      glBegin(GL_LINE_LOOP);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd(); // right
-      x = padM;
-      glBegin(GL_LINE_LOOP);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd();
-   }
-   glPopName();
-
-   // text
-   Float_t zOff = 0.2; // more than 0, else not rendered
-   fFont.PreRender();
+   // annotation text
    TGLUtil::Color(fgCol);
-   TIter  next_base(lines);
-   TObjString* os;
+   fFont.PreRender();
    glPushMatrix();
-   glTranslatef(descent, line_height, zOff);
    Float_t tx = 0;
-   while ((os = (TObjString*) next_base()) != 0)
+   line_iter.Reset();
+   while ((osl = (TObjString*) line_iter()) != 0)
    {
-      glTranslatef(0, -(line_height + descent), 0);
       if (fTextAlign == TGLFont::kLeft) {
          tx = 0;
       }
       else if  (fTextAlign == TGLFont::kCenterH) {
-         tx = 0.5 * width - descent ;
+         tx = 0.5f * widthTxt - descent ;
       }
       else {
-         tx = width - 2*descent;
+         tx = widthTxt - 2.0f * descent;
       }
-      fFont.Render(os->GetString(), tx, 0, 0, fTextAlign, TGLFont::kTop);
+      glTranslatef(0.0f, -line_height, 0.0f);
+      fFont.Render(osl->GetString(), tx+descent, 0, z2, fTextAlign, TGLFont::kTop) ;
    }
    glPopMatrix();
    fFont.PostRender();
 
-   // menu
+   delete lines;
+
+   // buttons
+   if (fActive)
+   {
+      Float_t bbox[6];
+      fFont.PreRender();
+      fFont.BBox("X", bbox[0], bbox[1], bbox[2], bbox[3], bbox[4], bbox[5]);
+      glLoadName(kEditID);
+      fFont.Render("E", descent, descent, z2, fTextAlign, TGLFont::kTop);
+      x2 = bbox[3] + 2.0f * descent;
+      if (fAllowClose)
+      {
+         glLoadName(kDeleteID);
+         fFont.Render("X", x2 + descent, descent, z2, fTextAlign, TGLFont::kTop);
+      }
+      fFont.PostRender();
+
+      x1 = 0.0f;
+      y1 = 0.0f;
+      y2 = line_height + descent;
+      {
+         // edit button
+         glLoadName(kEditID);
+         // polygon
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         glBegin(GL_QUADS);
+         glVertex3f(x1, y1, z3);
+         glVertex3f(x2, y1, z3);
+         glVertex3f(x2, y2, z3);
+         glVertex3f(x1, y2, z3);
+         glEnd();
+         //  outline
+         TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
+         glBegin(GL_LINE_LOOP);
+         glVertex3f(x1, y1, z0);
+         glVertex3f(x2, y1, z0);
+         glVertex3f(x2, y2, z0);
+         glVertex3f(x1, y2, z0);
+         glEnd();
+      }
+      x1 += x2;
+      x2 += x2;
+      if (fAllowClose)
+      {
+         // close button
+         glLoadName(kDeleteID);
+         // polygon
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         glBegin(GL_QUADS);
+         glVertex3f(x1, y1, z3);
+         glVertex3f(x2, y1, z3);
+         glVertex3f(x2, y2, z3);
+         glVertex3f(x1, y2, z3);
+         glEnd();
+         //  outline
+         TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
+         glBegin(GL_LINE_LOOP);
+         glVertex3f(x1, y1, z0);
+         glVertex3f(x2, y1, z0);
+         glVertex3f(x2, y2, z0);
+         glVertex3f(x1, y2, z0);
+         glEnd();
+      }
+      {
+         // resize button
+         glLoadName(kResizeID);
+         // polygon
+         x1 =  widthTxt - line_height;
+         x2 =  widthTxt;
+         y1 = -heightTxt;
+         y2 = -heightTxt + line_height;
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         glBegin(GL_QUADS);
+         glVertex3f(x1, y1, z1);
+         glVertex3f(x2, y1, z1);
+         glVertex3f(x2, y2, z1);
+         glVertex3f(x1, y2, z1);
+         glEnd();
+         // draw resize corner lines
+         TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
+         glBegin(GL_LINES);
+         Float_t aOff = 0.25*line_height;
+         glVertex3f(x1+aOff, y1+aOff, z0);
+         glVertex3f(x2-aOff, y1+aOff, z0);
+         glVertex3f(x2-aOff, y1+aOff, z0);
+         glVertex3f(x2-aOff, y2-aOff, z0);
+         glEnd();
+      }
+   }
+
+   glPopName();
+
+   glPopMatrix();
 
-   if (fActive && fTransparency < 100)
+   if (fDrawRefLine)
    {
-      x = padT;
-      y = padT + 0.5*padF + line_height;
-      rnrCtx.RegisterFontNoScale(padF, "arial",  TGLFont::kPixmap, fMenuFont);
-      fMenuFont.PreRender();
-      fMenuFont.Render("X", x, y, zOff, TGLFont::kLeft, TGLFont::kCenterV);
-      x += padM + padT;
-      fMenuFont.Render("E", x, y, zOff, TGLFont::kLeft, TGLFont::kCenterV);
-      fMenuFont.PostRender();
+      TGLVertex3 op = rnrCtx.RefCamera().WorldToViewport(fPointer);
+      op[0] /= vp.Width();  op[1] /= vp.Height();
+
+      Float_t fx = op[0] < fPosX ? 0.0f : (op[0] > fPosX + fDrawW ? 1.0f : 0.5f);
+      Float_t fy = op[1] < fPosY-fDrawH ? 1.0f : (op[1] > fPosY ? 0.0f : 0.5f);
+
+      if (fx != 0.5f || fy != 0.5f)
+      {
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         TGLUtil::LineWidth(2);
+         glBegin(GL_LINES);
+         glVertex3f(fPosX + fx*fDrawW, fPosY - fy*fDrawH, z3);
+         glVertex3f(op[0], op[1], z3);
+         glEnd();
+      }
    }
 
    glMatrixMode(GL_PROJECTION);
@@ -406,6 +481,18 @@
 }
 
 //______________________________________________________________________________
+Char_t TGLAnnotation::GetLineTransparency() const
+{
+   // Returns transparecy of annotation outline.
+   // If annotation is selected enforce visiblity of outline.
+
+   if (fActive)
+      return TMath::Min(70, fTransparency);
+   else
+      return fTransparency;
+}
+
+//______________________________________________________________________________
 void TGLAnnotation::MakeEditor()
 {
    // Show the annotation editor.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLAxisPainter.cxx root/graf3d/gl/src/TGLAxisPainter.cxx
--- root-old/graf3d/gl/src/TGLAxisPainter.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLAxisPainter.cxx	2010-04-12 19:26:03.000000000 +0200
@@ -50,9 +50,12 @@
    fTitlePixelFontSize(14),
 
    fLabelAlignH(TGLFont::kCenterH),
-   fLabelAlignV(TGLFont::kCenterV)
+   fLabelAlignV(TGLFont::kCenterV),
+   fAllZeroesRE(0)
 {
    // Constructor.
+
+   fAllZeroesRE = new TPMERegexp("[-+]?0\\.0*$", "o");
 }
 
 
@@ -61,6 +64,7 @@
 {
    // Destructor.
 
+   delete fAllZeroesRE;
 }
 
 //______________________________________________________________________________
@@ -101,15 +105,15 @@
       return;
    }
 
-   if (s.EndsWith("."))
-      s += '0';
-
-   Ssiz_t ld = s.Last('.');
+   Ssiz_t ld = s.Last('.') + 1;
    if (s.Length() - ld > fDecimals)
       s.Remove(ld + fDecimals);
 
-   TPMERegexp zeroes("[-+]?0\\.0*$");
-   zeroes.Substitute(s, "0");
+
+   if (fDecimals == 0 && s.EndsWith("."))
+      s.Remove(s.Length() -1);
+
+   fAllZeroesRE->Substitute(s, "0", kFALSE);
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLCameraOverlay.cxx root/graf3d/gl/src/TGLCameraOverlay.cxx
--- root-old/graf3d/gl/src/TGLCameraOverlay.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLCameraOverlay.cxx	2010-04-12 19:26:04.000000000 +0200
@@ -74,13 +74,33 @@
 //______________________________________________________________________________
 TAttAxis* TGLCameraOverlay::GetAttAxis()
 {
+   // Get axis attributes.
+
    return dynamic_cast<TAttAxis*>(fAxis);
 }
 
 //______________________________________________________________________________
+void TGLCameraOverlay::SetFrustum(TGLCamera& cam)
+{
+   // Set frustum values from given camera.
+
+   TGLVector3 absRef(1., 1., 1.); // needed in case if orthographic camera is negative
+   Float_t l = -cam.FrustumPlane(TGLCamera::kLeft).D()  * Dot(cam.GetCamBase().GetBaseVec(2), absRef);
+   Float_t r =  cam.FrustumPlane(TGLCamera::kRight).D() * Dot(cam.GetCamBase().GetBaseVec(2), absRef);
+   Float_t t =  cam.FrustumPlane(TGLCamera::kTop).D();
+   Float_t b = -cam.FrustumPlane(TGLCamera::kBottom).D();
+
+   fFrustum[0] = l;
+   fFrustum[1] = b;
+   fFrustum[2] = r;
+   fFrustum[3] = t;
+}
+
+//______________________________________________________________________________
 void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx)
 {
-   // Print corss section coordinates in top right corner of screen.
+   // Draw cross section coordinates in top right corner of screen.
+
    TGLCamera &cam = rnrCtx.RefCamera();
    // get eye line
    const TGLMatrix& mx =  cam.GetCamBase() * cam.GetCamTrans();
@@ -158,20 +178,34 @@
    Float_t tlY = 0.015*rl/(vp[2]-vp[0]);
    Float_t tlX = 0.015*rl/(vp[3]-vp[1]);
    // corner vectors
+   Float_t minX, maxX;
    TGLVector3 xdir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(2); xdir.Normalise(); // left
+   if (fFrustum[2] > fFrustum[0] )
+   {   
+      minX =  fFrustum[0];
+      maxX =  fFrustum[2];
+   }
+   else {
+      xdir = -xdir;
+      minX =  fFrustum[2];
+      maxX =  fFrustum[0];
+   }
+
    TGLVector3 ydir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(3); ydir.Normalise(); // up
    TGLVector3 vy1 = ydir * fFrustum[1];
    TGLVector3 vy2 = ydir * fFrustum[3];
-   TGLVector3 vx1 = xdir * fFrustum[0];
-   TGLVector3 vx2 = xdir * fFrustum[2];
+
+   TGLVector3 vx1 = xdir * minX;
+   TGLVector3 vx2 = xdir * maxX;
    // range
    Double_t rngY = fFrustum[3] - fFrustum[1];
-   Double_t rngX = fFrustum[2] - fFrustum[0];
-   Double_t off = TMath::Sqrt((rngX*rngY)+(rngX*rngY)) * 0.03;
-   Double_t minX = fFrustum[0] + off;
-   Double_t maxX = fFrustum[2] - off ;
+   Double_t rngX = maxX - minX;
+   Double_t off =  TMath::Sqrt((rngX*rngX)+(rngY*rngY)) * 0.03;
    Double_t minY = fFrustum[1] + off;
    Double_t maxY = fFrustum[3] - off;
+   minX += off;
+   maxX -= off;
+
    // grid lines
    Char_t alpha = 80; //primary
    Char_t alpha2 = 90; //seconndary
@@ -344,7 +378,7 @@
    // Show frustum size with fixed screen line length and printed value.
 
    // factors 10, 5 and 2 are allowed
-   Double_t wfrust     = fFrustum[2]-fFrustum[0];
+   Double_t wfrust     = TMath::Abs(fFrustum[2]-fFrustum[0]);
    Float_t barsize= 0.14* wfrust;
    Int_t exp = (Int_t) TMath::Floor(TMath::Log10(barsize));
    Double_t fact = barsize/TMath::Power(10, exp);
@@ -428,32 +462,24 @@
    // Display coodinates info of current frustum.
 
    TGLCamera &cam = rnrCtx.RefCamera();
-   if ( rnrCtx.Selection() || (cam.IsPerspective()  && ! fShowPerspective) ||
-        (cam.IsOrthographic() && ! fShowOrthographic))
-      return;
-
 
-   // Frustum size.
-   TGLCamera &camera = rnrCtx.RefCamera();
-   Float_t l = -camera.FrustumPlane(TGLCamera::kLeft).D();
-   Float_t r =  camera.FrustumPlane(TGLCamera::kRight).D();
-   Float_t t =  camera.FrustumPlane(TGLCamera::kTop).D();
-   Float_t b = -camera.FrustumPlane(TGLCamera::kBottom).D();
-
-   fFrustum[0] = l;
-   fFrustum[1] = b;
-   fFrustum[2] = r;
-   fFrustum[3] = t;
+   if (rnrCtx.Selection() ||
+       (cam.IsPerspective()  && ! fShowPerspective) ||
+       (cam.IsOrthographic() && ! fShowOrthographic))
+   {
+      return;
+   }
 
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
+   TGLUtil::Color(rnrCtx.ColorSet().Markup());
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    Float_t old_depth_range[2];
    glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
 
-   TGLUtil::Color(rnrCtx.ColorSet().Markup());
+   SetFrustum(cam);
 
    if (cam.IsOrthographic())
    {
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLClip.cxx root/graf3d/gl/src/TGLClip.cxx
--- root-old/graf3d/gl/src/TGLClip.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLClip.cxx	2010-04-12 19:24:37.000000000 +0200
@@ -339,6 +339,7 @@
    fClipPlane   (new TGLClipPlane),
    fClipBox     (new TGLClipBox),
    fCurrentClip (0),
+   fAutoUpdate  (kTRUE),
    fShowClip    (kFALSE),
    fShowManip   (kFALSE),
    fManip       (new TGLManipSet)
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLClipSetEditor.cxx root/graf3d/gl/src/TGLClipSetEditor.cxx
--- root-old/graf3d/gl/src/TGLClipSetEditor.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLClipSetEditor.cxx	2010-04-12 19:24:37.000000000 +0200
@@ -38,6 +38,7 @@
    fBoxPropFrame(0),
    fBoxProp(),
    fClipInside(0),
+   fAutoUpdate(0),
    fClipEdit(0),
    fClipShow(0),
    fApplyButton(0),
@@ -45,15 +46,17 @@
 {
    // Constructor.
 
-   fTypeButtons = new TGButtonGroup(this, "Clip Type");
-   new TGRadioButton(fTypeButtons, "None");
-   new TGRadioButton(fTypeButtons, "Plane");
+   fTypeButtons = new TGButtonGroup(this, "Clip Type", kChildFrame|kHorizontalFrame);
+   new TGRadioButton(fTypeButtons, "None    ");
+   new TGRadioButton(fTypeButtons, "Plane    ");
    new TGRadioButton(fTypeButtons, "Box");
-
+   fTypeButtons->SetLayoutHints(new TGLayoutHints(kLHintsLeft|kLHintsBottom, 0, 0, 2, -10));
    AddFrame(fTypeButtons, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
    // Clip inside / edit
    fClipInside = new TGCheckButton(this, "Clip away inside");
    AddFrame(fClipInside, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
+   fAutoUpdate = new TGCheckButton(this, "Auto update clip");
+   AddFrame(fAutoUpdate, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
    fClipEdit   = new TGCheckButton(this, "Edit In Viewer");
    AddFrame(fClipEdit, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
    fClipShow   = new TGCheckButton(this, "Show In Viewer");
@@ -86,6 +89,7 @@
 
    fTypeButtons->Connect("Clicked(Int_t)", "TGLClipSetSubEditor", this, "ClipTypeChanged(Int_t)");
    fClipInside->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
+   fAutoUpdate->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
    fClipEdit->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
    fClipShow->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
 
@@ -122,12 +126,14 @@
    }
    Bool_t active = (fCurrentClip != kClipNone);
    fClipInside->SetEnabled(active);
+   fAutoUpdate->SetEnabled(active);
    fClipEdit  ->SetEnabled(active);
    fClipShow  ->SetEnabled(active);
    if (active) {
       fClipEdit->SetDown(fM->GetShowManip());
       fClipShow->SetDown(fM->GetShowClip());
       fClipInside->SetDown(fM->GetCurrentClip()->GetMode() == TGLClip::kInside);
+      fAutoUpdate->SetDown(fM->GetAutoUpdate());
 
       if (fCurrentClip == kClipPlane) {
          HideFrame(fBoxPropFrame);
@@ -208,6 +214,7 @@
    fM->SetShowClip (fClipShow->IsDown());
    if (fCurrentClip != kClipNone)
       fM->GetCurrentClip()->SetMode(fClipInside->IsDown() ? TGLClip::kInside : TGLClip::kOutside);
+   fM->SetAutoUpdate(fAutoUpdate->IsDown());
 
    Changed();
 }
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLEventHandler.cxx root/graf3d/gl/src/TGLEventHandler.cxx
--- root-old/graf3d/gl/src/TGLEventHandler.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLEventHandler.cxx	2010-04-12 19:26:06.000000000 +0200
@@ -700,7 +700,7 @@
    if (fGLViewer->IsLocked()) {
       if (gDebug>3) {
          Info("TGLEventHandler::HandleKey", "ignored - viewer is %s",
-            fGLViewer->LockName(fGLViewer->CurrentLock()));
+              fGLViewer->LockName(fGLViewer->CurrentLock()));
       }
       return kFALSE;
    }
@@ -777,8 +777,14 @@
             redraw = fGLViewer->CurrentCamera().Truck(10, 0, mod1, mod2);
             break;
          case kKey_Home:
-            fGLViewer->ResetCurrentCamera();
-            redraw = kTRUE;
+            if (mod1) {
+               TGLCamera &cam = fGLViewer->CurrentCamera();
+               cam.SetExternalCenter(!cam.GetExternalCenter());
+               fGLViewer->RefreshPadEditor(fGLViewer);
+            } else {
+               fGLViewer->ResetCurrentCamera();
+            }
+               redraw = kTRUE;
             break;
 
             // Toggle debugging mode
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLFaceSet.cxx root/graf3d/gl/src/TGLFaceSet.cxx
--- root-old/graf3d/gl/src/TGLFaceSet.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLFaceSet.cxx	2010-04-12 19:24:41.000000000 +0200
@@ -142,6 +142,8 @@
       Info("TGLFaceSet::DirectDraw", "this %d (class %s) LOD %d", this, IsA()->GetName(), rnrCtx.ShapeLOD());
    }
 
+   if (fNbPols == 0) return;
+
    GLUtesselator  *tessObj = TGLUtil::GetDrawTesselator3dv();
    const Double_t *pnts = &fVertices[0];
    const Double_t *normals = &fNormals[0];
@@ -217,6 +219,8 @@
 void TGLFaceSet::CalculateNormals()
 {
    // CalculateNormals
+
+   if (fNbPols == 0) return;
    Double_t *pnts = &fVertices[0];
    for (UInt_t i = 0, j = 0; i < fNbPols; ++i) {
       Int_t polEnd = fPolyDesc[j] + j + 1;
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLFontManager.cxx root/graf3d/gl/src/TGLFontManager.cxx
--- root-old/graf3d/gl/src/TGLFontManager.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLFontManager.cxx	2010-04-12 19:25:16.000000000 +0200
@@ -8,7 +8,8 @@
  * For the licensing terms see $ROOTSYS/LICENSE.                         *
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
-#include <iostream>
+
+#include "Riostream.h"
 #include "RConfigure.h"
 #include "TGLFontManager.h"
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLLockable.cxx root/graf3d/gl/src/TGLLockable.cxx
--- root-old/graf3d/gl/src/TGLLockable.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLLockable.cxx	2010-04-12 19:24:20.000000000 +0200
@@ -18,7 +18,7 @@
 // Simple locking interface used by viewer and scene.
 
 
-ClassImp(TGLLockable)
+ClassImp(TGLLockable);
 
 TGLLockable::TGLLockable() :
    fLock      (kUnlocked)
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLLogicalShape.cxx root/graf3d/gl/src/TGLLogicalShape.cxx
--- root-old/graf3d/gl/src/TGLLogicalShape.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLLogicalShape.cxx	2010-04-12 19:24:34.000000000 +0200
@@ -138,7 +138,7 @@
    // Physicals should have been cleared elsewhere as they are managed
    // by the scene. But this could change.
    if (fRef > 0) {
-      Warning("TGLLogicalShape::Destroy", "some physicals still lurking around.");
+      Warning("TGLLogicalShape::~TGLLogicalShape", "some physicals still lurking around.");
       DestroyPhysicals();
    }
    DLCachePurge();
@@ -211,6 +211,7 @@
       curr = next;
    }
    assert (fRef == 0);
+   fFirstPhysical = 0;
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLPadPainter.cxx root/graf3d/gl/src/TGLPadPainter.cxx
--- root-old/graf3d/gl/src/TGLPadPainter.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLPadPainter.cxx	2010-04-12 19:24:31.000000000 +0200
@@ -1,8 +1,12 @@
 #include <stdexcept>
-#include <iostream>
+#include <memory>
+#include <vector>
 
 #include "TAttMarker.h"
 #include "TVirtualX.h"
+#include "TError.h"
+#include "TImage.h"
+#include "TROOT.h"
 #include "TPad.h"
 
 #include "TGLPadPainter.h"
@@ -772,6 +776,57 @@
    glViewport(fVp[0], fVp[1], fVp[2], fVp[3]);
 }
 
+//______________________________________________________________________________
+void TGLPadPainter::SaveImage(TVirtualPad *pad, const char *fileName, Int_t type) const
+{
+   // Using TImage save frame-buffer contents as a picture.
+
+   TVirtualPad *canvas = (TVirtualPad *)pad->GetCanvas();
+   if (!canvas) return;
+   gROOT->ProcessLine(Form("((TCanvas *)0x%lx)->Flush();", canvas));
+
+   std::vector<unsigned> buff(canvas->GetWw() * canvas->GetWh());
+   glPixelStorei(GL_PACK_ALIGNMENT, 1);
+   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+   //In case GL_BGRA is not in gl.h (old windows' gl) - comment/uncomment lines.
+   //glReadPixels(0, 0, canvas->GetWw(), canvas->GetWh(), GL_BGRA, GL_UNSIGNED_BYTE, (char *)&buff[0]);
+   glReadPixels(0, 0, canvas->GetWw(), canvas->GetWh(), GL_RGBA, GL_UNSIGNED_BYTE, (char *)&buff[0]);
+
+   std::auto_ptr<TImage> image(TImage::Create());
+   if (!image.get()) {
+      Error("TGLPadPainter::SaveImage", "TImage creation failed");
+      return;
+   }
+
+   image->DrawRectangle(0, 0, canvas->GetWw(), canvas->GetWh());
+   UInt_t *argb = image->GetArgbArray();
+
+   if (!argb) {
+      Error("TGLPadPainter::SaveImage", "null argb array in TImage object");
+      return;
+   }
+
+   const Int_t nLines  = canvas->GetWh();
+   const Int_t nPixels = canvas->GetWw(); 
+
+   for (Int_t i = 0; i < nLines; ++i) {
+     Int_t base = (nLines - 1 - i) * nPixels;
+     for (Int_t j = 0; j < nPixels; ++j, ++base) {
+        //Uncomment/comment if you don't have GL_BGRA.
+        
+        const UInt_t pix  = buff[base];
+        const UInt_t bgra = ((pix & 0xff) << 16) | (pix & 0xff00) |
+                            ((pix & 0xff0000) >> 16) | (pix & 0xff000000);
+        
+        //argb[i * nPixels + j] = buff[base];
+        argb[i * nPixels + j] = bgra;
+     }
+   }
+
+   image->WriteImage(fileName, (TImage::EImageFileTypes)type);
+}
+
+
 //Aux. functions.
 namespace {
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLPadUtils.cxx root/graf3d/gl/src/TGLPadUtils.cxx
--- root-old/graf3d/gl/src/TGLPadUtils.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLPadUtils.cxx	2010-04-12 19:25:17.000000000 +0200
@@ -1,4 +1,4 @@
-#include <iostream>
+#include "Riostream.h"
 #include <stdexcept>
 
 #include "TVirtualPad.h"
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLParametric.cxx root/graf3d/gl/src/TGLParametric.cxx
--- root-old/graf3d/gl/src/TGLParametric.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLParametric.cxx	2010-04-12 19:25:17.000000000 +0200
@@ -9,7 +9,7 @@
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
 
-#include <iostream>
+#include "Riostream.h"
 #include <cctype>
 
 #ifdef WIN32
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLPlotPainter.cxx root/graf3d/gl/src/TGLPlotPainter.cxx
--- root-old/graf3d/gl/src/TGLPlotPainter.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLPlotPainter.cxx	2010-04-12 19:25:17.000000000 +0200
@@ -8,7 +8,7 @@
  * For the licensing terms see $ROOTSYS/LICENSE.                         *
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
-#include <iostream>
+#include "Riostream.h"
 #include <cstdio>
 
 #include "TVirtualPad.h"
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLRnrCtx.cxx root/graf3d/gl/src/TGLRnrCtx.cxx
--- root-old/graf3d/gl/src/TGLRnrCtx.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLRnrCtx.cxx	2010-04-12 19:25:57.000000000 +0200
@@ -61,6 +61,7 @@
    fSceneLOD     (kLODUndef),
    fCombiLOD     (kLODUndef),
    fShapeLOD     (kLODUndef),
+   fShapePixSize (0),
 
    fViewerStyle  (kStyleUndef),
    fSceneStyle   (kStyleUndef),
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLSAViewer.cxx root/graf3d/gl/src/TGLSAViewer.cxx
--- root-old/graf3d/gl/src/TGLSAViewer.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLSAViewer.cxx	2010-04-12 19:26:06.000000000 +0200
@@ -65,6 +65,7 @@
    \tk          --- ZOOM out\n\
    \tArrow Keys --- PAN (TRUCK) across scene\n\
    \tHome       --- reset current camera\n\
+   \tCtrl-Home  --- switch external/automatic camera center\n\
 \n\
    LEFT mouse button -- ROTATE (ORBIT) the scene by holding the mouse button and moving\n\
    the mouse (perspective camera, needs to be enabled in menu for orthograpic cameras).\n\
@@ -181,6 +182,8 @@
 
 ClassImp(TGLSAViewer);
 
+Long_t TGLSAViewer::fgMenuHidingTimeout = 400;
+
 const Int_t TGLSAViewer::fgInitX = 0;
 const Int_t TGLSAViewer::fgInitY = 0;
 const Int_t TGLSAViewer::fgInitW = 780;
@@ -214,6 +217,8 @@
    fMenuBar(0),
    fMenuBut(0),
    fHideMenuBar(kFALSE),
+   fMenuHidingTimer(0),
+   fMenuHidingShowMenu(kTRUE),
    fDeleteMenuBar(kFALSE)
 {
    // Construct a standalone viewer, bound to supplied 'pad'.
@@ -258,6 +263,8 @@
    fMenuBar(0),
    fMenuBut(0),
    fHideMenuBar(kFALSE),
+   fMenuHidingTimer(0),
+   fMenuHidingShowMenu(kTRUE),
    fDeleteMenuBar(kFALSE)
 {
    // Construct an embedded standalone viewer, bound to supplied 'pad'.
@@ -298,6 +305,8 @@
 
    fGedEditor->DisconnectFromCanvas();
 
+   DisableMenuBarHiding();
+
    delete fHelpMenu;
    delete fCameraMenu;
    delete fFileSaveMenu;
@@ -536,6 +545,30 @@
    fFrame->HideFrame(fMenuBar);
    fFrame->ShowFrame(fMenuBut);
    fFrame->Layout();
+
+   fMenuHidingTimer = new TTimer;
+   fMenuHidingTimer->Connect("Timeout()", "TGLSAViewer", this, "MenuHidingTimeout()");
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::DisableMenuBarHiding()
+{
+   // Disable hiding of menu bar.
+
+   if (!fHideMenuBar)
+      return;
+
+   fHideMenuBar = kFALSE;
+
+   fMenuBar->Disconnect("ProcessedEvent(Event_t*)", this, "HandleMenuBarHiding(Event_t*)");
+   fMenuBut->Disconnect("ProcessedEvent(Event_t*)", this, "HandleMenuBarHiding(Event_t*)");
+
+   fFrame->ShowFrame(fMenuBar);
+   fFrame->HideFrame(fMenuBut);
+   fFrame->Layout();
+
+   delete fMenuHidingTimer;
+   fMenuHidingTimer = 0;
 }
 
 //______________________________________________________________________________
@@ -548,11 +581,9 @@
    if (f == fMenuBut)
    {
       if (ev->fType == kEnterNotify)
-      {
-         fFrame->HideFrame(fMenuBut);
-         fFrame->ShowFrame(fMenuBar);
-         fFrame->Layout();
-      }
+         ResetMenuHidingTimer(kTRUE);
+      else
+         fMenuHidingTimer->TurnOff();
    }
    else if (f == fMenuBar)
    {
@@ -561,25 +592,59 @@
            ev->fY < 0 || ev->fY >= (Int_t) f->GetHeight()))
       {
          if (fMenuBar->GetCurrent() == 0)
-         {
-            fFrame->HideFrame(fMenuBar);
-            fFrame->ShowFrame(fMenuBut);
-            fFrame->Layout();
-         }
+            ResetMenuHidingTimer(kFALSE);
          else
-         {
             fMenuBar->GetCurrent()->Connect("ProcessedEvent(Event_t*)", "TGLSAViewer", this, "HandleMenuBarHiding(Event_t*)");
-         }
+      }
+      else
+      {
+         fMenuHidingTimer->TurnOff();
       }
    }
    else
    {
       f->Disconnect("ProcessedEvent(Event_t*)", this);
+      ResetMenuHidingTimer(kFALSE);
+   }
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::ResetMenuHidingTimer(Bool_t show_menu)
+{
+   // Reset the timer for menu-bar hiding.
+
+   fMenuHidingTimer->TurnOff();
+
+   fMenuHidingShowMenu = show_menu;
+
+   fMenuHidingTimer->SetTime(fgMenuHidingTimeout);
+   fMenuHidingTimer->Reset();
+   fMenuHidingTimer->TurnOn();
+}
 
+//______________________________________________________________________________
+void TGLSAViewer::MenuHidingTimeout()
+{
+   // Action for menu-hiding timeout.
+
+   fMenuHidingTimer->TurnOff();
+   if (fMenuHidingShowMenu) {
+      fFrame->HideFrame(fMenuBut);
+      fFrame->ShowFrame(fMenuBar);
+   } else {
       fFrame->HideFrame(fMenuBar);
       fFrame->ShowFrame(fMenuBut);
-      fFrame->Layout();
    }
+   fFrame->Layout();
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::SetMenuHidingTimeout(Long_t timeout)
+{
+   // Set global timeout for menu-hiding in mili-seconds.
+   // Static function.
+
+   fgMenuHidingTimeout = timeout;
 }
 
 //______________________________________________________________________________
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLScene.cxx root/graf3d/gl/src/TGLScene.cxx
--- root-old/graf3d/gl/src/TGLScene.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLScene.cxx	2010-04-12 19:25:57.000000000 +0200
@@ -288,7 +288,7 @@
    // Destroy scene objects
    TakeLock(kModifyLock);
    ReleaseGLCtxIdentity();
-   DestroyPhysicals(kTRUE); // including modified
+   DestroyPhysicals();
    DestroyLogicals();
    if (fGLCtxIdentity)
       fGLCtxIdentity->ReleaseClient();
@@ -853,6 +853,7 @@
       if (drawNeeded)
       {
          rnrCtx.SetShapeLOD((*i)->fFinalLOD);
+         rnrCtx.SetShapePixSize((*i)->fPixelSize);
          glPushName(drawShape->ID());
          drawShape->Draw(rnrCtx);
          glPopName();
@@ -1114,46 +1115,34 @@
 }
 
 //______________________________________________________________________________
-Int_t TGLScene::DestroyPhysicals(Bool_t incModified, const TGLCamera* camera)
+Int_t TGLScene::DestroyPhysicals()
 {
-   // Destroy physical shapes that are no longer of interest to camera.
-   // If 'incModified' is true also the modified ones are deleted.
-   // Return count of number destroyed.
-
-   // !!! MT this whole concept is strange. Why should i keep
-   // physicals that are modified? There is no working update
-   // mechanism so they'll be wiped on pad-update.
-   // Maybe should rename the method, or what?
+   // Destroy physical shapes.
 
    if (fLock != kModifyLock) {
       Error("TGLScene::DestroyPhysicals", "expected ModifyLock");
       return 0;
    }
 
-   Int_t count = 0;
-   PhysicalShapeMapIt_t pit = fPhysicalShapes.begin();
-   while (pit != fPhysicalShapes.end())
+   // Loop over logicals -- it is much more efficient that way.
+   
+   UInt_t count = 0;
+
+   LogicalShapeMapIt_t lit = fLogicalShapes.begin();
+   while (lit != fLogicalShapes.end())
    {
-      const TGLPhysicalShape * physical = pit->second;
-      if (physical) {
-         // If modified options allow this physical to be destoyed
-         if (incModified || (!incModified && !physical->IsModified())) {
-            // and no camera is passed, or it is no longer of interest
-            // to camera
-            Bool_t ignoreSize = physical->GetLogical()->IgnoreSizeForOfInterest();
-            if (!camera || (camera && !camera->OfInterest(physical->BoundingBox(), ignoreSize)))
-            {
-               DestroyPhysicalInternal(pit++);
-               ++count;
-               continue; // Incremented the iterator during erase()
-            }
-         }
-      } else {
-         assert(kFALSE);
+      TGLLogicalShape *lshp = lit->second;
+      if (lshp && lshp->Ref() != 0)
+      {
+         count += lshp->Ref();
+         lshp->DestroyPhysicals();
       }
-      ++pit;
+      ++lit;
    }
 
+   assert (count == fPhysicalShapes.size());
+   fPhysicalShapes.clear();
+
    if (count > 0) {
       InvalidateBoundingBox();
       IncTimeStamp();
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLSceneBase.cxx root/graf3d/gl/src/TGLSceneBase.cxx
--- root-old/graf3d/gl/src/TGLSceneBase.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLSceneBase.cxx	2010-04-12 19:24:36.000000000 +0200
@@ -408,7 +408,6 @@
    TGLSceneInfo& sInfo = * rnrCtx.GetSceneInfo();
 
    rnrCtx.SetClip         (sInfo.LastClip());
-   rnrCtx.SetCamera       (sInfo.LastCamera());
    rnrCtx.SetCombiLOD     (sInfo.LastLOD());
    rnrCtx.SetSceneStyle   (sInfo.LastStyle());
    rnrCtx.SetSceneWFLineW (sInfo.LastWFLineW());
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLScenePad.cxx root/graf3d/gl/src/TGLScenePad.cxx
--- root-old/graf3d/gl/src/TGLScenePad.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLScenePad.cxx	2010-04-12 19:24:35.000000000 +0200
@@ -237,9 +237,9 @@
    }
 
    // Rebuilds can potentially invalidate all logical and
-   // physical shapes - including any modified physicals.
+   // physical shapes.
    // Physicals must be removed first.
-   destroyedPhysicals = DestroyPhysicals(kTRUE); // include modified
+   destroyedPhysicals = DestroyPhysicals();
    if (fSmartRefresh) {
       destroyedLogicals = BeginSmartRefresh();
    } else {
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLSurfacePainter.cxx root/graf3d/gl/src/TGLSurfacePainter.cxx
--- root-old/graf3d/gl/src/TGLSurfacePainter.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLSurfacePainter.cxx	2010-04-12 19:25:17.000000000 +0200
@@ -1,5 +1,5 @@
 #include <algorithm>
-#include <iostream>
+#include "Riostream.h"
 #include <cstdlib>
 #include <cctype>
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLUtil.cxx root/graf3d/gl/src/TGLUtil.cxx
--- root-old/graf3d/gl/src/TGLUtil.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLUtil.cxx	2010-04-12 19:26:03.000000000 +0200
@@ -270,12 +270,46 @@
 }
 
 //______________________________________________________________________________
+void TGLRect::Expand(Int_t x, Int_t y)
+{
+   // Expand the rect to encompass point (x,y)
+   Int_t delX = x - fX;
+   Int_t delY = y - fY;
+
+   if (delX > fWidth) {
+      fWidth = delX;
+   }
+   if (delY > fHeight) {
+      fHeight = delY;
+   }
+
+   if (delX < 0) {
+      fX = x;
+      fWidth += -delX;
+   }
+   if (delY < 0) {
+      fY = y;
+      fHeight += -delY;
+   }
+}
+
+//______________________________________________________________________________
+Int_t TGLRect::Diagonal() const
+{
+   // Return the diagonal of the rectangle.
+
+   const Double_t w = static_cast<Double_t>(fWidth);
+   const Double_t h = static_cast<Double_t>(fHeight);
+   return TMath::Nint(TMath::Sqrt(w*w + h*h));
+}
+
+//______________________________________________________________________________
 EOverlap TGLRect::Overlap(const TGLRect & other) const
 {
    // Return overlap result (kInside, kOutside, kPartial) of this
    // rect with 'other'
    if ((fX <= other.fX) && (fX + fWidth >= other.fX + other.fWidth) &&
-        (fY <= other.fY) && (fY +fHeight >= other.fY + other.fHeight)) {
+       (fY <= other.fY) && (fY +fHeight >= other.fY + other.fHeight)) {
       return kInside;
    }
    else if ((fX >= other.fX + static_cast<Int_t>(other.fWidth)) ||
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLViewer.cxx root/graf3d/gl/src/TGLViewer.cxx
--- root-old/graf3d/gl/src/TGLViewer.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLViewer.cxx	2010-04-12 19:24:38.000000000 +0200
@@ -15,7 +15,6 @@
 #include "TGLRnrCtx.h"
 #include "TGLSelectBuffer.h"
 #include "TGLLightSet.h"
-#include "TGLClip.h"
 #include "TGLManipSet.h"
 #include "TGLCameraOverlay.h"
 
@@ -119,7 +118,6 @@
 
    fLightSet          (0),
    fClipSet           (0),
-   fClipAutoUpdate    (kTRUE),
    fSelectedPShapeRef (0),
    fCurrentOvlElm     (0),
 
@@ -182,7 +180,6 @@
 
    fLightSet          (0),
    fClipSet           (0),
-   fClipAutoUpdate    (kTRUE),
    fSelectedPShapeRef (0),
    fCurrentOvlElm     (0),
 
@@ -471,6 +468,20 @@
 }
 
 //______________________________________________________________________________
+void TGLViewer::SetupClipObject()
+{
+   // Setup clip-object. Protected virtual method.
+
+   if (GetClipAutoUpdate())
+   {
+      fClipSet->SetupCurrentClip(fOverallBoundingBox);
+   }
+   else
+   {
+      fClipSet->SetupCurrentClipIfInvalid(fOverallBoundingBox);
+   }
+}
+//______________________________________________________________________________
 void TGLViewer::PreRender()
 {
    // Initialize objects that influence rendering.
@@ -494,11 +505,6 @@
 
    // Setup lighting
    fLightSet->StdSetupLights(fOverallBoundingBox, *fCamera, fDebugMode);
-   // Setup clip object.
-   if (fClipAutoUpdate)
-      fClipSet->SetupCurrentClip(fOverallBoundingBox);
-   else
-      fClipSet->SetupCurrentClipIfInvalid(fOverallBoundingBox);
 }
 
 //______________________________________________________________________________
@@ -532,8 +538,9 @@
       }
    }
 
+   TUnlocker ulck(this);
+
    if (fGLDevice == -1 && (fViewport.Width() <= 1 || fViewport.Height() <= 1)) {
-      ReleaseLock(kDrawLock);
       if (gDebug > 2) {
 	 Info("TGLViewer::DoDraw()", "zero surface area, draw skipped.");
       }
@@ -595,7 +602,6 @@
 
    MakeCurrent();
 
-   glDrawBuffer(GL_BACK);
    if (!fIsPrinting) PreDraw();
    PreRender();
 
@@ -737,6 +743,7 @@
 
    // End
    SwapBuffers();
+   glDrawBuffer(GL_BACK);
 }
 
 //______________________________________________________________________________
@@ -804,6 +811,8 @@
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    std::auto_ptr<TImage> image(TImage::Create());
 
    fRnrCtx->SetGrabImage(kTRUE, GL_BACK);
@@ -856,6 +865,8 @@
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    std::auto_ptr<TImage> image(TImage::Create());
 
    MakeCurrent();
@@ -1154,6 +1165,8 @@
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    MakeCurrent();
 
    fRnrCtx->BeginSelection(x, y, 3);
@@ -1193,7 +1206,12 @@
 //______________________________________________________________________________
 Bool_t TGLViewer::RequestSecondarySelect(Int_t x, Int_t y)
 {
-   // 
+   // Request secondary select.
+
+   if ( ! TakeLock(kSelectLock)) {
+      return kFALSE;
+   }
+
    if (!gVirtualX->IsCmdThread())
       return Bool_t(gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoSecondarySelect(%d, %d, %s)", this, x, y)));
    else
@@ -1205,20 +1223,25 @@
 {
    // Secondary selection.
 
-   GLint nHits = 1;
-   //glGetIntegerv(GL_RENDER, &nHits);
-   if ( nHits < 1 || ! fSelRec.GetSceneInfo() || ! fSelRec.GetPhysShape() ||
-         ! fSelRec.GetPhysShape()->GetLogical()->SupportsSecondarySelect())
+   if (CurrentLock() != kSelectLock) {
+      Error("TGLViewer::DoSecondarySelect", "expected kSelectLock, found %s", LockName(CurrentLock()));
+      return kFALSE;
+   }
+
+   TUnlocker ulck(this);
+
+   if (! fSelRec.GetSceneInfo() || ! fSelRec.GetPhysShape() ||
+       ! fSelRec.GetPhysShape()->GetLogical()->SupportsSecondarySelect())
    {
       if (gDebug > 0)
          Info("TGLViewer::SecondarySelect", "Skipping secondary selection "
-              "(nPrimHits=%d, sinfo=0x%lx, pshape=0x%lx).\n",
-              nHits, fSelRec.GetSceneInfo(), fSelRec.GetPhysShape());
+              "(sinfo=0x%lx, pshape=0x%lx).\n",
+              fSelRec.GetSceneInfo(), fSelRec.GetPhysShape());
       fSecSelRec.Reset();
       return kFALSE;
    }
 
-   TakeLock(kSelectLock);
+   MakeCurrent();
 
    TGLSceneInfo*    sinfo = fSelRec.GetSceneInfo();
    TGLSceneBase*    scene = sinfo->GetScene();
@@ -1312,6 +1335,8 @@
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    MakeCurrent();
 
    fRnrCtx->BeginSelection(x, y, 3);
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLViewerBase.cxx root/graf3d/gl/src/TGLViewerBase.cxx
--- root-old/graf3d/gl/src/TGLViewerBase.cxx	2010-04-12 19:15:44.000000000 +0200
+++ root/graf3d/gl/src/TGLViewerBase.cxx	2010-04-12 19:26:07.000000000 +0200
@@ -16,6 +16,7 @@
 
 #include "TGLRnrCtx.h"
 #include "TGLCamera.h"
+#include "TGLClip.h"
 #include "TGLOverlay.h"
 #include "TGLSelectBuffer.h"
 #include "TGLSelectRecord.h"
@@ -182,6 +183,21 @@
       return 0;
 }
 
+//______________________________________________________________________________
+TGLLogicalShape* TGLViewerBase::FindLogicalInScenes(TObject* id)
+{
+   // Find logical-shape representing object id in the list of scenes.
+   // Return 0 if not found.
+
+   for (SceneInfoList_i i=fScenes.begin(); i!=fScenes.end(); ++i)
+   {
+      TGLLogicalShape *lshp = (*i)->GetScene()->FindLogical(id);
+      if (lshp)
+         return lshp;
+   }
+   return 0;
+}
+
 //______________________________________________________________________
 void TGLViewerBase::AddOverlayElement(TGLOverlayElement* el)
 {
@@ -270,6 +286,17 @@
 // Rendering / selection virtuals
 /**************************************************************************/
 
+//______________________________________________________________________________
+void TGLViewerBase::SetupClipObject()
+{
+   // Setup clip-object. Protected virtual method.
+
+   if (fClip)
+   {
+      fClip->Setup(fOverallBoundingBox);
+   }
+}
+
 //______________________________________________________________________
 void TGLViewerBase::PreRender()
 {
@@ -331,6 +358,7 @@
    }
 
    fCamera->Apply(fOverallBoundingBox, fRnrCtx->GetPickRectangle());
+   SetupClipObject();
 
    // Make precursory selection of visible scenes.
    // Only scene bounding-box .vs. camera frustum check performed.
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/inc/TGShutter.h root/gui/gui/inc/TGShutter.h
--- root-old/gui/gui/inc/TGShutter.h	2010-04-12 19:15:49.000000000 +0200
+++ root/gui/gui/inc/TGShutter.h	2010-04-12 19:25:48.000000000 +0200
@@ -82,6 +82,8 @@
    Int_t           fHeightIncrement;        // Height delta
    Int_t           fClosingHeight;          // Closing items current height
    Int_t           fClosingHadScrollbar;    // Closing item had a scroll bar
+   UInt_t          fDefWidth;               // Default width
+   UInt_t          fDefHeight;              // Default height
 
 private:
    TGShutter(const TGShutter&);             // not implemented
@@ -105,6 +107,9 @@
    virtual void   SetSelectedItem(const char *name);
    virtual void   EnableItem(const char *name, Bool_t on = kTRUE);
 
+   virtual TGDimension GetDefaultSize() const;
+   virtual void        SetDefaultSize(UInt_t w, UInt_t h);
+
    virtual void   SavePrimitive(ostream &out, Option_t *option = "");
 
    virtual Bool_t ProcessMessage(Long_t cmd, Long_t parm1, Long_t parm2);
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/inc/TGTextEntry.h root/gui/gui/inc/TGTextEntry.h
--- root-old/gui/gui/inc/TGTextEntry.h	2010-04-12 19:15:49.000000000 +0200
+++ root/gui/gui/inc/TGTextEntry.h	2010-04-12 19:25:47.000000000 +0200
@@ -73,6 +73,8 @@
    EInsertMode       fInsertMode;        // *OPTION={GetMethod="GetInsertMode";SetMethod="SetInsertMode";Items=(kInsert="Insert",kReplace="Replace")}*
    ETextJustification fAlignment;        // *OPTION={GetMethod="GetAlignment";SetMethod="SetAlignment";Items=(kTextLeft="Left",kTextCenterX="Center",kTextRight="Right")}*
    Bool_t            fHasOwnFont;        // kTRUE - font defined locally,  kFALSE - globally
+   UInt_t            fDefWidth;          // default width
+   UInt_t            fDefHeight;         // default height
 
             void        CopyText() const;
    virtual  void        DoRedraw();
@@ -112,6 +114,9 @@
 
    virtual ~TGTextEntry();
 
+   virtual  TGDimension GetDefaultSize() const;
+   virtual  void        SetDefaultSize(UInt_t w, UInt_t h);
+
    virtual  void        AppendText(const char *text);
             void        Backspace();
             void        Clear(Option_t *option="");
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/inc/TRootContextMenu.h root/gui/gui/inc/TRootContextMenu.h
--- root-old/gui/gui/inc/TRootContextMenu.h	2010-04-12 19:15:49.000000000 +0200
+++ root/gui/gui/inc/TRootContextMenu.h	2010-04-12 19:24:22.000000000 +0200
@@ -56,6 +56,7 @@
    virtual Bool_t HandleCrossing(Event_t *event);
    virtual Bool_t HandleMotion(Event_t *event);
    virtual void   OnlineHelp();
+   virtual void   RecursiveRemove(TObject *obj);
 
    Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2);
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/src/TGFont.cxx root/gui/gui/src/TGFont.cxx
--- root-old/gui/gui/src/TGFont.cxx	2010-04-12 19:15:48.000000000 +0200
+++ root/gui/gui/src/TGFont.cxx	2010-04-12 19:24:17.000000000 +0200
@@ -2610,7 +2610,8 @@
    lastChar = 0xff; //fontStruct->max_char_or_byte2;
 
    for (i = 0; i < 256; i++) {
-      if ((i == 0177) || (i < firstChar) || (i > lastChar)) {
+      if ((i == 160) || (i == 173) || (i == 177) || 
+          (i < firstChar) || (i > lastChar)) {
          newFont->fTypes[i] = kCharReplace;
       } else {
          newFont->fTypes[i] = kCharNormal;
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/src/TGShutter.cxx root/gui/gui/src/TGShutter.cxx
--- root-old/gui/gui/src/TGShutter.cxx	2010-04-12 19:15:48.000000000 +0200
+++ root/gui/gui/src/TGShutter.cxx	2010-04-12 19:25:48.000000000 +0200
@@ -44,6 +44,8 @@
    fTimer               = 0;
    fTrash               = new TList;
 
+   fDefWidth = fDefHeight = 0;
+
    // layout manager is not used
    delete fLayoutManager;
    fLayoutManager = 0;
@@ -312,6 +314,25 @@
    return item;
 }
 
+//______________________________________________________________________________
+TGDimension TGShutter::GetDefaultSize() const
+{
+   // Return the default / minimal size of the widget.
+
+   UInt_t w = (GetOptions() & kFixedWidth)  || (fDefWidth  == 0) ? fWidth  : fDefWidth;
+   UInt_t h = (GetOptions() & kFixedHeight) || (fDefHeight == 0) ? fHeight : fDefHeight;
+   return TGDimension(w, h);
+}
+
+//______________________________________________________________________________
+void TGShutter::SetDefaultSize(UInt_t w, UInt_t h)
+{
+   // Set the default / minimal size of the widget.
+
+   fDefWidth  = w;
+   fDefHeight = h;
+}
+
 
 //______________________________________________________________________________
 TGShutterItem::TGShutterItem(const TGWindow *p, TGHotString *s, Int_t id,
@@ -419,6 +440,11 @@
    out << GetName() << " = new TGShutter(" << fParent->GetName() << ","
        << GetOptionString() << ");" << endl;
 
+   if ((fDefWidth > 0) || (fDefHeight > 0)) {
+      out << "   " << GetName() << "->SetDefaultSize(";
+      out << fDefWidth << "," << fDefHeight << ");" << endl;
+   }
+
    if (!fList) return;
 
    TGFrameElement *el;
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/src/TGTextEntry.cxx root/gui/gui/src/TGTextEntry.cxx
--- root-old/gui/gui/src/TGTextEntry.cxx	2010-04-12 19:15:48.000000000 +0200
+++ root/gui/gui/src/TGTextEntry.cxx	2010-04-12 19:25:55.000000000 +0200
@@ -335,6 +335,7 @@
    fEchoMode = kNormal;
    fAlignment= kTextLeft;
    fInsertMode = kInsert;
+   fDefWidth = fDefHeight = 0;
 
    int tw, max_ascent, max_descent;
    tw = gVirtualX->TextWidth(fFontStruct, GetText(), fText->GetTextLength());
@@ -375,6 +376,25 @@
 }
 
 //______________________________________________________________________________
+TGDimension TGTextEntry::GetDefaultSize() const
+{
+   // Return the default / minimal size of the widget.
+
+   UInt_t w = (GetOptions() & kFixedWidth)  || (fDefWidth  == 0) ? fWidth  : fDefWidth;
+   UInt_t h = (GetOptions() & kFixedHeight) || (fDefHeight == 0) ? fHeight : fDefHeight;
+   return TGDimension(w, h);
+}
+
+//______________________________________________________________________________
+void TGTextEntry::SetDefaultSize(UInt_t w, UInt_t h)
+{
+   // Set the default / minimal size of the widget.
+
+   fDefWidth  = w;
+   fDefHeight = h;
+}
+
+//______________________________________________________________________________
 void TGTextEntry::ReturnPressed()
 {
    // This signal is emitted when the return or enter key is pressed.
@@ -1851,6 +1871,11 @@
    out << "   " << GetName() << "->Resize("<< GetWidth() << "," << GetName()
        << "->GetDefaultHeight());" << endl;
 
+   if ((fDefWidth > 0) || (fDefHeight > 0)) {
+      out << "   " << GetName() << "->SetDefaultSize(";
+      out << fDefWidth << "," << fDefHeight << ");" << endl;
+   }
+
    if (fTip) {
       TString tiptext = fTip->GetText()->GetString();
       tiptext.ReplaceAll("\n", "\\n");
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/src/TRootContextMenu.cxx root/gui/gui/src/TRootContextMenu.cxx
--- root-old/gui/gui/src/TRootContextMenu.cxx	2010-04-12 19:15:48.000000000 +0200
+++ root/gui/gui/src/TRootContextMenu.cxx	2010-04-12 19:24:22.000000000 +0200
@@ -67,6 +67,7 @@
    fDialog  = 0;
    fTrash = new TList;
 
+   gROOT->GetListOfCleanups()->Add(this);
    // Context menu handles its own messages
    Associate(this);
 }
@@ -76,6 +77,7 @@
 {
    // Delete a context menu.
 
+   gROOT->GetListOfCleanups()->Remove(this);
    delete fDialog;
    if (fTrash) fTrash->Delete();
    delete fTrash;
@@ -392,7 +394,7 @@
 
    Int_t selfobjpos;
 
-   if (!function) return;
+   if (!function || !object) return;
 
    // Position, if it exists, of the argument that correspond to the object itself
    if (fContextMenu->GetSelectedMenuItem())
@@ -754,3 +756,25 @@
 
    return kTRUE;
 }
+
+//______________________________________________________________________________
+void TRootContextMenu::RecursiveRemove(TObject *obj)
+{
+   // Close the context menu if the object is deleted in the
+   // RecursiveRemove() operation.
+
+   void *ud;
+   if (obj == fContextMenu->GetSelectedCanvas())
+      fContextMenu->SetCanvas(0);
+   if (obj == fContextMenu->GetSelectedPad())
+      fContextMenu->SetPad(0);
+   if (obj == fContextMenu->GetSelectedObject()) {
+      // if the object being deleted is the one selected,
+      // ungrab the mouse pointer and terminate (close) the menu
+      fContextMenu->SetObject(0);
+      if (fHasGrab) 
+         gVirtualX->GrabPointer(0, 0, 0, 0, kFALSE);
+      EndMenu(ud);
+   }
+}
+
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/icons/eve_line.xpm root/icons/eve_line.xpm
--- root-old/icons/eve_line.xpm	1970-01-01 01:00:00.000000000 +0100
+++ root/icons/eve_line.xpm	2010-04-12 19:24:51.000000000 +0200
@@ -0,0 +1,33 @@
+/* XPM */
+static char * eve_line_xpm[] = {
+"16 16 14 1",
+" 	c None",
+".	c #FFFFFF",
+"+	c #655D85",
+"@	c #7D7698",
+"#	c #D9D7E1",
+"$	c #A8A3BA",
+"%	c #70688E",
+"&	c #EBEAEF",
+"*	c #908AA7",
+"=	c #BEBBCC",
+"-	c #908AA8",
+";	c #817A9B",
+">	c #CECBD8",
+",	c #6B638A",
+".............+..",
+"............@#..",
+"...........$$...",
+"..........$$....",
+".........#@.....",
+".........%&.....",
+"........*=......",
+".......$$.......",
+"......=-........",
+".....&%.........",
+".....;>.........",
+"....*=..........",
+"...=-...........",
+"..>;............",
+".&@&............",
+".,$............."};
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/tutorials/eve/alice_vsd.C root/tutorials/eve/alice_vsd.C
--- root-old/tutorials/eve/alice_vsd.C	2010-04-12 19:15:16.000000000 +0200
+++ root/tutorials/eve/alice_vsd.C	2010-04-12 19:25:27.000000000 +0200
@@ -289,6 +289,7 @@
       // !!!! Need to store field on file !!!!
       // Can store TEveMagField ?
       trkProp->SetMagField(0.5);
+      trkProp->SetStepper(TEveTrackPropagator::kRungeKutta);
 
       Int_t nTracks = fVSD->fTreeR->GetEntries();
       for (Int_t n = 0; n < nTracks; ++n)
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/tutorials/eve/box.C root/tutorials/eve/box.C
--- root-old/tutorials/eve/box.C	1970-01-01 01:00:00.000000000 +0100
+++ root/tutorials/eve/box.C	2010-04-12 19:25:21.000000000 +0200
@@ -0,0 +1,28 @@
+// @(#)root/eve:$Id: root-5.26.00b-fireworks1.patch,v 1.2 2010/10/09 09:42:53 eulisse Exp $
+// Author: Matevz Tadel
+
+// Demonstrates usage of TEveBox class.
+
+
+TEveBox* box(Float_t a=10, Float_t d=5, Float_t x=0, Float_t y=0, Float_t z=0)
+{
+   TEveManager::Create();
+
+   TRandom& r = * gRandom;
+
+   TEveBox* b = new TEveBox;
+   b->SetMainColor(kCyan);
+   b->SetMainTransparency(0);
+
+   b->SetVertex(0, x - a + r.Uniform(-d, d), y - a + r.Uniform(-d, d), z - a + r.Uniform(-d, d));
+   b->SetVertex(1, x - a + r.Uniform(-d, d), y + a + r.Uniform(-d, d), z - a + r.Uniform(-d, d));
+   b->SetVertex(2, x + a + r.Uniform(-d, d), y + a + r.Uniform(-d, d), z - a + r.Uniform(-d, d));
+   b->SetVertex(3, x + a + r.Uniform(-d, d), y - a + r.Uniform(-d, d), z - a + r.Uniform(-d, d));
+   b->SetVertex(4, x - a + r.Uniform(-d, d), y - a + r.Uniform(-d, d), z + a + r.Uniform(-d, d));
+   b->SetVertex(5, x - a + r.Uniform(-d, d), y + a + r.Uniform(-d, d), z + a + r.Uniform(-d, d));
+   b->SetVertex(6, x + a + r.Uniform(-d, d), y + a + r.Uniform(-d, d), z + a + r.Uniform(-d, d));
+   b->SetVertex(7, x + a + r.Uniform(-d, d), y - a + r.Uniform(-d, d), z + a + r.Uniform(-d, d));
+
+   gEve->AddElement(b);
+   gEve->Redraw3D(kTRUE);
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/tutorials/eve/boxset.C root/tutorials/eve/boxset.C
--- root-old/tutorials/eve/boxset.C	2010-04-12 19:15:16.000000000 +0200
+++ root/tutorials/eve/boxset.C	2010-04-12 19:24:48.000000000 +0200
@@ -69,3 +69,33 @@
 
    return q;
 }
+
+TEveBoxSet* boxset_single_color(Float_t x=0, Float_t y=0, Float_t z=0,
+                                Int_t num=100, Bool_t register=kTRUE)
+{
+   TEveManager::Create();
+
+   TRandom r(0);
+
+   TEveBoxSet* q = new TEveBoxSet("BoxSet");
+   q->UseSingleColor();
+   q->SetMainColor(kCyan-2);
+   q->SetMainTransparency(50);
+   q->Reset(TEveBoxSet::kBT_AABox, kFALSE, 64);
+   for (Int_t i=0; i<num; ++i) {
+      q->AddBox(r.Uniform(-10, 10), r.Uniform(-10, 10), r.Uniform(-10, 10),
+                r.Uniform(0.2, 1),  r.Uniform(0.2, 1),  r.Uniform(0.2, 1));
+   }
+   q->RefitPlex();
+
+   TEveTrans& t = q->RefMainTrans();
+   t.SetPos(x, y, z);
+
+   if (register)
+   {
+      gEve->AddElement(q);
+      gEve->Redraw3D(kTRUE);
+   }
+
+   return q;
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/tutorials/eve/geom_alice_its.C root/tutorials/eve/geom_alice_its.C
--- root-old/tutorials/eve/geom_alice_its.C	2010-04-12 19:15:16.000000000 +0200
+++ root/tutorials/eve/geom_alice_its.C	2010-04-12 19:26:09.000000000 +0200
@@ -3,6 +3,16 @@
 
 // Shows geometry of ALICE ITS.
 
+#include "TEveManager.h"
+#include "TEveGeoNode.h"
+
+#include "TGeoManager.h"
+#include "TGeoNode.h"
+#include "TGeoVolume.h"
+#include "TGeoMedium.h"
+
+#include "TString.h"
+
 void geom_alice_its()
 {
    TEveManager::Create();
@@ -15,3 +25,81 @@
 
    gEve->Redraw3D(kTRUE);
 }
+
+
+//==============================================================================
+// Demonstrate extraction of volumes matching certain criteria.
+//==============================================================================
+
+// Should be run in compiled mode -- CINT has issues with recursion.
+//
+// 1. Creation:
+//    root
+//      .L geom_alice_its.C+
+//      extract_ssd_modules()
+//      .q
+//    This creates file "test-extract.root" in current dir.
+//
+// 2. Viewing:
+//    root
+//      .x show_extract.C("test-extract.root")
+
+TEveGeoNode* descend_extract(TGeoNode* node)
+{
+   // We only return something if:
+   // - this is a node of interest;
+   // - one of the daughters returns something of interest.
+
+   const TString material("ITS_SI$");
+
+   TEveGeoNode *res = 0;
+
+   TGeoMedium *medium = node->GetVolume()->GetMedium();
+   if (medium && material == medium->GetName())
+   {
+      // Node of interest - instantiate eve representation and return.
+      res = new TEveGeoNode(node);
+      return res;
+   }
+
+   Int_t nd = node->GetNdaughters();
+   for (Int_t i = 0; i < nd; ++i)
+   {
+      TEveGeoNode *ed = descend_extract(node->GetDaughter(i));
+
+      if (ed)
+      {
+         if (res == 0) res = new TEveGeoNode(node);
+         res->AddElement(ed);
+      }
+   }
+
+   return res;
+}
+
+void extract_ssd_modules()
+{
+   const TString kEH("extract_ssd_modules");
+
+   TEveManager::Create();
+
+   gGeoManager = gEve->GetGeometry("http://root.cern.ch/files/alice.root");
+
+   Bool_t s = gGeoManager->cd("/ITSV_1/ITSD_1/IT56_1");
+   if (!s) {
+      Error(kEH, "Start node not found.");
+      return;
+   }
+
+   TGeoNode *node = gGeoManager->GetCurrentNode();
+
+   TEveGeoNode *egn = descend_extract(node);
+
+   if (egn == 0)
+   {
+      Warning(kEH, "No matching nodes found.");
+      return;
+   }
+
+   egn->SaveExtract("test-extract.root", "AliSDD", kTRUE);
+}
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/tutorials/eve/pointset.C root/tutorials/eve/pointset.C
--- root-old/tutorials/eve/pointset.C	2010-04-12 19:15:16.000000000 +0200
+++ root/tutorials/eve/pointset.C	2010-04-12 19:24:42.000000000 +0200
@@ -10,6 +10,7 @@
 #include <TEveRGBAPalette.h>
 #include <TColor.h>
 #include <TRandom.h>
+#include <TMath.h>
 
 #endif
 
diff -Naur -I '@(#)root' -I '// Author' -I '\$Id' root-old/tutorials/eve/track.C root/tutorials/eve/track.C
--- root-old/tutorials/eve/track.C	2010-04-12 19:15:16.000000000 +0200
+++ root/tutorials/eve/track.C	2010-04-12 19:24:33.000000000 +0200
@@ -27,6 +27,7 @@
 
 #include "TEveTrackPropagator.h"
 #include "TEveTrack.h"
+#include "TEveVSDStructs.h"
 #include "TEveManager.h"
 #include "TEveViewer.h"
 #include "TSystem.h"
