diff -Naur orig.root/reflex/python/genreflex/gendict.py root/reflex/python/genreflex/gendict.py
--- orig.root/reflex/python/genreflex/gendict.py	2008-02-21 17:38:28.000000000 +0100
+++ root/reflex/python/genreflex/gendict.py	2008-11-12 23:55:40.000000000 +0100
@@ -7,12 +7,12 @@
 # This software is provided "as is" without express or implied warranty.
 
 import xml.parsers.expat
-import os, sys, string, time
+import os, sys, string, time, re
 import gccdemangler
 
 class genDictionary(object) :
 #----------------------------------------------------------------------------------
-  def __init__(self, hfile, opts):
+  def __init__(self, hfile, opts, gccxmlvers):
     self.classes    = []
     self.namespaces = []
     self.typeids    = []
@@ -37,7 +37,7 @@
     self.cppEnumSelect     = {}
     self.cppFunctionSelect = {}
     self.last_id    = ''
-    self.transtable = string.maketrans('<>&*,: ().$-', '__rp__s___dm')
+    self.transtable = string.maketrans('<>&*,: ().$-[]', '__rp__s___dm__')
     self.ignoremeth = ('rbegin', 'rend', '_Eq','_Lt', 'value_comp')
     self.x_id       = iter(xrange(sys.maxint))
     self.errors     = 0
@@ -46,13 +46,54 @@
     self.iocomments     = opts.get('iocomments', False)
     self.no_membertypedefs  = opts.get('no_membertypedefs', False)
     self.generated_shadow_classes = []
-    self.selectionname      = 'ROOT::Reflex::Selection'
+    self.selectionname      = 'Reflex::Selection'
     self.unnamedNamespaces = []
     self.globalNamespaceID = ''
+    self.typedefs_for_usr = []
+    self.gccxmlvers = gccxmlvers
     # The next is to avoid a known problem with gccxml that it generates a
     # references to id equal '_0' which is not defined anywhere
     self.xref['_0'] = {'elem':'Unknown', 'attrs':{'id':'_0','name':''}, 'subelems':[]}
 #----------------------------------------------------------------------------------
+  def addTemplateToName(self, attrs):
+    if attrs['name'].find('>') == -1 and 'demangled' in attrs :
+      # check whether this method is templated; GCCXML will
+      # not pass the real name foo<int> but only foo"
+      demangled = attrs['demangled']
+      posargs = demangled.rfind('(')
+      if posargs and posargs > 1 \
+             and demangled[posargs - 1] == '>' \
+             and (demangled[posargs - 2].isalnum() \
+                  or demangled[posargs - 2] == '_') :
+        posname = demangled.find(attrs['name'] + '<');
+        if posname :
+          reui = re.compile('\\b(unsigned)(\\s+)?([^\w\s])')
+          name1 = demangled[posname : posargs]
+          attrs['name'] = reui.sub('unsigned int\\3', name1)
+#----------------------------------------------------------------------------------
+  def patchTemplateName(self, attrs, elem):
+    if 'name' not in attrs: return
+    name = attrs['name']
+    postmpltend = name.rfind('>')
+    if postmpltend != -1 :
+      # check whether this entity is templated and extract the template parameters
+      postmpltend = len(name)
+      if elem in ('Function','OperatorFunction','Constructor','Method','OperatorMethod'):
+        postmpltend = name.rfind('(')
+      postmplt = -1
+      if postmpltend and postmpltend > 1 \
+               and name[postmpltend - 1] == '>':
+        postmplt = name.find('<')
+      if postmplt != -1:
+        postmplt += 1
+        postmpltend -= 1
+        # replace template argument "12u" by "12":
+        rep = re.sub(r"\b([\d]+)u\b", '\\1', name[postmplt:postmpltend])
+        # replace -0x00000000000000001 by -1
+        rep = re.sub(r"-0x0*([1-9A-Fa-f][0-9A-Fa-f]*)\b", '-\\1', rep)
+        name = name[:postmplt] + rep + name[postmpltend:]
+        attrs['name'] = name
+#----------------------------------------------------------------------------------
   def start_element(self, name, attrs):
     if 'id' in attrs :
       self.xref[attrs['id']] = {'elem':name, 'attrs':attrs, 'subelems':[]}
@@ -63,18 +104,25 @@
       if not 'bases' in self.xref[self.last_id] : self.xref[self.last_id]['bases'] = []
       self.xref[self.last_id]['bases'].append(attrs)       
     elif name in ('Class','Struct') :
+      self.patchTemplateName(attrs, name)
       self.classes.append(attrs)
     elif name in ('Function',) :
+      self.addTemplateToName(attrs)
+      self.patchTemplateName(attrs, name)
       self.functions.append(attrs)
     elif name in ('Enumeration',) :
       self.enums.append(attrs)
     elif name in ('Variable',) :
       self.variables.append(attrs)
     elif name in ('OperatorFunction',) :
+      self.patchTemplateName(attrs, name)
       attrs['operator'] = 'true'
+      self.addTemplateToName(attrs)
       self.functions.append(attrs)
     elif name in ('Constructor','Method','OperatorMethod') :
       if 'name' in attrs and attrs['name'][0:3] != '_ZT' :
+        self.addTemplateToName(attrs)
+        self.patchTemplateName(attrs, name)
         self.methods.append(attrs)
     elif name == 'Namespace' :
       self.namespaces.append(attrs)
@@ -320,8 +368,11 @@
             catt = c['attrs']
             catt['extra'] = match[0]
             if catt not in selec :
-              print '--->> genreflex: INFO: Using typedef %s to select class %s' % (self.genTypeName(t['id']), self.genTypeName(catt['id']))
+              t['fullname'] = self.genTypeName(t['id'])
+              if not self.quiet:
+                print '--->> genreflex: INFO: Using typedef %s to select class %s' % (t['fullname'], self.genTypeName(catt['id']))
               selec.append(catt)
+              self.typedefs_for_usr.append(t)
       if self.resolvettd :
         newselector = self.resolveSelectorTypedefs( self.selector.sel_classes )
         if newselector:
@@ -335,6 +386,10 @@
               c['extra'] = match[0]
               if c not in selec : selec.append(c)
               if n == 'name' : self.genFakeTypedef(c['id'], match[0]['o_name'])
+      # Filter STL implementation specific classes
+      selec =  filter( lambda c: c.has_key('name'), selec)  # unamed structs and unions
+      # Filter internal GCC classes
+      selec =  filter( lambda c: c['name'].find('_type_info_pseudo') == -1, selec)
       return self.autosel (selec)
     else : self.selector = None
     local = filter(self.filefilter, self.classes)
@@ -349,8 +404,10 @@
     else :
       classes =  clean( local + typed + templ )
     # Filter STL implementation specific classes
-    classes =  filter( lambda c: self.genTypeName(c['id'])[:6] != 'std::_' ,classes)
-    classes =  filter( lambda c: c['name'][:2] != '._' ,classes)  # unamed structs and unions
+    classes =  filter( lambda c: self.genTypeName(c['id'])[:6] != 'std::_', classes)
+    classes =  filter( lambda c: c.has_key('name'), classes)  # unamed structs and unions
+    # Filter internal GCC classes
+    classes =  filter( lambda c: c['name'].find('_type_info_pseudo') == -1, classes)
     return self.autosel( classes )
  #----------------------------------------------------------------------------------
   def autosel(self, classes):
@@ -427,9 +484,20 @@
         types.append(attrs['id'])
         if 'members' in attrs :
           for m in attrs['members'].split() :
-            if self.xref[m]['elem'] == 'Field' :
-              type = self.xref[m]['attrs']['type']
+            xref = self.xref[m]
+            if xref['elem'] in ['Field','Typedef'] and xref['attrs']['access']=="public":
+              type = xref['attrs']['type']
               self.getdependent(type, types)
+	    elif xref['elem'] in ['Method','OperatorMethod','Constructor'] \
+                     and self.isMethodReallyPublic(m):
+              if 'returns' in xref['attrs']:
+                type = xref['attrs']['returns']
+                self.getdependent(type, types)
+	      for arg in  xref['subelems']:
+		  type = arg['type']
+		  self.getdependent(type, types)
+	    else:
+	      pass #print "Doing nothing for element:", self.xref[m]['elem']
         if 'bases' in attrs :
           for b in attrs['bases'].split() :
             if b[:10] == 'protected:' : b = b[10:]
@@ -453,27 +521,55 @@
       if ap : l2.append(x)
     return l2
 #----------------------------------------------------------------------------------
-  def generate(self, file, selclasses, selfunctions, selenums, selvariables, cppinfo) :
+  def generate(self, file, selclasses, selfunctions, selenums, selvariables, cppinfo, ioReadRules = None, ioReadRawRules = None) :
     for c in selclasses :  c['fullname'] = self.genTypeName(c['id'])
     selclasses = self.sortselclasses(selclasses)
     names = []
     f = open(file,'w') 
     f.write(self.genHeaders(cppinfo))
+
+    #------------------------------------------------------------------------------
+    # Process includes relevent to the IO rules
+    #------------------------------------------------------------------------------
+    if ioReadRules or ioReadRawRules:
+      f.write( '#include "TBuffer.h"\n' )
+      f.write( '#include "TVirtualObject.h"\n' )
+      f.write( '#include <vector>\n' )
+      f.write( '#include "TSchemaHelper.h"\n\n' )
+
+      includes = self.getIncludes( ioReadRules, ioReadRawRules )
+      for inc in includes:
+        f.write( '#include <%s>\n' % (inc,) )
+      f.write( '\n' )
+
     f_buffer = ''
     f_shadow =  '\n// Shadow classes to obtain the data member offsets \n'
     f_shadow += 'namespace __shadow__ {\n'
     for c in selclasses :
       if 'incomplete' not in c :
-        if not self.quiet : print  'class '+ c['fullname']
-        names.append(c['fullname'])
+        className = c['fullname']
+        if not self.quiet : print  'class '+ className
+
+        #--------------------------------------------------------------------------
+        # Get the right io rules
+        #--------------------------------------------------------------------------
+        clReadRules = None
+        if ioReadRules and ioReadRules.has_key( className ):
+          clReadRules = ioReadRules[className]
+        clReadRawRules = None
+        if ioReadRawRules and ioReadRawRules.has_key( className ):
+          clReadRawRules = ioReadRawRules[className]
+
+        names.append(className)
         self.completeClass( c )
         self.enhanceClass( c )
-        scons, stubs   = self.genClassDict( c )
+        scons, stubs   = self.genClassDict( c, clReadRules, clReadRawRules )
         f_buffer += stubs
         f_buffer += scons
         f_shadow += self.genClassShadow(c)
     f_shadow += '}\n\n'
     f_buffer += self.genFunctionsStubs( selfunctions )
+    f_buffer += ClassDefImplementation(selclasses, self)
     f_buffer += self.genInstantiateDict(selclasses, selfunctions, selenums, selvariables)
     f.write('namespace {\n')
     f.write(self.genNamespaces(selclasses + selfunctions + selenums + selvariables))
@@ -556,6 +652,11 @@
     if 'context' in attrs :
       if 'abstract' in self.xref[attrs['context']]['attrs'] : 
         if elem in ('Constructor',) : return 0
+
+    if elem in ['Method', 'Constructor', 'OperatorMethod']:
+      if self.hasNonPublicArgs(args):
+        print "censoring method:",attrs['name']
+        return 0
     #----Filter using the exclusion list in the selection file
     if self.selector and 'name' in attrs and  elem in ('Constructor','Destructor','Method','OperatorMethod','Converter') :
       context = self.genTypeName(attrs['context'])
@@ -564,15 +665,56 @@
       if self.selector.excmethod(self.genTypeName(attrs['context']), attrs['name'], demangledMethod ) : return 0
     return 1
 #----------------------------------------------------------------------------------
+  def isMethodReallyPublic(self,id):
+    """isMethodReallyPublic checks the accessibility of the method as well as the accessibility of the types
+    of arguments and return value. This is needed because C++ allows methods in a public section to be defined
+    from types defined in a private/protected section.
+    """
+    xref = self.xref[id]
+    attrs = xref['attrs']
+    return (attrs['access'] == "public"
+            and
+            (not self.hasNonPublicArgs(xref['subelems'])) 
+            and
+            (not 'returns' in attrs or self.isTypePublic(attrs['returns'])))
+#----------------------------------------------------------------------------------
+  def hasNonPublicArgs(self,args):
+    """hasNonPublicArgs will process a list of method arguments to check that all the referenced arguments in there are publically available (i.e not defined using protected or private types)."""
+    for arg in args:
+      type = arg["type"]
+      public = self.isTypePublic(type)
+      if public == 0:
+        return 1
+    return 0
+#----------------------------------------------------------------------------------
+  def isTypePublic(self, id):
+    type_dict = self.xref[id]
+
+    if type_dict['elem'] in ['PointerType','Typedef', 'ReferenceType', 'CvQualifiedType']:
+      return self.isTypePublic(type_dict['attrs']['type'])
+    elif type_dict['elem'] in ['FundamentalType']:
+      return 1
+    elif type_dict['elem'] in ['Class','Struct']:
+      access=type_dict['attrs'].get('access')
+      if access and access != 'public':
+        return 0
+      else:
+        return 1
+    else:
+      return 1
+      #raise "Unknown type category in isTypePublic",type_dict['elem']
+#----------------------------------------------------------------------------------
   def tmplclasses(self, local):
+    import re
     result = []
+    lc_patterns = map(lambda lc: re.compile("\\b%s\\b" % lc['name']) , local)
     for c in self.classes :
       if not 'name' in c: continue
       name = c['name']
       if name.find('<') == -1 : continue
       temp = name[name.find('<')+1:name.rfind('>')]
-      for lc in local :
-        if temp.find(lc['name']) != -1 : result.append(c)
+      for lc_pattern in lc_patterns :
+        if lc_pattern.match(temp) : result.append(c)
     return result
 #----------------------------------------------------------------------------------
   def typedefclasses(self):
@@ -651,11 +793,12 @@
     if (gccxmlinfo) : c += '/*\n%s*/\n\n' % gccxmlinfo
     c += '#ifdef _WIN32\n'
     c += '#pragma warning ( disable : 4786 )\n'
+    c += '#pragma warning ( disable : 4345 )\n'
     c += '#endif\n'
     c += '#include "%s"\n' % self.hfile
     c += '#include "Reflex/Builder/ReflexBuilder.h"\n'
     c += '#include <typeinfo>\n'
-    c += 'using namespace ROOT::Reflex;\n\n'
+    c += 'using namespace ::Reflex;\n\n'
     return c
 #----------------------------------------------------------------------------------
   def genInstantiateDict( self, selclasses, selfunctions, selenums, selvariables) :
@@ -676,13 +819,232 @@
     c += '  static Dictionaries instance;\n}\n'
     return c
 #---------------------------------------------------------------------------------
+  def processIoRules( self, rules, listname ):
+    sc = ''
+    i = 0
+    for rule in rules:
+      attrs = rule['attrs']
+      sc += '  rule = &%s[%d];\n' %(listname, i)
+      i += 1
+
+      sc += '  rule->fSourceClass = "%s";\n' % (attrs['sourceClass'],)
+
+      if attrs.has_key( 'target' ):
+        sc += '  rule->fTarget      = "%s";\n' % (attrs['target'],)
+
+      if attrs.has_key( 'source' ):
+        sc += '  rule->fSource      = "%s";\n' % (attrs['source'],)
+        
+      if rule.has_key( 'funcname' ):
+        sc += '  rule->fFunctionPtr = (void *)%s;\n' % (rule['funcname'],)
+        sc += '  rule->fCode        = "%s";\n' % (rule['code'].replace( '\n', '\\n' ), )
+
+      if attrs.has_key( 'version' ):
+        sc += '  rule->fVersion     = "%s";\n' % (attrs['version'],)
+
+      if attrs.has_key( 'checksum' ):
+        sc += '  rule->fChecksum    = "%s";\n' % (attrs['checksum'],)
+
+      if attrs.has_key( 'embed' ):
+        sc += '  rule->fEmbed       = %s;\n' % (attrs['embed'],)
+
+      if attrs.has_key( 'include' ):
+        sc += '  rule->fInclude     = "%s";\n' % (attrs['include'],)
+
+    return sc
+#---------------------------------------------------------------------------------
+  def processIOAutoVariables( self, className, mappedName, source, target, memTypes ):
+    sc = '  //--- Variables added by the code generator ---\n'
+
+    #-----------------------------------------------------------------------------
+    # Write the source member ids and check if we should write the on-disk struct
+    #-----------------------------------------------------------------------------
+    generateOnFile = False
+    sc += '#if 0\n'
+    for member in source:
+      sc += '  static int id_%s = oldObj->GetId("%s");\n' % (member[1], member[1])
+      if member[0] != '':
+        generateOnFile = True
+    sc += '#endif\n'
+
+    #-----------------------------------------------------------------------------
+    # Generate the onfile structure if needed
+    #-----------------------------------------------------------------------------
+    if generateOnFile:
+      onfileStructName = mappedName + '_Onfile'
+      sc += '  struct ' + onfileStructName + ' {\n'
+
+      #---------------------------------------------------------------------------
+      # Generate the member list
+      #---------------------------------------------------------------------------
+      for member in source:
+        if member[0] == '': continue
+        sc += '    ' + member[0] + ' &' + member[1] + ';\n'
+
+      #---------------------------------------------------------------------------
+      # Generate the constructor
+      #---------------------------------------------------------------------------
+      sc += '    ' + onfileStructName + '( '
+      start = True
+      for member in source:
+        if member[0] == '': continue
+
+        if not start: sc += ', ';
+        else: start = False
+
+        sc += member[0] + ' &onfile_' + member[1]
+      sc += ' ): '
+
+      #---------------------------------------------------------------------------
+      # Generate the initializer list
+      #---------------------------------------------------------------------------
+      start = True
+      for member in source:
+        if member[0] == '': continue
+
+        if not start: sc += ', ';
+        else: start = False
+
+        sc += member[1] + '(onfile_' + member[1] + ')'
+      sc += '{}\n'
+      sc += '  };\n'
+
+      #---------------------------------------------------------------------------
+      # Initialize the structure - to  be changed later
+      #---------------------------------------------------------------------------
+      for member in source:
+        sc += '  static Long_t offset_Onfile_' + mappedName
+        sc += '_' + member[1] + ' = oldObj->GetClass()->GetDataMemberOffset("'
+        sc += member[1] +'");\n';
+
+      sc += '  char *onfile_add = (char*)oldObj->GetObject();\n'
+      sc += '  ' + mappedName + '_Onfile onfile(\n'
+
+      start = True
+      for member in source:
+        if member[0] == '': continue;
+
+        if not start: sc += ",\n"
+        else: start = False
+
+        sc += '         '
+        sc += '*(' + member[0] + '*)(onfile_add+offset_Onfile_'
+        sc += mappedName + '_' + member[1] + ')'  
+
+      sc += ' );\n\n'
+
+    #-----------------------------------------------------------------------------
+    # Write the target members
+    #-----------------------------------------------------------------------------
+    for member in target:
+      sc += '  %s &%s = *(%s*)(target + OffsetOf(__shadow__::%s, %s));\n' % (memTypes[member], member, memTypes[member], mappedName, member)
+    return sc + '\n'
+#---------------------------------------------------------------------------------
+  def processIoReadFunctions( self, cl, clt, rules, memTypes ):
+    i = 0;
+    sc = ''
+    for rule in rules:
+      if rule.has_key( 'code' ) and rule['code'] != '':
+        funcname = 'read_%s_%d' % (clt, i)
+
+        #--------------------------------------------------------------------------
+        # Process the data members
+        #--------------------------------------------------------------------------
+        sourceMembers = [member.strip() for member in rule['attrs']['source'].split(',')]
+        sourceMembersSpl = []
+        for member in sourceMembers:
+          type = ''
+          elem = ''
+          spl = member.split( ' ' )
+
+          if len(spl) == 1:
+            elem = member
+          else:
+            type = spl[0]
+            elem = spl[1]
+          sourceMembersSpl.append( (type, elem) )
 
+        targetMembers = [member.strip() for member in rule['attrs']['target'].split(',')]
+
+        #--------------------------------------------------------------------------
+        # Print things out
+        #--------------------------------------------------------------------------
+        sc += 'void %s( char *target, TVirtualObject *oldObj )\n' % (funcname,)
+        sc += '{\n'
+        sc += self.processIOAutoVariables( cl, clt, sourceMembersSpl, targetMembers, memTypes )
+        sc += '  %s* newObj = (%s*)target;\n' % (cl, cl)
+        sc += '  //--- User\'s code ---\n'
+        sc += rule['code'].strip('\n')
+        sc += '\n}\n\n'
+        rule['funcname'] = funcname
+        i += 1
+    return sc
+#---------------------------------------------------------------------------------
+  def processIoReadRawFunctions( self, cl, clt, rules, memTypes ):
+    i = 0;
+    sc = ''
+    for rule in rules:
+      if rule.has_key( 'code' ):
+        funcname = 'readraw_%s_%d' % (clt, i)
+        targetMembers = [member.strip() for member in rule['attrs']['target'].split(',')]
+        sc += 'static void %s( char *target, TBuffer *oldObj )\n' % (funcname,)
+        sc += '{\n'
+        sc += '#if 0\n';
+        sc += self.processIOAutoVariables( cl, clt, [], targetMembers, memTypes )
+        sc += '  %s* newObj = (%s*)target;\n' % (cl, cl)
+        sc += '  //--- User\'s code ---\n'
+        sc += rule['code'].strip('\n')
+        sc += '\n#endif\n'
+        sc += '}\n\n'
+        rule['funcname'] = funcname
+        i += 1
+    return sc
+
+#---------------------------------------------------------------------------------
+  def createTypeMap( self, memIds ):
+    toRet = {}
+    for memId in memIds:
+      if self.xref[memId]['elem'] != 'Field': continue
+      attrs = self.xref[memId]['attrs']
+      toRet[attrs['name']] = self.genTypeName( attrs['type'] )
+    return toRet
+#---------------------------------------------------------------------------------
+  def removeBrokenIoRules( self, cl, rules, members ):
+    for rule in rules:
+      if rule.has_key( 'target'):
+        targets = [target.strip() for target in rule['attrs']['target'].split(',')]
+        ok = True
+        for t in targets:
+          if not members.has_key( t ): ok = False
+        if not ok:
+          print '--->> genreflex: WARNING: IO rule for class', cl,
+          print '- data member', t, 'appears on the target list but does not seem',
+          print 'to be present in the target class'
+          rules.remove( rule )
+#---------------------------------------------------------------------------------
+  def getIncludes( self, readRules, readRawRules ):
+    testDict = {}
+    rulesets = []
+
+    if readRules: rulesets.append( readRules )
+    if readRawRules: rulesets.append( readRawRules )
+
+    for ruleset in rulesets:
+      for ruleList in ruleset.values():
+        for rule in ruleList:
+          if not rule['attrs'].has_key( 'include' ):
+            continue
+          lst = [r.strip() for r in rule['attrs']['include'].split( ',' )]
+          for r in lst:
+            testDict[r] = 1
+    return testDict.keys()
+#---------------------------------------------------------------------------------
   def translate_typedef (self, id):
     while self.xref[id]['elem'] in ['CvQualifiedType', 'Typedef']:
       id = self.xref[id]['attrs']['type']
     return self.genTypeName(id,enum=True, const=True)
-
-  def genClassDict(self, attrs):
+#---------------------------------------------------------------------------------
+  def genClassDict(self, attrs, ioReadRules, ioReadRawRules):
     members, bases = [], []
     cl  = attrs.get('name')
     clf = '::' + attrs['fullname']
@@ -698,9 +1060,40 @@
     else :  # new in version 0.6.0
       if self.isClassVirtual(attrs) :  mod += ' | VIRTUAL'
     members = filter(self.memberfilter, members)  # Eliminate problematic members
+
     # Fill the different streams sc: constructor, ss: stub functions
-    sc = '//------Dictionary for class %s -------------------------------\n' % cl
+    sc = ''
+
+    #-----------------------------------------------------------------------------
+    # Get the data members infor and write down the schema evolution functions
+    #-----------------------------------------------------------------------------
+    memberTypeMap = self.createTypeMap( members )
+    if ioReadRules:
+      self.removeBrokenIoRules( cls, ioReadRules, memberTypeMap );
+      sc += self.processIoReadFunctions( cls, clt, ioReadRules, memberTypeMap )
+    if ioReadRawRules:
+      self.removeBrokenIoRules( csl, ioReadRawRules, memberTypeMap );
+      sc += self.processIoReadRawFunctions( cls, clt, ioReadRawRules, memberTypeMap )
+
+    sc += '//------Dictionary for class %s -------------------------------\n' % cl
     sc += 'void %s_dict() {\n' % (clt,)
+
+    # Write the schema evolution rules
+    if ioReadRules or ioReadRawRules:
+      sc += '  ROOT::TSchemaHelper* rule;\n'
+      
+    if ioReadRules:
+      sc += '  // the io read rules\n'
+      sc += '  std::vector<ROOT::TSchemaHelper> readrules(%d);\n' % (len(ioReadRules),)
+      sc += self.processIoRules( ioReadRules, 'readrules' )
+      sc += '\n\n'
+
+    if ioReadRawRules:
+      sc += '  // the io readraw rules\n'
+      sc += '  std::vector<ROOT::TSchemaHelper> readrawrules(%d);\n' % (len(ioReadRawRules),)
+      sc += self.processIoRules( ioReadRawRules, 'readrawrules' )
+      sc += '\n\n'
+
     if 'extra' in attrs and 'contid' in attrs['extra'] : 
       cid = attrs['extra']['contid'].upper()
     else :
@@ -711,12 +1104,24 @@
     elif notAccessibleType :
       sc += '  ClassBuilder("%s", typeid(%s%s), sizeof(%s), %s, %s)' % ( cls, self.xref[notAccessibleType]['attrs']['access'].title(), self.xref[attrs['id']]['elem'], '__shadow__::'+ string.translate(str(clf),self.transtable), mod, typ )
     else :
-      sc += '  ClassBuilder("%s", typeid(%s), sizeof(%s), %s, %s)' % (cls, cls, cls, mod, typ)
+      typeidtype = '::' + cls
+      # a funny bug in MSVC7.1: sizeof(::namesp::cl) doesn't work
+      if sys.platform == 'win32':
+         typeidtype = 'MSVC71_typeid_bug_workaround'
+         sc += '  typedef ::%s %s;\n' % (cls, typeidtype)
+      sc += '  ClassBuilder("%s", typeid(%s), sizeof(::%s), %s, %s)' \
+            % (cls, typeidtype, cls, mod, typ)
     if 'extra' in attrs :
       for pname, pval in attrs['extra'].items() :
         if pname not in ('name','pattern','n_name','file_name','file_pattern') :
           if pname == 'id' : pname = 'ClassID'
           sc += '\n  .AddProperty("%s", "%s")' % (pname, pval)
+
+    if ioReadRules:
+      sc += '\n  .AddProperty("ioread", readrules )'
+    if ioReadRawRules:
+      sc += '\n  .AddProperty("ioreadraw", readrawrules )'
+
     for b in bases :
       sc += '\n' + self.genBaseClassBuild( clf, b )
     for m in members :
@@ -766,21 +1171,25 @@
     else:
       cls = self.genTypeName(attrs['id'],const=True,colon=True)
       clt = string.translate(str(cls), self.transtable)
+    if clt :
+      c = '#ifdef ' + clt + '\n' + '#undef ' + clt + '\n' + '#endif' + '\n'
+    else :
+      c = ''
     xtyp = self.xref[attrs['id']]
     typ = xtyp['elem'].lower()
     indent = inner * 2 * ' '
     if typ == 'enumeration' :
-      c = indent + 'enum %s {};\n' % clt
+      c += indent + 'enum %s {};\n' % clt
     else:
       if not bases : 
-        c = indent + '%s %s {\n%s  public:\n' % (typ, clt, indent)
+        c += indent + '%s %s {\n%s  public:\n' % (typ, clt, indent)
       else :
-        c = indent + '%s %s : ' % (typ, clt)
+        c += indent + '%s %s : ' % (typ, clt)
         for b in bases :
           if b.get('virtual','') == '1' : acc = 'virtual ' + b['access']
           else                          : acc = b['access']
-	  bname = self.genTypeName(b['type'],colon=True)
-	  if self.xref[b['type']]['attrs'].get('access') in ('private','protected'):
+          bname = self.genTypeName(b['type'],colon=True)
+          if self.xref[b['type']]['attrs'].get('access') in ('private','protected'):
             bname = string.translate(str(bname),self.transtable)
             if not inner: c = self.genClassShadow(self.xref[b['type']]['attrs']) + c
           c += indent + '%s %s' % ( acc , bname )
@@ -792,6 +1201,7 @@
           c += indent + '  virtual ~%s() throw();\n' % ( clt )
       members = attrs.get('members','')
       memList = members.split()
+      # Inner class/struct/union/enum.
       for m in memList :
         member = self.xref[m]
         if member['elem'] in ('Class','Struct','Union','Enumeration') \
@@ -801,6 +1211,66 @@
           if cmem != cls and cmem not in inner_shadows :
             inner_shadows[cmem] = string.translate(str(cmem), self.transtable)
             c += self.genClassShadow(member['attrs'], inner + 1)
+            
+      #
+      # Virtual methods, see https://savannah.cern.ch/bugs/index.php?32874
+      # Shadow classes inherit from the same bases as the shadowed class; if a
+      # shadowed class is inherited from at least two bases and it defines
+      # virtual methods of at least two bases then these virtual methods must
+      # be declared in the shadow class or the compiler will complain about
+      # ambiguous inheritance.
+      allbases = []
+      self.getAllBases(attrs['id'], allbases)
+      if len(allbases) > 1 :
+        allBasesMethods = {}
+        # count method occurrences collected over all bases
+        for b in allbases:
+          baseattrs = self.xref[b[0]]['attrs']
+          currentBaseName = baseattrs['demangled']
+          basemem = baseattrs.get('members','')
+          basememList = members.split()
+          for bm in basememList:
+            basemember = self.xref[bm]
+            if basemember['elem'] in ('Method','OperatorMethod') \
+                 and basemember['attrs'].get('virtual') == '1' \
+                 and self.isTypePublic(basemember['attrs']['returns']) \
+                 and not self.hasNonPublicArgs(basemember['subelems']):
+              # This method is virtual and publicly accessible.
+              # Remove the class name and the scope operator from the demangled method name.
+              demangledBaseMethod = basemember['attrs'].get('demangled')
+              posFuncName = demangledBaseMethod.rfind('::' + basemember['attrs'].get('name') + '(')
+              if posFuncName == -1 : continue
+              demangledBaseMethod = demangledBaseMethod[posFuncName + 2:]
+              found = 0
+              if demangledBaseMethod in allBasesMethods.keys():
+                # the method exists in another base.
+                # getAllBases collects the bases along each line of inheritance,
+                # i.e. either the method we found is in a derived class of b
+                # or it's in a different line and we have to write it out
+                # to prevent ambiguous inheritance.
+                for foundbases in allBasesMethods[demangledBaseMethod]['bases']:
+                  if b in foundbases:
+                    found = 1
+                    break
+                if found == 0: found = 2
+              if found != 1:
+                allbasebases = []
+                self.getAllBases(baseattrs['id'], allbasebases)
+                if found == 0:
+                  allBasesMethods[demangledBaseMethod] = { 'bases': ( allbasebases ), 'returns': basemember['attrs'].get('returns') }
+                else:
+                  allBasesMethods[demangledBaseMethod]['bases'].append( allbasebases )
+                  allBasesMethods[demangledBaseMethod]['returns'] = basemember['attrs'].get('returns')
+        # write out ambiguous methods
+        for demangledMethod in allBasesMethods.keys() :
+          member = allBasesMethods[demangledMethod]
+          if len(member['bases']) > 1:
+            ret = self.genTypeName(member['returns'])
+            if '(' not in ret:
+              # skip functions returning functions; we don't get the prototype right easily:
+              cmem = '  virtual %s %s throw();' % (ret, demangledMethod)
+              c += indent + cmem + '\n'
+      # Data members.
       for m in memList :
         member = self.xref[m]
         if member['elem'] in ('Field',) :
@@ -871,11 +1341,11 @@
     values = values[:-1]
     mod = self.genModifier(attrs, None)
     if self.isUnnamedType(name) :
-      s += '  .AddEnum("%s", "%s", &typeid(ROOT::Reflex::UnnamedEnum), %s)' % (name[name.rfind('::')+3:], values, mod) 
+      s += '  .AddEnum("%s", "%s", &typeid(::Reflex::UnnamedEnum), %s)' % (name[name.rfind('::')+3:], values, mod) 
     else :
       if attrs.get('access') in ('protected','private'):
         if not self.interpreter:
-          s += '  .AddEnum("%s", "%s", &typeid(ROOT::Reflex::UnknownType), %s)' % (name, values, mod)        
+          s += '  .AddEnum("%s", "%s", &typeid(::Reflex::UnknownType), %s)' % (name, values, mod)        
       else:
         s += '  .AddEnum("%s", "%s", &typeid(%s), %s)' % (name, values, name, mod)
     return s 
@@ -890,7 +1360,15 @@
       elif colon  : s = '::'
     return s
 #----------------------------------------------------------------------------------
-  def genTypeName(self, id, enum=False, const=False, colon=False, alltempl=False) :
+  def genTypeName(self, id, enum=False, const=False, colon=False, alltempl=False, _useCache=True,_cache={}) :
+    if _useCache:
+      key = (self,id,enum,const,colon,alltempl)
+      if _cache.has_key(key):
+        return _cache[key]
+      else:
+        ret = self.genTypeName(id,enum,const,colon,alltempl,False)
+        _cache[key] = ret
+        return ret
     elem  = self.xref[id]['elem']
     attrs = self.xref[id]['attrs']
     if self.isUnnamedType(attrs.get('demangled')) :
@@ -898,6 +1376,8 @@
       else : return attrs['demangled']
     if id[-1] in ['c','v'] :
       nid = id[:-1]
+      if nid[-1] in ['c','v'] :
+        nid = nid[:-1]
       cvdict = {'c':'const','v':'volatile'}
       prdict = {'PointerType':'*', 'ReferenceType':'&'}
       nidelem = self.xref[nid]['elem']
@@ -916,8 +1396,8 @@
     elif elem == 'PointerType' :
       t = self.genTypeName(attrs['type'],enum, const, colon)
       if   t[-1] == ')' or t[-7:] == ') const' or t[-10:] == ') volatile' : s += t.replace('::*)','::**)').replace('::)','::*)').replace('(*)', '(**)').replace('()','(*)')
-      elif t[-1] == ']' or t[-7:] == ') const' or t[-10:] == ') volatile' : s += t[:t.find('[')] + '(*)' + t[t.find('['):]
-      else              : s += t + '*'   
+      elif t[-1] == ')' or t[-7:] == ') const' or t[-10:] == ') volatile' : s += t[:t.find('[')] + '(*)' + t[t.find('['):]
+      else              : s += t + '*'
     elif elem == 'ReferenceType' :
       s += self.genTypeName(attrs['type'],enum, const, colon)+'&'
     elif elem in ('FunctionType','MethodType') :
@@ -937,7 +1417,8 @@
       if (attrs.get('const') == '1') : s += ' const'
       if (attrs.get('volatile') == '1') : s += ' volatile'
     elif elem == 'ArrayType' :
-      arr = '[%s]' % str(int(attrs['max'])+1)
+      max = attrs['max'].rstrip('u')
+      arr = '[%s]' % str(int(max)+1)
       typ = self.genTypeName(attrs['type'], enum, const, colon)
       if typ[-1] == ']' :
         pos = typ.find('[')
@@ -957,7 +1438,13 @@
       else : pass
     elif elem == 'OffsetType' :
       s += self.genTypeName(attrs['type'], enum, const, colon) + ' '
-      s += self.genTypeName(attrs['basetype'], enum, const, colon) + '::'  
+      s += self.genTypeName(attrs['basetype'], enum, const, colon) + '::'
+      # OffsetType A::*, different treatment for GCCXML 0.7 and 0.9:
+      # 0.7: basetype: A*
+      # 0.9: basetype: A - add a "*" here
+      version = float(re.compile('\\b\\d+\\.\\d+\\b').match(self.gccxmlvers).group())
+      if  version >= 0.9 : 
+        s += "*"
     else :
       if 'name' in attrs : s += attrs['name']
       s = normalizeClass(s,alltempl)                   # Normalize STL class names, primitives, etc.
@@ -1008,7 +1495,7 @@
         elif elem == 'ReferenceType' :
           c += 'ReferenceBuilder(type'+attrs['type']+');\n'
         elif elem == 'ArrayType' :
-          mx = attrs['max']
+          mx = attrs['max'].rstrip('u')
           # check if array is bound (max='fff...' for unbound arrays)
           if mx.isdigit() : len = str(int(mx)+1)
           else            : len = '0' 
@@ -1057,7 +1544,7 @@
       if 'incomplete' not in c : used_context.append(c['context'])
     idx = 0
     for ns in self.namespaces :
-      if ns['id'] in used_context and ns['name'] != '::' :
+      if ns['id'] in used_context and 'name' in ns and  ns['name'] != '::' :
         s += '  NamespaceBuilder nsb%d( "%s" );\n' % (idx, self.genTypeName(ns['id']))
         idx += 1
     return s
@@ -1125,12 +1612,6 @@
     for f in selfunctions :
       id   = f['id']
       name = self.genTypeName(id)
-      if ( self.xref[id]['attrs'].has_key('mangled') ):
-        mm = self.xref[id]['attrs']['mangled'][2:]
-        dname = gccdemangler.demangle_name(mm)
-      else :
-        dname = name
-      name += getTemplateArgString(dname[1])
       args = self.xref[id]['subelems']      
       if args : params  = '"'+ string.join( map(self.genParameter, args),';')+'"'
       else    : params  = '0'
@@ -1198,7 +1679,10 @@
       print '--->> genreflex: WARNING: Bit-fields are not supported as data members (%s %s::%s:%s)' % ( type, cls, name, attrs['bits'] )
       self.warnings += 1
       return ''
-    if self.selector : xattrs = self.selector.selfield( cls,name)
+    if self.selector :
+      fieldsel = self.selector.matchfield(cls,name)
+      if not fieldsel[1]: xattrs = fieldsel[0]
+      else              : return ""
     else             : xattrs = None
     mod = self.genModifier(attrs,xattrs)
     if attrs['type'][-1] == 'c' :
@@ -1329,25 +1813,25 @@
         if n == narg-ndarg :  s += '  if ( arg.size() == %d ) {\n' % n
         else               :  s += '  else if ( arg.size() == %d ) { \n' % n
       if returns == 'void' :
-        first = iden + '  ((%s*)o)->%s(' % ( cl, name )
+        first = iden + '  (((%s*)o)->%s)(' % ( cl, name )
         s += first + self.genMCOArgs(args, n, len(first)) + ');\n'
         s += iden + '  return 0;\n'
       else :
         if returns[-1] in ('*',')') and returns.find('::*') == -1 :
-          first = iden + '  return (void*)((%s*)o)->%s(' % ( cl, name )
+          first = iden + '  return (void*)(((%s*)o)->%s)(' % ( cl, name )
           s += first + self.genMCOArgs(args, n, len(first)) + ');\n'
         elif returns[-1] == '&' :
-          first = iden + '  return (void*)&((%s*)o)->%s(' % ( cl, name )
+          first = iden + '  return (void*)&(((%s*)o)->%s)(' % ( cl, name )
           s += first + self.genMCOArgs(args, n, len(first)) + ');\n'
         elif (returns in self.basictypes or
               self.translate_typedef (attrs['returns']) in self.basictypes or
               returns.find('::*') != -1 or
               name == 'operator '+tdfname):
-          first = iden + '  ret = ((%s*)o)->%s(' % ( cl, name )
+          first = iden + '  ret = (((%s*)o)->%s)(' % ( cl, name )
           s += first + self.genMCOArgs(args, n, len(first)) + ');\n'
           s += iden + '  return &ret;\n'        
         else :
-          first = iden + '  return new %s(((%s*)o)->%s(' % ( returns, cl, name )
+          first = iden + '  return new %s((((%s*)o)->%s)(' % ( returns, cl, name )
           s += first + self.genMCOArgs(args, n, len(first)) + '));\n'
       if ndarg : 
         if n != narg : s += '  }\n'
@@ -1434,7 +1918,7 @@
 #----------------------------------------------------------------------------------
   def genDestructorDef(self, attrs, childs):
     cl = self.genTypeName(attrs['context'])
-    return 'static void* destructor%s(void * o, const std::vector<void*>&, void *) {\n  ((::%s*)o)->~%s(); return 0;\n}' % ( attrs['id'], cl, attrs['name'] )
+    return 'static void* destructor%s(void * o, const std::vector<void*>&, void *) {\n  (((::%s*)o)->::%s::~%s)(); return 0;\n}' % ( attrs['id'], cl, cl, attrs['name'] )
 #----------------------------------------------------------------------------------
   def genDestructorBuild(self, attrs, childs):
     if self.isUnnamedType(self.xref[attrs['context']]['attrs'].get('demangled')) or \
@@ -1546,7 +2030,7 @@
     clt      = string.translate(str(cl), self.transtable)
     t        = getTemplateArgs(cl)[0]
     s  = 'static void* method%s( void*, const std::vector<void*>&, void*)\n{\n' %( attrs['id'], )
-    s += '  return ROOT::Reflex::Proxy< %s >::Generate();\n' % (cl,)
+    s += '  return ::Reflex::Proxy< %s >::Generate();\n' % (cl,)
     s += '}\n'
     return s
 #----BasesMap stuff--------------------------------------------------------
@@ -1560,14 +2044,14 @@
     cl       = self.genTypeName(cid, colon=True)
     clt      = string.translate(str(cl), self.transtable)
     s  = 'static void* method%s( void*, const std::vector<void*>&, void*)\n{\n' %( attrs['id'], )
-    s += '  static std::vector<std::pair<ROOT::Reflex::Base, int> > s_bases;\n'
+    s += '  static std::vector<std::pair< ::Reflex::Base, int> > s_bases;\n'
     s += '  if ( !s_bases.size() ) {\n'
     bases = []
     self.getAllBases( cid, bases ) 
     for b in bases :
       bname = self.genTypeName(b[0],colon=True)
       bname2 = self.genTypeName(b[0])
-      s += '    s_bases.push_back(std::make_pair(ROOT::Reflex::Base( ROOT::Reflex::TypeBuilder("%s"), ROOT::Reflex::BaseOffset< %s,%s >::Get(),%s), %d));\n' % (bname2, cl, bname, b[1], b[2])
+      s += '    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder("%s"), ::Reflex::BaseOffset< %s,%s >::Get(),%s), %d));\n' % (bname2, cl, bname, b[1], b[2])
     s += '  }\n  return &s_bases;\n' 
     s += '}\n'
     return s
@@ -1644,8 +2128,18 @@
         bases.append( [id,  mod, level] )
         self.getAllBases( id, bases, level+1, access, virtual )
 #----------------------------------------------------------------------------------
+  def isCopyCtor(self, cid, mid):
+    args = self.xref[mid]['subelems']
+    if (len(args) == 1 or (len(args) > 1 and 'default' in args[1])) :
+      arg0type = args[0]['type']
+      while self.xref[arg0type]['elem'] in ( 'ReferenceType', 'CvQualifiedType') :
+        arg0type = self.xref[arg0type]['attrs']['type']
+      if arg0type == cid: return 1
+    return 0
+#----------------------------------------------------------------------------------
   def completeClass(self, attrs):
     # Complete class with "instantiated" templated methods or constructors
+    # for GCCXML 0.9: add default c'tor, copy c'tor, d'tor if not available.
     if 'members' in attrs : members = attrs['members'].split()
     else                  : members = []
     cid = attrs['id']
@@ -1665,6 +2159,54 @@
             fname =  dname[1][dname[1].rfind('::' + m['name'])+2:]
             m['name'] = fname
         attrs['members'] += u' ' + m['id']
+    # GCCXML now (>0.7) takes care by itself of which functions are implicitly defined:
+    haveCtor    = 1
+    haveCtorCpy = 1
+    haveDtor    = 1
+    if self.gccxmlvers.find('0.7') == 0:
+      haveCtor    = 0
+      haveCtorCpy = 0
+      haveDtor    = 0
+      for m in members :
+        if self.xref[m]['elem'] == 'Constructor' :
+          haveCtor = 1
+          if haveCtorCpy == 0:
+            haveCtorCpy = self.isCopyCtor(cid, m)
+        elif self.xref[m]['elem'] == 'Destructor' :
+          haveDtor = 1
+    if haveCtor == 0 :
+      id = u'_x%d' % self.x_id.next()
+      new_attrs = { 'name':attrs['name'], 'id':id, 'context':cid, 'artificial':'true', 'access':'public' }
+      self.xref[id] = {'elem':'Constructor', 'attrs':new_attrs, 'subelems':[] }
+      attrs['members'] += u' ' + id
+    if haveCtorCpy == 0 :
+      ccid = cid + 'c'
+      # const cid exists?
+      if ccid not in self.xref :
+        new_attrs = { 'id':ccid, 'type':cid }
+        self.xref[ccid] = {'elem':'ReferenceType', 'attrs':new_attrs }
+      # const cid& exists?
+      crcid = 0
+      for xid in self.xref :
+        if self.xref[xid]['elem'] == 'ReferenceType' and self.xref[xid]['attrs']['type'] == ccid :
+          crcid = xid
+          break
+      if crcid == 0:
+        crcid = u'_x%d' % self.x_id.next()
+        new_attrs = { 'id':crcid, 'type':ccid, 'const':'1' }
+        self.xref[crcid] = {'elem':'ReferenceType', 'attrs':new_attrs }
+
+      # build copy ctor
+      id = u'_x%d' % self.x_id.next()
+      new_attrs = { 'name':attrs['name'], 'id':id, 'context':cid, 'artificial':'true', 'access':'public' }
+      arg = { 'type':crcid }
+      self.xref[id] = {'elem':'Constructor', 'attrs':new_attrs, 'subelems':[arg] }
+      attrs['members'] += u' ' + id
+    if haveDtor == 0 :
+      id = u'_x%d' % self.x_id.next()
+      new_attrs = { 'name':attrs['name'], 'id':id, 'context':cid, 'artificial':'true', 'access':'public' }
+      self.xref[id] = {'elem':'Destructor', 'attrs':new_attrs, 'subelems':[] }
+      attrs['members'] += u' ' + id      
 #---------------------------------------------------------------------------------------
 def getContainerId(c):
   if   c[-8:] == 'iterator' : return ('NOCONTAINER','')
@@ -1713,41 +2255,57 @@
   stldeftab['hash_multimap'] = '=','=','__gnu_cxx::hash','std::equal_to','std::allocator'  
 #---------------------------------------------------------------------------------------
 def getTemplateArgs( cl ) :
-  if cl.find('<') == -1 : return []
+  begin = cl.find('<')
+  if begin == -1 : return []
+  end = cl.rfind('>')
+  if end == -1 : return []
   args, cnt = [], 0
-  for s in string.split(cl[cl.find('<')+1:cl.rfind('>')],',') :
+  for s in string.split(cl[begin+1:end],',') :
     if   cnt == 0 : args.append(s)
     else          : args[-1] += ','+ s
     cnt += s.count('<')+s.count('(')-s.count('>')-s.count(')')
-  if args[-1][-1] == ' ' : args[-1] = args[-1][:-1]
+  if len(args) and len(args[-1]) and args[-1][-1] == ' ' :
+    args[-1] = args[-1][:-1]
   return args
 #---------------------------------------------------------------------------------------
-def getTemplateArgString( cl ) :
-  bc = 0
-  if cl[-1] != '>' : return ''
-  for i in range( len(cl)-1, -1, -1) :
-    if   cl[i] == '>' : bc += 1
-    elif cl[i] == '<' : bc -= 1
-    if bc == 0 : return cl[i:]
-  return ''
-#---------------------------------------------------------------------------------------
 def normalizeClassAllTempl(name)   : return normalizeClass(name,True)
 def normalizeClassNoDefTempl(name) : return normalizeClass(name,False)
-def normalizeClass(name,alltempl) :
+def normalizeClass(name,alltempl,_useCache=True,_cache={}) :
+  if _useCache:
+    key = (name,alltempl)
+    if _cache.has_key(key):
+      return _cache[key]    
+    else:
+      ret = normalizeClass(name,alltempl,False)
+      _cache[key] = ret
+      return ret
   names, cnt = [], 0
+  # Special cases:
+  # a< (0 > 1) >::b
+  # a< b::c >
+  # a< b::c >::d< e::f >
   for s in string.split(name,'::') :
     if cnt == 0 : names.append(s)
     else        : names[-1] += '::' + s
-    cnt += s.count('<')-s.count('>')
+    cnt += s.count('<')+s.count('(')-s.count('>')-s.count(')')
   if alltempl : return string.join(map(normalizeFragmentAllTempl,names),'::')
   else        : return string.join(map(normalizeFragmentNoDefTempl,names),'::')
 #--------------------------------------------------------------------------------------
 def normalizeFragmentAllTempl(name)   : return normalizeFragment(name,True)
 def normalizeFragmentNoDefTempl(name) : return normalizeFragment(name) 
-def normalizeFragment(name,alltempl=False) :
+def normalizeFragment(name,alltempl=False,_useCache=True,_cache={}) :
   name = name.strip()
+  if _useCache:
+    key = (name,alltempl)
+    if _cache.has_key(key):
+      return _cache[key]    
+    else:
+      ret = normalizeFragment(name,alltempl,False)
+      _cache[key] = ret
+      return ret
   if name.find('<') == -1  : 
     nor =  name
+    if nor.find('int') == -1: return nor
     for e in [ ['long long unsigned int', 'unsigned long long'],
              ['long long int',          'long long'],
              ['unsigned short int',     'unsigned short'],
@@ -1758,9 +2316,9 @@
              ['long int',               'long']] :
       nor = nor.replace(e[0], e[1])
     return nor
-  else                     : clname = name[:name.find('<')]
-  if name.rfind('>') == -1 : suffix = ''
-  else                     : suffix = name[name.rfind('>')+1:]
+  else : clname = name[:name.find('<')]
+  if name.rfind('>') < len(clname) : suffix = ''
+  else                             : suffix = name[name.rfind('>')+1:]
   args = getTemplateArgs(name)
   sargs = [normalizeClass(a, alltempl) for a in args]
 
@@ -1784,7 +2342,7 @@
       sargs = []
       for i in range(len(args)) :  
         if args[i].find(defargs[i]) == -1 : sargs.append(args[i])
-      sargs = [normalizeClass(a, alltempl) for a in sargs]
+    sargs = [normalizeClass(a, alltempl) for a in sargs]
 
   nor = clname + '<' + string.join(sargs,',')
   if nor[-1] == '>' : nor += ' >' + suffix
@@ -1796,3 +2354,94 @@
   for i in a :
 	if i not in r : r.append(i)
   return r
+#--------------------------------------------------------------------------------------
+# Add implementations of functions declared by ROOT's ClassDef() macro
+def ClassDefImplementation(selclasses, self) :
+  # test whether Rtypes.h got included:
+  haveRtypes = 0
+  for file in self.files:
+    if self.files[file]['name'].endswith('Rtypes.h') \
+           and ( self.files[file]['name'][-9] == '/' or self.files[file]['name'][-9] == '\\' ):
+      haveRtypes = 1
+      break
+  if haveRtypes == 0: return ''
+  
+  returnValue  = '#include "TClass.h"\n'
+  returnValue += '#include "TMemberInspector.h"\n'
+  haveClassDef = 0
+
+  for attrs in selclasses :
+    members = attrs.get('members','')
+    membersList = members.split()
+
+    listOfMembers = ""
+    for ml in membersList:
+      if ml[1].isdigit() :
+        listOfMembers += self.xref[ml]['attrs']['name']
+
+    if  "fgIsA" in listOfMembers \
+      and "Class" in listOfMembers \
+      and "Class_Name" in listOfMembers  \
+      and "Class_Version" in listOfMembers  \
+      and "Dictionary" in listOfMembers  \
+      and "IsA" in listOfMembers  \
+      and "ShowMembers" in listOfMembers  \
+      and "Streamer" in listOfMembers  \
+      and "StreamerNVirtual" in listOfMembers \
+      and "DeclFileName" in listOfMembers \
+      and "ImplFileLine" in listOfMembers \
+      and "ImplFileName" in listOfMembers :
+
+         haveClassDef = 1
+
+         clname = '::' + attrs['fullname']
+         returnValue += 'TClass* ' + clname + '::fgIsA = 0;\n'
+         returnValue += 'TClass* ' + clname + '::Class() {\n'
+         returnValue += '   if (!fgIsA)\n'
+         returnValue += '      fgIsA = TClass::GetClass("' + clname[2:] + '");\n'
+         returnValue += '   return fgIsA;\n'
+         returnValue += '}\n'
+         returnValue += 'const char * ' + clname + '::Class_Name() {return "' + clname[2:]  + '";}\n'
+         returnValue += 'void ' + clname + '::Dictionary() {}\n'
+         returnValue += 'const char *' + clname  + '::ImplFileName() {return "";}\n'
+
+         returnValue += 'int ' + clname + '::ImplFileLine() {return 0;}\n'
+
+         returnValue += 'void '+ clname  +'::ShowMembers(TMemberInspector &R__insp, char *R__parent) {\n'
+         returnValue += '   TClass *R__cl = ' + clname  + '::IsA();\n'
+         returnValue += '   Int_t R__ncp = strlen(R__parent);\n'
+         returnValue += '   if (R__ncp || R__cl || R__insp.IsA()) { }\n'
+
+         for ml in membersList:
+           if ml[1].isdigit() :
+             if self.xref[ml]['elem'] == 'Field' :
+               mattrs = self.xref[ml]['attrs']
+               varname  = mattrs['name']
+               tt = self.xref[mattrs['type']]
+               te = tt['elem']
+               if te == 'PointerType' :
+                 varname1 = '*' + varname
+               elif te == 'ArrayType' :
+                 t = self.genTypeName(mattrs['type'],colon=True,const=True)
+                 arraytype = t[t.find('['):]
+                 varname1 = varname + arraytype
+               else :
+                 varname1 = varname
+               returnValue += '   R__insp.Inspect(R__cl, R__parent, "' + varname1 + '", &' + varname + ');\n'
+
+         if 'bases' in attrs :
+           for b in attrs['bases'].split() :
+             returnValue +=  '   ' + self.xref[b]['attrs']['name'] + '::ShowMembers(R__insp,R__parent);\n'
+
+         returnValue += '}\n'
+
+         returnValue += 'void '+ clname  +'::Streamer(TBuffer &b) {\n   if (b.IsReading()) {\n'
+         returnValue += '      b.ReadClassBuffer(' + clname + '::Class(),this);\n'
+         returnValue += '   } else {\n'
+         returnValue += '      b.WriteClassBuffer(' + clname  + '::Class(),this);\n'
+         returnValue += '   }\n'
+         returnValue += '}\n'
+
+  if haveClassDef == 1 :
+    return "} // unnamed namespace\n\n" + returnValue + "\nnamespace {\n"
+  return ""
diff -Naur orig.root/reflex/python/genreflex/genreflex.py root/reflex/python/genreflex/genreflex.py
--- orig.root/reflex/python/genreflex/genreflex.py	2008-02-21 17:38:28.000000000 +0100
+++ root/reflex/python/genreflex/genreflex.py	2008-11-12 23:55:40.000000000 +0100
@@ -24,7 +24,7 @@
     self.opts            = {}
     self.gccxmlpath      = None
     self.gccxmlopt       = ''
-    self.gccxmlvers      = '0.7.0_20070615'
+    self.gccxmlvers      = '[UNKNOWN]'
     self.selector        = None
     self.gccxml          = ''
     self.quiet           = False
@@ -104,7 +104,7 @@
       --debug
          Print extra debug information while processing. Keep intermediate files\n
       --quiet
-         No not print informational messages\n
+         Do not print informational messages\n
       -h, --help
          Print this help\n
      """ 
@@ -212,6 +212,7 @@
         self.usage()
       for l in open(self.select).readlines() : classes.append(l[:-1])
     #----------GCCXML command------------------------------
+    self.gccxml = ''
     if not self.gccxmlpath:
       try:
         import gccxmlpath
@@ -225,15 +226,14 @@
         self.gccxml = self.gccxmlpath + os.sep + 'gccxml'
       if not os.path.isfile(self.gccxml) :
         print '--->> genreflex: ERROR: Path to gccxml given, but no executable found at', self.gccxml
-    elif self.which('gccxml') :
-      self.gccxml = 'gccxml'
-      print '--->> genreflex: INFO: No explicit path to gccxml given. Found gccxml at', self.which('gccxml')
-    else :
-      if sys.platform == 'win32' :
-        self.gccxml = r'\\cern.ch\dfs\Experiments\sw\lcg\external\gccxml\0.6.0_patch3\win32_vc71\bin\gccxml'
+        self.gccxml = ''
+    if len(self.gccxml) == 0 :
+      if self.which('gccxml') :
+        self.gccxml = 'gccxml'
+        print '--->> genreflex: INFO: Using gccxml from', self.which('gccxml')
       else :
-        self.gccxml = '/afs/cern.ch/sw/lcg/external/gccxml/0.6.0_patch3/slc3_ia32_gcc323/bin/gccxml'
-      print '--->> genreflex: INFO: No gccxml executable found, using fallback location at', self.gccxml
+        print '--->> genreflex: ERROR: Cannot find gccxml executable, aborting!'
+        sys.exit(1)
     #---------------Open selection file-------------------
     try :
       if self.select : self.selector = selclass.selClass(self.select,parse=1)
@@ -244,17 +244,21 @@
 #----------------------------------------------------------------------------------
   def genGccxmlInfo(self):
     s = ''
-    (inp,out,err) = os.popen3(self.gccxml + ' --print')
-    serr = err.read()
+    (inp,out,err) = os.popen3('"' + self.gccxml + '" --print')
     sout = out.read()
+    serr = err.read()
     if serr :
       print '--->> genreflex: WARNING: Could not invoke %s --print' % self.gccxml
       print '--->> genreflex: WARNING: %s' % serr
       return s
-    gccxmlv = sout.split('\n')[0].split()[-1]
-    # For 0.6.0 we can't do much because we have not put in a patch info into the version string 
-    if gccxmlv != '0.6.0' and gccxmlv != self.gccxmlvers :
-      print '--->> genreflex: WARNING: gccxml versions differ. Used version: %s. Recommended version: %s. ' % ( gccxmlv, self.gccxmlvers)
+    self.gccxmlvers = sout.split('\n')[0].split()[-1]
+    recommendedvers = ( '0.7.0_20070615', '0.9.' )
+    foundgoodvers = filter(lambda c: self.gccxmlvers.startswith(c), recommendedvers)
+    if len(foundgoodvers) == 0:
+      plural = ''
+      if len(recommendedvers) > 1 : plural = 's'
+      print '--->> genreflex: WARNING: gccxml versions differ. Used version: %s. Recommended version%s: %s ' \
+            % ( self.gccxmlvers, plural, ', '.join(recommendedvers) )
       print '--->> genreflex: WARNING: gccxml binary used: %s' % ( self.gccxml )
     s += sout    
     compiler = ''
@@ -271,11 +275,11 @@
     else :
       print '--->> genreflex: WARNING: While trying to retrieve compiler version, found unknown compiler %s' % compiler
       return s
-    (inp,out,err) = os.popen3('%s %s'%(compiler,vopt))
+    (inp,out,err) = os.popen3('"%s" %s'%(compiler,vopt))
     serr = err.read()
     # cl puts its version into cerr!
     if serr:
-      if bcomp in ('cl.exe','cl'):
+      if bcomp in ('cl.exe','cl') and serr.find('is not recognized') == -1:
         s += '\nCompiler info:\n' + serr
         return s
       else:
@@ -286,6 +290,7 @@
     return s
 #----------------------------------------------------------------------------------
   def process_files(self):
+    total_errors = 0
     total_warnings = 0
     file_extension = '_rflx.cpp'
     #----------Loop oover all the input files--------------
@@ -298,25 +303,40 @@
       else :
         dicfile = os.path.join(self.outputDir,name+file_extension)
       #---------------Parse the header file with GCC_XML
-      cmd  = '%s %s %s -fxml=%s %s -D__REFLEX__' %(self.gccxml, self.gccxmlopt, source, xmlfile, self.cppopt)
+      if sys.platform == 'win32' :
+        cmd  = '"%s" %s "%s" -fxml=%s %s -D__REFLEX__' %(self.gccxml, self.gccxmlopt, source, xmlfile, self.cppopt)
+      else :
+        cmd  = '%s %s "%s" -fxml=%s %s -D__REFLEX__' %(self.gccxml, self.gccxmlopt, source, xmlfile, self.cppopt)
       if 'debug' in self.opts : print '--->> genreflex: INFO: invoking ', cmd
       if not self.quiet : print '--->> genreflex: INFO: Parsing file %s with GCC_XML' % source,
+      if sys.platform == 'win32' :
+        # bug http://bugs.python.org/issue1524: os.system fails if the
+        # command is quoted and something else in the command is quoted.
+        # Workaround: prepend "call ":
+        cmd = "call " + cmd
       status = os.system(cmd)
       if status :
         print '\n--->> genreflex: ERROR: processing file with gccxml. genreflex command failed.'
-        sys.exit(1)
+        total_errors += 1
+        continue
       else: 
         if not self.quiet : print 'OK'
       gccxmlinfo = self.genGccxmlInfo()
      #---------------Generate the dictionary---------------
       if not self.quiet : print '--->> genreflex: INFO: Generating Reflex Dictionary'
-      dg = gendict.genDictionary(source, self.opts)
+      dg = gendict.genDictionary(source, self.opts, self.gccxmlvers)
       dg.parse(xmlfile)
       classes   = dg.selclasses(self.selector, self.deep)
       functions = dg.selfunctions(self.selector)
       enums     = dg.selenums(self.selector)
       variables = dg.selvariables(self.selector)
-      cnames, warnings, errors = dg.generate(dicfile, classes, functions, enums, variables, gccxmlinfo )
+      if self.selector :
+        cnames, warnings, errors = dg.generate(dicfile, classes, functions, enums, variables, gccxmlinfo,
+                                               self.selector.io_read_rules, self.selector.io_readraw_rules )
+      else :
+        cnames, warnings, errors = dg.generate(dicfile, classes, functions, enums, variables, gccxmlinfo)
+      if errors or (warnings and self.opts.get('fail_on_warnings', False)): os.remove(dicfile)
+      total_errors += errors
       total_warnings += warnings
     #------------Produce Seal Capabilities source file------
       if self.capabilities :
@@ -332,16 +352,21 @@
         else :
           mapfile = os.path.join(self.outputDir, self.rootmap)
         if not self.rootmaplib :  self.rootmaplib = 'lib'+name+'.so'
+        cnames += [ td['fullname'] for td in dg.typedefs_for_usr ]
+        classes+= dg.typedefs_for_usr
         genrootmap.genRootMap(mapfile, name,  self.rootmaplib, cnames, classes)
+    #------------Delete intermediate files------------------
+      if 'debug' not in self.opts :
+         os.remove(xmlfile)
     #------------Report unused class selections in selection
     if self.selector : 
-      warnings += self.selector.reportUnusedClasses()
-    #------------Delete intermediate files------------------
-    if 'debug' not in self.opts :
-       os.remove(xmlfile)
+      total_warnings += self.selector.reportUnusedClasses()
+    #------------Exit with status if errors ----------------
+    if total_errors:
+      sys.exit(1)
     #------------Exit with status if warnings --------------
-    if warnings and self.opts.get('fail_on_warnings',False) : 
-      print '--->> genreflex: ERROR: Exiting with error due to %d warnings ( --fail_on_warnings enabled )' % warnings
+    if total_warnings and self.opts.get('fail_on_warnings',False) : 
+      print '--->> genreflex: ERROR: Exiting with error due to %d warnings ( --fail_on_warnings enabled )' % total_warnings
       sys.exit(1)
 #---------------------------------------------------------------------
   def which(self, name) :
diff -Naur orig.root/reflex/python/genreflex/genrootmap.py root/reflex/python/genreflex/genrootmap.py
--- orig.root/reflex/python/genreflex/genrootmap.py	2008-02-21 17:38:28.000000000 +0100
+++ root/reflex/python/genreflex/genrootmap.py	2008-11-12 23:55:40.000000000 +0100
@@ -28,6 +28,9 @@
   transtable = string.maketrans(': ', '@-')
   transtable = string.maketrans(': ', '@-')
 
+  for c in classes :
+    c['fullname'] = c.get('fullname', c['name'])
+
   # filter out classes that were de-selected by rootmap attribute
   cveto = filter( lambda c: isRootmapVetoed(c),classes)
   for cv in cveto :
diff -Naur orig.root/reflex/python/genreflex/selclass.py root/reflex/python/genreflex/selclass.py
--- orig.root/reflex/python/genreflex/selclass.py	2008-02-21 17:38:28.000000000 +0100
+++ root/reflex/python/genreflex/selclass.py	2008-11-12 23:55:40.000000000 +0100
@@ -8,29 +8,35 @@
 
 import xml.parsers.expat
 import os, sys, string, time, fnmatch
+import re
 
 class selClass :
 #----------------------------------------------------------------------------------
   def __init__(self, file, parse=0):
-    self.file           = file
-    self.sel_classes    = []
-    self.exc_classes    = []
-    self.sel_functions  = []
-    self.exc_functions  = []
-    self.sel_enums      = []
-    self.exc_enums      = []
-    self.sel_vars       = []
-    self.exc_vars       = []
+    self.file             = file
+    self.sel_classes      = []
+    self.exc_classes      = []
+    self.sel_functions    = []
+    self.exc_functions    = []
+    self.sel_enums        = []
+    self.exc_enums        = []
+    self.sel_vars         = []
+    self.exc_vars         = []
+    self.io_read_rules    = {}
+    self.io_readraw_rules = {}
+    self.current_io_rule  = None
     self.classes   = self.sel_classes
     self.functions = self.sel_functions
     self.enums     = self.sel_enums
     self.vars      = self.sel_vars
+    self.ver_re    = re.compile('^\d+-$|^-\d+$|^\d+$|^(\d+)-(\d+)$') # ie. it matches: 1-,-1,1,1-2
     if parse : self.parse()
 #----------------------------------------------------------------------------------
   def parse(self):
     p = xml.parsers.expat.ParserCreate()
     p.StartElementHandler = self.start_element
     p.EndElementHandler = self.end_element
+    p.CharacterDataHandler = self.char_data
     f = open(self.file)
     # Replace any occurence of <>& in the attribute values by the xml parameter
     rxml, nxml = f.read(), ''
@@ -79,6 +85,8 @@
       self.classes[-1]['fields'].append(attrs)
     elif name in ('method',) :
       self.classes[-1]['methods'].append(attrs)
+    elif name in ('ioread', 'ioreadraw'):
+      self.current_io_rule = {'attrs': attrs, 'code': '' }
     elif name in ('selection',) :
       self.classes   = self.sel_classes
       self.functions = self.sel_functions
@@ -98,6 +106,147 @@
       self.functions = self.sel_functions
       self.vars      = self.sel_vars
       self.enums     = self.sel_enums
+
+    #------------------------------------------------------------------------------
+    # Processing io rules
+    #------------------------------------------------------------------------------
+    elif name == 'ioread' or name =='ioreadraw':
+      if not self.isRuleValid( self.current_io_rule ):
+        print '--->> genreflex: WARNING: The IO rule has been omited'
+        self.current_io_rule = None
+        return
+
+      className = self.current_io_rule['attrs']['targetClass']
+
+      #----------------------------------------------------------------------------
+      # Handle read rule
+      #----------------------------------------------------------------------------
+      if name == 'ioread':
+        if not self.io_read_rules.has_key( className ):
+          self.io_read_rules[className] = []
+        self.io_read_rules[className].append( self.current_io_rule )
+        self.current_io_rule = None
+
+      #----------------------------------------------------------------------------
+      # Handle readraw rule
+      #----------------------------------------------------------------------------
+      elif name == 'ioreadraw':
+        source = self.current_io_rule['attrs']['source'].split(',')
+        if len(source) > 1:
+          print '--->> genreflex: WARNING: IO rule for class:', className,
+          print '- multiple sources speciffied for readraw rule!'
+          return
+        if not self.io_readraw_rules.has_key( className ):
+          self.io_readraw_rules[className] = []
+        self.io_readraw_rules[className].append( self.current_io_rule )
+        self.current_io_rule = None
+
+      self.current_io_rule = None
+#----------------------------------------------------------------------------------
+  def isRuleValid(self, rule):
+
+    #------------------------------------------------------------------------------
+    # Checks if we have all necessary tags
+    #------------------------------------------------------------------------------
+    attrs = self.current_io_rule['attrs']
+    if not attrs.has_key( 'targetClass' ):
+      print '--->> genreflex: WARNING: You always have to specify the targetClass when specyfying an IO rule'
+      return False
+
+    className = attrs['targetClass'].strip()
+    warning = '--->> genreflex: WARNING: IO rule for class ' + className
+
+    if not attrs.has_key( 'sourceClass' ):
+        print warning, '- sourceClass attribute is missing'
+        return False
+
+    if not attrs.has_key( 'version' ) and not attrs.has_key( 'checksum' ):
+      print warning, '- You need to specify either version or checksum'
+      return False
+
+    #------------------------------------------------------------------------------
+    # Check if the checksums are correct
+    #------------------------------------------------------------------------------
+    if attrs.has_key( 'checksum' ):
+      chk = attrs['checksum']
+      if chk[0] != '[' or chk[-1] != ']':
+        print warning, '- a comma separated list of ints enclosed in square brackets expected',
+        print 'as a value of checksum parameter'
+        return False
+
+      lst = [item.strip() for item in chk[1:-1].split(',')]
+      if len( lst ) == 0:
+        print warning, 'the checksum list is empty'
+        return False
+
+      for chk in lst:
+        try:
+          i = int( chk )
+        except:
+          print warning, chk, 'is not a valid value of checksum parameter - an integer expected'
+          return False
+
+    #------------------------------------------------------------------------------
+    # Check if the versions are correct
+    #------------------------------------------------------------------------------
+    if attrs.has_key( 'version' ):
+      ver = attrs['version']
+      if ver[0] != '[' or ver[-1] != ']':
+        print warning, '- a comma separated list of version specifiers enclosed in square',
+        print 'brackets expected as a value of version parameter'
+        return False
+
+      lst = [item.strip() for item in ver[1:-1].split(',')]
+      if len( lst ) == 0:
+        print warning, 'the version list is empty'
+        return False
+
+      for v in lst:
+        matchObj = self.ver_re.match( v )
+        if not matchObj:
+          print warning, '-', v, 'is not a valid value of version parameter'
+          return False
+        else:
+          rng = matchObj.groups()
+          if rng[0] and rng[1]:
+            b, e = int(rng[0]), int(rng[1])
+            if b >= e:
+              print warning, '-', v, 'is not a valid version range'
+              return False
+
+    #------------------------------------------------------------------------------
+    # Check if we deal with renameing rule
+    #------------------------------------------------------------------------------
+    if len( attrs ) == 3 or (len( attrs ) == 4 and attrs.has_key( 'version' ) and attrs.has_key( 'checksum' )):
+      return True
+
+    #------------------------------------------------------------------------------
+    # Check if we have other parameters specified correctly
+    #------------------------------------------------------------------------------
+    for k in ['target', 'source' ]:
+      if not attrs.has_key(k):
+        print warning, '- Required attribute is missing:', k
+        return False
+
+    if attrs.has_key( 'embed' ):
+      if attrs['embed'] != 'true' and attrs['embed'] != 'false':
+        print warning, '- true or false expected as a value of embed parameter'
+        return False
+
+    #------------------------------------------------------------------------------
+    # Check if the include list is not empty
+    #------------------------------------------------------------------------------
+    if attrs.has_key( 'include' ):
+      if len( attrs['include'] ) == 0:
+        print warning, 'empty include list specified'
+        return False
+
+    return True
+
+#----------------------------------------------------------------------------------
+  def char_data(self, data):
+    if self.current_io_rule:
+      self.current_io_rule['code'] += data
 #----------------------------------------------------------------------------------
   def matchclassTD(self, clname, fname, sltor) :
     clname = clname.replace(' ','')
