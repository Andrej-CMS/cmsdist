diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/LinkDef2.h root/graf3d/eve/inc/LinkDef2.h
--- root-old/graf3d/eve/inc/LinkDef2.h	2012-02-12 20:59:06.024916890 -0800
+++ root/graf3d/eve/inc/LinkDef2.h	2012-06-27 13:26:49.928327037 -0700
@@ -154,3 +154,4 @@
 #pragma link C++ class TEveRGBAPalette+;
 #pragma link C++ class TEveRGBAPaletteEditor+;
 #pragma link C++ class TEveRGBAPaletteSubEditor+;
+#pragma link C++ class TEveRGBAPaletteOverlay+;
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEvePathMark.h root/graf3d/eve/inc/TEvePathMark.h
--- root-old/graf3d/eve/inc/TEvePathMark.h	2012-02-12 20:59:06.006916886 -0800
+++ root/graf3d/eve/inc/TEvePathMark.h	2012-06-27 13:31:50.782334666 -0700
@@ -22,7 +22,7 @@
 class TEvePathMarkT
 {
 public:
-   enum EType_e { kReference, kDaughter, kDecay, kCluster2D };
+   enum EType_e { kReference, kDaughter, kDecay, kCluster2D, kLineSegment };
 
    EType_e         fType; // Mark-type.
    TEveVectorT<TT> fV;    // Vertex.
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveRGBAPalette.h root/graf3d/eve/inc/TEveRGBAPalette.h
--- root-old/graf3d/eve/inc/TEveRGBAPalette.h	2012-02-12 20:59:06.015916887 -0800
+++ root/graf3d/eve/inc/TEveRGBAPalette.h	2012-06-27 13:27:29.871328043 -0700
@@ -17,6 +17,8 @@
 #include "TObject.h"
 #include "TQObject.h"
 
+#include "TMath.h"
+
 class TEveRGBAPalette : public TObject,
                         public TQObject,
                         public TEveRefCnt
@@ -24,6 +26,8 @@
    friend class TEveRGBAPaletteEditor;
    friend class TEveRGBAPaletteSubEditor;
 
+   friend class TEveRGBAPaletteOverlay;
+
 public:
    enum ELimitAction_e { kLA_Cut, kLA_Mark, kLA_Clip, kLA_Wrap };
 
@@ -32,11 +36,15 @@
    TEveRGBAPalette& operator=(const TEveRGBAPalette&); // Not implemented
 
 protected:
+   Double_t  fUIf;       // UI representation calculated as: d = fUIf*i + fUIc
+   Double_t  fUIc;       // UI representation calculated as: d = fUIf*i + fUIc
+
    Int_t     fLowLimit;  // Low  limit for Min/Max values (used by editor)
    Int_t     fHighLimit; // High limit for Min/Max values (used by editor)
    Int_t     fMinVal;
    Int_t     fMaxVal;
 
+   Bool_t    fUIDoubleRep;    // Represent UI parts with real values.
    Bool_t    fInterpolate;    // Interpolate colors for signal values.
    Bool_t    fShowDefValue;   // Flags whether signals with default value should be shown.
    Bool_t    fFixColorRange;  // If true, map palette to low/high limit otherwise to min/max value.
@@ -57,6 +65,12 @@
 
    void SetupColor(Int_t val, UChar_t* pix) const;
 
+   Double_t IntToDouble(Int_t i)    const { return fUIf*i + fUIc; }
+   Int_t    DoubleToInt(Double_t d) const { return TMath::Nint((d - fUIc) / fUIf); }
+
+   Double_t GetCAMinAsDouble() const { return IntToDouble(fCAMin); }
+   Double_t GetCAMaxAsDouble() const { return IntToDouble(fCAMax); }
+
    static TEveRGBAPalette* fgDefaultPalette;
 
 public:
@@ -87,6 +101,9 @@
 
    // ================================================================
 
+   Bool_t GetUIDoubleRep() const { return fUIDoubleRep; }
+   void   SetUIDoubleRep(Bool_t b, Double_t f=1, Double_t c=0);
+
    Bool_t GetInterpolate() const { return fInterpolate; }
    void   SetInterpolate(Bool_t b);
 
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveRGBAPaletteEditor.h root/graf3d/eve/inc/TEveRGBAPaletteEditor.h
--- root-old/graf3d/eve/inc/TEveRGBAPaletteEditor.h	2012-02-12 20:59:06.028916888 -0800
+++ root/graf3d/eve/inc/TEveRGBAPaletteEditor.h	2012-06-27 13:27:30.965328072 -0700
@@ -37,6 +37,8 @@
    TGColorSelect        *fOverColor;
 
    TEveGDoubleValuator  *fMinMax;
+   Double_t              fOldMin;
+   Double_t              fOldMax;
 
    TGCheckButton        *fInterpolate;
    TGCheckButton        *fShowDefValue;
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveRGBAPaletteOverlay.h root/graf3d/eve/inc/TEveRGBAPaletteOverlay.h
--- root-old/graf3d/eve/inc/TEveRGBAPaletteOverlay.h	1969-12-31 16:00:00.000000000 -0800
+++ root/graf3d/eve/inc/TEveRGBAPaletteOverlay.h	2012-06-27 13:26:48.810327011 -0700
@@ -0,0 +1,54 @@
+// @(#)root/eve:$Id: root-5.32.00-fireworks2.patch,v 1.1 2012/06/28 01:09:28 matevz Exp $
+// Author: Alja Mrak Tadel 2012
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveRGBAPaletteOverlay
+#define ROOT_TEveRGBAPaletteOverlay
+
+#include "TAxis.h"
+#include "TGLOverlay.h"
+#include "TGLAxisPainter.h"
+
+class TEveRGBAPalette;
+
+class TEveRGBAPaletteOverlay : public TGLOverlayElement
+{
+private:
+   TEveRGBAPaletteOverlay(const TEveRGBAPaletteOverlay&);            // Not implemented
+   TEveRGBAPaletteOverlay& operator=(const TEveRGBAPaletteOverlay&); // Not implemented
+
+protected:
+   TEveRGBAPalette *fPalette;
+   TAxis            fAxis;
+   TGLAxisPainter   fAxisPainter;
+
+   Float_t          fPosX;         // x position
+   Float_t          fPosY;         // y position
+   Float_t          fWidth;        // width
+   Float_t          fHeight;       // height
+
+public:
+   TEveRGBAPaletteOverlay(TEveRGBAPalette* p, Float_t posx, Float_t posy,
+                          Float_t width, Float_t height);
+   virtual ~TEveRGBAPaletteOverlay() {}
+
+   virtual void Render(TGLRnrCtx& rnrCtx);
+
+   TAxis&           RefAxis() { return fAxis; }
+   TGLAxisPainter&  RefAxisPainter() { return fAxisPainter; }
+   
+
+   void SetPosition(Float_t x, Float_t y) { fPosX = x; fPosY = y; }
+   void SetSize(Float_t w, Float_t h) { fWidth = w; fHeight = h; }
+
+   ClassDef(TEveRGBAPaletteOverlay, 0); // Draws TEveRGBAPalette as GL overlay.
+};
+
+#endif
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackPropagator.h root/graf3d/eve/inc/TEveTrackPropagator.h
--- root-old/graf3d/eve/inc/TEveTrackPropagator.h	2012-02-12 20:59:06.028916888 -0800
+++ root/graf3d/eve/inc/TEveTrackPropagator.h	2012-06-27 13:31:53.162334713 -0700
@@ -33,10 +33,10 @@
    Bool_t  fFieldConstant;
 
 public:
-   TEveMagField(): fFieldConstant(kFALSE){}
-   virtual ~TEveMagField(){}
+   TEveMagField() : fFieldConstant(kFALSE) {}
+   virtual ~TEveMagField() {}
 
-   virtual Bool_t IsConst() const {return fFieldConstant;};
+   virtual Bool_t IsConst() const { return fFieldConstant; }
 
    virtual void  PrintField(Double_t x, Double_t y, Double_t z) const
    {
@@ -69,7 +69,8 @@
    TEveVectorD fB;
 
 public:
-   TEveMagFieldConst(Double_t x, Double_t y, Double_t z) : TEveMagField(), fB(x, y, z)
+   TEveMagFieldConst(Double_t x, Double_t y, Double_t z) :
+      TEveMagField(), fB(x, y, z)
    { fFieldConstant = kTRUE; }
    virtual ~TEveMagFieldConst() {}
 
@@ -93,8 +94,9 @@
    Double_t    fR2;
 
 public:
-   TEveMagFieldDuo(Double_t r, Double_t bIn, Double_t bOut) : TEveMagField(),
-     fBIn(0,0,bIn), fBOut(0,0,bOut), fR2(r*r)
+   TEveMagFieldDuo(Double_t r, Double_t bIn, Double_t bOut) :
+      TEveMagField(),
+      fBIn(0,0,bIn), fBOut(0,0,bOut), fR2(r*r)
    {
       fFieldConstant = kFALSE;
    }
@@ -107,7 +109,7 @@
    virtual Double_t GetMaxFieldMagD() const
    { Double_t b1 = fBIn.Mag(), b2 = fBOut.Mag(); return b1 > b2 ? b1 : b2; }
 
-   ClassDef(TEveMagFieldDuo, 0); // Interface to magnetic field with two different values depending of radius.
+   ClassDef(TEveMagFieldDuo, 0); // Interface to magnetic field with two different values depending on radius.
 };
 
 
@@ -174,6 +176,8 @@
    TEveTrackPropagator(const TEveTrackPropagator&);            // Not implemented
    TEveTrackPropagator& operator=(const TEveTrackPropagator&); // Not implemented
 
+  void  DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p);
+
 protected:
    EStepper_e               fStepper;
 
@@ -193,6 +197,7 @@
    Bool_t                   fFitReferences; // Pass through given track-references when extrapolating a track.
    Bool_t                   fFitDecay;      // Pass through decay point when extrapolating a track.
    Bool_t                   fFitCluster2Ds; // Pass through 2D-clusters when extrapolating a track.
+   Bool_t                   fFitLineSegments; // Pass through line when extrapolating a track.
    Bool_t                   fRnrDaughters;  // Render daughter path-marks.
    Bool_t                   fRnrReferences; // Render track-reference path-marks.
    Bool_t                   fRnrDecay;      // Render decay path-marks.
@@ -218,6 +223,7 @@
    void    Step(const TEveVector4D &v, const TEveVectorD &p, TEveVector4D &vOut, TEveVectorD &pOut);
 
    Bool_t  LoopToVertex(TEveVectorD& v, TEveVectorD& p);
+   Bool_t  LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p);
    void    LoopToBounds(TEveVectorD& p);
 
    Bool_t  LineToVertex (TEveVectorD& v);
@@ -229,8 +235,10 @@
                                TEveVectorD&itsect);
    Bool_t  LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal,
                               TEveVectorD& itsect);
+   Bool_t  PointOverVertex(const TEveVector4D& v0, const TEveVector4D& v, Double_t* p=0);
 
-   Bool_t PointOverVertex(const TEveVector4D& v0, const TEveVector4D& v, Double_t* p=0);
+   void    ClosestPointFromVertexToLineSegment(const TEveVectorD& v, const TEveVectorD& s, const TEveVectorD& r, Double_t rMagInv, TEveVectorD& c);
+   Bool_t ClosestPointBetweenLines(const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , const TEveVectorD& , TEveVectorD& out);
 
 public:
    TEveTrackPropagator(const char* n="TEveTrackPropagator", const char* t="",
@@ -246,13 +254,15 @@
    // propagation
    void   InitTrack(const TEveVectorD& v, Int_t charge);
    void   ResetTrack();
-   void   GoToBounds(TEveVectorD& p);
-   Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p);
+   virtual void   GoToBounds(TEveVectorD& p);
+   virtual Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p);
+   virtual Bool_t GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p);
 
    // TEveVectorF wrappers
    void   InitTrack(const TEveVectorF& v, Int_t charge);
    void   GoToBounds(TEveVectorF& p);
    Bool_t GoToVertex(TEveVectorF& v, TEveVectorF&p);
+   Bool_t GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p);
 
    Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal,
                          TEveVectorD& itsect);
@@ -282,6 +292,7 @@
    void   SetFitReferences(Bool_t x);
    void   SetFitDecay(Bool_t x);
    void   SetFitCluster2Ds(Bool_t x);
+   void   SetFitLineSegments(Bool_t x);
    void   SetRnrFV(Bool_t x);
    void   SetProjTrackBreaking(UChar_t x);
    void   SetRnrPTBMarkers(Bool_t x);
@@ -308,6 +319,7 @@
    Bool_t  GetFitReferences() const { return fFitReferences; }
    Bool_t  GetFitDecay()      const { return fFitDecay;      }
    Bool_t  GetFitCluster2Ds() const { return fFitCluster2Ds; }
+   Bool_t  GetFitLineSegments() const { return fFitLineSegments; }
    Bool_t  GetRnrFV()         const { return fRnrFV;         }
    UChar_t GetProjTrackBreaking() const { return fProjTrackBreaking; }
    Bool_t  GetRnrPTBMarkers()     const { return fRnrPTBMarkers; }
@@ -315,7 +327,7 @@
    TMarker& RefPMAtt()  { return fPMAtt; }
    TMarker& RefFVAtt()  { return fFVAtt; }
    TMarker& RefPTBAtt() { return fPTBAtt; }
-   
+
 
    static Bool_t IsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ);
 
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackPropagatorEditor.h root/graf3d/eve/inc/TEveTrackPropagatorEditor.h
--- root-old/graf3d/eve/inc/TEveTrackPropagatorEditor.h	2012-02-12 20:59:06.008916888 -0800
+++ root/graf3d/eve/inc/TEveTrackPropagatorEditor.h	2012-06-27 13:31:51.881334669 -0700
@@ -55,6 +55,7 @@
    TGButton           *fFitReferences;
    TGButton           *fFitDecay;
    TGButton           *fFitCluster2Ds;
+   TGButton           *fFitLineSegments;
    TGButton           *fRnrDaughters;
    TGButton           *fRnrReferences;
    TGButton           *fRnrDecay;
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEvePathMark.cxx root/graf3d/eve/src/TEvePathMark.cxx
--- root-old/graf3d/eve/src/TEvePathMark.cxx	2012-02-12 20:59:05.878916875 -0800
+++ root/graf3d/eve/src/TEvePathMark.cxx	2012-06-27 13:31:46.573334543 -0700
@@ -26,6 +26,11 @@
 //               fP - normal to detector plane,
 //               fE - large error direction, must be normalized.
 //               Track is propagated to plane and correction in fE direction is discarded.
+//  kLineSegment - line segment with vertex fV and vector fE
+//               fV - first point of line segment
+//               fP - normal to detector plane,
+//               fE - vector from fV to the second vertex of line segment
+
 
 ClassImp(TEvePathMarkT<Float_t>);
 ClassImp(TEvePathMarkT<Double_t>);
@@ -37,11 +42,12 @@
 
    switch (fType)
    {
-      case kDaughter:  return "Daughter";
-      case kReference: return "Reference";
-      case kDecay:     return "Decay";
-      case kCluster2D: return "Cluster2D";
-      default:         return "Unknown";
+      case kDaughter:    return "Daughter";
+      case kReference:   return "Reference";
+      case kDecay:       return "Decay";
+      case kCluster2D:   return "Cluster2D";
+      case kLineSegment: return "LineSegment";
+      default:           return "Unknown";
    }
 }
 
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveRGBAPalette.cxx root/graf3d/eve/src/TEveRGBAPalette.cxx
--- root-old/graf3d/eve/src/TEveRGBAPalette.cxx	2012-02-12 20:59:05.873916875 -0800
+++ root/graf3d/eve/src/TEveRGBAPalette.cxx	2012-06-27 13:27:26.930327983 -0700
@@ -32,8 +32,11 @@
    TObject(), TQObject(),
    TEveRefCnt(),
 
+   fUIf(1), fUIc(0),
+
    fLowLimit(0), fHighLimit(0), fMinVal(0), fMaxVal(0),
 
+   fUIDoubleRep     (kFALSE),
    fInterpolate     (kTRUE),
    fShowDefValue    (kTRUE),
    fFixColorRange   (kFALSE),
@@ -62,8 +65,11 @@
    TObject(), TQObject(),
    TEveRefCnt(),
 
+   fUIf(1), fUIc(0),
+
    fLowLimit(0), fHighLimit(0), fMinVal(0), fMaxVal(0),
 
+   fUIDoubleRep     (kFALSE),
    fInterpolate     (interp),
    fShowDefValue    (showdef),
    fFixColorRange   (fixcolrng),
@@ -108,7 +114,7 @@
    Float_t f;
    if      (val >= fCAMax) f = nCol - 1;
    else if (val <= fCAMin) f = 0;
-   else                     f = (val - fCAMin)/div*(nCol - 1);
+   else                    f = (val - fCAMin)/div*(nCol - 1);
 
    if (fInterpolate) {
       Int_t  bin = (Int_t) f;
@@ -220,6 +226,21 @@
 /******************************************************************************/
 
 //______________________________________________________________________________
+void TEveRGBAPalette::SetUIDoubleRep(Bool_t b, Double_t f, Double_t c)
+{
+   // Set flag determining whether GUI editor and overlays should show limits
+   // and axis values as real values with mapping from integer value i to real
+   // value d as: d = f*i + fc
+
+   fUIDoubleRep = b;
+   if (fUIDoubleRep) {
+      fUIf = f;  fUIc = c;
+   } else {
+      fUIf = 1;  fUIc = 0;
+   }
+}
+
+//______________________________________________________________________________
 void TEveRGBAPalette::SetInterpolate(Bool_t b)
 {
    // Set interpolation flag. This determines how colors from ROOT's
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveRGBAPaletteEditor.cxx root/graf3d/eve/src/TEveRGBAPaletteEditor.cxx
--- root-old/graf3d/eve/src/TEveRGBAPaletteEditor.cxx	2012-02-12 20:59:05.875916875 -0800
+++ root/graf3d/eve/src/TEveRGBAPaletteEditor.cxx	2012-06-27 13:27:28.041328003 -0700
@@ -40,7 +40,7 @@
    fOverflowAction  (0),
    fOverColor       (0),
 
-   fMinMax(0),
+   fMinMax(0), fOldMin(0), fOldMax(0),
 
    fInterpolate(0),
    fShowDefValue(0),
@@ -146,7 +146,6 @@
    fMinMax->Connect("ValueSet()",
                     "TEveRGBAPaletteSubEditor", this, "DoMinMax()");
    AddFrame(fMinMax, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
-
 }
 
 /******************************************************************************/
@@ -158,8 +157,21 @@
 
    fM = p;
 
-   fMinMax->SetValues(fM->fMinVal, fM->fMaxVal);
-   fMinMax->SetLimits(fM->fLowLimit, fM->fHighLimit);
+   if (fM->fUIDoubleRep)
+   {
+      fMinMax->SetValues(fM->IntToDouble(fM->fMinVal), fM->IntToDouble(fM->fMaxVal));
+      Double_t ll = fM->IntToDouble(fM->fLowLimit);
+      Double_t hl = fM->IntToDouble(fM->fHighLimit);
+      Int_t   mgk = TMath::Min(3, TMath::Max(0, 3 - TMath::Nint(TMath::Log10(hl-ll))));
+      fMinMax->SetLimits(ll, hl, (TGNumberFormat::EStyle)(TGNumberFormat::kNESInteger + mgk));
+      fOldMin = fMinMax->GetMin();
+      fOldMax = fMinMax->GetMax();
+   }
+   else
+   {
+      fMinMax->SetValues(fM->fMinVal, fM->fMaxVal);
+      fMinMax->SetLimits(fM->fLowLimit, fM->fHighLimit, TGNumberFormat::kNESInteger);
+   }
 
    fInterpolate  ->SetState(fM->fInterpolate ? kButtonDown : kButtonUp);
    fShowDefValue ->SetState(fM->fShowDefValue ? kButtonDown : kButtonUp);
@@ -190,7 +202,31 @@
 {
    // Slot for MinMax.
 
-   fM->SetMinMax((Int_t) fMinMax->GetMin(), (Int_t) fMinMax->GetMax());
+   if (fM->fUIDoubleRep)
+   {
+      Double_t min = fMinMax->GetMin();
+      if (min != fOldMin && fM->DoubleToInt(min) == fM->fMinVal)
+      {
+         if (min < fOldMin)
+            min = fM->IntToDouble(fM->fMinVal - 1);
+         else
+            min = fM->IntToDouble(fM->fMinVal + 1);
+      }
+      Double_t max = fMinMax->GetMax();
+      if (max != fOldMax && fM->DoubleToInt(max) == fM->fMaxVal)
+      {
+         if (max < fOldMax)
+            max = fM->IntToDouble(fM->fMaxVal - 1);
+         else
+            max = fM->IntToDouble(fM->fMaxVal + 1);
+      }
+      fM->SetMinMax(fM->DoubleToInt(min), fM->DoubleToInt(max));
+   }
+   else
+   {
+      fM->SetMinMax((Int_t) fMinMax->GetMin(), (Int_t) fMinMax->GetMax());
+   }
+
    Changed();
    fM->MinMaxValChanged();
 }
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveRGBAPaletteOverlay.cxx root/graf3d/eve/src/TEveRGBAPaletteOverlay.cxx
--- root-old/graf3d/eve/src/TEveRGBAPaletteOverlay.cxx	1969-12-31 16:00:00.000000000 -0800
+++ root/graf3d/eve/src/TEveRGBAPaletteOverlay.cxx	2012-06-27 13:27:25.830327941 -0700
@@ -0,0 +1,123 @@
+// @(#)root/eve:$Id: root-5.32.00-fireworks2.patch,v 1.1 2012/06/28 01:09:28 matevz Exp $
+// Author: Alja Mrak Tadel 2012
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveRGBAPaletteOverlay.h"
+#include "TEveRGBAPalette.h"
+
+#include "TGLIncludes.h"
+#include "TGLAxis.h"
+#include "TGLRnrCtx.h"
+#include "TGLUtil.h"
+
+//______________________________________________________________________________
+// Description of TEveRGBAPaletteOverlay
+//
+
+ClassImp(TEveRGBAPaletteOverlay);
+
+//______________________________________________________________________________
+TEveRGBAPaletteOverlay::TEveRGBAPaletteOverlay(TEveRGBAPalette* p, Float_t posx, Float_t posy,
+                                               Float_t width, Float_t height) :
+   TGLOverlayElement(),
+   fPalette(p),
+   fPosX(posx),
+   fPosY(posy),
+   fWidth(width),
+   fHeight(height)
+{
+   // Constructor.
+
+   fAxis.SetNdivisions(900);
+   fAxisPainter.SetUseAxisColors(kFALSE);
+   fAxisPainter.SetLabelPixelFontSize(10);
+   fAxisPainter.SetFontMode(TGLFont::kPixmap);
+   fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
+}
+
+void TEveRGBAPaletteOverlay::Render(TGLRnrCtx& rnrCtx) 
+{ 
+   // Render the overlay.
+
+   const Double_t ca_min = fPalette->GetCAMinAsDouble();
+   const Double_t ca_max = fPalette->GetCAMaxAsDouble();
+
+   // Uninitialized palette.
+   if (ca_min == ca_max) return;
+
+   fAxis.SetLimits(ca_min, ca_max);
+
+   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
+
+   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);  
+   glDisable(GL_CULL_FACE);
+   glEnable(GL_BLEND);
+   glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
+
+   // reset to [0,1] units
+   glMatrixMode(GL_PROJECTION);
+   glPushMatrix();
+   glLoadIdentity();
+   glOrtho(0, 1, 0, 1, 0, 1);
+   glMatrixMode(GL_MODELVIEW);
+   glPushMatrix();
+   glLoadIdentity();
+
+   // postion pallette
+   glTranslatef(fPosX, fPosY, 0);
+
+   // colored quads
+   {
+      TGLCapabilitySwitch move_to_back(GL_POLYGON_OFFSET_FILL, kTRUE);
+      glPolygonOffset(0.5f, 0.5f);
+
+      glBegin(GL_QUAD_STRIP);
+      TGLUtil::Color4ubv(fPalette->ColorFromValue(fPalette->fCAMin));
+      glVertex2f(0, 0);
+      glVertex2f(0, fHeight);
+      Float_t xs = fWidth / (fPalette->fCAMax - fPalette->fCAMin);
+      Float_t x  = xs;
+      for (Int_t i = fPalette->fCAMin + 1; i < fPalette->fCAMax; ++i)
+      {
+         TGLUtil::Color4ubv(fPalette->ColorFromValue(i));
+         glVertex2f(x, 0);
+         glVertex2f(x, fHeight);
+         x += xs;
+      }
+      TGLUtil::Color4ubv(fPalette->ColorFromValue(fPalette->fCAMax));
+      glVertex2f(fWidth, 0);
+      glVertex2f(fWidth, fHeight);
+      glEnd();
+   }
+
+   // axis
+   glPushMatrix();
+   Float_t sf = fWidth / (ca_max - ca_min);
+   glScalef(sf, 1, 1);
+   glTranslatef(-ca_min, 0, 0);
+   fAxis.SetTickLength(0.05*fWidth);
+   fAxisPainter.RefTMOff(0).Set(0, -1, 0);
+   fAxisPainter.PaintAxis(rnrCtx, &fAxis);
+   glPopMatrix();
+
+   // frame around palette
+   glBegin(GL_LINE_LOOP);
+   glVertex2f(0, 0);             glVertex2f(fWidth, 0);
+   glVertex2f(fWidth, fHeight);  glVertex2f(0, fHeight);
+   glEnd();
+
+   glMatrixMode(GL_PROJECTION);
+   glPopMatrix();
+   glMatrixMode(GL_MODELVIEW);
+   glPopMatrix();
+
+   glPopAttrib();
+}
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrack.cxx root/graf3d/eve/src/TEveTrack.cxx
--- root-old/graf3d/eve/src/TEveTrack.cxx	2012-02-12 20:59:05.884916876 -0800
+++ root/graf3d/eve/src/TEveTrack.cxx	2012-06-27 13:31:47.858334576 -0700
@@ -409,11 +409,25 @@
                   Warning("TEveTrack::MakeTrack", "Failed to intersect plane for Cluster2D. Ignoring path-mark.");
                }
             }
+            else if (rTP.GetFitLineSegments() && pm->fType == TEvePathMarkD::kLineSegment)
+            {
+               if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
+                  break;
+
+               if (fPropagator->GoToLineSegment(pm->fV, pm->fE, currP))
+               {
+                  currP.fX -= pm->fP.fX; currP.fY -= pm->fP.fY; currP.fZ -= pm->fP.fZ;
+               }
+               else
+               {
+                  break;
+               }
+            }
             else
             {
                if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
                   break;
-            }            
+            }
          } // loop path-marks
 
          if (!decay)
@@ -503,10 +517,11 @@
 
    for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
    {
-      printf("  %-9s  p: %8f %8f %8f Vertex: %8e %8e %8e %g \n",
+      printf("  %-9s  p: %8f %8f %8f Vertex: %8e %8e %8e %g Extra:%8f %8f %8f\n",
              pm->TypeName(),
              pm->fP.fX,  pm->fP.fY, pm->fP.fZ,
              pm->fV.fX,  pm->fV.fY, pm->fV.fZ,
+             pm->fE.fX,  pm->fE.fY, pm->fE.fZ,
              pm->fTime);
    }
 }
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackPropagator.cxx root/graf3d/eve/src/TEveTrackPropagator.cxx
--- root-old/graf3d/eve/src/TEveTrackPropagator.cxx	2012-02-12 20:59:05.876916875 -0800
+++ root/graf3d/eve/src/TEveTrackPropagator.cxx	2012-06-27 13:31:45.478334517 -0700
@@ -18,6 +18,40 @@
 
 #include <cassert>
 
+//==============================================================================
+// TEveMagFiled classes -- documentation only
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Abstract base-class for interfacing to magnetic field needed by the
+// TEveTrackPropagator.
+// See sub-classes for two simple implementations.
+//
+// NOTE: Magnetic field direction convention is inverted.
+
+ClassImp(TEveMagField);
+
+//______________________________________________________________________________
+//
+// Implements constant magnetic field, given by a vector fB.
+//
+// NOTE: Magnetic field direction convention is inverted.
+
+ClassImp(TEveMagFieldConst);
+
+//______________________________________________________________________________
+//
+// Implements constant magnetic filed that switches on given axial radius fR2
+// from vector fBIn to fBOut.
+//
+// NOTE: Magnetic field direction convention is inverted.
+
+ClassImp(TEveMagFieldDuo);
+
+
+//==============================================================================
+
 namespace
 {
    const Double_t kBMin     = 1e-6;
@@ -164,16 +198,20 @@
 // Holding structure for a number of track rendering parameters.
 // Calculates path taking into account the parameters.
 //
+// NOTE: Magnetic field direction convention is inverted.
+//
 // This is decoupled from TEveTrack/TEveTrackList to allow sharing of the
-// Propagator among several instances. Back references are kept so the
-// tracks can be recreated when the parameters change.
+// Propagator among several instances. Back references are kept so the tracks
+// can be recreated when the parameters change.
 //
 // TEveTrackList has Get/Set methods for RnrStlye. TEveTrackEditor and
 // TEveTrackListEditor provide editor access.
 //
-// Specify whether 2D projected tracks get broken into several
-// segments when the projected space consists of separate domains
-// (like Rho-Z). This is true by default.
+// Enum EProjTrackBreaking_e and member fProjTrackBreaking specify whether 2D
+// projected tracks get broken into several segments when the projected space
+// consists of separate domains (like Rho-Z). The track-breaking is enabled by
+// default.
+//
 
 ClassImp(TEveTrackPropagator);
 
@@ -199,7 +237,8 @@
 
    fEditPathMarks (kTRUE),
    fFitDaughters  (kTRUE),   fFitReferences (kTRUE),
-   fFitDecay      (kTRUE),   fFitCluster2Ds (kTRUE),
+   fFitDecay      (kTRUE),
+   fFitCluster2Ds (kTRUE),   fFitLineSegments (kTRUE),
    fRnrDaughters  (kFALSE),  fRnrReferences (kFALSE),
    fRnrDecay      (kFALSE),  fRnrCluster2Ds (kFALSE),
    fRnrFV         (kFALSE),
@@ -330,6 +369,26 @@
 }
 
 //______________________________________________________________________________
+Bool_t TEveTrackPropagator::GoToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p)
+{
+   // Propagate particle with momentum p to line with start point s and vector r to the second point.
+
+   Update(fV, p, kTRUE);
+
+   if (!fH.fValid)
+   {
+      TEveVectorD v;
+      ClosestPointBetweenLines(s, r, fV, p, v);
+      LineToVertex(v);
+      return kTRUE;
+   }
+   else
+   {
+      return LoopToLineSegment(s, r, p);
+   }
+}
+
+//______________________________________________________________________________
 Bool_t TEveTrackPropagator::GoToVertex(TEveVectorF& v, TEveVectorF& p)
 {
    // TEveVectorF wrapper.
@@ -341,6 +400,17 @@
 }
 
 //______________________________________________________________________________
+Bool_t TEveTrackPropagator::GoToLineSegment(const TEveVectorF& s, const TEveVectorF& r, TEveVectorF& p)
+{
+   // TEveVectorF wrapper.
+
+   TEveVectorD sd(s), rd(r), pd(p);
+   Bool_t result = GoToLineSegment(sd, rd, pd);
+   p = pd;
+   return result;
+}
+
+//______________________________________________________________________________
 void TEveTrackPropagator::GoToBounds(TEveVectorD& p)
 {
    // Propagate particle to bounds.
@@ -403,7 +473,7 @@
 	 }
 	 else
 	 {
-            fH.fRKStep = fH.fMaxStep; 
+            fH.fRKStep = fH.fMaxStep;
 	 }
       }
    }
@@ -573,32 +643,96 @@
 
          TEveVectorD off(v - currV);
          off *= 1.0f / currV.fT;
+         DistributeOffset(off,  first_point, np, p);
+         fV = v;
+         return kTRUE;
+      }
+   }
+
+   fPoints.push_back(v);
+   fV = v;
+   return kTRUE;
+}
+
+//______________________________________________________________________________
+Bool_t TEveTrackPropagator::LoopToLineSegment(const TEveVectorD& s, const TEveVectorD& r, TEveVectorD& p)
+{
+   // Propagate charged particle with momentum p to line segment with point s and vector r to the second point.
+   // It is expected that Update() with full-update was called before. Returns kFALSE if hits bounds.
+
+   const Double_t maxRsq = fMaxR * fMaxR;
+   const Double_t rMagInv = 1./r.Mag();
+
+   TEveVector4D currV(fV);
+   TEveVector4D forwV(fV);
+   TEveVectorD  forwP(p);
+
+   Int_t first_point = fPoints.size();
+   Int_t np          = first_point;
 
-         // Calculate the required momentum rotation.
-         // lpd - last-points-delta
-         TEveVectorD lpd0(fPoints[np-1]);
-         lpd0 -= fPoints[np-2];
-         lpd0.Normalize();
+   TEveVectorD forwC;
+   TEveVectorD currC;
+   do
+   {
+      Step(currV, p, forwV, forwP);
+      Update(forwV, forwP);
+
+      ClosestPointFromVertexToLineSegment(forwV, s, r, rMagInv, forwC);
+
+      // check forwV is over segment with orthogonal component of
+      // of momentum to vector r
+      TEveVectorD b = r; b.Normalize();
+      Double_t x = forwP.Dot(b);
+      TEveVectorD pTPM = forwP - x*b;
+      if (pTPM.Dot(forwC-forwV) < 0)
+      {
+         break;
+      }
 
-         for (Int_t i = first_point; i < np; ++i)
+      if (IsOutsideBounds(forwV, maxRsq, fMaxZ))
+      {
+         fV = currV;
+         return kFALSE;
+      }
+
+      fPoints.push_back(forwV);
+      currV = forwV;
+      p     = forwP;
+      currC=forwC;
+      ++np;
+   } while (np < fNMax);
+
+   // Get closest point on segment relative to line with forw and currV points.
+   TEveVectorD v;
+   ClosestPointBetweenLines(s, r, currV, forwV - currV, v);
+
+   // make the remaining fractional step
+   if (np > first_point)
+   {
+      if ((v - currV).Mag() > kStepEps)
+      {
+
+         Double_t step_frac = (v-currV).Mag()/(currV-forwV).Mag();
+         if (step_frac > 0)
          {
-            fPoints[i] += off * fPoints[i].fT;
+            // Step for fraction of previous step size.
+            // We pass 'enforce_max_step' flag to Update().
+            Float_t orig_max_step = fH.fMaxStep;
+            fH.fMaxStep = step_frac * (forwV - currV).Mag();
+            Update(currV, p, kTRUE, kTRUE);
+            Step(currV, p, forwV, forwP);
+            p     = forwP;
+            currV = forwV;
+            fPoints.push_back(currV);
+            ++np;
+            fH.fMaxStep = orig_max_step;
          }
 
-         TEveVectorD lpd1(fPoints[np-1]);
-         lpd1 -= fPoints[np-2];
-         lpd1.Normalize();
-
-         TEveTrans tt;
-         tt.SetupFromToVec(lpd0, lpd1);
-
-         // TEveVectorD pb4(p);
-         // printf("Rotating momentum: p0 = "); p.Dump();
-         tt.RotateIP(p);
-         // printf("                   p1 = "); p.Dump();
-         // printf("  n1=%f, n2=%f, dp = %f deg\n", pb4.Mag(), p.Mag(),
-         //        TMath::RadToDeg()*TMath::ACos(p.Dot(pb4)/(pb4.Mag()*p.Mag())));
+         // Distribute offset to desired crossing point over all segment.
 
+         TEveVectorD off(v - currV);
+         off *= 1.0f / currV.fT;
+         DistributeOffset(off, first_point, np, p);
          fV = v;
          return kTRUE;
       }
@@ -610,6 +744,38 @@
 }
 
 //______________________________________________________________________________
+void TEveTrackPropagator::DistributeOffset(const TEveVectorD& off, Int_t first_point, Int_t np, TEveVectorD& p)
+{
+   // Distribute offset between first and last point index and rotate
+   // momentum.
+
+   // Calculate the required momentum rotation.
+   // lpd - last-points-delta
+   TEveVectorD lpd0(fPoints[np-1]);
+   lpd0 -= fPoints[np-2];
+   lpd0.Normalize();
+
+   for (Int_t i = first_point; i < np; ++i)
+   {
+      fPoints[i] += off * fPoints[i].fT;
+   }
+
+   TEveVectorD lpd1(fPoints[np-1]);
+   lpd1 -= fPoints[np-2];
+   lpd1.Normalize();
+
+   TEveTrans tt;
+   tt.SetupFromToVec(lpd0, lpd1);
+
+   // TEveVectorD pb4(p);
+   // printf("Rotating momentum: p0 = "); p.Dump();
+   tt.RotateIP(p);
+   // printf("                   p1 = "); p.Dump();
+   // printf("  n1=%f, n2=%f, dp = %f deg\n", pb4.Mag(), p.Mag(),
+   //        TMath::RadToDeg()*TMath::ACos(p.Dot(pb4)/(pb4.Mag()*p.Mag())));
+}
+
+//______________________________________________________________________________
 Bool_t TEveTrackPropagator::LineToVertex(TEveVectorD& v)
 {
    // Propagate neutral particle to vertex v.
@@ -755,6 +921,55 @@
 }
 
 //______________________________________________________________________________
+void TEveTrackPropagator::ClosestPointFromVertexToLineSegment(const TEveVectorD& v,
+                                                    const TEveVectorD& s,
+                                                    const TEveVectorD& r,
+                                                    Double_t rMagInv,
+                                                    TEveVectorD& c)
+{
+   // Get closest point from given vertex v to line segment defined with s and r.
+   // Argument rMagInv is cached. rMagInv= 1./rMag()
+
+   TEveVectorD dir = v - s;
+   TEveVectorD b1 = r*rMagInv;
+
+   // paralell distance
+   Double_t dot = dir.Dot(b1);
+   TEveVectorD dirI = dot *  b1;
+
+   Double_t facX = dot * rMagInv;
+   if ( facX <= 0)
+      c = s;
+   else if ( facX >= 1)
+      c = s + r;
+   else
+      c = s + dirI;
+}
+
+//______________________________________________________________________________
+Bool_t TEveTrackPropagator::ClosestPointBetweenLines(const TEveVectorD& p0,
+                                                     const TEveVectorD& u,
+                                                     const TEveVectorD& q0,
+                                                     const TEveVectorD& v,
+                                                     TEveVectorD& out)
+{
+   // Get closest point on line defined with vector p0 and u.
+   // Return false if the point is forced on the line segment.
+
+   TEveVectorD w0 = p0 -q0;
+   Double_t a = u.Mag2();
+   Double_t b = u.Dot(v);
+   Double_t c = v.Mag2();
+   Double_t d = u.Dot(w0);
+   Double_t e = v.Dot(w0);
+
+   Double_t x = (b*e - c*d)/(a*c -b*b);
+   Bool_t force = (x < 0 || x > 1);
+   out = p0 + TMath::Range(0., 1., x) * u;
+   return force;
+}
+
+//______________________________________________________________________________
 void TEveTrackPropagator::FillPointSet(TEvePointSet* ps) const
 {
    // Reset ps and populate it with points in propagation cache.
@@ -913,6 +1128,15 @@
    RebuildTracks();
 }
 
+//______________________________________________________________________________
+void TEveTrackPropagator::SetFitLineSegments(Bool_t x)
+{
+   // Set line segment fitting and rebuild tracks.
+
+   fFitLineSegments = x;
+   RebuildTracks();
+}
+
 //______________________________________________________________________________
 void TEveTrackPropagator::SetFitCluster2Ds(Bool_t x)
 {
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackPropagatorEditor.cxx root/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
--- root-old/graf3d/eve/src/TEveTrackPropagatorEditor.cxx	2012-02-12 20:59:05.896916877 -0800
+++ root/graf3d/eve/src/TEveTrackPropagatorEditor.cxx	2012-06-27 13:31:48.959334605 -0700
@@ -45,7 +45,8 @@
 
    fRefsCont(0),      fPMFrame(0),
    fFitDaughters(0),  fFitReferences(0),
-   fFitDecay(0),      fFitCluster2Ds(0),
+   fFitDecay(0),
+   fFitCluster2Ds(0), fFitLineSegments(0),
    fRnrDaughters(0),  fRnrReferences(0),
    fRnrDecay(0),      fRnrCluster2Ds(0),
    fRnrFV(0),
@@ -124,16 +125,19 @@
       fFitReferences = new TGCheckButton(fitPM, "Fit Refs",        TEvePathMark::kReference);
       fFitDecay      = new TGCheckButton(fitPM, "Fit Decay",       TEvePathMark::kDecay);
       fFitCluster2Ds = new TGCheckButton(fitPM, "Fit 2D Clusters", TEvePathMark::kCluster2D);
+      fFitLineSegments = new TGCheckButton(fitPM, "Fit Line Segments", TEvePathMark::kLineSegment);
 
       fitPM->AddFrame(fFitDaughters);
       fitPM->AddFrame(fFitReferences);
       fitPM->AddFrame(fFitDecay);
       fitPM->AddFrame(fFitCluster2Ds);
+      fitPM->AddFrame(fFitLineSegments);
 
-      fFitDecay     ->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
-      fFitReferences->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
-      fFitDaughters ->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
-      fFitCluster2Ds->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
+      fFitDecay       ->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
+      fFitReferences  ->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
+      fFitDaughters   ->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
+      fFitCluster2Ds  ->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
+      fFitLineSegments->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoFitPM()");
    }
    // Kinematics fitting.
    {
@@ -260,6 +264,7 @@
       fFitReferences->SetState(fM->fFitReferences ? kButtonDown : kButtonUp);
       fFitDecay->SetState(fM->fFitDecay ? kButtonDown : kButtonUp);
       fFitCluster2Ds->SetState(fM->fFitCluster2Ds ? kButtonDown : kButtonUp);
+      fFitLineSegments->SetState(fM->fFitLineSegments ? kButtonDown : kButtonUp);
 
       fPMAtt->SetModel(&fM->fPMAtt);
    }
@@ -358,6 +363,9 @@
       case TEvePathMark::kCluster2D:
          fM->SetFitCluster2Ds(on);
          break;
+      case TEvePathMark::kLineSegment:
+         fM->SetFitLineSegments(on);
+         break;
 
       default:
          break;
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLCamera.h root/graf3d/gl/inc/TGLCamera.h
--- root-old/graf3d/gl/inc/TGLCamera.h	2012-02-12 20:59:06.268916913 -0800
+++ root/graf3d/gl/inc/TGLCamera.h	2012-06-27 13:32:06.964335053 -0700
@@ -76,6 +76,7 @@
    TGLMatrix   fCamTrans;        //! transformation relative to fCamTrans
    Bool_t      fExternalCenter;  //! use external center insead of scene center
    Bool_t      fFixDefCenter;    //! use fixed default center
+   Bool_t      fWasArcBalled;    //! set when arc-ball rotation is used
    TGLVector3  fExtCenter;       //! external camera center
    TGLVector3  fDefCenter;       //! deafult camera center
    TGLVector3  fFDCenter;        //! fixed deafult camera center
@@ -136,6 +137,8 @@
    virtual Bool_t Truck(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2) = 0;
    virtual Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
    virtual Bool_t RotateRad(Double_t hRotate, Double_t vRotate);
+   virtual Bool_t RotateArcBall(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
+   virtual Bool_t RotateArcBallRad(Double_t hRotate, Double_t vRotate);
 
    virtual void   Apply(const TGLBoundingBox & sceneBox, const TGLRect * pickRect = 0) const = 0;
 
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLEventHandler.h root/graf3d/gl/inc/TGLEventHandler.h
--- root-old/graf3d/gl/inc/TGLEventHandler.h	2012-02-12 20:59:06.267916913 -0800
+++ root/graf3d/gl/inc/TGLEventHandler.h	2012-06-27 13:32:05.865335034 -0700
@@ -48,6 +48,7 @@
    Bool_t            fInPointerGrab;
    Bool_t            fMouseTimerRunning;
    Bool_t            fTooltipShown;
+   Bool_t            fArcBall;
    Int_t             fTooltipPixelTolerance;
    Int_t             fSecSelType; // secondary selection type
    Bool_t            fDoInternalSelection;
@@ -103,6 +104,9 @@
    Bool_t GetDoInternalSelection() const { return fDoInternalSelection; }
    void   SetDoInternalSelection(Bool_t x) { fDoInternalSelection = x; }
 
+   Bool_t GetArcBall() const   { return fArcBall; }
+   void   SetArcBall(Bool_t a) { fArcBall = a;    }
+
    ClassDef(TGLEventHandler, 0); // Base-class and default implementation of event-handler for TGLViewer.
 };
 
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLViewer.h root/graf3d/gl/inc/TGLViewer.h
--- root-old/graf3d/gl/inc/TGLViewer.h	2012-02-12 21:14:55.828006457 -0800
+++ root/graf3d/gl/inc/TGLViewer.h	2012-06-27 13:32:04.768335011 -0700
@@ -268,6 +268,7 @@
                              Double_t center[3], Double_t hRotate, Double_t vRotate);
    void SetPerspectiveCamera(ECameraType camera, Double_t fov, Double_t dolly,
                              Double_t center[3], Double_t hRotate, Double_t vRotate);
+   void ReinitializeCurrentCamera(const TGLVector3& hAxis, const TGLVector3& vAxis, Bool_t redraw=kTRUE);
    void GetGuideState(Int_t & axesType, Bool_t & axesDepthTest, Bool_t & referenceOn, Double_t* referencePos) const;
    void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos);
    void SetDrawCameraCenter(Bool_t x);
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLCamera.cxx root/graf3d/gl/src/TGLCamera.cxx
--- root-old/graf3d/gl/src/TGLCamera.cxx	2012-02-12 20:59:06.167916903 -0800
+++ root/graf3d/gl/src/TGLCamera.cxx	2012-06-27 13:31:56.094334787 -0700
@@ -44,6 +44,7 @@
 TGLCamera::TGLCamera() :
    fExternalCenter(kFALSE),
    fFixDefCenter(kFALSE),
+   fWasArcBalled(kFALSE),
    fCenter(&fDefCenter),
    fNearClip(0), fFarClip(0),
    fDollyDefault(1.0), fDollyDistance(1.0),
@@ -66,6 +67,7 @@
 TGLCamera::TGLCamera(const TGLVector3 & hAxis, const TGLVector3 & vAxis) :
    fExternalCenter(kFALSE),
    fFixDefCenter(kFALSE),
+   fWasArcBalled(kFALSE),
    fCenter(&fDefCenter),
    fNearClip(0), fFarClip(0),
    fDollyDefault(1.0), fDollyDistance(1.0),
@@ -901,7 +903,24 @@
    // Rotate camera around center.
 
    using namespace TMath;
-   if (hRotate != 0.0)
+
+   if (fWasArcBalled)
+   {
+      Double_t *M = fCamTrans.Arr();
+      Double_t  d = M[2];
+      if      (d >  1) d =  1;
+      else if (d < -1) d = -1; // Fix numerical errors
+
+      Double_t theta = ASin(d);
+      Double_t phi   = Abs(Cos(theta)) > 8.7e-6 ? ATan2(M[1], M[0]) : ATan2(-M[4], M[5]);
+
+      M[0] = M[5] = M[10] = 1;
+      M[1] = M[2] = M[4] = M[6] = M[8] = M[9] = 0;
+      fCamTrans.RotateLF(1, 2, phi);
+      fCamTrans.RotateLF(1, 3, theta);
+   }
+
+   if (hRotate != 0.0 || fWasArcBalled)
    {
       TGLVector3 fwd  = fCamTrans.GetBaseVec(1);
       TGLVector3 lft  = fCamTrans.GetBaseVec(2);
@@ -914,11 +933,12 @@
 
       // up vector lock
       TGLVector3 zdir = fCamBase.GetBaseVec(3);
+
       fCamBase.RotateIP(fwd);
       Double_t theta = ACos(fwd*zdir);
-      if(theta+hRotate < fVAxisMinAngle)
+      if (theta + hRotate < fVAxisMinAngle)
          hRotate = fVAxisMinAngle - theta;
-      else if(theta+hRotate > Pi() - fVAxisMinAngle)
+      else if (theta + hRotate > Pi() - fVAxisMinAngle)
          hRotate = Pi() - fVAxisMinAngle - theta;
 
       fCamTrans.MoveLF(1, -deltaF);
@@ -926,6 +946,8 @@
       fCamTrans.RotateLF(3, 1, hRotate);
       fCamTrans.MoveLF(3,  deltaU);
       fCamTrans.MoveLF(1,  deltaF);
+
+      fWasArcBalled = kFALSE;
    }
    if (vRotate != 0.0)
    {
@@ -934,6 +956,60 @@
 
    IncTimeStamp();
    return kTRUE;
+}
+
+//______________________________________________________________________________
+Bool_t TGLCamera::RotateArcBall(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2)
+{
+   // Rotate the camera round view volume center established in Setup().
+   // Arguments are:
+   // xDelta - horizontal delta (pixels)
+   // YDelta - vertical delta (pixels)
+
+   Double_t vRotate = AdjustDelta(xDelta, TMath::TwoPi() / fViewport.Width(), mod1, mod2);
+   Double_t hRotate = AdjustDelta(yDelta, TMath::Pi()   / fViewport.Height(), mod1, mod2);
+
+   return RotateArcBallRad(hRotate, vRotate);
+}
+
+//______________________________________________________________________________
+Bool_t TGLCamera::RotateArcBallRad(Double_t hRotate, Double_t vRotate)
+{
+   // Rotate camera around center.
+
+   using namespace TMath;
+
+   TGLVector3 fwd  = fCamTrans.GetBaseVec(1);
+   TGLVector3 lft  = fCamTrans.GetBaseVec(2);
+   TGLVector3 up   = fCamTrans.GetBaseVec(3);
+   TGLVector3 pos  = fCamTrans.GetTranslation();
+
+   TGLVector3 deltaT = pos - (pos*lft)*lft;
+   Double_t   deltaF = deltaT * fwd;
+   Double_t   deltaL = deltaT * lft;
+   Double_t   deltaU = deltaT * up;
+
+   fCamTrans.MoveLF(1, -deltaF);
+   fCamTrans.MoveLF(2, -deltaL);
+   fCamTrans.MoveLF(3, -deltaU);
+
+   if (hRotate != 0.0)
+   {
+      fCamTrans.RotateLF(3, 1, hRotate);
+   }
+   if (vRotate != 0.0)
+   {
+      fCamTrans.RotateLF(1, 2, -vRotate);
+   }
+
+   fCamTrans.MoveLF(3, deltaU);
+   fCamTrans.MoveLF(2, deltaL);
+   fCamTrans.MoveLF(1, deltaF);
+
+   fWasArcBalled = kTRUE;
+
+   IncTimeStamp();
+   return kTRUE;
 }
 
 //______________________________________________________________________________
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLEventHandler.cxx root/graf3d/gl/src/TGLEventHandler.cxx
--- root-old/graf3d/gl/src/TGLEventHandler.cxx	2012-02-15 19:53:22.361987142 -0800
+++ root/graf3d/gl/src/TGLEventHandler.cxx	2012-06-27 13:32:00.871334909 -0700
@@ -71,6 +71,7 @@
    fInPointerGrab      (kFALSE),
    fMouseTimerRunning  (kFALSE),
    fTooltipShown       (kFALSE),
+   fArcBall            (kFALSE),
    fTooltipPixelTolerance (3),
    fSecSelType(TGLViewer::kOnRequest),
    fDoInternalSelection(kTRUE),
@@ -797,6 +798,10 @@
             break;
 
             // Camera
+         case kKey_A:
+         case kKey_a:
+            fArcBall = ! fArcBall;
+            break;
          case kKey_Plus:
          case kKey_J:
          case kKey_j:
@@ -942,7 +947,9 @@
 {
    // Method to handle action TGLViewer::kDragCameraRotate.
 
-   return fGLViewer->CurrentCamera().Rotate(xDelta, -yDelta, mod1, mod2);
+   TGLCamera &cam = fGLViewer->CurrentCamera();
+   if (fArcBall) return cam.RotateArcBall(xDelta, -yDelta, mod1, mod2);
+   else          return cam.Rotate       (xDelta, -yDelta, mod1, mod2);
 }
 
 //______________________________________________________________________________
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLOrthoCamera.cxx root/graf3d/gl/src/TGLOrthoCamera.cxx
--- root-old/graf3d/gl/src/TGLOrthoCamera.cxx	2012-02-12 20:59:06.178916905 -0800
+++ root/graf3d/gl/src/TGLOrthoCamera.cxx	2012-06-27 13:31:59.587334879 -0700
@@ -277,7 +277,7 @@
    TGLVector3 pos    = mx.GetTranslation();
    TGLVector3 fwd    = mx.GetBaseVec(1);
    TGLVector3 center = pos - fwd;
-   TGLVector3 up     = fCamBase.GetBaseVec(3);
+   TGLVector3 up     = mx.GetBaseVec(3);
 
    gluLookAt(pos[0],    pos[1],    pos[2],
              center[0], center[1], center[2],
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLPerspectiveCamera.cxx root/graf3d/gl/src/TGLPerspectiveCamera.cxx
--- root-old/graf3d/gl/src/TGLPerspectiveCamera.cxx	2012-02-12 20:59:06.169916904 -0800
+++ root/graf3d/gl/src/TGLPerspectiveCamera.cxx	2012-06-27 13:31:57.200334811 -0700
@@ -191,7 +191,7 @@
    TGLVector3 pos    = mx.GetTranslation();
    TGLVector3 fwd    = mx.GetBaseVec(1);
    TGLVector3 center = pos - fwd;
-   TGLVector3 up     = fCamBase.GetBaseVec(3);
+   TGLVector3 up     = mx.GetBaseVec(3);
 
    gluLookAt(pos[0],    pos[1],    pos[2],
              center[0], center[1], center[2],
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLSAViewer.cxx root/graf3d/gl/src/TGLSAViewer.cxx
--- root-old/graf3d/gl/src/TGLSAViewer.cxx	2012-02-12 20:59:06.175916902 -0800
+++ root/graf3d/gl/src/TGLSAViewer.cxx	2012-06-27 13:31:58.487334849 -0700
@@ -63,6 +63,7 @@
    \tt          --- outline mode\n\
    \tj          --- ZOOM in\n\
    \tk          --- ZOOM out\n\
+   \ta          --- switch on/off arc-ball camera rotation control\n\
    \tArrow Keys --- PAN (TRUCK) across scene\n\
    \tHome       --- reset current camera\n\
    \tCtrl-Home  --- switch external/automatic camera center\n\
diff -Naur '--exclude=.svn' -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLViewer.cxx root/graf3d/gl/src/TGLViewer.cxx
--- root-old/graf3d/gl/src/TGLViewer.cxx	2012-03-01 20:03:18.875332895 -0800
+++ root/graf3d/gl/src/TGLViewer.cxx	2012-06-27 13:32:02.344334944 -0700
@@ -883,7 +883,14 @@
    catch (std::runtime_error& exc)
    {
       Error(eh, "%s",exc.what());
-      return kFALSE;
+      if (gEnv->GetValue("OpenGL.SavePictureFallbackToBB", 1)) {
+         Info(eh, "Falling back to saving image via back-buffer. Window must be fully visible.");
+         if (w != fViewport.Width() || h != fViewport.Height())
+            Warning(eh, "Back-buffer does not support image scaling, window size will be used.");
+         return SavePictureUsingBB(fileName);
+      } else {
+         return kFALSE;
+      }
    }
 
    TGLRect old_vp(fViewport);
@@ -1772,6 +1779,20 @@
 }
 
 //______________________________________________________________________________
+void TGLViewer::ReinitializeCurrentCamera(const TGLVector3& hAxis, const TGLVector3& vAxis, Bool_t redraw)
+{
+   // Change base-vectors defining the camera-base transformation of current
+   // camera. hAxis and vAxis are the default directions for forward
+   // (inverted) and upwards.
+
+   TGLMatrix& cb = fCurrentCamera->RefCamBase();
+   cb.Set(cb.GetTranslation(), vAxis, hAxis);
+   fCurrentCamera->Setup(fOverallBoundingBox, kTRUE);
+   if (redraw)
+      RequestDraw();
+}
+
+//______________________________________________________________________________
 TGLAutoRotator* TGLViewer::GetAutoRotator()
 {
    // Get the auto-rotator for this viewer.
