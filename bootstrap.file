#!/bin/bash
# Revision: $Revision: 1.52 $

if [ X"$(id -u)" = X0 ]; then
  echo "*** CMS SOFTWARE INSTALLATION ABORTED ***" 1>&2
  echo "CMS software cannot be installed as the super-user." 1>&2
  echo "(We recommend reading any standard unix security guide.)" 1>&2
  exit 1
fi

if [ "X`printf hasprintf 2>/dev/null`" = Xhasprintf ]; then
  echo_n() { printf "%s" ${1+"$@"}; }
elif [ "X`echo -n`" = "X-n" ]; then
  echo_n() { echo ${1+"$@"}"\c"; }
else
  echo_n() { echo -n ${1+"$@"}; }
fi

cleanup_and_exit () {
    exitcode=$1
    exitmessage=$2
    [ "X$exitmessage" = X ] || { echo && echo $exitmessage 1>&2; }
    [ "X$debug" = Xtrue ] && exit $exitcode
    [ "X$tempdir" = X ] || [ -d $tempdir ] && rm -rf $tempdir
    [ "X$DOWNLOAD_DIR" = X ] || [ -d $DOWNLOAD_DIR ] && rm -rf $DOWNLOAD_DIR
    [ "X$importTmp" = X ] || [ -d $importTmp ] && rm -rf $importTmp
    exit $exitcode 
}

download_method=
download_curl () { curl -f -q -s "$1" -o "$2.tmp" && mv "$2.tmp" "$2"; }
download_wget () { (wget --no-check-certificate -q -O "$2.tmp" "$1" 2>/dev/null || wget -q -O "$2.tmp" "$1") && mv "$2.tmp" "$2"; }
download_none () { cleanup_and_exit 1 "No curl or wget, cannot fetch $1" 
}

# Figure out how to download stuff
if [ -z "$download_method" ]; then
  if [ `wget --version 2>/dev/null | wc -l` != 0 ]; then
    download_method=wget
  elif [ `curl --version 2>/dev/null | wc -l` != 0 ]; then
    download_method=curl
  else
    download_method=none
  fi
fi

# Safely create a user-specific temp directory.
[ "X$TMPDIR" = X ] && TMPDIR=/tmp/$USER
tempdir=`mktemp -d $TMPDIR/tmpXXXXX`

# We have our own version of find-provides for bootstrap, so that we don't
# depend on a "system" rpm installation. This is particularly handy in the case 
# of macosx and other unsupported distributions which don't use rpm as a 
# package manager (e.g. ubuntu).
rpmFindProvides=$tempdir/my-find-provides
cat > $rpmFindProvides <<\EOF_FIND_PROVIDES
#!/bin/bash

# This script reads filenames from STDIN and outputs any relevant provides
# information that needs to be included in the package.

filelist=`sed "s/['\"]/\\\&/g"`

solist=$(echo $filelist | grep "\\.so" | grep -v "^/lib/ld.so" | \
        xargs file -L 2>/dev/null | grep "ELF.*shared object" | cut -d: -f1)
pythonlist=
tcllist=

#
# --- Alpha does not mark 64bit dependencies
case `uname -m` in
  alpha*)       mark64="" ;;
  *)            mark64="()(64bit)" ;;
esac

#
# --- Library sonames and weak symbol versions (from glibc).
for f in $solist; do
    soname=$(objdump -p $f | awk '/SONAME/ {print $2}')

    lib64=`if file -L $f 2>/dev/null | \
        grep "ELF 64-bit" >/dev/null; then echo "$mark64"; fi`
    if [ "$soname" != "" ]; then
        if [ ! -L $f ]; then
            echo $soname$lib64
            objdump -p $f | awk '
                BEGIN { START=0 ; }
                /Version definitions:/ { START=1; }
                /^[0-9]/ && (START==1) { print $4; }
                /^$/ { START=0; }
            ' | \
                grep -v $soname | \
                while read symbol ; do
                    echo "$soname($symbol)`echo $lib64 | sed 's/()//'`"
                done
        fi
    else
        echo ${f##*/}$lib64
    fi
done | sort -u

#
# --- Perl modules.
[ -x /usr/lib/rpm/perl.prov ] &&
    echo $filelist | tr '[:blank:]' \\n | grep '\.pm$' | /usr/lib/rpm/perl.prov | sort -u

#
# --- Python modules.
[ -x /usr/lib/rpm/python.prov -a -n "$pythonlist" ] &&
    echo $pythonlist | tr '[:blank:]' \\n | /usr/lib/rpm/python.prov | sort -u

#
# --- Tcl modules.
[ -x /usr/lib/rpm/tcl.prov -a -n "$tcllist" ] &&
    echo $tcllist | tr '[:blank:]' \\n | /usr/lib/rpm/tcl.prov | sort -u

exit 0
EOF_FIND_PROVIDES

source() { . ${1+"$@"}; }

chmod u+x $rpmFindProvides

server=cmsrep.cern.ch
server_main_dir=cms/cpt/Software/download
repository=/cms
apt_dir=apt
groups="lcg cms external"

rootdir=$(pwd)
testInstance=false

while [ $# -gt 0 ]; do
  case $1 in
        setup )
          command=setup 
          shift ;;
        reseed )
          command=reseed
          shift;;
        -path|-p )
          [ $# -gt 0 ] || cleanup_and_exit 1 "Option \`$1' requires an argument"
          if [ "$(echo $2 | cut -b 1)" = "/" ]; then
            rootdir="$2"
          else
            rootdir="$PWD/$2"
          fi
          shift; shift ;;
        -server )
          [ $# -gt 1 ] || cleanup_and_exit 1 "Option \`$1' requires an argument"
          server=$2
          testInstance=true
          shift; shift ;;
        -server-path )
          [ $# -gt 1 ] || cleanup_and_exit 1 "Option \`$1' requires an argument"
          server_main_dir=`echo $2 | sed -e "s|\(.*\)/.*/.*|\1|"`
          apt_dir=`echo $2 | sed -e "s|.*/||"`
          repository=/`echo $2 | sed -e "s|.*/\(.*\)/.*|\1|"`
          echo "server_main_dir $server_main_dir"
          echo "apt_dir $apt_dir"
          echo "repository $repository"
          testInstance=true
          shift; shift ;;
        -repository|-r )
          [ $# -gt 1 ] || cleanup_and_exit 1 "Option \`$1' requires an argument"
          repository=/$2 
          testInstance=true
          shift; shift ;;
        -groups|-g )
          [ $# -gt 1 ] || cleanup_and_exit 1 "Option \`$1' requires at lease one argument"
          shift
          groups=""
          while [ $# -gt 0 ]
          do
            [ "X$(echo $1 | cut -b1)" = X- ] && break
            [ "X$1" = Xsetup ] && break
            [ "X$1" = Xreseed ] && break
            groups="$groups $1"
            shift
          done
          testInstance=true
          ;;
        -architecture|-arch|-a )
            [ $# -gt 1 ] || cleanup_and_exit 1 "Option \`$1' requires at lease one argument"
            cmsplatf="$2"
            shift; shift ;;
        -unsupported_distribution_hack )
          unsupportedDistribution=true; shift
          ;;
        -verbose|-v )
          verbose=true; shift
          doReturn="\n"
          ;;
        -debug )
          debug=true; shift
          doReturn="\n"
          ;;
        -assume-yes|-y )
          assumeYes=true; shift
          ;;
        -only-once )
          onlyOnce=true; shift
          ;;
        -additional-pkgs )
          while [ $# -gt 0 ]
          do
            [ "X$(echo $1 | cut -b1)" = X- ] && break
            [ "X$1" = Xsetup ] && break
            [ "X$1" = Xreseed ] && break
            additionalPkgs="$additionalPkgs $1"
            shift
          done
          ;;
        -help|-h )
          cat << \EOF_HELP 
bootstrap.sh 

A script to bootstrap a CMS software area.

Syntax:
bootstrap.sh setup [-path <cms-path>] [-server <server>] [-server-path <download-path>] 

-path <cms-path> : location of where the installation must be done (default $PWD).
-server <server>  : repositories are to be found on server <server> (default cmsrep.cern.ch).
-server-path <download-path> : package structure is found on <download-path> on server (default cms/cpt/Software/download/apt).
-repository <repository> : use private apt repository cms.<username> (default: public repository)
-groups <groups-list> : list of the channels we want to subscribe to (default: "cms external lcg virtual").
EOF_HELP
        cleanup_and_exit 1
        ;;
        * )
            cleanup_and_exit 1 "bootstrap.sh: argument $1 not supported"
        ;;
    esac
done

rpmdb=$cmsplatf/var/lib/rpm
rpmlock=$rootdir/$cmsplatf/var/lib/rpm/__db.0
importTmp=$rootdir/$cmsplatf/tmp/system-import

[ "X$verbose" = Xtrue ] && echo "Using $download_method to download files."
[ "X$verbose" = Xtrue ] && echo "RPM db in $cmsplatf/var/lib/rpm."

# Get the architecture driver from the web
driver=$server/$server_main_dir/$repository/$cmsplatf-driver.txt
[ "X$verbose" = Xtrue ] && echo_n "Downloading driver file..."
download_${download_method} $driver $tempdir/$cmsplatf-driver.txt
[ -f $tempdir/$cmsplatf-driver.txt ] || cleanup_and_exit 1 "FATAL: Unable to download platform driver: $driver"
eval `cat $tempdir/$cmsplatf-driver.txt`
[ "X$verbose" = Xtrue ] && echo "Done."


perlHarvester () {
	[ "X$verbose" = Xtrue ] && echo && echo "...Harvesting for perl modules" 1>&2
    for x in `perl -e'print join "\n", @INC'`
    do
        find -L $x 2>/dev/null  \
		| grep -v -e '\(^[.]/\|[/]$\)' \
		| grep -e '\([.]pm$\|[.]pl$\|[.]pod$\)' \
		| sed -e "s|$x/||;s|[.]pm||;s|[.]pod||;s|/|::|g;s|^\(.*\)|Provides: perl(\1)|"
	done
}

generateSeedSpec () {
    # Seed system info
    # GL asound odbc java libtcl libtk
    [ "X$verbose" = Xtrue ] && echo && echo "...Seeding RPM database from selected system RPMs." 1>&2
    
    seed="$platformSeeds"
    
    if [ "X$unsupportedDistribution" = Xtrue ]
    then
        echo "WARNING: you are running on an unsupported distribution."
        echo "This might lead to unknown problems."
        seed="$seed $unsupportedSeeds"
    fi
    
     rm -rf $importTmp
     mkdir -p $importTmp
     cd $importTmp
     mkdir -p SOURCES BUILD SPEC RPMS SRPMS tmp
     : > SOURCES/none
     # FIXME: It might be better to use rootdir rather than PWD
     (echo "%define _sourcedir      $PWD/SOURCES"
      echo "%define _builddir       $PWD/BUILD"
      echo "%define _specdir        $PWD/SPEC"
      echo "%define _rpmdir         $PWD/RPMS"
      echo "%define _srcrpmdir      $PWD/SRPMS"
      echo "%define _tmppath        $PWD/tmp"
      echo "%define _topdir         $PWD"
      echo "%define _rpmfilename    system-base-import.rpm"
      echo;
      echo "Name: system-base-import"
      echo "Version: 1.0"
      echo "Release: `date +%s`"
      echo "Summary: Base system seed"
      echo "License: Unknown"
      echo "Group: Hacks"
      echo "Packager: install.sh"
      echo "Source: none"
      for provide in $additionalProvides
      do
        echo "Provides: $provide"
      done
      
      if [ "X$unsupportDistribution" = X ]
      then
        # Guess perl
        echo "Provides: perl = `perl -MConfig -e 'print $Config{version}'`"
        for provide in $unsupportedProvides
        do
            echo "Provides: $provide"
        done
      fi
      
      case $cmsplatf in
        osx* )
  	        find /usr/bin | sed 's!^!Provides: !'
  	        find /bin | sed 's!^!Provides: !'
    	    /bin/ls -1 /usr/lib/*.dylib | awk -F"/" '{print $4}' | sed 's!^!Provides: !'
    	    /bin/ls -1 /usr/lib/*/*.dylib | awk -F"/" '{print $5}' | sed 's!^!Provides: !'
            /bin/ls -1 /usr/X11R6/lib/*.dylib | awk -F"/" '{print $5}' | sed 's!^!Provides: !'
        ;;
      esac

      if [ "$(which dpkg 2>&1 | grep 'no dpkg' )" = "" ]
      then
    	[ "X$verbose" = Xtrue ] && echo && echo "...dpkg found in $(which dpkg), using it to seed the database." >&2
    	for p in $seed; do
    	  if [ "$(dpkg -L $p 2>&1 | grep 'is not installed')" = "" ]; then
          	  dpkg -L $p 2>/dev/null | sed -e "s|^|Provides:|"
              dpkg -L $p 2>/dev/null | $rpmFindProvides | sed -e "s|^|Provides:|"
          fi
    	done
    	perlHarvester
      fi
      if which rpm 2>&1 >/dev/null && [ "$(rpm -qa 2>&1 | grep 'use alien')" = "" ]
      then
    	[ "X$verbose" = Xtrue ] && echo && echo "...rpm found in $(which rpm), using it to seed the database." >&2
    	  for p in $seed; do
            rpm -q $p >/dev/null
            if [ "$?" == "0" ]
            then
              rpm -q $p --provides | sed 's!<*=.*!!; s!^!Provides: !'
              rpm -q $p --list | grep '\.so' | sed 's!^.*/!Provides: !'
              rpm -q $p --list | grep '/bin/' | sed 's!^!Provides: !'
            fi
    	  done
      fi
      echo; echo "%description"; echo "Seeds RPM repository from the base system."
      echo; echo "%prep"; echo "%build"; echo "%install"; echo "%files";
     ) > system-base-import.spec
    perl -p -i -e 's|^Provides:[\s]*$||' system-base-import.spec
    cd $was
}

seed ()
{
    rcfile=$1
    cd $importTmp
    (rpmbuild -ba --rcfile $rcfile system-base-import.spec >/dev/null 2>&1
     [ "X$verbose" = Xtrue ] && echo && echo "...Seeding database in in $rootdir/$rpmdb"
     rpm --define "_rpmlock_path $rpmlock" -U -r $rootdir --rcfile $rcfile --dbpath $rootdir/$rpmdb RPMS/system-base-import.rpm
    ) || cleanup_and_exit $? "Error while seeding rpm database with system packages."
    cd $was
}

setup() {
# FIXME: this is the ugliest trick ever found in a shell script.
# The problem is that rpm sometimes applies the value of --root
# to dbpath, some other times it does not.
# At some point this should be really fixed in the rpm sources,
# but for the time being we keep it as it is.
[ "$rootdir" = "" ] && cleanup_and_exit 1 "Installation path not specified."

rootdir=`echo $rootdir | perl -p -e 's|/$||'`
mkdir -p $rootdir
eval `echo $rootdir | awk -F \/ '{print "fakelink=$rootdir/"$2}'`
if [ ! -e $fakelink ]
then
    #echo $rootdir | awk -F \/ '{print "ln -s /"$2" $rootdir/"$2}'
    command=`echo $rootdir | awk -F \/ '{print "ln -s /"$2" $rootdir/"$2}'`
    eval $command
fi

# Fetch the required RPMS for RPM and APT from the server and install them using rpmcpio
export DOWNLOAD_DIR=$rootdir/tmp/BOOTSTRAP
mkdir -p $DOWNLOAD_DIR
cd $DOWNLOAD_DIR
downloadPath=$server/$server_main_dir/$repository/RPMS/$cmsplatf
# Get the architecture driver from the web
driver=$server/$server_main_dir/$repository/$cmsplatf-driver.txt
echo_n "Downloading driver file..."
download_${download_method} $driver $tempdir/$cmsplatf-driver.txt
[ -f $tempdir/$cmsplatf-driver.txt ] || cleanup_and_exit 1 "Unable to download platform driver: $driver"
eval `cat $tempdir/$cmsplatf-driver.txt`
echo "Done."

echo_n "Downloading bootstrap core packages..."
for pkg in $packageList
do
    download_${download_method} $downloadPath/$pkg $pkg
    [ -f $pkg ] || cleanup_and_exit 1 "Error downloading $pkg. Exiting."
done
echo "Done."

was=`pwd`
cd $rootdir
forceOption=""
if [ -d $rootdir/$rpmdb ]
then
    [ "X$onlyOnce" = Xtrue ] && cleanup_and_exit 0 "Area already initialised. Skipping bootstrap and exiting."
    if [ "X$assumeYes" = Xtrue ]
    then
        forceOption=--force
    else
        read -e -p "Warning, $rootdir already set up. Do you want to reconfigure it? [ y / N ] " override
        case $(echo $override | tr [A-Z] [a-z]) in
            y|ye|yes) 
                forceOption=--force
                ;;
            *) 
                cleanup_and_exit 0 "No changes made. Exiting... " 
            ;;
        esac
    fi
else
    mkdir -p $rootdir/$rpmdb
fi

# Extract the packages via rpm, source the init.sh
# Some packages might actually not be there (gcc on darwin, for example, .
# where we use the system one).
cd $DOWNLOAD_DIR
# http://linuxmafia.com/pub/linux/utilities-general/rpm2cpio
cat > myrpm2cpio <<\EOF_RPM2CPIO
#!/usr/bin/env perl

# Why does the world need another rpm2cpio?  Because the existing one
# won't build unless you have half a ton of things that aren't really
# required for it, since it uses the same library used to extract RPMs.
# In particular, it won't build on the HPsUX box I'm on.

#
# Expanded quick-reference help by Rick Moen (not the original author
# of this script).
#

# add a path if desired
$gzip = "gzip";

sub printhelp {
  print "\n";
  print "rpm2cpio, perl version by orabidoo <odar\@pobox.com>\n";
  print "\n";
  print "use: rpm2cpio [file.rpm]\n";
  print "dumps the contents to stdout as a GNU cpio archive\n";
  print "\n";
  print "In case it's non-obvious, you'll need to redirect output\n";
  print "from this script, e.g., './rpm2cpio package.rpm > package.cpio'.\n";
  print "Then, unpack in, say, /tmp with a cpio incantation like this one:\n";
  print "'cpio -ivd < package.cpio'\n";
  print "\n";
  print "You can optionally combine both steps:\n";
  print "'rpm2cpio package.rpm | cpio -iduv'\n";
  print "\n";
  print "In either event, you will also need the 'cpio' utility available\n";
  print "on your system.  If you can't find it elsewhere, source code for\n";
  print "GNU cpio is always available at ftp://ftp.gnu.org/gnu/cpio/.)\n";
  print "You'll also, of course, need Perl, and will want this Perl script\n";
  print "set as executable, i.e., by doing 'chmod 775 rpm2cpio'\n";
  print "\n";
  print "Be aware that this script works ONLY on version 3 or 4-format RPM\n";
  print "archives.  You can check an archive's RPM-format version
sing\n";
  print "the Unix 'file' utility.  Also, be aware that the 'cpio'\n";
  print "incantations above will unpack files at the current directory\n";
  print "level.\n";
  print "\n";
  exit 0;
}

if ($#ARGV == -1) {
  printhelp if -t STDIN;
  $f = "STDIN";
} elsif ($#ARGV == 0) {
  open(F, "< $ARGV[0]") or die "Can't read file $ARGV[0]\n";
  $f = 'F';
} else {
  printhelp;
}

printhelp if -t STDOUT;

# gobble the file up
undef $/;
$|=1;
$rpm = <$f>;
close ($f);

($magic, $major, $minor, $crap) = unpack("NCC C90", $rpm);

die "Not an RPM\n" if $magic != 0xedabeedb;
die "Not a version 3 or 4 RPM\n" if $major != 3 and $major != 4;

$rpm = substr($rpm, 96);

while ($rpm ne '') {
  $rpm =~ s/^\c@*//s;
  ($magic, $crap, $sections, $bytes) = unpack("N4", $rpm);
  $smagic = unpack("n", $rpm);
  last if $smagic eq 0x1f8b;
  die "Error: header not recognized\n" if $magic != 0x8eade801;
  $rpm = substr($rpm, 16*(1+$sections) + $bytes);
}

die "bogus RPM\n" if $rpm eq '';

open(ZCAT, "|gzip -cd") || die "can't pipe to gzip\n";

print ZCAT $rpm;
close ZCAT;
EOF_RPM2CPIO

echo_n "Unpacking core packages..."
for pkg in $packageList
do
    perl ./myrpm2cpio $DOWNLOAD_DIR/$pkg | cpio -idu 2>/dev/null || cleanup_and_exit 1 "Unable to unpack $DOWNLOAD_DIR/$pkg"
done
echo "Done."

# Generate the seed spec using the old rpm:
echo_n "Harvesting system for locally available software..."
generateSeedSpec
# Now move to use the new RPM by sourcing its init.sh
perl -p -i -e "s!(/[^ ]*$cmsplatf)!$DOWNLOAD_DIR\$1!g" `grep -R -e "/[^ ]*$cmsplatf" $DOWNLOAD_DIR$instroot | grep -v Binary | cut -d: -f1 | uniq`
source $DOWNLOAD_DIR$instroot/$cmsplatf/external/rpm/$rpm_version/etc/profile.d/init.sh
cd $rootdir
echo "Done."
# Initialise the rpmdb using the new rpm.
echo_n "Initializing local rpm database..."
rpm --define "_rpmlock_path $rpmlock" -r $rootdir --dbpath $rootdir/$rpmdb --initdb || cleanup_and_exit 1 "Unable to initialize $rootdir/$rpmdb. Exiting."
# Build the seed spec and install it, in order to seed the newly generated db.
rpmOptions="-r $rootdir --dbpath $rootdir/$rpmdb --rcfile $DOWNLOAD_DIR$instroot/$cmsplatf/external/rpm/$rpm_version/lib/rpm/rpmrc --nodeps --prefix $rootdir --ignoreos --ignorearch"
seed $DOWNLOAD_DIR$instroot/$cmsplatf/external/rpm/$rpm_version/lib/rpm/rpmrc
echo "Done."

# Install the packages, this time using rpm.
echo_n "Installing packages in the local rpm database..."
for pkg in $packageList
do
    rpm -U $forceOption --define "_rpmlock_path $rpmlock" $rpmOptions $DOWNLOAD_DIR/$pkg || cleanup_and_exit 1 "Error while installing $pkg. Exiting."
done
echo "Done"

# If we want to use a test instance, we need to adjust the sources.list accordingly.
if [ "$testInstance" = "true" ]
then
    perl -p -i -e "s|^([^#][^;].*) http://cmsrep.cern.ch cms/cpt/Software/download/cms/|#\$1 http://cmsrep.cern.ch cms/cpt/Software/download/cms/|;
                   s|#;||;
                   s|\@GROUPS\@|$groups|;
                   s|\@SERVER\@|$server|;
                   s|\@SERVER_PATH\@|$server_main_dir|;
                   s|\@REPOSITORY\@|$repository|" $rootdir/$cmsplatf/external/apt/$apt_version/etc/sources.list
fi

# Source the apt environment and upgrade what's already there.
echo_n "Initializing apt-get environment."
source $rootdir/$cmsplatf/external/apt/$apt_version/etc/profile.d/init.sh
apt-get update >$tempdir/apt-get-update.log 2>&1 || { echo && echo "WARNING: There was a problem while running apt-get update. \
While this might not be a problem you might want to tweak your sources.list \
to avoid warnings in future. "; cat $tempdir/apt-get-update.log; }

echo "Done"
[ "X$additionalPkgs" = X ] || apt-get install -y $additionalPkgs >$tempdir/apt-get-install.log 2>&1 || { echo && echo "WARNING: a set of additional \
packages where required by the bootstrap options/driver, but they are impossible to install. \
Error message is:"; cat $tempdir/apt-get-install.log;  }

cd $was
}

##########################################################
case $command in
    setup )
        setup 
        ;;
    reseed )
        generateSeedSpec
        seed $cmsplatf/external/rpm/$rpm_version/lib/rpm/rpmrc 
        ;;
esac

cleanup_and_exit 0 "Everything completed correctly."
