commit 02eaf615f6f08e49b29b3fadcc4bdfe9999804bb
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Sat Oct 9 11:15:48 2010 +0200

    ../CMSDIST/root-5.22-00d-fireworks8.patch

diff --git a/graf2d/asimage/src/TASImage.cxx b/graf2d/asimage/src/TASImage.cxx
index acd1638..f557a3f 100644
--- a/graf2d/asimage/src/TASImage.cxx
+++ b/graf2d/asimage/src/TASImage.cxx
@@ -457,6 +457,8 @@ void TASImage::ReadImage(const char *filename, EImageFileTypes /*type*/)
    if (!gIconPaths[0]) {
       init_icon_paths();
    }
+   // suppress the "root : looking for image ..." messages
+   set_output_threshold(0);
 
    static ASImageImportParams iparams;
    iparams.flags = 0;
diff --git a/graf3d/eve/Module.mk b/graf3d/eve/Module.mk
index dea4ff7..2eb4b1a 100644
--- a/graf3d/eve/Module.mk
+++ b/graf3d/eve/Module.mk
@@ -30,7 +30,8 @@ EVEH1     := TEveBrowser TEveChunkManager TEveCompound \
              TEveGedEditor TEveMacro TEveManager TEvePad TEveParamList \
              TEveProjectionAxes TEveProjectionBases TEveProjectionManager \
              TEveProjections TEveScene TEveSelection TEveTrans TEveTreeTools \
-             TEveUtil TEveVector TEveVSD TEveViewer TEveWindow
+             TEveUtil TEveVector TEvePathMark TEveVSD TEveViewer TEveWindow \
+             TEveSecondarySelectable
 
 EVEH2     := TEveArrow TEveBox TEveCalo \
              TEveDigitSet TEveFrameBox TEveGeo \
diff --git a/graf3d/eve/inc/LinkDef1.h b/graf3d/eve/inc/LinkDef1.h
index c829a7f..a849cd0 100644
--- a/graf3d/eve/inc/LinkDef1.h
+++ b/graf3d/eve/inc/LinkDef1.h
@@ -17,6 +17,64 @@
 // LinkDef1.h - Core EVE objects and services.
 //==============================================================================
 
+// TEveVector
+#pragma link C++ class   TEveVectorT<Float_t>+;
+#pragma link C++ class   TEveVectorT<Double_t>+;
+#pragma link C++ typedef TEveVector;
+#pragma link C++ typedef TEveVectorF;
+#pragma link C++ typedef TEveVectorD;
+
+#pragma link C++ class   TEveVector4T<Float_t>+;
+#pragma link C++ class   TEveVector4T<Double_t>+;
+#pragma link C++ typedef TEveVector4;
+#pragma link C++ typedef TEveVector4F;
+#pragma link C++ typedef TEveVector4D;
+
+#pragma link C++ class   TEveVector2T<Float_t>+;
+#pragma link C++ class   TEveVector2T<Double_t>+;
+#pragma link C++ typedef TEveVector2;
+#pragma link C++ typedef TEveVector2F;
+#pragma link C++ typedef TEveVector2D;
+
+// Operators for TEveVectorXT<Float_t>
+#pragma link C++ function operator+(const TEveVectorT<Float_t>&, const TEveVectorT<Float_t>&);
+#pragma link C++ function operator-(const TEveVectorT<Float_t>&, const TEveVectorT<Float_t>&);
+#pragma link C++ function operator*(const TEveVectorT<Float_t>&, Float_t);
+#pragma link C++ function operator*(Float_t, const TEveVectorT<Float_t>&);
+#pragma link C++ function operator+(const TEveVector4T<Float_t>&, const TEveVector4T<Float_t>&);
+#pragma link C++ function operator-(const TEveVector4T<Float_t>&, const TEveVector4T<Float_t>&);
+#pragma link C++ function operator*(const TEveVector4T<Float_t>&, Float_t);
+#pragma link C++ function operator*(Float_t, const TEveVector4T<Float_t>&);
+#pragma link C++ function operator+(const TEveVector2T<Float_t>&, const TEveVector2T<Float_t>&);
+#pragma link C++ function operator-(const TEveVector2T<Float_t>&, const TEveVector2T<Float_t>&);
+#pragma link C++ function operator*(const TEveVector2T<Float_t>&, Float_t);
+#pragma link C++ function operator*(Float_t, const TEveVector2T<Float_t>&);
+// Operators for TEveVectorXT<Double_t>
+#pragma link C++ function operator+(const TEveVectorT<Double_t>&, const TEveVectorT<Double_t>&);
+#pragma link C++ function operator-(const TEveVectorT<Double_t>&, const TEveVectorT<Double_t>&);
+#pragma link C++ function operator*(const TEveVectorT<Double_t>&, Double_t);
+#pragma link C++ function operator*(Double_t, const TEveVectorT<Double_t>&);
+#pragma link C++ function operator+(const TEveVector4T<Double_t>&, const TEveVector4T<Double_t>&);
+#pragma link C++ function operator-(const TEveVector4T<Double_t>&, const TEveVector4T<Double_t>&);
+#pragma link C++ function operator*(const TEveVector4T<Double_t>&, Double_t);
+#pragma link C++ function operator*(Double_t, const TEveVector4T<Double_t>&);
+#pragma link C++ function operator+(const TEveVector2T<Double_t>&, const TEveVector2T<Double_t>&);
+#pragma link C++ function operator-(const TEveVector2T<Double_t>&, const TEveVector2T<Double_t>&);
+#pragma link C++ function operator*(const TEveVector2T<Double_t>&, Double_t);
+#pragma link C++ function operator*(Double_t, const TEveVector2T<Double_t>&);
+
+// TEvePathMark
+#pragma link C++ class   TEvePathMarkT<Float_t>+;
+#pragma link C++ class   TEvePathMarkT<Double_t>+;
+#pragma link C++ typedef TEvePathMark;
+#pragma link C++ typedef TEvePathMarkF;
+#pragma link C++ typedef TEvePathMarkD;
+
+// TEveTrans
+#pragma link C++ class TEveTrans-;
+#pragma link C++ class TEveTransSubEditor+;
+#pragma link C++ class TEveTransEditor+;
+
 // TEveUtil
 #pragma link C++ class TEveUtil+;
 #pragma link C++ class TEveException+;
@@ -42,17 +100,6 @@
 #pragma link C++ class TEveRecCascade+;
 #pragma link C++ class TEveMCRecCrossRef+;
 
-// TEveVector
-#pragma link C++ class TEveVector+;
-#pragma link C++ class TEveVector4+;
-#pragma link C++ class TEvePoint+;
-#pragma link C++ class TEvePathMark+;
-
-// TEveTrans
-#pragma link C++ class TEveTrans-;
-#pragma link C++ class TEveTransSubEditor+;
-#pragma link C++ class TEveTransEditor+;
-
 // TEveChunkManager
 #pragma link C++ class TEveChunkManager+;
 #pragma link C++ class TEveChunkManager::iterator-;
@@ -93,6 +140,7 @@
 
 // TEveSelection
 #pragma link C++ class TEveSelection+;
+#pragma link C++ class TEveSecondarySelectable+;
 
 // GL-interface
 #pragma link C++ class TEveScene+;
diff --git a/graf3d/eve/inc/LinkDef2.h b/graf3d/eve/inc/LinkDef2.h
index 7568489..69014a9 100644
--- a/graf3d/eve/inc/LinkDef2.h
+++ b/graf3d/eve/inc/LinkDef2.h
@@ -60,7 +60,9 @@
 // TEveDigitSet
 #pragma link C++ class TEveDigitSet+;
 #pragma link C++ class TEveDigitSetEditor+;
+#pragma link C++ class TEveDigitSetGL+;
 #pragma link C++ typedef TEveDigitSet::Callback_foo;
+#pragma link C++ typedef TEveDigitSet::TooltipCB_foo;
 
 // TEveQuadSet
 #pragma link C++ class TEveQuadSet+;
@@ -132,6 +134,8 @@
 #pragma link C++ class TEveJetCone+;
 #pragma link C++ class TEveJetConeEditor+;
 #pragma link C++ class TEveJetConeGL+;
+#pragma link C++ class TEveJetConeProjected+;
+#pragma link C++ class TEveJetConeProjectedGL+;
 
 // TEvePlots
 #pragma link C++ class TEvePlot3D+;
diff --git a/graf3d/eve/inc/TEveArrow.h b/graf3d/eve/inc/TEveArrow.h
index a8b486e..7cc719c 100644
--- a/graf3d/eve/inc/TEveArrow.h
+++ b/graf3d/eve/inc/TEveArrow.h
@@ -47,6 +47,9 @@ public:
              Float_t xOrg=0, Float_t yOrg=0, Float_t zOrg=0);
    virtual ~TEveArrow() {}
 
+   virtual TObject* GetObject(const TEveException& /*eh*/="TEveElementList::GetObject ") const
+   { const TObject* obj = this; return const_cast<TObject*>(obj); }
+
    void SetTubeR(Float_t x) { fTubeR = x; }
    void SetConeR(Float_t x) { fConeR = x; }
    void SetConeL(Float_t x) { fConeL = x; }
@@ -64,8 +67,6 @@ public:
    virtual void ComputeBBox();
    virtual void Paint(Option_t* option="");
 
-   virtual Bool_t CanEditMainColor() const { return kTRUE; }
-
    ClassDef(TEveArrow, 0); // Class for gl visualisation of arrow.
 };
 
diff --git a/graf3d/eve/inc/TEveBox.h b/graf3d/eve/inc/TEveBox.h
index bdfd548..f4abf07 100644
--- a/graf3d/eve/inc/TEveBox.h
+++ b/graf3d/eve/inc/TEveBox.h
@@ -63,9 +63,9 @@ private:
    TEveBoxProjected& operator=(const TEveBoxProjected&); // Not implemented
 
 protected:
-   vPoint_t     fPoints;
+   vVector2_t   fPoints;
    Int_t        fBreakIdx;
-   vPoint_t     fDebugPoints;
+   vVector2_t   fDebugPoints;
 
    virtual void SetDepthLocal(Float_t d);
 
@@ -80,7 +80,9 @@ public:
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void UpdateProjection();
 
-   ClassDef(TEveBoxProjected, 0); // 3D box with arbitrary vertices.
+   virtual TEveElement* GetProjectedAsElement() { return this; }
+
+   ClassDef(TEveBoxProjected, 0); // Projection of TEveBox.
 };
 
 #endif
diff --git a/graf3d/eve/inc/TEveBoxSet.h b/graf3d/eve/inc/TEveBoxSet.h
index f81e8ed..d77f18a 100644
--- a/graf3d/eve/inc/TEveBoxSet.h
+++ b/graf3d/eve/inc/TEveBoxSet.h
@@ -40,15 +40,15 @@ protected:
 
    struct BFreeBox_t       : public DigitBase_t { Float_t fVertices[24]; };
 
-   struct BOrigin_t        : public DigitBase_t { Float_t fA, fB, fC; virtual ~BOrigin_t() {} };
+   struct BOrigin_t        : public DigitBase_t { Float_t fA, fB, fC; };
 
    struct BAABox_t         : public BOrigin_t   { Float_t fW, fH, fD; };
 
-   struct BAABoxFixedDim_t : public BOrigin_t {};
+   struct BAABoxFixedDim_t : public BOrigin_t   {};
 
-   struct BCone_t          : public DigitBase_t { TEveVector fPos, fDir; Float_t fR; virtual ~BCone_t() {} };
+   struct BCone_t          : public DigitBase_t { TEveVector fPos, fDir; Float_t fR; };
 
-   struct BEllipticCone_t  : public BCone_t  { Float_t fR2, fAngle; };
+   struct BEllipticCone_t  : public BCone_t     { Float_t fR2, fAngle; };
 
 protected:
    EBoxType_e        fBoxType;      // Type of rendered box.
diff --git a/graf3d/eve/inc/TEveBoxSetGL.h b/graf3d/eve/inc/TEveBoxSetGL.h
index 64af0f9..8cff42a 100644
--- a/graf3d/eve/inc/TEveBoxSetGL.h
+++ b/graf3d/eve/inc/TEveBoxSetGL.h
@@ -12,10 +12,10 @@
 #ifndef ROOT_TEveBoxSetGL
 #define ROOT_TEveBoxSetGL
 
-#include "TGLObject.h"
+#include "TEveDigitSetGL.h"
 #include "TEveBoxSet.h"
 
-class TEveBoxSetGL : public TGLObject
+class TEveBoxSetGL : public TEveDigitSetGL
 {
    TEveBoxSetGL(const TEveBoxSetGL&);            // Not implemented
    TEveBoxSetGL& operator=(const TEveBoxSetGL&); // Not implemented
@@ -26,29 +26,24 @@ protected:
    mutable UInt_t  fBoxDL;   // Display-list id for a box atom.
 
    Int_t  PrimitiveType() const;
-   Bool_t SetupColor(const TEveDigitSet::DigitBase_t& q) const;
    void   MakeOriginBox(Float_t p[24], Float_t dx, Float_t dy, Float_t dz) const;
    void   RenderBox(const Float_t p[24]) const;
    void   MakeDisplayList() const;
 
-   void   RenderBoxes(TGLRnrCtx & rnrCtx) const;
+   void   RenderBoxes(TGLRnrCtx& rnrCtx) const;
 
 public:
    TEveBoxSetGL();
    virtual ~TEveBoxSetGL();
 
-   virtual Bool_t ShouldDLCache(const TGLRnrCtx & rnrCtx) const;
+   virtual Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const;
    virtual void   DLCacheDrop();
    virtual void   DLCachePurge();
 
    virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
-   virtual void   SetBBox();
-   virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
+   virtual void   DirectDraw(TGLRnrCtx& rnrCtx) const;
 
-   virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
-   virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
-
-   virtual void Render(TGLRnrCtx & rnrCtx);
+   virtual void Render(TGLRnrCtx& rnrCtx);
 
    ClassDef(TEveBoxSetGL, 0); // GL-renderer for TEveBoxSet class.
 };
diff --git a/graf3d/eve/inc/TEveCalo.h b/graf3d/eve/inc/TEveCalo.h
index 781650c..a2278f0 100644
--- a/graf3d/eve/inc/TEveCalo.h
+++ b/graf3d/eve/inc/TEveCalo.h
@@ -79,6 +79,8 @@ public:
    virtual TClass* ProjectedClass(const TEveProjection* p) const;
    virtual Float_t GetValToHeight() const;
    virtual void    CellSelectionChanged() {}
+   
+   virtual void    SetScaleAbs(Bool_t x) { fScaleAbs = x; }
 
    TEveCaloData* GetData() const { return fData; }
    void    SetData(TEveCaloData* d);
@@ -103,7 +105,6 @@ public:
 
    void    SetMaxTowerH(Float_t x) { fMaxTowerH = x; }
    Float_t GetMaxTowerH() const    { return fMaxTowerH; }
-   void    SetScaleAbs(Bool_t x) { fScaleAbs = x; }
    Bool_t  GetScaleAbs() const { return fScaleAbs; }
    void    SetMaxValAbs(Float_t x) { fMaxValAbs = x; }
    Float_t GetMaxValAbs() const    { return fMaxValAbs; }
@@ -152,13 +153,13 @@ private:
 
 protected:
    TEveCaloData::vCellId_t fCellList;
-   TEveCaloData::vCellId_t fCellListSelected;
 
    Bool_t    fRnrEndCapFrame;
    Bool_t    fRnrBarrelFrame;
 
+   Float_t   fFrameWidth;
    Color_t   fFrameColor;
-   UChar_t   fFrameTransparency;
+   Char_t    fFrameTransparency;
 
    virtual void BuildCellIdCache();
 
@@ -167,14 +168,18 @@ public:
    virtual ~TEveCalo3D() {}
    virtual void ComputeBBox();
 
-   virtual Bool_t CanEditMainColor()        const { return kTRUE; }
-   virtual Bool_t CanEditMainTransparency() const { return kTRUE; }
+   void    SetFrameWidth(Float_t w) { fFrameWidth = w; }
+   Float_t GetFrameWidth() const    { return fFrameWidth; }
 
    void SetRnrFrame(Bool_t e, Bool_t b)         { fRnrEndCapFrame = e; fRnrBarrelFrame = b; }
    void GetRnrFrame(Bool_t &e, Bool_t &b) const { e = fRnrEndCapFrame; b = fRnrBarrelFrame; }
+   void SetRnrEndCapFrame(Bool_t r) { fRnrEndCapFrame = r; }
+   void SetRnrBarrelFrame(Bool_t r) { fRnrBarrelFrame = r; }
+   Bool_t GetRnrEndCapFrame() const { return fRnrEndCapFrame; }
+   Bool_t GetRnrBarrelFrame() const { return fRnrBarrelFrame; }
 
-   void    SetFrameTransparency(UChar_t x) { fFrameTransparency = x; }
-   UChar_t GetFrameTransparency() const { return fFrameTransparency; }
+   void   SetFrameTransparency(Char_t x) { fFrameTransparency = x; }
+   Char_t GetFrameTransparency() const { return fFrameTransparency; }
 
    ClassDef(TEveCalo3D, 0); // Class for 3D visualization of calorimeter event data.
 };
@@ -195,12 +200,13 @@ private:
    TEveCalo2D& operator=(const TEveCalo2D&); // Not implemented
 
    TEveProjection::EPType_e  fOldProjectionType;
+   void CellSelectionChangedInternal(TEveCaloData::vCellId_t& cells, std::vector<TEveCaloData::vCellId_t*>& cellLists);
 
 protected:
    std::vector<TEveCaloData::vCellId_t*>   fCellLists;
 
    std::vector<TEveCaloData::vCellId_t*>   fCellListsSelected;
-   std::vector<Int_t>                      fBinIdsSelected;
+   std::vector<TEveCaloData::vCellId_t*>   fCellListsHighlighted;
 
    Float_t                                 fMaxESumBin;
    Float_t                                 fMaxEtSumBin;
@@ -218,6 +224,8 @@ public:
    virtual void ComputeBBox();
 
    virtual void CellSelectionChanged();
+      
+   virtual void    SetScaleAbs(Bool_t);
 
    virtual Float_t GetValToHeight() const;
 
@@ -246,7 +254,7 @@ protected:
    Color_t                 fFontColor;
    Color_t                 fGridColor;
    Color_t                 fPlaneColor;
-   UChar_t                 fPlaneTransparency;
+   Char_t                  fPlaneTransparency;
 
    Int_t                   fNZSteps; // Z axis label step in GeV
    Float_t                 fZAxisStep;
@@ -262,7 +270,8 @@ protected:
    Bool_t                  fDrawHPlane;
    Float_t                 fHPlaneVal;
 
-   Int_t                   fBinStep;
+   Bool_t                  fHasFixedHeightIn2DMode;
+   Float_t                 fFixedHeightValIn2DMode; // 1% of whole height
 
    Int_t                   fDrawNumberCellPixels;
    Int_t                   fCellPixelFontSize;
@@ -285,8 +294,8 @@ public:
    Color_t  GetPlaneColor() const { return fPlaneColor; }
    void     SetPlaneColor(Color_t ci) { fPlaneColor=ci; }
 
-   UChar_t  GetPlaneTransparency() const { return fPlaneTransparency; }
-   void     SetPlaneTransparency(UChar_t t) { fPlaneTransparency=t; }
+   Char_t   GetPlaneTransparency() const { return fPlaneTransparency; }
+   void     SetPlaneTransparency(Char_t t) { fPlaneTransparency=t; }
 
    Int_t    GetNZSteps() const { return fNZSteps; }
    void     SetNZSteps(Int_t s) { fNZSteps = s;}
@@ -300,12 +309,18 @@ public:
    Bool_t   GetNormalizeRebin() const { return fNormalizeRebin; }
    void     SetNormalizeRebin(Bool_t s) { fNormalizeRebin = s; fCellIdCacheOK=kFALSE;}
 
+   EProjection_e  GetProjection() const { return fProjection; }
    void           SetProjection(EProjection_e p) { fProjection = p; }
-   EProjection_e  GetProjection() { return fProjection; }
 
    void       Set2DMode(E2DMode_e p) { f2DMode = p; }
    E2DMode_e  Get2DMode() { return f2DMode; }
 
+   bool       GetHasFixedHeightIn2DMode() const { return fHasFixedHeightIn2DMode; }
+   void       SetHasFixedHeightIn2DMode(bool x) { fHasFixedHeightIn2DMode = x; }
+
+   float      GetFixedHeightValIn2DMode() const  { return fFixedHeightValIn2DMode; }
+   void       SetFixedHeightValIn2DMode(float x) { fFixedHeightValIn2DMode = x; }
+
    void        SetBoxMode(EBoxMode_e p) { fBoxMode = p; }
    EBoxMode_e  GetBoxMode() { return fBoxMode; }
 
diff --git a/graf3d/eve/inc/TEveCalo2DGL.h b/graf3d/eve/inc/TEveCalo2DGL.h
index bc9faac..9dfc1af 100644
--- a/graf3d/eve/inc/TEveCalo2DGL.h
+++ b/graf3d/eve/inc/TEveCalo2DGL.h
@@ -36,9 +36,9 @@ protected:
    void      MakeRPhiCell(Float_t phiMin, Float_t phiMax, Float_t towerH, Float_t offset) const;
 
    void      DrawRPhi(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t&) const;
-   void      DrawRPhiHighlighted(TGLRnrCtx & rnrCtx) const;
+   void      DrawRPhiHighlighted(std::vector<TEveCaloData::vCellId_t*>& cellLists) const;
    void      DrawRhoZ(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t&) const;
-   void      DrawRhoZHighlighted(TGLRnrCtx & rnrCtx) const;
+   void      DrawRhoZHighlighted(std::vector<TEveCaloData::vCellId_t*>& cellLists) const;
 
    Bool_t    IsRPhi() const;
 
@@ -50,7 +50,7 @@ public:
    virtual void   SetBBox();
 
    virtual void DirectDraw(TGLRnrCtx & rnrCtx) const;
-   virtual void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps) const;
+   virtual void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps, Int_t lvl=-1) const;
 
    // To support two-level selection
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
diff --git a/graf3d/eve/inc/TEveCalo3DGL.h b/graf3d/eve/inc/TEveCalo3DGL.h
index e667cb9..f15071d 100644
--- a/graf3d/eve/inc/TEveCalo3DGL.h
+++ b/graf3d/eve/inc/TEveCalo3DGL.h
@@ -29,8 +29,10 @@ private:
    void    RenderGridEndCap() const;
    void    RenderGridBarrel() const;
    void    RenderGrid(TGLRnrCtx & rnrCtx) const;
-   Float_t RenderBarrelCell(const TEveCaloData::CellGeom_t &cell, Float_t towerH, Float_t offset) const;
-   Float_t RenderEndCapCell(const TEveCaloData::CellGeom_t &cell, Float_t towerH, Float_t offset) const;
+   void    RenderBarrelCell(const TEveCaloData::CellGeom_t &cell, Float_t towerH, Float_t& offset) const;
+   void    RenderEndCapCell(const TEveCaloData::CellGeom_t &cell, Float_t towerH, Float_t& offset) const;
+
+   void    DrawSelectedCells(TEveCaloData::vCellId_t cells) const;
 
 protected:
    TEveCalo3D     *fM;  // Model object.
@@ -45,7 +47,7 @@ public:
    virtual void   SetBBox();
 
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
-   virtual void   DrawHighlight(TGLRnrCtx & rnrCtx, const TGLPhysicalShape* ps) const;
+   virtual void   DrawHighlight(TGLRnrCtx & rnrCtx, const TGLPhysicalShape* ps, Int_t lvl=-1) const;
 
    virtual Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const;
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
diff --git a/graf3d/eve/inc/TEveCaloData.h b/graf3d/eve/inc/TEveCaloData.h
index 2b156d5..e79b583 100644
--- a/graf3d/eve/inc/TEveCaloData.h
+++ b/graf3d/eve/inc/TEveCaloData.h
@@ -15,6 +15,8 @@
 #include <vector>
 #include "TEveElement.h"
 
+class TGLSelectRecord;
+
 class TH2F;
 class TAxis;
 class THStack;
@@ -28,16 +30,18 @@ public:
       TString  fName;      // Name of the slice, eg. ECAL, HCAL.
       Float_t  fThreshold; // Only display towers with higher energy.
       Color_t  fColor;     // Color used to draw this longitudinal slice.
+      Color_t  fTransparency; // Transparency used to draw this longitudinal slice.
       
-      SliceInfo_t(): fName(""), fThreshold(0), fColor(kRed) {}
+      SliceInfo_t(): fName(""), fThreshold(0), fColor(kRed), fTransparency(0) {}
 
       virtual ~SliceInfo_t() {}
 
-      void Setup(const char* name, Float_t threshold, Color_t col)
+      void Setup(const char* name, Float_t threshold, Color_t col, Char_t transp = 101)
       {
          fName      = name;
          fThreshold = threshold;
          fColor     = col;
+         if (transp <= 100) fTransparency = transp;
       };
 
       ClassDef(SliceInfo_t, 0); // Slice info for histogram stack.
@@ -57,7 +61,10 @@ public:
 
       Float_t fFraction;
 
-      CellId_t(Int_t t, Int_t s, Float_t fr=1.f):fTower(t), fSlice(s), fFraction(fr){}
+      CellId_t(Int_t t, Int_t s, Float_t f=1.0f) : fTower(t), fSlice(s), fFraction(f) {}
+
+      bool operator<(const CellId_t& o) const
+      { return (fTower == o.fTower) ? fSlice < o.fSlice : fTower < o.fTower; }
    };
 
    struct CellGeom_t
@@ -153,20 +160,27 @@ protected:
    Float_t      fEps;
 
    vCellId_t    fCellsSelected;
+   vCellId_t    fCellsHighlighted;
 
 public:
    TEveCaloData(const char* n="TEveCalData", const char* t="");
    virtual ~TEveCaloData() {}
 
-   virtual void    SelectElement(Bool_t state);
+   virtual void UnSelected();
+   virtual void UnHighlighted();
+
+   virtual TString GetHighlightTooltip();
+
    virtual void    FillImpliedSelectedSet(Set_t& impSelSet);
 
    virtual void    GetCellList(Float_t etaMin, Float_t etaMax,
                                Float_t phi,    Float_t phiRng,
                                vCellId_t &out) const = 0;
 
-   vCellId_t&      GetCellsSelected() { return fCellsSelected; }
+   vCellId_t&      GetCellsSelected()    { return fCellsSelected; }
+   vCellId_t&      GetCellsHighlighted() { return fCellsHighlighted; }
    void            PrintCellsSelected();
+   void  ProcessSelection(vCellId_t& sel_cells, TGLSelectRecord& rec);
 
    virtual void    Rebin(TAxis *ax, TAxis *ay, vCellId_t &in, Bool_t et, RebinData_t &out) const = 0;
 
@@ -183,6 +197,8 @@ public:
    Float_t         GetSliceThreshold(Int_t slice) const;
    void            SetSliceColor(Int_t slice, Color_t col);
    Color_t         GetSliceColor(Int_t slice) const;
+   void            SetSliceTransparency(Int_t slice, Char_t t);
+   Char_t          GetSliceTransparency(Int_t slice) const;
 
    virtual void    GetEtaLimits(Double_t &min, Double_t &max) const = 0;
 
@@ -227,7 +243,6 @@ protected:
    typedef std::vector<vFloat_t>::iterator    vvFloat_i;
 
    vvFloat_t   fSliceVec;
-   vFloat_t    fValVec;
    vCellGeom_t fGeomVec;
 
    Int_t       fTower; // current tower
@@ -241,12 +256,15 @@ protected:
 public:
    TEveCaloDataVec(Int_t nslices);
    virtual ~TEveCaloDataVec();
-
+  
+   Int_t AddSlice();
    Int_t AddTower(Float_t etaMin, Float_t etaMax, Float_t phiMin, Float_t phiMax);
    void  FillSlice(Int_t slice, Float_t value);
    void  FillSlice(Int_t slice, Int_t tower, Float_t value);
 
    Int_t GetNCells() { return fGeomVec.size(); }
+   std::vector<Float_t>&  GetSliceVals(Int_t slice) { return fSliceVec[slice]; }
+   std::vector<TEveCaloData::CellGeom_t>& GetCellGeom() { return fGeomVec; } 
 
    virtual void GetCellList(Float_t etaMin, Float_t etaMax,
                             Float_t phi,    Float_t phiRng,
@@ -258,6 +276,7 @@ public:
    virtual void GetEtaLimits(Double_t &min, Double_t &max) const { min=fEtaMin, max=fEtaMax;}
    virtual void GetPhiLimits(Double_t &min, Double_t &max) const { min=fPhiMin; max=fPhiMax;}
 
+  
    virtual void  DataChanged();
    void          SetAxisFromBins(Double_t epsX=0.001, Double_t epsY=0.001);
 
diff --git a/graf3d/eve/inc/TEveCaloLegoGL.h b/graf3d/eve/inc/TEveCaloLegoGL.h
index 4fa26ed..4dad22f 100644
--- a/graf3d/eve/inc/TEveCaloLegoGL.h
+++ b/graf3d/eve/inc/TEveCaloLegoGL.h
@@ -25,6 +25,8 @@ class TEveCaloLego;
 
 class TEveCaloLegoGL : public TGLObject
 {
+   friend class TEveCaloLegoOverlay;
+
 private:
    struct Cell2D_t
    {
@@ -39,6 +41,7 @@ private:
          fId       = id;
          fSumVal   = sumVal;
          fMaxSlice = maxSlice;
+         fX0 = fX1 = fY0 = fY1 = 0;
       }
 
       void SetGeom(Float_t x0, Float_t x1, Float_t y0, Float_t y1)
@@ -87,6 +90,8 @@ private:
    mutable SliceDLMap_t              fDLMap;
    mutable Bool_t                    fCells3D;
 
+   mutable Int_t                     fBinStep;
+
    TEveCaloLegoGL(const TEveCaloLegoGL&);            // Stop default
    TEveCaloLegoGL& operator=(const TEveCaloLegoGL&); // Stop default
 
@@ -99,6 +104,9 @@ protected:
    void    DrawAxis2D(TGLRnrCtx &rnrCtx) const;
    void    DrawHistBase(TGLRnrCtx &rnrCtx) const;
 
+   // highlight 
+   void    DrawSelectedCells(TGLRnrCtx & rnrCtx, TEveCaloData::vCellId_t cells) const;
+
    // top view
    void    PrepareCell2DData(TEveCaloData::vCellId_t& cellList, vCell2D_t& cells2D) const;
    void    PrepareCell2DDataRebin(TEveCaloData::RebinData_t& rebinData, vCell2D_t& cells2D) const;
@@ -124,7 +132,7 @@ public:
    virtual void   DLCachePurge();
 
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
-   virtual void   DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps) const;
+   virtual void   DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps, Int_t lvl=-1) const;
 
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
    virtual Bool_t AlwaysSecondarySelect()   const { return kTRUE; }
diff --git a/graf3d/eve/inc/TEveCaloLegoOverlay.h b/graf3d/eve/inc/TEveCaloLegoOverlay.h
index 2795fd8..708e2ab 100644
--- a/graf3d/eve/inc/TEveCaloLegoOverlay.h
+++ b/graf3d/eve/inc/TEveCaloLegoOverlay.h
@@ -37,7 +37,7 @@ protected:
    // 2D scales
    Bool_t         fShowScales;
    Color_t        fScaleColor;
-   UChar_t        fScaleTransparency; //transaprency in %
+   Char_t         fScaleTransparency; //transaprency in %
    Double_t       fScaleCoordX;
    Double_t       fScaleCoordY;
    Double_t       fScaleW;
@@ -46,8 +46,8 @@ protected:
    Double_t       fCellY;
 
    Color_t        fFrameColor;
-   UChar_t        fFrameLineTransp;
-   UChar_t        fFrameBgTransp;
+   Char_t         fFrameLineTransp;
+   Char_t         fFrameBgTransp;
 
    // move of scales
    Int_t             fMouseX, fMouseY; //! last mouse position
@@ -96,10 +96,10 @@ public:
    const char*   GetHeaderTxt() const { return fHeaderTxt; }
 
    void          SetShowScales(Bool_t x) { fShowScales = x;}
-   void          SetScaleColorTransparency(Color_t colIdx, UChar_t transp);
+   void          SetScaleColorTransparency(Color_t colIdx, Char_t transp);
    void          SetScalePosition(Double_t x, Double_t y);
 
-   void          SetFrameAttribs(Color_t frameCol, UChar_t lineTransp, UChar_t bgTransp);
+   void          SetFrameAttribs(Color_t frameCol, Char_t lineTransp, Char_t bgTransp);
 
    ClassDef(TEveCaloLegoOverlay, 0); // GL-overaly control GUI for TEveCaloLego.
 };
diff --git a/graf3d/eve/inc/TEveCaloVizEditor.h b/graf3d/eve/inc/TEveCaloVizEditor.h
index aae4272..4a9c243 100644
--- a/graf3d/eve/inc/TEveCaloVizEditor.h
+++ b/graf3d/eve/inc/TEveCaloVizEditor.h
@@ -69,6 +69,7 @@ public:
 
    void DoSliceThreshold();
    void DoSliceColor(Pixel_t color);
+   void DoSliceTransparency(Long_t transp);
 
    ClassDef(TEveCaloVizEditor, 0); // GUI editor for TEveCaloVizEditor.
 };
diff --git a/graf3d/eve/inc/TEveChunkManager.h b/graf3d/eve/inc/TEveChunkManager.h
index 549fe9e..440805f 100644
--- a/graf3d/eve/inc/TEveChunkManager.h
+++ b/graf3d/eve/inc/TEveChunkManager.h
@@ -75,19 +75,30 @@ public:
       Int_t             fNextChunk;
       Int_t             fAtomsToGo;
 
+      const std::set<Int_t>           *fSelection;
+      std::set<Int_t>::const_iterator  fSelectionIterator;
+
       iterator(TEveChunkManager* p) :
-         fPlex(p), fCurrent(0), fAtomIndex(-1), fNextChunk(0), fAtomsToGo(0) {}
+         fPlex(p), fCurrent(0), fAtomIndex(-1),
+         fNextChunk(0), fAtomsToGo(0), fSelection(0), fSelectionIterator() {}
       iterator(TEveChunkManager& p) :
-         fPlex(&p), fCurrent(0), fAtomIndex(-1), fNextChunk(0), fAtomsToGo(0) {}
+         fPlex(&p), fCurrent(0), fAtomIndex(-1),
+         fNextChunk(0), fAtomsToGo(0), fSelection(0), fSelectionIterator() {}
       iterator(const iterator& i) :
-         fPlex(i.fPlex), fCurrent(i.fCurrent), fAtomIndex(i.fAtomIndex), fNextChunk(i.fNextChunk), fAtomsToGo(i.fAtomsToGo) {}
-
-      iterator& operator=(const iterator& i)
-      { fPlex = i.fPlex; fCurrent = i.fCurrent; fAtomIndex = i.fAtomIndex; fNextChunk = i.fNextChunk; fAtomsToGo = i.fAtomsToGo; return *this; }
+         fPlex(i.fPlex), fCurrent(i.fCurrent), fAtomIndex(i.fAtomIndex),
+         fNextChunk(i.fNextChunk), fAtomsToGo(i.fAtomsToGo),
+         fSelection(i.fSelection), fSelectionIterator(i.fSelectionIterator) {}
+
+      iterator& operator=(const iterator& i) {
+         fPlex = i.fPlex; fCurrent = i.fCurrent; fAtomIndex = i.fAtomIndex;
+         fNextChunk = i.fNextChunk; fAtomsToGo = i.fAtomsToGo;
+         fSelection = i.fSelection; fSelectionIterator = i.fSelectionIterator;
+         return *this;
+      }
 
       Bool_t  next();
-      void    reset() { fCurrent = 0; fNextChunk = fAtomsToGo = 0; }
-
+      void    reset() { fCurrent = 0; fAtomIndex = -1; fNextChunk = fAtomsToGo = 0; }
+      
       Char_t* operator()() { return fCurrent; }
       Char_t* operator*()  { return fCurrent; }
       Int_t   index()      { return fAtomIndex; }
@@ -97,8 +108,6 @@ public:
 };
 
 
-/******************************************************************************/
-
 //______________________________________________________________________________
 inline Char_t* TEveChunkManager::NewAtom()
 {
@@ -107,25 +116,6 @@ inline Char_t* TEveChunkManager::NewAtom()
    return a;
 }
 
-//______________________________________________________________________________
-inline Bool_t TEveChunkManager::iterator::next()
-{
-   if (fAtomsToGo <= 0) {
-      if (fNextChunk < fPlex->VecSize()) {
-         fCurrent   = fPlex->Chunk(fNextChunk);
-         fAtomsToGo = fPlex->NAtoms(fNextChunk);
-         ++fNextChunk;
-      } else {
-         return kFALSE;
-      }
-   } else {
-      fCurrent += fPlex->S();
-   }
-   ++fAtomIndex;
-   --fAtomsToGo;
-   return kTRUE;
-}
-
 
 /******************************************************************************/
 // Templated some-class TEveChunkVector
diff --git a/graf3d/eve/inc/TEveCompound.h b/graf3d/eve/inc/TEveCompound.h
index 3d8f203..1f67757 100644
--- a/graf3d/eve/inc/TEveCompound.h
+++ b/graf3d/eve/inc/TEveCompound.h
@@ -31,7 +31,7 @@ protected:
 
 public:
    TEveCompound(const char* n="TEveCompound", const char* t="",
-                Bool_t doColor=kTRUE);
+                Bool_t doColor=kTRUE, Bool_t doTransparency=kFALSE);
    virtual ~TEveCompound() {}
 
    void   OpenCompound()         { ++fCompoundOpen;  }
@@ -39,6 +39,7 @@ public:
    Bool_t IsCompoundOpen() const { return fCompoundOpen > 0; }
 
    virtual void SetMainColor(Color_t color);
+   virtual void SetMainTransparency(Char_t t);
 
    virtual void AddElement(TEveElement* el);
    virtual void RemoveElementLocal(TEveElement* el);
@@ -63,9 +64,6 @@ private:
    TEveCompoundProjected(const TEveCompoundProjected&);            // Not implemented
    TEveCompoundProjected& operator=(const TEveCompoundProjected&); // Not implemented
 
-protected:
-   virtual void SetDepthLocal(Float_t /*d*/) {}
-
 public:
    TEveCompoundProjected();
    virtual ~TEveCompoundProjected() {}
@@ -73,6 +71,7 @@ public:
    virtual void SetMainColor(Color_t color);
 
    virtual void UpdateProjection()      {}
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    ClassDef(TEveCompoundProjected, 0); // Projected TEveCompund container.
 };
diff --git a/graf3d/eve/inc/TEveDigitSet.h b/graf3d/eve/inc/TEveDigitSet.h
index 45ac02c..2cdff00 100644
--- a/graf3d/eve/inc/TEveDigitSet.h
+++ b/graf3d/eve/inc/TEveDigitSet.h
@@ -22,15 +22,18 @@
 #include "TEveFrameBox.h"
 #include "TEveRGBAPalette.h"
 #include "TEveChunkManager.h"
+#include "TEveSecondarySelectable.h"
 
-#include "TObject.h"
+class TRefArray;
 
 class TEveDigitSet : public TEveElement,
                      public TNamed, public TQObject,
                      public TAtt3D,
-                     public TAttBBox
+                     public TAttBBox,
+                     public TEveSecondarySelectable
 {
    friend class TEveDigitSetEditor;
+   friend class TEveDigitSetGL;
 
    TEveDigitSet(const TEveDigitSet&);            // Not implemented
    TEveDigitSet& operator=(const TEveDigitSet&); // Not implemented
@@ -39,27 +42,31 @@ public:
    enum ERenderMode_e { kRM_AsIs, kRM_Line, kRM_Fill };
 
    typedef void (*Callback_foo)(TEveDigitSet*, Int_t, TObject*);
+   typedef TString (*TooltipCB_foo)(TEveDigitSet*, Int_t);
 
 protected:
    struct DigitBase_t
    {
       // Base-class for digit representation classes.
 
-      Int_t fValue; // signal value of a digit (can be direct RGBA color)
-      TRef  fId;    // external object reference
+      Int_t  fValue;    // signal value of a digit (can be direct RGBA color)
+      void  *fUserData; // user-data for given digit
 
-      DigitBase_t(Int_t v=0) : fValue(v), fId() {}
-      virtual ~DigitBase_t() {}
+      DigitBase_t(Int_t v=0) : fValue(v), fUserData(0) {}
    };
 
+   TRefArray        *fDigitIds;       //  Array holding references to external objects.
+
    Int_t             fDefaultValue;   //  Default signal value.
    Bool_t            fValueIsColor;   //  Interpret signal value as RGBA color.
    Bool_t            fSingleColor;    //  Use the same color for all digits.
+   Bool_t            fAntiFlick;      // Make extra render pass to avoid flickering when quads are too small.
    Bool_t            fOwnIds;         //  Flag specifying if id-objects are owned by the TEveDigitSet.
    TEveChunkManager  fPlex;           //  Container of digit data.
-   DigitBase_t*      fLastDigit;      //! The last digit added to collection.
+   DigitBase_t*      fLastDigit;      //! The last / current digit added to collection.
+   Int_t             fLastIdx;        //! The last / current idx added to collection.
 
-   Color_t           fColor;          //  Color used for frame
+   Color_t           fColor;          //  Color used for frame (or all digis with single-color).
    TEveFrameBox*     fFrame;          //  Pointer to frame structure.
    TEveRGBAPalette*  fPalette;        //  Pointer to signal-color palette.
    ERenderMode_e     fRenderMode;     //  Render mode: as-is / line / filled.
@@ -68,20 +75,29 @@ protected:
 
    Bool_t            fEmitSignals;    //  Emit signals on secondary-select.
    Callback_foo      fCallbackFoo;    //! Additional function to call on secondary-select.
+   TooltipCB_foo     fTooltipCBFoo;   //! Function providing highlight tooltips when always-sec-select is active.
 
    DigitBase_t* NewDigit();
-   void       ReleaseIds();
+   void         ReleaseIds();
 
 public:
    TEveDigitSet(const char* n="TEveDigitSet", const char* t="");
    virtual ~TEveDigitSet();
 
-   void UseSingleColor();
+   virtual TObject* GetObject(const TEveException& /*eh*/="TEveDigitSet::GetObject ") const
+   { const TObject* obj = this; return const_cast<TObject*>(obj); }
+
+   void   UseSingleColor();
+
+   Bool_t GetAntiFlick() const   { return fAntiFlick; }
+   void   SetAntiFlick(Bool_t f) { fAntiFlick = f; }
 
-   virtual Bool_t CanEditMainColor() const { return kTRUE; }
-   virtual void   SetMainColor(Color_t color);
+   virtual void SetMainColor(Color_t color);
 
-   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+   virtual void UnSelected();
+   virtual void UnHighlighted();
+
+   virtual TString GetHighlightTooltip();
 
    // Implemented in sub-classes:
    // virtual void Reset(EQuadType_e quadType, Bool_t valIsCol, Int_t chunkSize);
@@ -91,19 +107,26 @@ public:
 
    // --------------------------------
 
+   void SetCurrentDigit(Int_t idx);
+
    void DigitValue(Int_t value);
    void DigitColor(Color_t ci);
-   void DigitColor(Color_t ci, UChar_t transparency);
+   void DigitColor(Color_t ci, Char_t transparency);
    void DigitColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a=255);
    void DigitColor(UChar_t* rgba);
 
-   void DigitId(TObject* id);
-
    Bool_t GetOwnIds() const     { return fOwnIds; }
    void   SetOwnIds(Bool_t o)   { fOwnIds = o; }
 
-   DigitBase_t* GetDigit(Int_t n) { return (DigitBase_t*) fPlex.Atom(n);   }
-   TObject*     GetId(Int_t n)    { return GetDigit(n)->fId.GetObject(); }
+   void   DigitId(TObject* id);
+   void   DigitUserData(void* ud);
+
+   void   DigitId(Int_t n, TObject* id);
+   void   DigitUserData(Int_t n, void* ud);
+
+   DigitBase_t* GetDigit(Int_t n) const { return (DigitBase_t*) fPlex.Atom(n); }
+   TObject*     GetId(Int_t n) const;
+   void*        GetUserData(Int_t n) const;
 
    // --------------------------------
 
@@ -140,6 +163,9 @@ public:
    Callback_foo GetCallbackFoo()         const { return fCallbackFoo; }
    void         SetCallbackFoo(Callback_foo f) { fCallbackFoo = f; }
 
+   TooltipCB_foo GetTooltipCBFoo()          const { return fTooltipCBFoo; }
+   void          SetTooltipCBFoo(TooltipCB_foo f) { fTooltipCBFoo = f; }
+
    ClassDef(TEveDigitSet, 0); // Base-class for storage of digit collections; provides transformation matrix (TEveTrans), signal to color mapping (TEveRGBAPalette) and visual grouping (TEveFrameBox).
 };
 
diff --git a/graf3d/eve/inc/TEveDigitSetGL.h b/graf3d/eve/inc/TEveDigitSetGL.h
new file mode 100644
index 0000000..ad860e7
--- /dev/null
+++ b/graf3d/eve/inc/TEveDigitSetGL.h
@@ -0,0 +1,49 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveDigitSetGL
+#define ROOT_TEveDigitSetGL
+
+#include "TGLObject.h"
+#include "TEveDigitSet.h"
+
+class TGLViewer;
+class TGLScene;
+
+class TEveDigitSet;
+
+class TEveDigitSetGL : public TGLObject
+{
+private:
+   TEveDigitSetGL(const TEveDigitSetGL&);            // Not implemented
+   TEveDigitSetGL& operator=(const TEveDigitSetGL&); // Not implemented
+
+protected:
+   mutable const std::set<Int_t> *fHighlightSet;
+
+   Bool_t SetupColor(const TEveDigitSet::DigitBase_t& q) const;
+
+public:
+   TEveDigitSetGL();
+   virtual ~TEveDigitSetGL() {}
+
+   virtual void   SetBBox();
+
+   virtual void   DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl=-1) const;
+
+   virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   virtual Bool_t AlwaysSecondarySelect()   const { return ((TEveDigitSet*)fExternalObj)->GetAlwaysSecSelect(); }
+   virtual void   ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec);
+
+   ClassDef(TEveDigitSetGL, 0); // GL renderer class for TEveDigitSet.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveElement.h b/graf3d/eve/inc/TEveElement.h
index 49f527c..a4aa753 100644
--- a/graf3d/eve/inc/TEveElement.h
+++ b/graf3d/eve/inc/TEveElement.h
@@ -81,16 +81,19 @@ protected:
    TEveElement     *fVizModel;             //! Element used as model from VizDB.
    TString          fVizTag;               //  Tag used to query VizDB for model element.
 
+   Int_t            fNumChildren;          //!
    Int_t            fParentIgnoreCnt;      //! Counter for parents that are ignored in ref-counting.
    Int_t            fTopItemCnt;           //! Counter for top-level list-tree items that prevent automatic destruction.
    Int_t            fDenyDestroy;          //! Deny-destroy count.
    Bool_t           fDestroyOnZeroRefCnt;  //  Auto-destruct when ref-count reaches zero.
 
-   Bool_t           fRnrSelf;              //  Render this element.
-   Bool_t           fRnrChildren;          //  Render children of this element.
-   Bool_t           fCanEditMainTrans;     //  Allow editing of main transformation.
+   Bool_t           fRnrSelf;                 //  Render this element.
+   Bool_t           fRnrChildren;             //  Render children of this element.
+   Bool_t           fCanEditMainColor;        //  Allow editing of main color.
+   Bool_t           fCanEditMainTransparency; //  Allow editing of main transparency.
+   Bool_t           fCanEditMainTrans;        //  Allow editing of main transformation.
 
-   UChar_t          fMainTransparency;     //  Main-transparency variable.
+   Char_t           fMainTransparency;     //  Main-transparency variable.
    Color_t         *fMainColorPtr;         //  Pointer to main-color variable.
    TEveTrans       *fMainTrans;            //  Pointer to main transformation matrix.
 
@@ -116,6 +119,7 @@ public:
 
    virtual const char* GetElementName()  const;
    virtual const char* GetElementTitle() const;
+   virtual TString     GetHighlightTooltip() { return TString(GetElementTitle()); }
    virtual void SetElementName (const char* name);
    virtual void SetElementTitle(const char* title);
    virtual void SetElementNameTitle(const char* name, const char* title);
@@ -159,8 +163,8 @@ public:
    List_i  EndChildren()         { return  fChildren.end();   }
    List_ci BeginChildren() const { return  fChildren.begin(); }
    List_ci EndChildren()   const { return  fChildren.end();   }
-   Int_t   NumChildren()   const { return  fChildren.size();  }
-   Bool_t  HasChildren()   const { return !fChildren.empty(); }
+   Int_t   NumChildren()   const { return  fNumChildren;      }
+   Bool_t  HasChildren()   const { return  fNumChildren != 0; }
 
    Bool_t       HasChild(TEveElement* el);
    TEveElement* FindChild(const TString& name, const TClass* cls=0);
@@ -231,6 +235,7 @@ public:
    virtual void RemoveElementsLocal();
 
    virtual void ProjectChild(TEveElement* el, Bool_t same_depth=kTRUE);
+   virtual void ProjectAllChildren(Bool_t same_depth=kTRUE);
 
    virtual void Destroy();                      // *MENU*
    virtual void DestroyOrWarn();
@@ -251,9 +256,10 @@ public:
    virtual Bool_t SetRnrState(Bool_t rnr);
    virtual void   PropagateRnrStateToProjecteds();
 
-   virtual Bool_t CanEditMainColor() const  { return kFALSE; }
-   Color_t* GetMainColorPtr()        const  { return fMainColorPtr; }
-   void     SetMainColorPtr(Color_t* color) { fMainColorPtr = color; }
+   virtual Bool_t CanEditMainColor() const   { return fCanEditMainColor; }
+   void           SetEditMainColor(Bool_t x) { fCanEditMainColor = x; }
+   Color_t* GetMainColorPtr()        const   { return fMainColorPtr; }
+   void     SetMainColorPtr(Color_t* color)  { fMainColorPtr = color; }
 
    virtual Bool_t  HasMainColor() const { return fMainColorPtr != 0; }
    virtual Color_t GetMainColor() const { return fMainColorPtr ? *fMainColorPtr : 0; }
@@ -263,10 +269,12 @@ public:
    void            SetMainColorRGB(Float_t r, Float_t g, Float_t b);
    virtual void    PropagateMainColorToProjecteds(Color_t color, Color_t old_color);
 
-   virtual Bool_t  CanEditMainTransparency() const { return kFALSE; }
-   virtual UChar_t GetMainTransparency()     const { return fMainTransparency; }
-   virtual void    SetMainTransparency(UChar_t t);
+   virtual Bool_t  CanEditMainTransparency() const   { return fCanEditMainTransparency; }
+   void            SetEditMainTransparency(Bool_t x) { fCanEditMainTransparency = x; }
+   virtual Char_t  GetMainTransparency()     const { return fMainTransparency; }
+   virtual void    SetMainTransparency(Char_t t);
    void            SetMainAlpha(Float_t alpha);
+   virtual void    PropagateMainTransparencyToProjecteds(Char_t t, Char_t old_t);
 
    virtual Bool_t     CanEditMainTrans() const { return fCanEditMainTrans; }
    virtual Bool_t     HasMainTrans()     const { return fMainTrans != 0;   }
@@ -289,8 +297,10 @@ public:
    void* GetUserData() const { return fUserData; }
    void  SetUserData(void* ud) { fUserData = ud; }
 
+
    // Selection state and management
    //--------------------------------
+
 protected:
    Bool_t  fPickable;
    Bool_t  fSelected;             //!
@@ -298,6 +308,18 @@ protected:
    Short_t fImpliedSelected;      //!
    Short_t fImpliedHighlighted;   //!
 
+   enum ECompoundSelectionColorBits
+   {
+      kCSCBImplySelectAllChildren           = BIT(0), // compound will select all children
+      kCSCBTakeAnyParentAsMaster            = BIT(1), // element will take any compound parent as master
+      kCSCBApplyMainColorToAllChildren      = BIT(2), // compound will apply color change to all children
+      kCSCBApplyMainColorToMatchingChildren = BIT(3), // compound will apply color change to all children with matching color
+      kCSCBApplyMainTransparencyToAllChildren      = BIT(4), // compound will apply transparency change to all children
+      kCSCBApplyMainTransparencyToMatchingChildren = BIT(5)  // compound will apply transparency change to all children with matching color
+   };
+
+   UChar_t fCSCBits;
+
 public:
    typedef void (TEveElement::* Select_foo)      (Bool_t);
    typedef void (TEveElement::* ImplySelect_foo) ();
@@ -311,16 +333,31 @@ public:
    virtual void SelectElement(Bool_t state);
    virtual void IncImpliedSelected();
    virtual void DecImpliedSelected();
+   virtual void UnSelected();
 
    virtual void HighlightElement(Bool_t state);
    virtual void IncImpliedHighlighted();
    virtual void DecImpliedHighlighted();
+   virtual void UnHighlighted();
 
    virtual void FillImpliedSelectedSet(Set_t& impSelSet);
 
    virtual UChar_t GetSelectedLevel() const;
 
-   void RecheckImpliedSelections();
+   void   RecheckImpliedSelections();
+
+   void   SetCSCBits(UChar_t f)   { fCSCBits |=  f; }
+   void   ResetCSCBits(UChar_t f) { fCSCBits &= ~f; }
+   Bool_t TestCSCBits(UChar_t f) const { return (fCSCBits & f) != 0; }
+
+   void   ResetAllCSCBits()                     { fCSCBits  =  0; }
+   void   CSCImplySelectAllChildren()           { fCSCBits |= kCSCBImplySelectAllChildren; }
+   void   CSCTakeAnyParentAsMaster()            { fCSCBits |= kCSCBTakeAnyParentAsMaster;  }
+   void   CSCApplyMainColorToAllChildren()      { fCSCBits |= kCSCBApplyMainColorToAllChildren; }
+   void   CSCApplyMainColorToMatchingChildren() { fCSCBits |= kCSCBApplyMainColorToMatchingChildren; }
+   void   CSCApplyMainTransparencyToAllChildren()      { fCSCBits |= kCSCBApplyMainTransparencyToAllChildren; }
+   void   CSCApplyMainTransparencyToMatchingChildren() { fCSCBits |= kCSCBApplyMainTransparencyToMatchingChildren; }
+
 
    // Change-stamping and change bits
    //---------------------------------
@@ -338,8 +375,8 @@ public:
    };
 
 protected:
-   UChar_t      fChangeBits;
-   Bool_t       fDestructing;
+   UChar_t      fChangeBits;  //!
+   Bool_t       fDestructing; //!
 
 public:
    void StampColorSelection() { AddStamp(kCBColorSelection); }
@@ -414,16 +451,18 @@ private:
    TEveElementList& operator=(const TEveElementList&); // Not implemented
 
 protected:
-   Color_t   fColor;       // Color of the object.
-   Bool_t    fDoColor;     // Should serve fColor as the main color of the object.
-   TClass   *fChildClass;  // Class of acceptable children, others are rejected.
+   Color_t   fColor;          // Color of the object.
+   TClass   *fChildClass;     // Class of acceptable children, others are rejected.
 
 public:
    TEveElementList(const char* n="TEveElementList", const char* t="",
-                   Bool_t doColor=kFALSE);
+                   Bool_t doColor=kFALSE, Bool_t doTransparency=kFALSE);
    TEveElementList(const TEveElementList& e);
    virtual ~TEveElementList() {}
 
+   virtual TObject* GetObject(const TEveException& /*eh*/="TEveElementList::GetObject ") const
+   { const TObject* obj = this; return const_cast<TObject*>(obj); }
+
    virtual TEveElementList* CloneElement() const;
 
    virtual const char* GetElementName()  const { return GetName();  }
@@ -438,8 +477,6 @@ public:
    virtual void SetElementNameTitle(const char* name, const char* title)
    { TNamed::SetNameTitle(name, title); NameTitleChanged(); }
 
-   virtual Bool_t CanEditMainColor() const { return fDoColor; }
-
    TClass* GetChildClass() const { return fChildClass; }
    void    SetChildClass(TClass* c) { fChildClass = c; }
 
@@ -462,15 +499,12 @@ private:
    TEveElementListProjected(const TEveElementListProjected&);            // Not implemented
    TEveElementListProjected& operator=(const TEveElementListProjected&); // Not implemented
 
-
-protected:
-   virtual void SetDepthLocal(Float_t d);
-
 public:
    TEveElementListProjected();
    virtual ~TEveElementListProjected() {}
 
    virtual void UpdateProjection();
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    ClassDef(TEveElementListProjected, 0); // Projected TEveElementList.
 };
diff --git a/graf3d/eve/inc/TEveGeoNode.h b/graf3d/eve/inc/TEveGeoNode.h
index 4a7ac0b..11aad7e 100644
--- a/graf3d/eve/inc/TEveGeoNode.h
+++ b/graf3d/eve/inc/TEveGeoNode.h
@@ -46,6 +46,9 @@ protected:
 public:
    TEveGeoNode(TGeoNode* node);
 
+   virtual TObject* GetObject(const TEveException& /*eh*/="TEveElementList::GetObject ") const
+   { const TObject* obj = this; return const_cast<TObject*>(obj); }
+
    virtual const char* GetName()  const;
    virtual const char* GetTitle() const;
    virtual const char* GetElementName()  const;
@@ -66,8 +69,8 @@ public:
    virtual void   SetMainColor(Color_t color);
 
    virtual Bool_t  CanEditMainTransparency() const;
-   virtual UChar_t GetMainTransparency() const;
-   virtual void    SetMainTransparency(UChar_t t);
+   virtual Char_t  GetMainTransparency() const;
+   virtual void    SetMainTransparency(Char_t t);
 
    void UpdateNode(TGeoNode* node);
    void UpdateVolume(TGeoVolume* volume);
diff --git a/graf3d/eve/inc/TEveGeoShape.h b/graf3d/eve/inc/TEveGeoShape.h
index 2701061..abf280a 100644
--- a/graf3d/eve/inc/TEveGeoShape.h
+++ b/graf3d/eve/inc/TEveGeoShape.h
@@ -41,8 +41,8 @@ public:
    TEveGeoShape(const char* name="TEveGeoShape", const char* title=0);
    virtual ~TEveGeoShape();
 
-   virtual Bool_t  CanEditMainColor()        const { return kTRUE; }
-   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+   virtual TObject* GetObject(const TEveException& /*eh*/="TEveElementList::GetObject ") const
+   { const TObject* obj = this; return const_cast<TObject*>(obj); }
 
    Color_t     GetColor()      const { return fColor; }
    Int_t       GetNSegments()  const { return fNSegments; }
@@ -90,9 +90,10 @@ public:
 
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
    virtual void UpdateProjection();
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    virtual void ComputeBBox();
-   virtual void Paint(Option_t* option = "");
+   virtual void Paint(Option_t* option = ""); 
 
    ClassDef(TEveGeoShapeProjected, 0);
 };
diff --git a/graf3d/eve/inc/TEveJetCone.h b/graf3d/eve/inc/TEveJetCone.h
index b42f07c..59d14b9 100644
--- a/graf3d/eve/inc/TEveJetCone.h
+++ b/graf3d/eve/inc/TEveJetCone.h
@@ -12,51 +12,89 @@
 #ifndef ROOT_TEveJetCone
 #define ROOT_TEveJetCone
 
-#include "TEveElement.h"
+#include "TEveShape.h"
 #include "TEveVector.h"
-#include "TAttBBox.h"
 
-class TEveJetCone : public TEveElementList,
-                    public TAttBBox
+
+//------------------------------------------------------------------------------
+// TEveJetCone
+//------------------------------------------------------------------------------
+
+class TEveJetCone : public TEveShape
 {
+   friend class TEveJetConeProjected;
    friend class TEveJetConeGL;
+   friend class TEveJetConeProjectedGL;
 
 private:
    TEveJetCone(const TEveJetCone&);            // Not implemented
    TEveJetCone& operator=(const TEveJetCone&); // Not implemented
 
-   void    FillTEveVectorFromEtaPhi( TEveVector &vec, const Float_t& eta, const Float_t& phi );
-   Float_t GetArcCosConeOpeningAngle( const TEveVector& axis, const TEveVector& contour );
-
 protected:
-   typedef std::vector<TEveVector>        vTEveVector_t;
-   typedef vTEveVector_t::iterator        vTEveVector_i;
-   typedef vTEveVector_t::const_iterator  vTEveVector_ci;
+   TEveVector      fApex;        // Apex of the cone.
+   TEveVector      fAxis;        // Axis of the cone.
+   TEveVector      fLimits;      // Border of Barrel/Cylinder to cut the cone.
+   Float_t         fThetaC;      // Transition theta
+   Float_t         fEta,  fPhi;
+   Float_t         fDEta, fDPhi;
+   Int_t           fNDiv;
 
-   TEveVector      fApex;             // Apex of the cone, initialized to ( 0., 0., 0. )
-   vTEveVector_t   fBasePoints;       // List of contour points
-   TEveVector      fCylinderBorder;   // Border of Barrel/Cylinder to cut the cone
-   Float_t         fThetaC;           // Angle between axis and  the edge of top-side of cylinder
+   TEveVector CalcEtaPhiVec(Float_t eta, Float_t phi) const;
+   TEveVector CalcBaseVec  (Float_t eta, Float_t phi) const;
+   TEveVector CalcBaseVec  (Float_t alpha) const;
+   Bool_t     IsInTransitionRegion() const;
 
 public:
    TEveJetCone(const Text_t* n="TEveJetCone", const Text_t* t="");
    virtual ~TEveJetCone() {}
 
-   void SetApex(const TEveVector& a)                      { fApex = a; }  // Sets apex of cone
-   void SetCylinder( const Float_t& r, const Float_t& z ) {
-      fCylinderBorder.Set( r, 0.f, z ); fThetaC = fCylinderBorder.Theta(); } // Set border cylinder
+   virtual void    ComputeBBox();
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
+
+   void  SetApex(const TEveVector& a)      { fApex = a; }
+   void  SetCylinder(Float_t r, Float_t z) { fLimits.Set(0, r, z); fThetaC = fLimits.Theta(); }
+   void  SetRadius  (Float_t r)            { fLimits.Set(r, 0, 0); fThetaC = 10; }
+
+   Int_t GetNDiv() const  { return fNDiv; }
+   void  SetNDiv(Int_t n) { fNDiv = TMath::Max(3, n); }
+
+   Int_t AddCone(Float_t eta, Float_t phi, Float_t cone_r, Float_t length=0);
+   Int_t AddEllipticCone(Float_t eta, Float_t phi, Float_t reta, Float_t rphi, Float_t length=0);
+
+   ClassDef(TEveJetCone, 0); // Short description.
+};
+
 
-   Int_t AddCone(Float_t eta, Float_t phi, Float_t coneRadius, Float_t height=-1);
-   Int_t AddEllipticCone(Float_t eta, Float_t phi, Float_t reta, Float_t rphi, Float_t height=-1);
+//------------------------------------------------------------------------------
+// TEveJetConeProjected
+//------------------------------------------------------------------------------
 
-   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+class TEveJetConeProjected : public TEveShape,
+                             public TEveProjected
+{
+   friend class TEveJetConeProjectedGL;
+
+private:
+   TEveJetConeProjected(const TEveJetConeProjected&);            // Not implemented
+   TEveJetConeProjected& operator=(const TEveJetConeProjected&); // Not implemented
+
+protected:
+   virtual void SetDepthLocal(Float_t d);
+
+public:
+   TEveJetConeProjected(const char* n="TEveJetConeProjected", const char* t="");
+   virtual ~TEveJetConeProjected();
 
    // For TAttBBox:
    virtual void ComputeBBox();
-   // If painting is needed:
-   virtual void Paint(Option_t* option="");
 
-   ClassDef(TEveJetCone, 0); // Short description.
+   // Projected:
+   virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
+   virtual void UpdateProjection();
+
+   virtual TEveElement* GetProjectedAsElement() { return this; }
+
+   ClassDef(TEveJetConeProjected, 0); // Projection of TEveJetCone.
 };
 
 #endif
diff --git a/graf3d/eve/inc/TEveJetConeGL.h b/graf3d/eve/inc/TEveJetConeGL.h
index 81053ba..d3ea912 100644
--- a/graf3d/eve/inc/TEveJetConeGL.h
+++ b/graf3d/eve/inc/TEveJetConeGL.h
@@ -13,11 +13,17 @@
 #define ROOT_TEveJetConeGL
 
 #include "TGLObject.h"
+#include "TEveVector.h"
 
 class TGLViewer;
 class TGLScene;
 
 class TEveJetCone;
+class TEveJetConeProjected;
+
+//------------------------------------------------------------------------------
+// TEveJetCone
+//------------------------------------------------------------------------------
 
 class TEveJetConeGL : public TGLObject
 {
@@ -26,7 +32,10 @@ private:
    TEveJetConeGL& operator=(const TEveJetConeGL&); // Not implemented
 
 protected:
-   TEveJetCone             *fM;  // Model object.
+   TEveJetCone                     *fC;  // Model object.
+   mutable std::vector<TEveVector>  fP;
+
+   virtual void CalculatePoints() const;
 
 public:
    TEveJetConeGL();
@@ -35,13 +44,43 @@ public:
    virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
    virtual void   SetBBox();
 
-   virtual void DirectDraw(TGLRnrCtx & rnrCtx) const;
-
-   // To support two-level selection
-   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
-   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+   virtual void   DLCacheClear();
+   virtual void   Draw(TGLRnrCtx& rnrCtx) const;
+   virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
 
    ClassDef(TEveJetConeGL, 0); // GL renderer class for TEveJetCone.
 };
 
+
+//------------------------------------------------------------------------------
+// TEveJetConeProjectedGL
+//------------------------------------------------------------------------------
+
+class TEveJetConeProjectedGL : public TEveJetConeGL
+{
+private:
+   TEveJetConeProjectedGL(const TEveJetConeProjectedGL&);            // Not implemented
+   TEveJetConeProjectedGL& operator=(const TEveJetConeProjectedGL&); // Not implemented
+
+protected:
+   TEveJetConeProjected  *fM;  // Model object.
+
+   virtual void CalculatePoints() const;
+
+   void RenderOutline() const;
+   void RenderPolygon() const;
+
+public:
+   TEveJetConeProjectedGL();
+   virtual ~TEveJetConeProjectedGL() {}
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void   Draw(TGLRnrCtx& rnrCtx) const;
+   virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
+
+   ClassDef(TEveJetConeProjectedGL, 0); // GL renderer class for TEveJetCone.
+};
+
 #endif
diff --git a/graf3d/eve/inc/TEveLine.h b/graf3d/eve/inc/TEveLine.h
index dd31d10..6e58404 100644
--- a/graf3d/eve/inc/TEveLine.h
+++ b/graf3d/eve/inc/TEveLine.h
@@ -95,6 +95,7 @@ public:
 
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void UpdateProjection();
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    ClassDef(TEveLineProjected, 0); // Projected replica of a TEveLine.
 };
diff --git a/graf3d/eve/inc/TEveManager.h b/graf3d/eve/inc/TEveManager.h
index e7251e5..6fa1a74 100644
--- a/graf3d/eve/inc/TEveManager.h
+++ b/graf3d/eve/inc/TEveManager.h
@@ -19,6 +19,7 @@
 #include "TVirtualPad.h"
 
 class TMap;
+class TExMap;
 class TMacro;
 class TFolder;
 class TCanvas;
@@ -111,7 +112,7 @@ private:
 
 protected:
    // Fine grained scene updates.
-   TEveElement::Set_t        fStampedElements;
+   TExMap                   *fStampedElements;
 
    // Selection / hihglight elements
    TEveSelection            *fSelection;
@@ -182,7 +183,7 @@ public:
    void ScenesChanged(TEveElement::List_t& scenes);
 
    // Fine grained updates via stamping.
-   void ElementStamped(TEveElement* element) { fStampedElements.insert(element); }
+   void ElementStamped(TEveElement* element);
 
    // These are more like TEveManager stuff.
    TGListTree*     GetListTree() const;
diff --git a/graf3d/eve/inc/TEvePathMark.h b/graf3d/eve/inc/TEvePathMark.h
new file mode 100644
index 0000000..37e6d38
--- /dev/null
+++ b/graf3d/eve/inc/TEvePathMark.h
@@ -0,0 +1,57 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEvePathMark
+#define ROOT_TEvePathMark
+
+#include <TEveVector.h>
+
+//==============================================================================
+// TEvePathMark
+//==============================================================================
+
+template <typename TT>
+class TEvePathMarkT
+{
+public:
+   enum EType_e { kReference, kDaughter, kDecay, kCluster2D };
+
+   EType_e         fType; // Mark-type.
+   TEveVectorT<TT> fV;    // Vertex.
+   TEveVectorT<TT> fP;    // Momentum.
+   TEveVectorT<TT> fE;    // Extra, meaning depends on fType.
+   TT              fTime; // Time.
+
+   TEvePathMarkT(EType_e type=kReference) :
+      fType(type), fV(), fP(), fE(), fTime(0) {}
+
+   TEvePathMarkT(EType_e type, const TEveVectorT<TT>& v, TT time=0) :
+      fType(type), fV(v), fP(), fE(), fTime(time) {}
+
+   TEvePathMarkT(EType_e type, const TEveVectorT<TT>& v, const TEveVectorT<TT>& p, TT time=0) :
+      fType(type), fV(v), fP(p), fE(), fTime(time) {}
+
+   TEvePathMarkT(EType_e type, const TEveVectorT<TT>& v, const TEveVectorT<TT>& p, const TEveVectorT<TT>& e, TT time=0) :
+      fType(type), fV(v), fP(p), fE(e), fTime(time) {}
+
+   const char* TypeName();
+
+   // Needed as ClassDefNV not available for 5.22
+   virtual ~TEvePathMarkT() {}
+
+   ClassDef(TEvePathMarkT, 1); // Template for a special point on a track: position/momentum reference, daughter creation or decay.
+};
+
+typedef TEvePathMarkT<Float_t>  TEvePathMark;
+typedef TEvePathMarkT<Float_t>  TEvePathMarkF;
+typedef TEvePathMarkT<Double_t> TEvePathMarkD;
+
+#endif
diff --git a/graf3d/eve/inc/TEvePointSet.h b/graf3d/eve/inc/TEvePointSet.h
index 38e35bd..9e00b3f 100644
--- a/graf3d/eve/inc/TEvePointSet.h
+++ b/graf3d/eve/inc/TEvePointSet.h
@@ -52,12 +52,13 @@ public:
    TEvePointSet(const TEvePointSet& e);
    virtual ~TEvePointSet();
 
+   virtual TObject* GetObject(const TEveException& /*eh*/="TEvePointSet::GetObject ") const
+   { const TObject* obj = this; return const_cast<TObject*>(obj); }
+
    virtual TEvePointSet* CloneElement() const { return new TEvePointSet(*this); }
 
    virtual void ClonePoints(const TEvePointSet& e);
 
-   virtual void ComputeBBox();
-
    void  Reset(Int_t n_points=0, Int_t n_int_ids=0);
    Int_t GrowFor(Int_t n_points);
 
@@ -182,9 +183,11 @@ public:
 
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
    virtual void UpdateProjection();
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    virtual void PointSelected(Int_t id);
 
+
    ClassDef(TEvePointSetProjected, 1); // Projected copy of a TEvePointSet.
 };
 
diff --git a/graf3d/eve/inc/TEvePolygonSetProjected.h b/graf3d/eve/inc/TEvePolygonSetProjected.h
index adc83cd..d416fbc 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjected.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjected.h
@@ -12,13 +12,12 @@
 #ifndef ROOT_TEvePolygonSetProjected
 #define ROOT_TEvePolygonSetProjected
 
+#include "TEveVector.h"
 #include "TEveShape.h"
 #include "TEveProjectionBases.h"
 
 class TBuffer3D;
 
-class TEveVector;
-
 class TEvePolygonSetProjected : public TEveShape,
                                 public TEveProjected
 {
@@ -77,6 +76,7 @@ public:
 
    virtual void    SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void    UpdateProjection();
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    void            ProjectBuffer3D();
 
diff --git a/graf3d/eve/inc/TEvePolygonSetProjectedGL.h b/graf3d/eve/inc/TEvePolygonSetProjectedGL.h
index 7053781..7c4cdd6 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjectedGL.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjectedGL.h
@@ -25,7 +25,7 @@ public:
    virtual void   Draw(TGLRnrCtx& rnrCtx) const;
    virtual void   DirectDraw(TGLRnrCtx& rnrCtx) const;
 
-   virtual void   DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const;
+   virtual void   DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl=-1) const;
 
    virtual Bool_t IgnoreSizeForOfInterest() const { return kTRUE; }
 
diff --git a/graf3d/eve/inc/TEveProjectionBases.h b/graf3d/eve/inc/TEveProjectionBases.h
index 4ff10e2..af1a9d2 100644
--- a/graf3d/eve/inc/TEveProjectionBases.h
+++ b/graf3d/eve/inc/TEveProjectionBases.h
@@ -56,13 +56,14 @@ public:
    ProjList_i   EndProjecteds()         { return  fProjectedList.end();   }
 
    virtual void AddProjected(TEveProjected* p)    { fProjectedList.push_back(p); }
-   virtual void RemoveProjected(TEveProjected* p) { fProjectedList.remove(p);    }
+   virtual void RemoveProjected(TEveProjected* p) { fProjectedList.remove(p);   }
 
    virtual void AddProjectedsToSet(std::set<TEveElement*>& set);
 
    virtual void PropagateVizParams(TEveElement* el=0);
    virtual void PropagateRenderState(Bool_t rnr_self, Bool_t rnr_children);
    virtual void PropagateMainColor(Color_t color, Color_t old_color);
+   virtual void PropagateMainTransparency(Char_t t, Char_t old_t);
 
    ClassDef(TEveProjectable, 0); // Abstract base class for classes that can be transformed with non-linear projections.
 };
@@ -88,7 +89,7 @@ protected:
    Float_t                fDepth;         // z coordinate
 
    void         SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox);
-   virtual void SetDepthLocal(Float_t d) = 0;
+   virtual void SetDepthLocal(Float_t d);
 
 public:
    TEveProjected();
@@ -98,12 +99,11 @@ public:
    TEveProjectable*       GetProjectable() const { return fProjectable; }
    Float_t                GetDepth()       const { return fDepth; }
 
-   TEveElement*           GetProjectableAsElement() const;
-
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void UnRefProjectable(TEveProjectable* assumed_parent);
 
-   virtual void UpdateProjection() = 0;
+   virtual void UpdateProjection() = 0;   
+   virtual TEveElement* GetProjectedAsElement();
 
    virtual void SetDepth(Float_t d);
 
diff --git a/graf3d/eve/inc/TEveProjectionManager.h b/graf3d/eve/inc/TEveProjectionManager.h
index 7bfd15b..61044bf 100644
--- a/graf3d/eve/inc/TEveProjectionManager.h
+++ b/graf3d/eve/inc/TEveProjectionManager.h
@@ -67,6 +67,7 @@ public:
                                        TEveElement* ext_list=0);
 
    virtual TEveElement* SubImportElements(TEveElement* el, TEveElement* proj_parent);
+   virtual Int_t        SubImportChildren(TEveElement* el, TEveElement* proj_parent);
 
    virtual void    ProjectChildren();
    virtual void    ProjectChildrenRecurse(TEveElement* el);
diff --git a/graf3d/eve/inc/TEveProjections.h b/graf3d/eve/inc/TEveProjections.h
index 4df31f0..7b3a73e 100644
--- a/graf3d/eve/inc/TEveProjections.h
+++ b/graf3d/eve/inc/TEveProjections.h
@@ -129,9 +129,12 @@ public:
    Float_t  GetMaxTrackStep() const    { return fMaxTrackStep; }
    void     SetMaxTrackStep(Float_t x) { fMaxTrackStep = TMath::Max(x, 1.0f); }
 
-   virtual   Bool_t    AcceptSegment(TEveVector&, TEveVector&, Float_t /*tolerance*/) const { return kTRUE; }
-   virtual   Int_t     SubSpaceId(const TEveVector&) const { return 0; }
-   virtual   void      SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
+   virtual Bool_t      HasSeveralSubSpaces() const { return kFALSE; }
+   virtual Bool_t      AcceptSegment(TEveVector&, TEveVector&, Float_t /*tolerance*/) const { return kTRUE; }
+   virtual Int_t       SubSpaceId(const TEveVector&) const { return 0; }
+   virtual Bool_t      IsOnSubSpaceBoundrary(const TEveVector&) const { return kFALSE; }
+   virtual void        BisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr=1e-10f);
+   virtual void        SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
 
    // utils to draw axis
    virtual Float_t     GetValForScreenPos(Int_t ax, Float_t value);
@@ -166,11 +169,13 @@ public:
    virtual void        SetCenter(TEveVector& center);
    virtual Float_t*    GetProjectedCenter() { return fProjectedCenter.Arr(); }
 
-   virtual   void      UpdateLimit();
+   virtual void        UpdateLimit();
 
-   virtual   Bool_t    AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance) const;
-   virtual   Int_t     SubSpaceId(const TEveVector& v) const;
-   virtual   void      SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
+   virtual Bool_t      HasSeveralSubSpaces() const { return kTRUE; }
+   virtual Bool_t      AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance) const;
+   virtual Int_t       SubSpaceId(const TEveVector& v) const;
+   virtual Bool_t      IsOnSubSpaceBoundrary(const TEveVector& v) const;
+   virtual void        SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
 
    ClassDef(TEveRhoZProjection, 0); // Rho/Z non-linear projection.
 };
diff --git a/graf3d/eve/inc/TEveQuadSet.h b/graf3d/eve/inc/TEveQuadSet.h
index f4cc772..9f9ee69 100644
--- a/graf3d/eve/inc/TEveQuadSet.h
+++ b/graf3d/eve/inc/TEveQuadSet.h
@@ -55,16 +55,13 @@ public:
 
 protected:
 
-   struct QFreeQuad_t     : public DigitBase_t      { Float_t fVertices[12]; };
+   struct QFreeQuad_t     : public DigitBase_t     { Float_t fVertices[12]; };
 
-   struct QOrigin_t       : public DigitBase_t      {
-     virtual ~QOrigin_t() {} ; Float_t fA, fB; };
+   struct QOrigin_t       : public DigitBase_t     { Float_t fA, fB; };
 
-   struct QRectFixDimC_t  : public QOrigin_t       {
-     virtual ~QRectFixDimC_t() {} };
+   struct QRectFixDimC_t  : public QOrigin_t       {};
 
-   struct QRectFixDim_t   : public QRectFixDimC_t  {
-     virtual ~QRectFixDim_t() {} ; Float_t fC; };
+   struct QRectFixDim_t   : public QRectFixDimC_t  { Float_t fC; };
 
    struct QRectFixC_t     : public QRectFixDimC_t  { Float_t fW, fH; };
 
@@ -81,8 +78,6 @@ protected:
    Float_t           fDefHeight;    // Breadth assigned to second coordinate (B)
    Float_t           fDefCoord;     // Default value for third coordinate    (C)
 
-   Bool_t            fAntiFlick;    // Make extra render pass to avoid flickering when quads are too small.
-
    static Int_t SizeofAtom(EQuadType_e qt);
 
 public:
@@ -96,12 +91,10 @@ public:
    Float_t GetDefWidth()  const { return fDefWidth;  }
    Float_t GetDefHeight() const { return fDefHeight; }
    Float_t GetDefCoord()  const { return fDefCoord;  }
-   Bool_t  GetAntiFlick() const { return fAntiFlick; }
 
    void SetDefWidth(Float_t v)  { fDefWidth  = v; }
    void SetDefHeight(Float_t v) { fDefHeight = v; }
    void SetDefCoord(Float_t v)  { fDefCoord  = v; }
-   void SetAntiFlick(Bool_t f)  { fAntiFlick = f; }
 
    // --------------------------------
 
diff --git a/graf3d/eve/inc/TEveQuadSetGL.h b/graf3d/eve/inc/TEveQuadSetGL.h
index 8b31c46..65e571c 100644
--- a/graf3d/eve/inc/TEveQuadSetGL.h
+++ b/graf3d/eve/inc/TEveQuadSetGL.h
@@ -12,18 +12,16 @@
 #ifndef ROOT_TEveQuadSetGL
 #define ROOT_TEveQuadSetGL
 
-#include "TGLObject.h"
+#include "TEveDigitSetGL.h"
 #include "TEveQuadSet.h"
 
-class TEveQuadSetGL : public TGLObject
+class TEveQuadSetGL : public TEveDigitSetGL
 {
    TEveQuadSetGL(const TEveQuadSetGL&);            // Not implemented
    TEveQuadSetGL& operator=(const TEveQuadSetGL&); // Not implemented
 
 protected:
-   TEveQuadSet* fM;
-
-   Bool_t SetupColor(const TEveDigitSet::DigitBase_t& q) const;
+   TEveQuadSet     *fM;
 
    void   RenderQuads(TGLRnrCtx & rnrCtx) const;
    void   RenderLines(TGLRnrCtx & rnrCtx) const;
@@ -34,14 +32,10 @@ public:
    virtual ~TEveQuadSetGL() {}
 
    virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
-   virtual void   SetBBox();
-   virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
+   virtual void   DirectDraw(TGLRnrCtx& rnrCtx) const;
 
    virtual Bool_t IgnoreSizeForOfInterest() const { return kTRUE; }
 
-   virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
-   virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
-
    ClassDef(TEveQuadSetGL, 0); // GL-renderer for TEveQuadSet class.
 };
 
diff --git a/graf3d/eve/inc/TEveScene.h b/graf3d/eve/inc/TEveScene.h
index a34a986..c2eaf19 100644
--- a/graf3d/eve/inc/TEveScene.h
+++ b/graf3d/eve/inc/TEveScene.h
@@ -17,6 +17,7 @@
 class TEvePad;
 class TGLScenePad;
 
+class TExMap;
 
 /******************************************************************************/
 // TEveScene
@@ -93,7 +94,7 @@ public:
 
    void DestroyElementRenderers(TEveElement* element);
 
-   void ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet);
+   void ProcessSceneChanges(Bool_t dropLogicals, TExMap* stampMap);
 
    ClassDef(TEveSceneList, 0); // List of Scenes providing common operations on TEveScene collections.
 };
diff --git a/graf3d/eve/inc/TEveSecondarySelectable.h b/graf3d/eve/inc/TEveSecondarySelectable.h
new file mode 100644
index 0000000..4875cbe
--- /dev/null
+++ b/graf3d/eve/inc/TEveSecondarySelectable.h
@@ -0,0 +1,57 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveSecondarySelectable
+#define ROOT_TEveSecondarySelectable
+
+#include "Rtypes.h"
+
+#include <set>
+
+class TGLSelectRecord;
+
+
+class TEveSecondarySelectable
+{
+private:
+   TEveSecondarySelectable(const TEveSecondarySelectable&);            // Not implemented
+   TEveSecondarySelectable& operator=(const TEveSecondarySelectable&); // Not implemented
+
+public:
+   typedef std::set<Int_t>                SelectionSet_t;
+   typedef SelectionSet_t::iterator       SelectionSet_i;
+   typedef SelectionSet_t::const_iterator SelectionSet_ci;
+
+
+protected:
+   Bool_t         fAlwaysSecSelect; // Always do secondary-selection in GL.
+
+   SelectionSet_t fSelectedSet;     // Selected indices.
+   SelectionSet_t fHighlightedSet;  // Highlighted indices.
+
+   void ProcessGLSelectionInternal(TGLSelectRecord& rec, SelectionSet_t& sset);
+
+public:
+   TEveSecondarySelectable();
+   virtual ~TEveSecondarySelectable() {}
+
+   Bool_t GetAlwaysSecSelect() const   { return fAlwaysSecSelect; }
+   void   SetAlwaysSecSelect(Bool_t f) { fAlwaysSecSelect = f; }
+
+   const SelectionSet_t& RefSelectedSet()    const { return fSelectedSet;    }
+   const SelectionSet_t& RefHighlightedSet() const { return fHighlightedSet; }
+
+   void   ProcessGLSelection(TGLSelectRecord& rec);
+
+   ClassDef(TEveSecondarySelectable, 0); // Semi-abstract interface for classes supporting secondary-selection.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveShape.h b/graf3d/eve/inc/TEveShape.h
index 0258459..d7e4971 100644
--- a/graf3d/eve/inc/TEveShape.h
+++ b/graf3d/eve/inc/TEveShape.h
@@ -30,8 +30,8 @@ private:
    TEveShape& operator=(const TEveShape&); // Not implemented
 
 public:
-   typedef std::vector<TEvePoint>           vPoint_t;
-   typedef std::vector<TEvePoint>::iterator vPoint_i;
+   typedef std::vector<TEveVector2>           vVector2_t;
+   typedef std::vector<TEveVector2>::iterator vVector2_i;
 
 protected:
    Color_t      fFillColor; // fill color of polygons
@@ -46,11 +46,8 @@ public:
    virtual ~TEveShape();
 
    // Rendering parameters.
-   virtual Bool_t  CanEditMainColor() const { return kTRUE; }
    virtual void    SetMainColor(Color_t color);
 
-   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
-
    virtual Color_t GetFillColor() const { return fFillColor; }
    virtual Color_t GetLineColor() const { return fLineColor; }
    virtual Float_t GetLineWidth() const { return fLineWidth;}
@@ -81,7 +78,7 @@ public:
 
    // ----------------------------------------------------------------
 
-   static Int_t FindConvexHull(const vPoint_t& pin, vPoint_t& pout, TEveElement* caller=0);
+   static Int_t FindConvexHull(const vVector2_t& pin, vVector2_t& pout, TEveElement* caller=0);
 
    ClassDef(TEveShape, 0); // Abstract base-class for 2D/3D shapes.
 };
diff --git a/graf3d/eve/inc/TEveStraightLineSet.h b/graf3d/eve/inc/TEveStraightLineSet.h
index d1c5f2a..f8102f4 100644
--- a/graf3d/eve/inc/TEveStraightLineSet.h
+++ b/graf3d/eve/inc/TEveStraightLineSet.h
@@ -46,12 +46,13 @@ private:
 public:
    struct Line_t
    {
+      Int_t          fId;
       Float_t        fV1[3];
       Float_t        fV2[3];
       TRef           fRef;
 
       Line_t(Float_t x1, Float_t y1, Float_t z1,
-             Float_t x2, Float_t y2, Float_t z2)
+             Float_t x2, Float_t y2, Float_t z2) : fId(-1), fRef()
       {
          fV1[0] = x1, fV1[1] = y1, fV1[2] = z1;
          fV2[0] = x2, fV2[1] = y2, fV2[2] = z2;
@@ -60,19 +61,22 @@ public:
 
    struct Marker_t
    {
-      Int_t        fLineID;
-      Float_t      fPos;
+      Float_t      fV[3];
+      Int_t        fLineId;
       TRef         fRef;
 
-      Marker_t(Int_t lineID, Float_t pos) : fLineID(lineID), fPos(pos) {};
+      Marker_t(Float_t x, Float_t y, Float_t z, Int_t line_id) : fLineId(line_id), fRef()
+      {
+         fV[0] = x, fV[1] = y, fV[2] = z;
+      }
    };
 
 protected:
    TEveChunkManager  fLinePlex;
    TEveChunkManager  fMarkerPlex;
 
-   Bool_t            fOwnLinesIds;    // Flag specifying if id-objects are owned by the TEveQuadSet
-   Bool_t            fOwnMarkersIds;  // Flag specifying if id-objects are owned by the TEveQuadSet
+   Bool_t            fOwnLinesIds;    // Flag specifying if id-objects are owned by the line-set
+   Bool_t            fOwnMarkersIds;  // Flag specifying if id-objects are owned by the line-set
 
    Bool_t            fRnrMarkers;
    Bool_t            fRnrLines;
@@ -87,8 +91,11 @@ public:
 
    virtual void SetLineColor(Color_t col) { SetMainColor(col); }
 
-   void AddLine(Float_t x1, Float_t y1, Float_t z1, Float_t x2, Float_t y2, Float_t z2);
-   void AddMarker(Int_t lineID, Float_t pos);
+   Line_t*   AddLine(Float_t x1, Float_t y1, Float_t z1, Float_t x2, Float_t y2, Float_t z2);
+   Line_t*   AddLine(const TEveVector& p1, const TEveVector& p2);
+   Marker_t* AddMarker(Float_t x, Float_t y, Float_t z, Int_t line_id=-1);
+   Marker_t* AddMarker(const TEveVector& p, Int_t line_id=-1);
+   Marker_t* AddMarker(Int_t line_id, Float_t pos);
 
    TEveChunkManager& GetLinePlex()   { return fLinePlex;   }
    TEveChunkManager& GetMarkerPlex() { return fMarkerPlex; }
@@ -131,6 +138,7 @@ public:
 
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void UpdateProjection();
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    ClassDef(TEveStraightLineSetProjected, 1); // Projected copy of a TEveStraightLineSet.
 };
diff --git a/graf3d/eve/inc/TEveText.h b/graf3d/eve/inc/TEveText.h
index ce277ab..b5f394c 100644
--- a/graf3d/eve/inc/TEveText.h
+++ b/graf3d/eve/inc/TEveText.h
@@ -69,7 +69,6 @@ public:
    Float_t  GetPolygonOffset(Int_t i) const { return fPolygonOffset[i]; }
    void     SetPolygonOffset(Float_t factor, Float_t units);
 
-   virtual Bool_t CanEditMainColor() const { return kTRUE; }
    virtual void   Paint(Option_t* option="");
    virtual void   ComputeBBox();
 
diff --git a/graf3d/eve/inc/TEveTrack.h b/graf3d/eve/inc/TEveTrack.h
index 00a68fd..cb72c1f 100644
--- a/graf3d/eve/inc/TEveTrack.h
+++ b/graf3d/eve/inc/TEveTrack.h
@@ -15,6 +15,7 @@
 #include <vector>
 
 #include "TEveVector.h"
+#include "TEvePathMark.h"
 #include "TEveElement.h"
 #include "TEveLine.h"
 
@@ -42,6 +43,7 @@ public:
    typedef vPathMark_t::iterator        vPathMark_i;
    typedef vPathMark_t::const_iterator  vPathMark_ci;
 
+   // Deprecated -- to be removed.
    enum EBreakProjectedTracks_e { kBPTDefault, kBPTAlways, kBPTNever };
 
 protected:
@@ -60,10 +62,6 @@ protected:
 
    TEveTrackPropagator *fPropagator;   // Pointer to shared render-style
 
-   UChar_t            fBreakProjectedTracks;  // How to handle breaks during projection - track specific settings.
-
-   static Bool_t      fgDefaultBreakProjectedTracks; // How to handle breaks during projection - global setting.
-
 public:
    TEveTrack();
    TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop=0);
@@ -72,6 +70,8 @@ public:
    TEveTrack(const TEveTrack& t);
    virtual ~TEveTrack();
 
+   virtual void ComputeBBox();
+
    virtual void SetStdTitle();
 
    virtual void SetTrackParams(const TEveTrack& t);
@@ -120,11 +120,11 @@ public:
 
    virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
-   Bool_t  ShouldBreakTrack() const;
-
-   UChar_t GetBreakProjectedTracks() const     { return fBreakProjectedTracks; }
-   void    SetBreakProjectedTracks(UChar_t bt) { fBreakProjectedTracks = bt;   }
-
+   // These functions are deprecated -- use TEveTrackPropagator functions.
+   // Will be removed after 5.28.
+   Bool_t        ShouldBreakTrack() const;
+   UChar_t       GetBreakProjectedTracks() const;
+   void          SetBreakProjectedTracks(UChar_t bt);
    static Bool_t GetDefaultBreakProjectedTracks();
    static void   SetDefaultBreakProjectedTracks(Bool_t bt);
 
diff --git a/graf3d/eve/inc/TEveTrackProjected.h b/graf3d/eve/inc/TEveTrackProjected.h
index 869e3d6..78ccfd0 100644
--- a/graf3d/eve/inc/TEveTrackProjected.h
+++ b/graf3d/eve/inc/TEveTrackProjected.h
@@ -42,8 +42,10 @@ public:
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
 
    virtual void UpdateProjection();
+   virtual TEveElement* GetProjectedAsElement() { return this; }
    virtual void MakeTrack(Bool_t recurse=kTRUE);
 
+
    void         PrintLineSegments();
 
    virtual void SecSelected(TEveTrack*); // marked as signal in TEveTrack
@@ -72,6 +74,7 @@ public:
 
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
    virtual void UpdateProjection()  {}
+   virtual TEveElement* GetProjectedAsElement() { return this; }
 
    virtual void SetDepth(Float_t d);
    virtual void SetDepth(Float_t d, TEveElement* el);
diff --git a/graf3d/eve/inc/TEveTrackPropagator.h b/graf3d/eve/inc/TEveTrackPropagator.h
index 8b2c7b9..6883ca9 100644
--- a/graf3d/eve/inc/TEveTrackPropagator.h
+++ b/graf3d/eve/inc/TEveTrackPropagator.h
@@ -13,6 +13,7 @@
 #define ROOT_TEveTrackPropagator
 
 #include "TEveVector.h"
+#include "TEvePathMark.h"
 #include "TEveUtil.h"
 #include "TEveElement.h"
 #include "TMarker.h"
@@ -156,6 +157,9 @@ public:
    };
 
    enum EStepper_e    { kHelix, kRungeKutta };
+
+   enum EProjTrackBreaking_e { kPTB_Break, kPTB_UseFirstPointPos, kPTB_UseLastPointPos };
+
 private:
    TEveTrackPropagator(const TEveTrackPropagator&);            // Not implemented
    TEveTrackPropagator& operator=(const TEveTrackPropagator&); // Not implemented
@@ -164,6 +168,7 @@ protected:
    EStepper_e               fStepper;
 
    TEveMagField*            fMagFieldObj;
+   Bool_t                   fOwnMagFiledObj;
 
    // Track extrapolation limits
    Float_t                  fMaxR;          // Max radius for track extrapolation
@@ -186,6 +191,11 @@ protected:
    TMarker                  fPMAtt;         // Marker attributes for rendering of path-marks.
    TMarker                  fFVAtt;         // Marker attributes for fits vertex.
 
+   // Handling of discontinuities in projections
+   UChar_t                  fProjTrackBreaking; // Handling of projected-track breaking.
+   Bool_t                   fRnrPTBMarkers;     // Render break-points on tracks.
+   TMarker                  fPTBAtt;            // Marker attributes for track break-points.
+
    // ----------------------------------------------------------------
 
    // Propagation, state of current track
@@ -214,7 +224,7 @@ protected:
 
 public:
    TEveTrackPropagator(const char* n="TEveTrackPropagator", const char* t="",
-                       TEveMagField* field=0);
+                       TEveMagField* field=0, Bool_t own_field=kTRUE);
    virtual ~TEveTrackPropagator();
 
    virtual void OnZeroRefCount();
@@ -238,7 +248,7 @@ public:
 
    void   SetMagField(Float_t bX, Float_t bY, Float_t bZ);
    void   SetMagField(Float_t b) { SetMagField(0.f, 0.f, b); }
-   void   SetMagFieldObj(TEveMagField * x);
+   void   SetMagFieldObj(TEveMagField* field, Bool_t own_field=kTRUE);
 
    void   SetMaxR(Float_t x);
    void   SetMaxZ(Float_t x);
@@ -257,7 +267,9 @@ public:
    void   SetFitReferences(Bool_t x);
    void   SetFitDecay(Bool_t x);
    void   SetFitCluster2Ds(Bool_t x);
-   void   SetRnrFV(Bool_t x) { fRnrFV = x; }
+   void   SetRnrFV(Bool_t x);
+   void   SetProjTrackBreaking(UChar_t x);
+   void   SetRnrPTBMarkers(Bool_t x);
 
    TEveVector GetMagField(Float_t x, Float_t y, Float_t z) { return fMagFieldObj->GetField(x, y, z); }
    void PrintMagField(Float_t x, Float_t y, Float_t z) const;
@@ -282,9 +294,13 @@ public:
    Bool_t  GetFitDecay()      const { return fFitDecay;      }
    Bool_t  GetFitCluster2Ds() const { return fFitCluster2Ds; }
    Bool_t  GetRnrFV()         const { return fRnrFV;         }
+   UChar_t GetProjTrackBreaking() const { return fProjTrackBreaking; }
+   Bool_t  GetRnrPTBMarkers()     const { return fRnrPTBMarkers; }
 
-   TMarker& RefPMAtt() { return fPMAtt; }
-   TMarker& RefFVAtt() { return fFVAtt; }
+   TMarker& RefPMAtt()  { return fPMAtt; }
+   TMarker& RefFVAtt()  { return fFVAtt; }
+   TMarker& RefPTBAtt() { return fPTBAtt; }
+   
 
    static Bool_t IsOutsideBounds(const TEveVector& point, Float_t maxRsqr, Float_t maxZ);
 
diff --git a/graf3d/eve/inc/TEveTrackPropagatorEditor.h b/graf3d/eve/inc/TEveTrackPropagatorEditor.h
index 582c6fa..d02f283 100644
--- a/graf3d/eve/inc/TEveTrackPropagatorEditor.h
+++ b/graf3d/eve/inc/TEveTrackPropagatorEditor.h
@@ -48,9 +48,9 @@ protected:
    TEveGValuator      *fMaxAng;
    TEveGValuator      *fDelta;
 
-   TGCheckButton      *fRnrFV;
-
+   TGCompositeFrame   *fRefsCont;
    TGCompositeFrame   *fPMFrame;
+
    TGButton           *fFitDaughters;
    TGButton           *fFitReferences;
    TGButton           *fFitDecay;
@@ -59,12 +59,15 @@ protected:
    TGButton           *fRnrReferences;
    TGButton           *fRnrDecay;
    TGButton           *fRnrCluster2Ds;
-
-   TGCompositeFrame   *fRefsCont;
+   TGButton           *fRnrFV;
 
    TAttMarkerEditor   *fPMAtt;
    TAttMarkerEditor   *fFVAtt;
 
+   TGComboBox         *fProjTrackBreaking;
+   TGButton           *fRnrPTBMarkers;
+   TAttMarkerEditor   *fPTBAtt;
+
 public:
    TEveTrackPropagatorSubEditor(const TGWindow* p);
    virtual ~TEveTrackPropagatorSubEditor() {}
@@ -84,6 +87,9 @@ public:
 
    void DoRnrFV();
 
+   void DoModePTB(UChar_t mode);
+   void DoRnrPTB();
+
    void CreateRefsContainer(TGVerticalFrame* p);
 
    ClassDef(TEveTrackPropagatorSubEditor, 0); // Sub-editor for TEveTrackPropagator class.
diff --git a/graf3d/eve/inc/TEveTrans.h b/graf3d/eve/inc/TEveTrans.h
index 686d009..0e884c7 100644
--- a/graf3d/eve/inc/TEveTrans.h
+++ b/graf3d/eve/inc/TEveTrans.h
@@ -12,10 +12,9 @@
 #ifndef ROOT_TEveTrans
 #define ROOT_TEveTrans
 
+#include "TEveVector.h"
 #include "TVector3.h"
 
-class TEveVector;
-
 class TGeoMatrix;
 class TGeoHMatrix;
 class TBuffer3D;
diff --git a/graf3d/eve/inc/TEveTriangleSet.h b/graf3d/eve/inc/TEveTriangleSet.h
index 5d05980..88c35e3 100644
--- a/graf3d/eve/inc/TEveTriangleSet.h
+++ b/graf3d/eve/inc/TEveTriangleSet.h
@@ -71,7 +71,7 @@ public:
    virtual void ComputeBBox();
    virtual void Paint(Option_t* option="");
 
-   void SetTransparency(UChar_t tr) { SetMainTransparency(tr); } // *MENU*
+   void SetTransparency(Char_t tr) { SetMainTransparency(tr); } // *MENU*
 
    static TEveTriangleSet* ReadTrivialFile(const char* file);
 
diff --git a/graf3d/eve/inc/TEveUtil.h b/graf3d/eve/inc/TEveUtil.h
index 2e07e6b..47c6070 100644
--- a/graf3d/eve/inc/TEveUtil.h
+++ b/graf3d/eve/inc/TEveUtil.h
@@ -52,7 +52,7 @@ public:
    // Color management
 
    static void     ColorFromIdx(Color_t ci, UChar_t col[4], Bool_t alpha=kTRUE);
-   static void     ColorFromIdx(Color_t ci, UChar_t col[4], UChar_t transparency);
+   static void     ColorFromIdx(Color_t ci, UChar_t col[4], Char_t transparency);
    static void     ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2,
                                 UChar_t col[4], Bool_t alpha=kTRUE);
    static Color_t* FindColorVar(TObject* obj, const char* varname);
diff --git a/graf3d/eve/inc/TEveVector.h b/graf3d/eve/inc/TEveVector.h
index a06a73b..c04c707 100644
--- a/graf3d/eve/inc/TEveVector.h
+++ b/graf3d/eve/inc/TEveVector.h
@@ -16,98 +16,111 @@
 
 class TVector3;
 
+
 //==============================================================================
-// TEveVector
+// TEveVectorT
 //==============================================================================
 
-class TEveVector
+template <typename TT>
+class TEveVectorT
 {
 public:
-   Float_t fX, fY, fZ; // Components of the vector.
+   TT fX, fY, fZ; // Components of the vector.
 
-   TEveVector() : fX(0), fY(0), fZ(0) {}
-   TEveVector(const Float_t* v)  : fX(v[0]), fY(v[1]), fZ(v[2]) {}
-   TEveVector(const Double_t* v) : fX(v[0]), fY(v[1]), fZ(v[2]) {}
-   TEveVector(Float_t x, Float_t y, Float_t z) : fX(x), fY(y), fZ(z) {}
-   virtual ~TEveVector() {}
+   TEveVectorT() : fX(0), fY(0), fZ(0) {}
+   template <typename OO>
+   TEveVectorT(const TEveVectorT<OO>& v) : fX(v.fX), fY(v.fY), fZ(v.fZ) {}
+   TEveVectorT(const Float_t*  v) : fX(v[0]), fY(v[1]), fZ(v[2]) {}
+   TEveVectorT(const Double_t* v) : fX(v[0]), fY(v[1]), fZ(v[2]) {}
+   TEveVectorT(TT x, TT y, TT  z) : fX(x), fY(y), fZ(z) {}
 
    void Dump() const;
 
-   operator const Float_t*() const { return &fX; }
-   operator       Float_t*()       { return &fX; }
-
-   TEveVector& operator *=(Float_t s)           { fX *= s;    fY *= s;    fZ *= s;    return *this; }
-   TEveVector& operator +=(const TEveVector& v) { fX += v.fX; fY += v.fY; fZ += v.fZ; return *this; }
-   TEveVector& operator -=(const TEveVector& v) { fX -= v.fX; fY -= v.fY; fZ -= v.fZ; return *this; }
+   operator const TT*() const { return &fX; }
+   operator       TT*()       { return &fX; }
 
-   TEveVector operator + (const TEveVector &) const;
-   TEveVector operator - (const TEveVector &) const;
-   TEveVector operator * (Float_t a) const;
+   TT  operator [] (Int_t idx) const { return (&fX)[idx]; }
+   TT& operator [] (Int_t idx)       { return (&fX)[idx]; }
 
-   Float_t& operator [] (Int_t indx);
-   Float_t  operator [] (Int_t indx) const;
+   const TT* Arr() const { return &fX; }
+   TT* Arr()             { return &fX; }
 
-   const Float_t* Arr() const { return &fX; }
-   Float_t* Arr()       { return &fX; }
+   TEveVectorT& operator*=(TT s)                 { fX *= s;    fY *= s;    fZ *= s;    return *this; }
+   TEveVectorT& operator+=(const TEveVectorT& v) { fX += v.fX; fY += v.fY; fZ += v.fZ; return *this; }
+   TEveVectorT& operator-=(const TEveVectorT& v) { fX -= v.fX; fY -= v.fY; fZ -= v.fZ; return *this; }
 
    void Set(const Float_t*  v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
    void Set(const Double_t* v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
-   void Set(Float_t  x, Float_t  y, Float_t  z) { fX = x; fY = y; fZ = z; }
-   void Set(Double_t x, Double_t y, Double_t z) { fX = x; fY = y; fZ = z; }
-   void Set(const TEveVector& v) { fX = v.fX;  fY = v.fY;  fZ = v.fZ;  }
+   void Set(TT x, TT  y, TT z) { fX = x; fY = y; fZ = z; }
    void Set(const TVector3& v);
 
+   template <typename OO>
+   void Set(const TEveVectorT<OO>& v) { fX = v.fX;  fY = v.fY;  fZ = v.fZ; }
+
    void NegateXYZ() { fX = - fX; fY = -fY; fZ = -fZ; }
-   void Normalize(Float_t length=1);
+   TT   Normalize(TT length=1);
+
+   TT   Phi()      const;
+   TT   Theta()    const;
+   TT   CosTheta() const;
+   TT   Eta()      const;
 
-   Float_t Phi()      const;
-   Float_t Theta()    const;
-   Float_t CosTheta() const;
-   Float_t Eta()      const;
+   TT   Mag2()  const { return fX*fX + fY*fY + fZ*fZ; }
+   TT   Mag()   const { return TMath::Sqrt(Mag2());   }
 
-   Float_t Mag()  const { return TMath::Sqrt(fX*fX + fY*fY + fZ*fZ);}
-   Float_t Mag2() const { return fX*fX + fY*fY + fZ*fZ;}
+   TT   Perp2() const { return fX*fX + fY*fY;        }
+   TT   Perp()  const { return TMath::Sqrt(Perp2()); }
+   TT   R()     const { return Perp();               }
 
-   Float_t Perp()  const { return TMath::Sqrt(fX*fX + fY*fY);}
-   Float_t Perp2() const { return fX*fX + fY*fY;}
-   Float_t R()     const { return Perp(); }
+   TT   Distance(const TEveVectorT& v) const;
+   TT   SquareDistance(const TEveVectorT& v) const;
 
-   Float_t Distance(const TEveVector& v) const;
-   Float_t SquareDistance(const TEveVector& v) const;
+   TT   Dot(const TEveVectorT& a) const;
 
-   Float_t    Dot(const TEveVector& a) const;
-   TEveVector Cross(const TEveVector& a) const;
+   TEveVectorT  Cross(const TEveVectorT& a) const;
 
-   TEveVector& Sub(const TEveVector& p, const TEveVector& q);
+   TEveVectorT& Sub(const TEveVectorT& a, const TEveVectorT& b);
+   TEveVectorT& Mult(const TEveVectorT& a, TT af);
 
-   TEveVector& Mult(const TEveVector& a, Float_t af);
+   TEveVectorT  Orthogonal() const;
+   void         OrthoNormBase(TEveVectorT& a, TEveVectorT& b) const;
 
-   TEveVector Orthogonal() const;
-   void       OrthoNormBase(TEveVector& a, TEveVector& b) const;
+   Bool_t       IsZero() const { return fX == 0 && fY == 0 && fZ == 0; }
 
-   ClassDef(TEveVector, 1); // Float three-vector; a minimal Float_t copy of TVector3 used to represent points and momenta (also used in VSD).
+   // Needed as ClassDefNV not available for 5.22
+   virtual ~TEveVectorT() {}
+
+   ClassDef(TEveVectorT, 2); // A three-vector template without TObject inheritance and virtual functions.
 };
 
+typedef TEveVectorT<Float_t>  TEveVector;
+typedef TEveVectorT<Float_t>  TEveVectorF;
+typedef TEveVectorT<Double_t> TEveVectorD;
+
 //______________________________________________________________________________
-inline Float_t TEveVector::Phi() const
+template<typename TT>
+inline TT TEveVectorT<TT>::Phi() const
 {
-   return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX);
+   return fX == 0 && fY == 0 ? 0 : TMath::ATan2(fY, fX);
 }
 
 //______________________________________________________________________________
-inline Float_t TEveVector::Theta() const
+template<typename TT> 
+inline TT TEveVectorT<TT>::Theta() const
 {
-   return fX == 0.0 && fY == 0.0 && fZ == 0.0 ? 0.0 : TMath::ATan2(Perp(), fZ);
+   return fX == 0 && fY == 0 && fZ == 0 ? 0 : TMath::ATan2(Perp(), fZ);
 }
 
 //______________________________________________________________________________
-inline Float_t TEveVector::CosTheta() const
+template<typename TT>
+inline TT TEveVectorT<TT>::CosTheta() const
 {
-   Float_t ptot = Mag(); return ptot == 0.0 ? 1.0 : fZ/ptot;
+   Float_t ptot = Mag(); return ptot == 0 ? 1 : fZ/ptot;
 }
 
 //______________________________________________________________________________
-inline Float_t TEveVector::Distance( const TEveVector& b) const
+template<typename TT>
+inline TT TEveVectorT<TT>::Distance(const TEveVectorT& b) const
 {
    return TMath::Sqrt((fX - b.fX)*(fX - b.fX) +
                       (fY - b.fY)*(fY - b.fY) +
@@ -115,7 +128,8 @@ inline Float_t TEveVector::Distance( const TEveVector& b) const
 }
 
 //______________________________________________________________________________
-inline Float_t TEveVector::SquareDistance(const TEveVector& b) const
+template<typename TT>
+inline TT TEveVectorT<TT>::SquareDistance(const TEveVectorT& b) const
 {
    return ((fX - b.fX) * (fX - b.fX) +
            (fY - b.fY) * (fY - b.fY) +
@@ -123,15 +137,17 @@ inline Float_t TEveVector::SquareDistance(const TEveVector& b) const
 }
 
 //______________________________________________________________________________
-inline Float_t TEveVector::Dot(const TEveVector& a) const
+template<typename TT>
+inline TT TEveVectorT<TT>::Dot(const TEveVectorT& a) const
 {
    return a.fX*fX + a.fY*fY + a.fZ*fZ;
 }
 
 //______________________________________________________________________________
-inline TEveVector TEveVector::Cross(const TEveVector& a) const
+template<typename TT>
+inline TEveVectorT<TT> TEveVectorT<TT>::Cross(const TEveVectorT<TT>& a) const
 {
-   TEveVector r;
+   TEveVectorT<TT> r;
    r.fX = fY * a.fZ - fZ * a.fY;
    r.fY = fZ * a.fX - fX * a.fZ;
    r.fZ = fX * a.fY - fY * a.fX;
@@ -139,16 +155,18 @@ inline TEveVector TEveVector::Cross(const TEveVector& a) const
 }
 
 //______________________________________________________________________________
-inline TEveVector& TEveVector::Sub(const TEveVector& p, const TEveVector& q)
+template<typename TT>
+inline TEveVectorT<TT>& TEveVectorT<TT>::Sub(const TEveVectorT<TT>& a, const TEveVectorT<TT>& b)
 {
-   fX = p.fX - q.fX;
-   fY = p.fY - q.fY;
-   fZ = p.fZ - q.fZ;
+   fX = a.fX - b.fX;
+   fY = a.fY - b.fY;
+   fZ = a.fZ - b.fZ;
    return *this;
 }
 
 //______________________________________________________________________________
-inline TEveVector& TEveVector::Mult(const TEveVector& a, Float_t af)
+template<typename TT>
+inline TEveVectorT<TT>& TEveVectorT<TT>::Mult(const TEveVectorT<TT>& a, TT af)
 {
    fX = a.fX * af;
    fY = a.fY * af;
@@ -157,146 +175,216 @@ inline TEveVector& TEveVector::Mult(const TEveVector& a, Float_t af)
 }
 
 //______________________________________________________________________________
-inline Float_t& TEveVector::operator [] (Int_t idx)
+template<typename TT>
+inline TEveVectorT<TT> operator+(const TEveVectorT<TT>& a, const TEveVectorT<TT>& b)
+{
+   TEveVectorT<TT> r(a);
+   return r += b;
+}
+
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVectorT<TT> operator-(const TEveVectorT<TT>& a, const TEveVectorT<TT>& b)
+{
+   TEveVectorT<TT> r(a);
+   return r -= b;
+}
+
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVectorT<TT> operator*(const TEveVectorT<TT>& a, TT b)
 {
-   return (&fX)[idx];
+   TEveVectorT<TT> r(a);
+   return r *= b;
 }
 
 //______________________________________________________________________________
-inline Float_t TEveVector::operator [] (Int_t idx) const
+template<typename TT>
+inline TEveVectorT<TT> operator*(TT b, const TEveVectorT<TT>& a)
 {
-   return (&fX)[idx];
+   TEveVectorT<TT> r(a);
+   return r *= b;
 }
 
 
 //==============================================================================
-// TEveVector4
+// TEveVector4T
 //==============================================================================
 
-class TEveVector4 : public TEveVector
+template <typename TT>
+class TEveVector4T : public TEveVectorT<TT>
 {
-public:
-   Float_t fT;
+   typedef TEveVectorT<TT> TP;
 
-   TEveVector4()                    : TEveVector(),  fT(0) {}
-   TEveVector4(const TEveVector& v) : TEveVector(v), fT(0) {}
-   TEveVector4(Float_t x, Float_t y, Float_t z, Float_t t=0) :
-      TEveVector(x, y, z), fT(t) {}
-   virtual ~TEveVector4() {}
+public:
+   TT fT;
+
+   TEveVector4T() : TP(),  fT(0) {}
+   template <typename OO>
+   TEveVector4T(const TEveVectorT<OO>& v) : TP(v.fX, v.fY, v.fZ), fT(0) {}
+   template <typename OO>
+   TEveVector4T(const TEveVectorT<OO>& v, Float_t t) : TP(v.fX, v.fY, v.fZ), fT(t) {}
+   template <typename OO>
+   TEveVector4T(const TEveVector4T<OO>& v) : TP(v.fX, v.fY, v.fZ), fT(v.fT) {}
+   TEveVector4T(const Float_t*  v) : TP(v), fT(v[3]) {}
+   TEveVector4T(const Double_t* v) : TP(v), fT(v[3]) {}
+   TEveVector4T(TT x, TT y, TT z, TT t=0) : TP(x, y, z), fT(t) {}
 
    void Dump() const;
 
-   TEveVector4 operator + (const TEveVector4 & b) const
-   { return TEveVector4(fX + b.fX, fY + b.fY, fZ + b.fZ, fT + b.fT); }
+   TEveVector4T& operator*=(TT s)                  { TP::operator*=(s); fT *= s;    return *this; }
+   TEveVector4T& operator+=(const TEveVector4T& v) { TP::operator+=(v); fT += v.fT; return *this; }
+   TEveVector4T& operator-=(const TEveVector4T& v) { TP::operator-=(v); fT -= v.fT; return *this; }
 
-   TEveVector4 operator - (const TEveVector4 & b) const
-   { return TEveVector4(fX - b.fX, fY - b.fY, fZ - b.fZ, fT - b.fT); }
+   using TP::operator+=;
+   using TP::operator-=;
 
-   TEveVector4 operator * (Float_t a) const
-   { return TEveVector4(a*fX, a*fY, a*fZ, a*fT); }
+   // Needed as ClassDefNV not available for 5.22
+   virtual ~TEveVector4T() {}
 
-   TEveVector4& operator += (const TEveVector4 & b)
-   { fX += b.fX; fY += b.fY; fZ += b.fZ; fT += b.fT; return *this; }
-
-   ClassDef(TEveVector4, 1); // Float four-vector.
+   ClassDef(TEveVector4T, 1); // A four-vector template without TObject inheritance and virtual functions.
 };
 
+typedef TEveVector4T<Float_t>  TEveVector4;
+typedef TEveVector4T<Float_t>  TEveVector4F;
+typedef TEveVector4T<Double_t> TEveVector4D;
+
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVector4T<TT> operator+(const TEveVector4T<TT>& a, const TEveVector4T<TT>& b)
+{
+   return TEveVector4T<TT>(a.fX + b.fX, a.fY + b.fY, a.fZ + b.fZ, a.fT + b.fT);
+}
+
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVector4T<TT> operator-(const TEveVector4T<TT>& a, const TEveVector4T<TT>& b)
+{
+   return TEveVector4T<TT>(a.fX - b.fX, a.fY - b.fY, a.fZ - b.fZ, a.fT - b.fT);
+}
+
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVector4T<TT> operator*(const TEveVector4T<TT>& a, TT b)
+{
+   return TEveVector4T<TT>(a.fX*b, a.fY*b, a.fZ*b, a.fT*b);
+}
+
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVector4T<TT> operator*(TT b, const TEveVector4T<TT>& a)
+{
+   return TEveVector4T<TT>(a.fX*b, a.fY*b, a.fZ*b, a.fT*b);
+}
+
 
 //==============================================================================
-// TEvePoint
+// TEveVector2T
 //==============================================================================
 
-class TEvePoint
+template <typename TT>
+class TEveVector2T
 {
 public:
-   Float_t fX, fY; // Components of the point.
+   TT fX, fY; // Components of the point.
 
-   TEvePoint() : fX(0), fY(0) {}
-   TEvePoint(const Float_t* v)  : fX(v[0]), fY(v[1]) {}
-   TEvePoint(const Double_t* v) : fX(v[0]), fY(v[1]) {}
-   TEvePoint(Float_t x, Float_t y) : fX(x), fY(y)    {}
-   virtual ~TEvePoint() {}
+   TEveVector2T() : fX(0), fY(0) {}
+   template <typename OO>
+   TEveVector2T(const TEveVector2T<OO>& v) : fX(v.fX), fY(v.fY) {}
+   TEveVector2T(const Float_t* v)  : fX(v[0]), fY(v[1]) {}
+   TEveVector2T(const Double_t* v) : fX(v[0]), fY(v[1]) {}
+   TEveVector2T(TT x, TT y) : fX(x), fY(y)    {}
 
    void Dump() const;
 
-   operator const Float_t*() const { return &fX; }
-   operator       Float_t*()       { return &fX; }
-
-   TEvePoint& operator *=(Float_t s)          { fX *= s;    fY *= s;    return *this; }
-   TEvePoint& operator +=(const TEvePoint& v) { fX += v.fX; fY += v.fY; return *this; }
-   TEvePoint& operator -=(const TEvePoint& v) { fX -= v.fX; fY -= v.fY; return *this; }
+   operator const TT*() const { return &fX; }
+   operator       TT*()       { return &fX; }
 
-   TEvePoint operator + (const TEvePoint &) const;
-   TEvePoint operator - (const TEvePoint &) const;
-   TEvePoint operator * (Float_t a) const;
+   TEveVector2T& operator*=(TT s)                  { fX *= s;    fY *= s;    return *this; }
+   TEveVector2T& operator+=(const TEveVector2T& v) { fX += v.fX; fY += v.fY; return *this; }
+   TEveVector2T& operator-=(const TEveVector2T& v) { fX -= v.fX; fY -= v.fY; return *this; }
 
-   Float_t& operator [] (Int_t indx);
-   Float_t  operator [] (Int_t indx) const;
+   TT& operator[](Int_t idx)       { return (&fX)[idx]; }
+   TT  operator[](Int_t idx) const { return (&fX)[idx]; }
 
-   const Float_t* Arr() const { return &fX; }
-   Float_t* Arr()       { return &fX; }
+   const TT* Arr() const { return &fX; }
+   TT* Arr()             { return &fX; }
 
    void Set(const Float_t*  v) { fX = v[0]; fY = v[1]; }
    void Set(const Double_t* v) { fX = v[0]; fY = v[1]; }
-   void Set(Float_t  x, Float_t  y) { fX = x; fY = y; }
-   void Set(Double_t x, Double_t y) { fX = x; fY = y; }
-   void Set(const TEvePoint& v) { fX = v.fX;  fY = v.fY;  }
+   void Set(TT x, TT y) { fX = x; fY = y; }
+
+   template <typename OO>
+   void Set(const TEveVector2T<OO>& v) { fX = v.fX; fY = v.fY; }
 
    void NegateXY() { fX = - fX; fY = -fY; }
-   void Normalize(Float_t length=1);
+   void Normalize(TT length=1);
+
+   TT Phi()  const;
 
-   Float_t Phi()  const;
+   TT Mag2() const { return fX*fX + fY*fY;}
+   TT Mag()  const { return TMath::Sqrt(Mag2());}
 
-   Float_t Mag()  const { return TMath::Sqrt(fX*fX + fY*fY);}
-   Float_t Mag2() const { return fX*fX + fY*fY;}
+   TT Distance(const TEveVector2T& v) const;
+   TT SquareDistance(const TEveVector2T& v) const;
 
-   Float_t Distance(const TEvePoint& v) const;
-   Float_t SquareDistance(const TEvePoint& v) const;
+   TT Dot(const TEveVector2T& a) const;
+   TT Cross(const TEveVector2T& a) const;
 
-   Float_t    Dot(const TEvePoint& a) const;
-   Float_t    Cross(const TEvePoint& a) const;
+   TEveVector2T& Sub(const TEveVector2T& p, const TEveVector2T& q);
 
-   TEvePoint& Sub(const TEvePoint& p, const TEvePoint& q);
+   TEveVector2T& Mult(const TEveVector2T& a, TT af);
 
-   TEvePoint& Mult(const TEvePoint& a, Float_t af);
+   // Needed as ClassDefNV not available for 5.22
+   virtual ~TEveVector2T() {}
 
-   ClassDef(TEvePoint, 1); // Float two-vector.
+   ClassDef(TEveVector2T, 1); // // A two-vector template without TObject inheritance and virtual functions.
 };
 
+typedef TEveVector2T<Float_t>  TEveVector2;
+typedef TEveVector2T<Float_t>  TEveVector2F;
+typedef TEveVector2T<Double_t> TEveVector2D;
+
 //______________________________________________________________________________
-inline Float_t TEvePoint::Phi() const
+template<typename TT>
+inline TT TEveVector2T<TT>::Phi() const
 {
    return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX);
 }
 
 //______________________________________________________________________________
-inline Float_t TEvePoint::Distance( const TEvePoint& b) const
+template<typename TT>
+inline TT TEveVector2T<TT>::Distance( const TEveVector2T<TT>& b) const
 {
    return TMath::Sqrt((fX - b.fX)*(fX - b.fX) +
                       (fY - b.fY)*(fY - b.fY));
 }
 
 //______________________________________________________________________________
-inline Float_t TEvePoint::SquareDistance(const TEvePoint& b) const
+template<typename TT>
+inline TT TEveVector2T<TT>::SquareDistance(const TEveVector2T<TT>& b) const
 {
    return ((fX - b.fX) * (fX - b.fX) +
            (fY - b.fY) * (fY - b.fY));
 }
 
 //______________________________________________________________________________
-inline Float_t TEvePoint::Dot(const TEvePoint& a) const
+template<typename TT>
+inline TT TEveVector2T<TT>::Dot(const TEveVector2T<TT>& a) const
 {
    return a.fX*fX + a.fY*fY;
 }
 
 //______________________________________________________________________________
-inline Float_t TEvePoint::Cross(const TEvePoint& a) const
+template<typename TT>
+inline TT TEveVector2T<TT>::Cross(const TEveVector2T<TT>& a) const
 {
    return fX * a.fY - fY * a.fX;
 }
 
 //______________________________________________________________________________
-inline TEvePoint& TEvePoint::Sub(const TEvePoint& p, const TEvePoint& q)
+template<typename TT>
+inline TEveVector2T<TT>& TEveVector2T<TT>::Sub(const TEveVector2T<TT>& p, const TEveVector2T<TT>& q)
 {
    fX = p.fX - q.fX;
    fY = p.fY - q.fY;
@@ -304,7 +392,8 @@ inline TEvePoint& TEvePoint::Sub(const TEvePoint& p, const TEvePoint& q)
 }
 
 //______________________________________________________________________________
-inline TEvePoint& TEvePoint::Mult(const TEvePoint& a, Float_t af)
+template<typename TT>
+inline TEveVector2T<TT>& TEveVector2T<TT>::Mult(const TEveVector2T<TT>& a, TT af)
 {
    fX = a.fX * af;
    fY = a.fY * af;
@@ -312,50 +401,35 @@ inline TEvePoint& TEvePoint::Mult(const TEvePoint& a, Float_t af)
 }
 
 //______________________________________________________________________________
-inline Float_t& TEvePoint::operator [] (Int_t idx)
+template<typename TT>
+inline TEveVector2T<TT> operator+(const TEveVector2T<TT>& a, const TEveVector2T<TT>& b)
 {
-   return (&fX)[idx];
+   TEveVector2T<TT> r(a);
+   return r += b;
 }
 
 //______________________________________________________________________________
-inline Float_t TEvePoint::operator [] (Int_t idx) const
+template<typename TT>
+inline TEveVector2T<TT> operator-(const TEveVector2T<TT>& a, const TEveVector2T<TT>& b)
 {
-   return (&fX)[idx];
+   TEveVector2T<TT> r(a);
+   return r -= b;
 }
 
-
-//==============================================================================
-// TEvePathMark
-//==============================================================================
-
-class TEvePathMark
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVector2T<TT> operator*(const TEveVector2T<TT>& a, TT b)
 {
-public:
-   enum EType_e   { kReference, kDaughter, kDecay, kCluster2D };
-
-   EType_e     fType; // Mark-type.
-   TEveVector  fV;    // Vertex.
-   TEveVector  fP;    // Momentum.
-   TEveVector  fE;    // Extra, meaning depends on fType.
-   Float_t     fTime; // Time.
-
-   TEvePathMark(EType_e type=kReference) :
-      fType(type), fV(), fP(), fE(), fTime(0) {}
-
-   TEvePathMark(EType_e type, const TEveVector& v, Float_t time=0) :
-      fType(type), fV(v), fP(), fE(), fTime(time) {}
-
-   TEvePathMark(EType_e type, const TEveVector& v, const TEveVector& p, Float_t time=0) :
-      fType(type), fV(v), fP(p), fE(), fTime(time) {}
-
-   TEvePathMark(EType_e type, const TEveVector& v, const TEveVector& p, const TEveVector& e, Float_t time=0) :
-      fType(type), fV(v), fP(p), fE(e), fTime(time) {}
-
-   virtual ~TEvePathMark() {}
-
-   const char* TypeName();
+   TEveVector2T<TT> r(a);
+   return r *= b;
+}
 
-   ClassDef(TEvePathMark, 1); // Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).
-};
+//______________________________________________________________________________
+template<typename TT>
+inline TEveVector2T<TT> operator*(TT b, const TEveVector2T<TT>& a)
+{
+   TEveVector2T<TT> r(a);
+   return r *= b;
+}
 
 #endif
diff --git a/graf3d/eve/inc/TEveViewer.h b/graf3d/eve/inc/TEveViewer.h
index 336bdfa..c86509b 100644
--- a/graf3d/eve/inc/TEveViewer.h
+++ b/graf3d/eve/inc/TEveViewer.h
@@ -20,7 +20,6 @@ class TGedEditor;
 class TGLViewer;
 class TGLSAViewer;
 class TGLEmbeddedViewer;
-class TGLPhysicalShape;
 
 class TEveScene;
 
@@ -89,9 +88,11 @@ protected:
    Float_t       fBrightness;
    Bool_t        fUseLightColorSet;
 
+   void HandleTooltip();
+
 public:
    TEveViewerList(const char* n="TEveViewerList", const char* t="");
-   virtual ~TEveViewerList() {}
+   virtual ~TEveViewerList();
 
    virtual void AddElement(TEveElement* el);
    virtual void RemoveElementLocal(TEveElement* el);
@@ -100,6 +101,7 @@ public:
    // --------------------------------
 
    virtual void Connect();
+   virtual void Disconnect();
 
    void RepaintChangedViewers(Bool_t resetCameras, Bool_t dropLogicals);
    void RepaintAllViewers(Bool_t resetCameras, Bool_t dropLogicals);
@@ -109,7 +111,9 @@ public:
 
    // --------------------------------
 
-   void OnMouseOver(TGLPhysicalShape* shape, UInt_t state);
+   void OnMouseOver(TObject* obj, UInt_t state);
+   void OnReMouseOver(TObject* obj, UInt_t state);
+   void OnUnMouseOver(TObject* obj, UInt_t state);
    void OnClicked(TObject *obj, UInt_t button, UInt_t state);
    void OnReClicked(TObject *obj, UInt_t button, UInt_t state);
    void OnUnClicked(TObject *obj, UInt_t button, UInt_t state);
diff --git a/graf3d/eve/src/TEveArrow.cxx b/graf3d/eve/src/TEveArrow.cxx
index 8a8da9f..57dd224 100644
--- a/graf3d/eve/src/TEveArrow.cxx
+++ b/graf3d/eve/src/TEveArrow.cxx
@@ -33,6 +33,9 @@ TEveArrow::TEveArrow(Float_t xVec, Float_t yVec, Float_t zVec,
    // Constructor.
    // Org - starting point.
    // Vec - vector from start to end of the arrow.
+
+   fCanEditMainColor        = kTRUE;
+   fCanEditMainTransparency = kTRUE;
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveBox.cxx b/graf3d/eve/src/TEveBox.cxx
index d0443a4..ab1835d 100644
--- a/graf3d/eve/src/TEveBox.cxx
+++ b/graf3d/eve/src/TEveBox.cxx
@@ -98,11 +98,16 @@ TClass* TEveBox::ProjectedClass(const TEveProjection*) const
 // TEveBoxProjected
 //==============================================================================
 
+//______________________________________________________________________________
+//
+// Projection of TEveBox.
+
 ClassImp(TEveBoxProjected);
 
 //______________________________________________________________________________
 TEveBoxProjected::TEveBoxProjected(const char* n, const char* t) :
-   TEveShape(n, t)
+   TEveShape(n, t),
+   fBreakIdx(0)
 {
    // Constructor.
 }
@@ -119,17 +124,18 @@ void TEveBoxProjected::ComputeBBox()
    // Compute bounding-box, virtual from TAttBBox.
 
    BBoxInit();
-   for (vPoint_i i = fPoints.begin(); i != fPoints.end(); ++i)
+   for (vVector2_i i = fPoints.begin(); i != fPoints.end(); ++i)
    {
       BBoxCheckPoint(i->fX, i->fY, fDepth);
    }
 }
 
 //______________________________________________________________________________
-void TEveBoxProjected::SetDepthLocal(Float_t)
+void TEveBoxProjected::SetDepthLocal(Float_t d)
 {
    // This is virtual method from base-class TEveProjected.
-   // Does nothing, must be implemented as it is abstract.
+
+   SetDepthCommon(d, this, fBBox);
 }
 
 //______________________________________________________________________________
@@ -159,7 +165,7 @@ void TEveBoxProjected::UpdateProjection()
    fDebugPoints.clear();
 
    // Project points in global CS, remove overlaps.
-   vPoint_t pp[2];
+   vVector2_t pp[2];
    {
       TEveProjection *projection = fManager->GetProjection();
       TEveTrans      *trans      = box->PtrMainTrans(kFALSE);
@@ -168,11 +174,11 @@ void TEveBoxProjected::UpdateProjection()
       for (Int_t i = 0; i < 8; ++i)
       {
          projection->ProjectPointfv(trans, box->GetVertex(i), pbuf, fDepth);
-         vPoint_t& ppv = pp[projection->SubSpaceId(pbuf)];
+         vVector2_t& ppv = pp[projection->SubSpaceId(pbuf)];
 
-         TEvePoint p(pbuf);
-         Bool_t    overlap = kFALSE;
-         for (vPoint_i j = ppv.begin(); j != ppv.end(); ++j)
+         TEveVector2 p(pbuf);
+         Bool_t      overlap = kFALSE;
+         for (vVector2_i j = ppv.begin(); j != ppv.end(); ++j)
          {
             if (p.SquareDistance(*j) < TEveProjection::fgEpsSqr)
             {
diff --git a/graf3d/eve/src/TEveBoxGL.cxx b/graf3d/eve/src/TEveBoxGL.cxx
index 678275a..c980cf9 100644
--- a/graf3d/eve/src/TEveBoxGL.cxx
+++ b/graf3d/eve/src/TEveBoxGL.cxx
@@ -184,7 +184,10 @@ void TEveBoxGL::Draw(TGLRnrCtx& rnrCtx) const
    // Render with OpenGL.
 
    if (rnrCtx.IsDrawPassOutlineLine())
+   {
+      RenderOutline(fM->fVertices);
       return;
+   }
 
    if (fM->fHighlightFrame && rnrCtx.Highlight())
    {
diff --git a/graf3d/eve/src/TEveBoxSetGL.cxx b/graf3d/eve/src/TEveBoxSetGL.cxx
index 634035b..2e4b968 100644
--- a/graf3d/eve/src/TEveBoxSetGL.cxx
+++ b/graf3d/eve/src/TEveBoxSetGL.cxx
@@ -31,7 +31,7 @@
 ClassImp(TEveBoxSetGL);
 
 //______________________________________________________________________________
-TEveBoxSetGL::TEveBoxSetGL() : fM(0), fBoxDL(0)
+TEveBoxSetGL::TEveBoxSetGL() : TEveDigitSetGL(), fM(0), fBoxDL(0)
 {
    // Default constructor.
 
@@ -61,30 +61,6 @@ Int_t TEveBoxSetGL::PrimitiveType() const
 }
 
 //______________________________________________________________________________
-inline Bool_t TEveBoxSetGL::SetupColor(const TEveDigitSet::DigitBase_t& q) const
-{
-   // Set GL color for given primitive.
-
-   if (fM->fSingleColor)
-   {
-      return kTRUE;
-   }
-   else if (fM->fValueIsColor)
-   {
-      TGLUtil::Color4ubv((UChar_t*) & q.fValue);
-      return kTRUE;
-   }
-   else
-   {
-      UChar_t c[4];
-      Bool_t visible = fM->fPalette->ColorFromValue(q.fValue, fM->fDefaultValue, c);
-      if (visible)
-         TGLUtil::Color4ubv(c);
-      return visible;
-   }
-}
-
-//______________________________________________________________________________
 void TEveBoxSetGL::MakeOriginBox(Float_t p[24], Float_t dx, Float_t dy, Float_t dz) const
 {
    // Fill array p to represent a box (0,0,0) - (dx,dy,dz).
@@ -185,14 +161,14 @@ void TEveBoxSetGL::MakeDisplayList() const
 /******************************************************************************/
 
 //______________________________________________________________________________
-Bool_t TEveBoxSetGL::ShouldDLCache(const TGLRnrCtx & rnrCtx) const
+Bool_t TEveBoxSetGL::ShouldDLCache(const TGLRnrCtx& rnrCtx) const
 {
    // Determines if display-list will be used for rendering.
    // Virtual from TGLLogicalShape.
 
    MakeDisplayList();
 
-   return TGLObject::ShouldDLCache(rnrCtx);
+   return TEveDigitSetGL::ShouldDLCache(rnrCtx);
 }
 
 //______________________________________________________________________________
@@ -228,22 +204,30 @@ Bool_t TEveBoxSetGL::SetModel(TObject* obj, const Option_t* /*opt*/)
    // Set model object.
    // Virtual from TGLObject.
 
-   Bool_t isok = SetModelCheckClass(obj, TEveBoxSet::Class());
-   fM = isok ? dynamic_cast<TEveBoxSet*>(obj) : 0;
-   return isok;
+   if (SetModelCheckClass(obj, TEveBoxSet::Class())) {
+      fM = dynamic_cast<TEveBoxSet*>(obj);
+      return kTRUE;
+   }
+   return kFALSE;
 }
 
-//______________________________________________________________________________
-void TEveBoxSetGL::SetBBox()
-{
-   // Fill the bounding-box data of the logical-shape.
-   // Virtual from TGLObject.
+/******************************************************************************/
 
-   SetAxisAlignedBBox(fM->AssertBBox());
+namespace
+{
+  inline void AntiFlick(Float_t x, Float_t y, Float_t z)
+  {
+     // Render anti-flickering point.
+     glBegin(GL_POINTS);
+     glVertex3f(x, y, z);
+     glEnd();
+  }
 }
 
+/******************************************************************************/
+
 //______________________________________________________________________________
-void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
+void TEveBoxSetGL::RenderBoxes(TGLRnrCtx& rnrCtx) const
 {
    // GL rendering for all box-types.
 
@@ -256,6 +240,8 @@ void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
       boxSkip = 6 - (rnrCtx.ShapeLOD()+1)/10;
 
    TEveChunkManager::iterator bi(fM->fPlex);
+   if (rnrCtx.Highlight() && fHighlightSet)
+      bi.fSelection = fHighlightSet;
 
    switch (fM->fBoxType)
    {
@@ -272,6 +258,10 @@ void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
                glBegin(primitiveType);
                RenderBox(b.fVertices);
                glEnd();
+               if (fM->fAntiFlick)
+                  AntiFlick(0.5f*(b.fVertices[0] + b.fVertices[18]),
+                            0.5f*(b.fVertices[1] + b.fVertices[19]),
+                            0.5f*(b.fVertices[2] + b.fVertices[20]));
             }
             if (boxSkip) { Int_t s = boxSkip; while (s--) bi.next(); }
          }
@@ -291,6 +281,8 @@ void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
                glTranslatef(b.fA, b.fB, b.fC);
                glScalef    (b.fW, b.fH, b.fD);
                glCallList(fBoxDL);
+               if (fM->fAntiFlick)
+                  AntiFlick(0.5f, 0.5f, 0.5f);
                glPopMatrix();
             }
             if (boxSkip) { Int_t s = boxSkip; while (s--) bi.next(); }
@@ -308,6 +300,8 @@ void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
                if (rnrCtx.SecSelection()) glLoadName(bi.index());
                glTranslatef(b.fA, b.fB, b.fC);
                glCallList(fBoxDL);
+               if (fM->fAntiFlick)
+                  AntiFlick(0.5f*fM->fDefWidth, 0.5f*fM->fDefHeight, 0.5f*fM->fDefDepth);
                glTranslatef(-b.fA, -b.fB, -b.fC);
             }
             if (boxSkip) { Int_t s = boxSkip; while (s--) bi.next(); }
@@ -336,6 +330,8 @@ void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
                glRotatef(90 - theta, 0, 1, 0);
                glScalef (b.fR, b.fR, h);
                glCallList(fBoxDL);
+               if (fM->fAntiFlick)
+                  AntiFlick(0.0f, 0.0f, 0.5f);
                glPopMatrix();
             }
             if (boxSkip) { Int_t s = boxSkip; while (s--) bi.next(); }
@@ -365,6 +361,8 @@ void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
                glRotatef(b.fAngle,   0, 0, 1);
                glScalef (b.fR, b.fR2, h);
                glCallList(fBoxDL);
+               if (fM->fAntiFlick)
+                  AntiFlick(0.0f, 0.0f, 0.5f);
                glPopMatrix();
             }
             if (boxSkip) { Int_t s = boxSkip; while (s--) bi.next(); }
@@ -383,7 +381,7 @@ void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
 }
 
 //______________________________________________________________________________
-void TEveBoxSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
+void TEveBoxSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
 {
    // Actual rendering code.
    // Virtual from TGLLogicalShape.
@@ -418,27 +416,15 @@ void TEveBoxSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
       glPopAttrib();
    }
 
-   if (mB.fFrame != 0 && ! rnrCtx.SecSelection())
+   if (mB.fFrame != 0 && ! rnrCtx.SecSelection() &&
+       ! (rnrCtx.Highlight() && AlwaysSecondarySelect()))
    {
       TEveFrameBoxGL::Render(mB.fFrame);
    }
 }
 
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEveBoxSetGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
-{
-   // Processes secondary selection from TGLViewer.
-   // Calls TPointSet3D::PointSelected(Int_t) with index of selected
-   // point as an argument.
-
-   if (rec.GetN() < 2) return;
-   fM->DigitSelected(rec.GetItem(1));
-}
-
 //______________________________________________________________________________
-void TEveBoxSetGL::Render(TGLRnrCtx & rnrCtx)
+void TEveBoxSetGL::Render(TGLRnrCtx& rnrCtx)
 {
    // Interface for direct rendering from classes that include TEveBoxSet
    // as a member.
diff --git a/graf3d/eve/src/TEveCalo.cxx b/graf3d/eve/src/TEveCalo.cxx
index 0181422..7b688ee 100644
--- a/graf3d/eve/src/TEveCalo.cxx
+++ b/graf3d/eve/src/TEveCalo.cxx
@@ -384,11 +384,12 @@ void TEveCaloViz::SetupColorHeight(Float_t value, Int_t slice, Float_t& outH) co
       outH = GetValToHeight()*fData->GetMaxVal(fPlotEt);
       UChar_t c[4];
       fPalette->ColorFromValue((Int_t)value, c);
+      c[3] = fData->GetSliceTransparency(slice);
       TGLUtil::Color4ubv(c);
    }
    else
    {
-      TGLUtil::Color(fData->RefSliceInfo(slice).fColor);
+      TGLUtil::ColorTransparency(fData->GetSliceColor(slice), fData->GetSliceTransparency(slice));
       outH = GetValToHeight()*value;
    }
 }
@@ -410,12 +411,15 @@ TEveCalo3D::TEveCalo3D(TEveCaloData* d, const char* n, const char* t):
 
    fRnrEndCapFrame    (kTRUE),
    fRnrBarrelFrame    (kTRUE),
+   fFrameWidth        (0.5),
    fFrameColor        (kGray+1),
    fFrameTransparency (80)
 {
 
    // Constructor.
 
+   fCanEditMainColor        = kTRUE;
+   fCanEditMainTransparency = kTRUE;
    fMainColorPtr = &fFrameColor;
 }
 
@@ -618,10 +622,19 @@ void TEveCalo2D::BuildCellIdCache()
 //______________________________________________________________________________
 void TEveCalo2D::CellSelectionChanged()
 {
+   // Sort slected cells in eta or phi bins for selection and highlight.
+
+   CellSelectionChangedInternal(fData->GetCellsSelected(), fCellListsSelected);
+   CellSelectionChangedInternal(fData->GetCellsHighlighted(), fCellListsHighlighted);
+}
+
+//______________________________________________________________________________
+void TEveCalo2D::CellSelectionChangedInternal(TEveCaloData::vCellId_t& cells, std::vector<TEveCaloData::vCellId_t*>& cellLists)
+{
    // Sort slected cells in eta or phi bins.
 
    // clear old cache
-   for (vBinCells_i it = fCellListsSelected.begin(); it != fCellListsSelected.end(); it++)
+   for (vBinCells_i it = cellLists.begin(); it != cellLists.end(); it++)
    {
       if (*it)
       {
@@ -629,18 +642,17 @@ void TEveCalo2D::CellSelectionChanged()
          delete *it;
       }
    }
-   fCellListsSelected.clear();
+   cellLists.clear();
 
-   TEveCaloData::vCellId_t&  cells = fData->GetCellsSelected();
    TEveCaloData::CellData_t  cellData;
    if (cells.size())
    {
       Bool_t rPhi  = fManager->GetProjection()->GetType() == TEveProjection::kPT_RPhi;
       UInt_t nBins = rPhi ? fData->GetPhiBins()->GetNbins() : fData->GetEtaBins()->GetNbins();
 
-      fCellListsSelected.resize(nBins+1);
+      cellLists.resize(nBins+1);
       for (UInt_t b = 0; b <= nBins; ++b)
-         fCellListsSelected[b] = 0;
+         cellLists[b] = 0;
 
       Int_t bin;
       for (TEveCaloData::vCellId_i i=cells.begin(); i!=cells.end(); i++)
@@ -655,16 +667,25 @@ void TEveCalo2D::CellSelectionChanged()
             else {
                bin = fData->GetEtaBins()->FindBin(cellData.Eta());
             }
-            if (fCellListsSelected[bin] == 0)
-               fCellListsSelected[bin] = new TEveCaloData::vCellId_t();
+            if (cellLists[bin] == 0)
+               cellLists[bin] = new TEveCaloData::vCellId_t();
 
-            fCellListsSelected[bin]->push_back(*i);
+            cellLists[bin]->push_back(*i);
          }
       }
    }
 }
 
 //______________________________________________________________________________
+void TEveCalo2D::SetScaleAbs(Bool_t sa)
+{
+   // Set absolute scale in projected calorimeter.
+   
+   TEveCaloViz::SetScaleAbs(sa);
+   BuildCellIdCache();
+}
+
+//______________________________________________________________________________
 Float_t TEveCalo2D::GetValToHeight() const
 {
    // Virtual function of TEveCaloViz.
@@ -758,7 +779,9 @@ TEveCaloLego::TEveCaloLego(TEveCaloData* d, const char* n, const char* t):
    fDrawHPlane(kFALSE),
    fHPlaneVal(0),
 
-   fBinStep(-1),
+   fHasFixedHeightIn2DMode(kFALSE),
+   fFixedHeightValIn2DMode(0.f),
+
    fDrawNumberCellPixels(18), // draw numbers on cell above 30 pixels
    fCellPixelFontSize(12) // size of cell fonts in pixels
 {
diff --git a/graf3d/eve/src/TEveCalo2DGL.cxx b/graf3d/eve/src/TEveCalo2DGL.cxx
index 839ed0f..ca0d455 100644
--- a/graf3d/eve/src/TEveCalo2DGL.cxx
+++ b/graf3d/eve/src/TEveCalo2DGL.cxx
@@ -115,7 +115,7 @@ void TEveCalo2DGL::DrawRPhi(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t& cellLis
 
    UInt_t nPhi = data->GetPhiBins()->GetNbins();
 
-   for(UInt_t phiBin = 0; phiBin < nPhi; ++phiBin)
+   for(UInt_t phiBin = 1; phiBin <= nPhi; ++phiBin)
    {
       if (cellLists[phiBin] )
       {
@@ -151,7 +151,7 @@ void TEveCalo2DGL::DrawRPhi(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t& cellLis
 }
 
 //______________________________________________________________________________
-void TEveCalo2DGL::DrawRPhiHighlighted(TGLRnrCtx & /*rnrCtx*/) const
+void TEveCalo2DGL::DrawRPhiHighlighted(std::vector<TEveCaloData::vCellId_t*>& cellLists) const
 {
    // Draw selected calorimeter cells in RPhi projection.
 
@@ -167,7 +167,7 @@ void TEveCalo2DGL::DrawRPhiHighlighted(TGLRnrCtx & /*rnrCtx*/) const
 
    for(UInt_t phiBin = 1; phiBin <= nPhiBins; ++phiBin)
    {
-      if (fM->fCellListsSelected[phiBin])
+      if (cellLists[phiBin])
       {
          if (!fM->fCellLists[phiBin])
             throw eh + "selected cell not in cell list cache.";
@@ -175,7 +175,7 @@ void TEveCalo2DGL::DrawRPhiHighlighted(TGLRnrCtx & /*rnrCtx*/) const
          Float_t off = 0;
          // selected eta sum
          for (Int_t s=0; s<nSlices; ++s) sliceVal[s] = 0;
-         TEveCaloData::vCellId_t& cids = *(fM->fCellListsSelected[phiBin]);
+         TEveCaloData::vCellId_t& cids = *(cellLists[phiBin]);
          for (TEveCaloData::vCellId_i i=cids.begin(); i!=cids.end(); i++) {
             data->GetCellData((*i), cellData);
             sliceVal[i->fSlice] += cellData.Value(fM->fPlotEt);
@@ -271,6 +271,7 @@ void TEveCalo2DGL::DrawRhoZ(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t& cellLis
    Float_t *sliceValsLow = new Float_t[nSlices];
    Bool_t   isBarrel;
    Float_t  towerH;
+   Float_t transEta = fM->GetTransitionEta();
 
    UInt_t nEta = data->GetEtaBins()->GetNbins();
    for (UInt_t etaBin = 1; etaBin <= nEta; ++etaBin)
@@ -295,7 +296,13 @@ void TEveCalo2DGL::DrawRhoZ(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t& cellLis
             else
                sliceValsLow[it->fSlice] += cellData.Value(fM->fPlotEt);
          }
-         isBarrel = TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta();
+
+         isBarrel = true;
+         if ((cellData.EtaMax() > 0 && cellData.EtaMax() > transEta) ||
+             (cellData.EtaMin() < 0 && cellData.EtaMin() < -transEta))
+         {
+            isBarrel = false;
+         }
 
          // draw
          if (rnrCtx.SecSelection()) glLoadName(etaBin); // name-stack eta bin
@@ -333,7 +340,7 @@ void TEveCalo2DGL::DrawRhoZ(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t& cellLis
 }
 
 //______________________________________________________________________________
-void TEveCalo2DGL::DrawRhoZHighlighted(TGLRnrCtx & /*rnrCtx*/) const
+void TEveCalo2DGL::DrawRhoZHighlighted(std::vector<TEveCaloData::vCellId_t*>& cellLists) const
 {
    // Draw selected calorimeter cells in RhoZ projection.
 
@@ -354,7 +361,7 @@ void TEveCalo2DGL::DrawRhoZHighlighted(TGLRnrCtx & /*rnrCtx*/) const
 
    for (UInt_t etaBin = 1; etaBin <= nEtaBins; ++etaBin)
    {
-      if (fM->fCellListsSelected[etaBin])
+      if (cellLists[etaBin])
       {
          if (!fM->fCellLists[etaBin])
             throw(eh + "selected cell not in cell list cache.");
@@ -364,7 +371,7 @@ void TEveCalo2DGL::DrawRhoZHighlighted(TGLRnrCtx & /*rnrCtx*/) const
          for (Int_t s = 0; s < nSlices; ++s) {
             sliceValsUp[s] = 0; sliceValsLow[s] = 0;
          }
-         TEveCaloData::vCellId_t& cids = *(fM->fCellListsSelected[etaBin]);
+         TEveCaloData::vCellId_t& cids = *(cellLists[etaBin]);
          for (TEveCaloData::vCellId_i i=cids.begin(); i!=cids.end(); i++) {
             data->GetCellData(*i, cellData);
             if (cellData.Phi() > 0)
@@ -422,6 +429,10 @@ void TEveCalo2DGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    TGLCapabilitySwitch light_off(GL_LIGHTING,  kFALSE);
    TGLCapabilitySwitch cull_off (GL_CULL_FACE, kFALSE);
 
+   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
+   glEnable(GL_BLEND);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
    if (fM->fCellIdCacheOK == kFALSE)
       fM->BuildCellIdCache();
 
@@ -433,85 +444,91 @@ void TEveCalo2DGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    else
       DrawRhoZ(rnrCtx, fM->fCellLists);
    if (rnrCtx.SecSelection()) glPopName();
+   glPopAttrib();
 }
 
 //______________________________________________________________________________
-void TEveCalo2DGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const
+void TEveCalo2DGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* /*pshp*/, Int_t /*lvl*/) const
 {
    // Draw towers in highlight mode.
 
    static const TEveException eh("TEveCalo2DGL::DrawHighlight ");
 
-   if ((pshp->GetSelected() == 2) && fM->fData->GetCellsSelected().size())
-   {
-      glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT  | GL_LINE_BIT );
-      glDisable(GL_CULL_FACE);
-      glDisable(GL_LIGHTING);
-      glEnable(GL_LINE_SMOOTH);
-      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
-      TGLUtil::LineWidth(2);
+   if (fM->fData->GetCellsSelected().empty() && fM->fData->GetCellsHighlighted().empty())
+      return;
 
-      glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
-      TGLUtil::LockColor();
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT |GL_POLYGON_BIT );
+   glDisable(GL_LIGHTING);
+   glDisable(GL_CULL_FACE);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+
+   TGLUtil::LineWidth(2);
+   TGLUtil::LockColor();
+   try
+   {
+      if (!fM->fData->GetCellsHighlighted().empty()) 
+      {
+         glColor4ubv(rnrCtx.ColorSet().Selection(3).CArr());
 
-      try {
          if (IsRPhi())
-            DrawRPhiHighlighted(rnrCtx);
+            DrawRPhiHighlighted(fM->fCellListsHighlighted);
          else
-            DrawRhoZHighlighted(rnrCtx);
+            DrawRhoZHighlighted(fM->fCellListsHighlighted);
       }
-      catch (TEveException& exc)
+      if (!fM->fData->GetCellsSelected().empty())
       {
-         Warning(eh, exc);
-      }
-      TGLUtil::UnlockColor();
+         Float_t dr[2];
+         glGetFloatv(GL_DEPTH_RANGE,dr);
+         glColor4ubv(rnrCtx.ColorSet().Selection(1).CArr());
+         glDepthRange(dr[0], 0.8*dr[1]);
+         if (IsRPhi())
+            DrawRPhiHighlighted(fM->fCellListsSelected);
+         else
+            DrawRhoZHighlighted(fM->fCellListsSelected);
 
-      glPopAttrib();
+         glDepthRange(dr[0], dr[1]);
+      }
+   }
+   catch (TEveException& exc)
+   {
+      Warning(eh, exc);
    }
+
+   TGLUtil::UnlockColor();
+   glPopAttrib();
 }
 
- //______________________________________________________________________________
+//______________________________________________________________________________
 void TEveCalo2DGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
 {
    // Processes tower selection in eta bin or phi bin.
    // Virtual function from TGLogicalShape. Called from TGLViewer.
 
-   Int_t prev = fM->fData->GetCellsSelected().size();
-   if (!rec.GetMultiple()) fM->fData->GetCellsSelected().clear();
-
-   Int_t binID = -1;
+   TEveCaloData::vCellId_t sel;
    if (rec.GetN() > 2)
    {
-      binID       = rec.GetItem(1);
+      Int_t bin   = rec.GetItem(1);
       Int_t slice = rec.GetItem(2);
-      TEveCaloData::CellData_t cellData;
-      for (TEveCaloData::vCellId_i it = fM->fCellLists[binID]->begin();
-           it!=fM->fCellLists[binID]->end(); it++)
+      for (TEveCaloData::vCellId_i it = fM->fCellLists[bin]->begin();
+           it != fM->fCellLists[bin]->end(); ++it)
       {
          if ((*it).fSlice == slice)
          {
-
-            fM->fData->GetCellData(*it, cellData);
-            if (!IsRPhi())
+            if (IsRPhi())
             {
-               if ((rec.GetItem(3) && cellData.Phi() > 0) || (rec.GetItem(3) == kFALSE && cellData.Phi() < 0)) {
-                  fM->fData->GetCellsSelected().push_back(*it);
-               }
+               sel.push_back(*it);
             }
-            else {
-               fM->fData->GetCellsSelected().push_back(*it);
+            else
+            {
+               assert(rec.GetN() > 3);
+               Bool_t is_upper = (rec.GetItem(3) == 1);
+               TEveCaloData::CellData_t cd;
+               fM->fData->GetCellData(*it, cd);
+               if ((is_upper && cd.Phi() > 0) || (!is_upper && cd.Phi() < 0))
+                  sel.push_back(*it);
             }
          }
       }
    }
-
-   // set secondary selection result
-   if (prev == 0 && binID >= 0)
-      rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
-   else if (prev  && binID < 0)
-      rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
-   else if (prev  && binID >= 0)
-      rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
-
-   fM->fData->CellSelectionChanged();
+   fM->fData->ProcessSelection(sel, rec);
 }
diff --git a/graf3d/eve/src/TEveCalo3DGL.cxx b/graf3d/eve/src/TEveCalo3DGL.cxx
index 37661c3..2078250 100644
--- a/graf3d/eve/src/TEveCalo3DGL.cxx
+++ b/graf3d/eve/src/TEveCalo3DGL.cxx
@@ -109,10 +109,10 @@ void TEveCalo3DGL::RenderGridEndCap() const
    Float_t r, z, theta, phiU, phiL, eta;
 
    // eta slices
-   for (Int_t i=1; i<nx; ++i)
+   for (Int_t i=0; i<=nx; ++i)
    {
-      eta = ax->GetBinLowEdge(i);
-      if (Abs(eta) > trans && (eta > etaMin && eta < etaMax))
+      eta = ax->GetBinUpEdge(i);
+      if (Abs(eta) >= trans && (eta > etaMin && eta < etaMax))
       {
          theta = TEveCaloData::EtaToTheta(eta);
          r = Abs(zE*Tan(theta));
@@ -140,7 +140,7 @@ void TEveCalo3DGL::RenderGridEndCap() const
       else
          r2 = zE*Tan(TEveCaloData::EtaToTheta(etaMin));
 
-      for (Int_t j=0; j<ny; ++j)
+      for (Int_t j=1; j<=ny; ++j)
       {
          phiL = ay->GetBinLowEdge(j);
          phiU = ay->GetBinUpEdge(j);
@@ -165,7 +165,7 @@ void TEveCalo3DGL::RenderGridEndCap() const
 
       r1 = Abs(r1);
       r2 = Abs(r2);
-      for (Int_t j=0; j<ny; ++j)
+      for (Int_t j=1; j<=ny; ++j)
       {
          phiL = ay->GetBinLowEdge(j);
          phiU = ay->GetBinUpEdge(j);
@@ -202,10 +202,10 @@ void TEveCalo3DGL::RenderGridBarrel() const
    Float_t z, theta, phiL, phiU, eta, x, y;
 
    // eta slices
-   for(Int_t i=1; i<nx; i++)
+   for(Int_t i=0; i<=nx; i++)
    {
-      eta = ax->GetBinLowEdge(i);
-      if ((Abs(eta)<trans) && (etaMin < eta && eta < etaMax))
+      eta = ax->GetBinUpEdge(i);
+      if ((Abs(eta)<=trans) && (etaMin < eta && eta < etaMax))
       {
          theta = TEveCaloData::EtaToTheta(eta);
          z  = rB/Tan(theta);
@@ -236,7 +236,7 @@ void TEveCalo3DGL::RenderGridBarrel() const
    else
       zF = fM->GetEndCapPos();
 
-   for (Int_t j=0; j<ny; j++)
+   for (Int_t j=1; j<=ny; j++)
    {
       phiU = ay->GetBinUpEdge(j);
       phiL = ay->GetBinLowEdge(j);
@@ -276,18 +276,19 @@ void TEveCalo3DGL::RenderGrid(TGLRnrCtx & rnrCtx) const
 
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
 
+   TGLUtil::LineWidth(fM->GetFrameWidth());
    glBegin(GL_LINES);
 
    Float_t etaMin = fM->GetEtaMin();
    Float_t etaMax = fM->GetEtaMax();
 
    Float_t trans = fM->GetTransitionEta();
-   if (etaMin < trans && etaMax > -trans)
+   if (fM->GetRnrBarrelFrame() && (etaMin < trans && etaMax > -trans))
    {
       RenderGridBarrel();
    }
 
-   if (etaMax > trans || etaMin < -trans)
+   if (fM->GetRnrEndCapFrame() && (etaMax > trans || etaMin < -trans))
    {
       RenderGridEndCap();
    }
@@ -377,7 +378,7 @@ void TEveCalo3DGL::RenderBox(const Float_t pnts[8]) const
 }
 
 //______________________________________________________________________________
-Float_t TEveCalo3DGL::RenderBarrelCell(const TEveCaloData::CellGeom_t &cellData, Float_t towerH, Float_t offset ) const
+void TEveCalo3DGL::RenderBarrelCell(const TEveCaloData::CellGeom_t &cellData, Float_t towerH, Float_t& offset ) const
 {
    // Render barrel cell.
 
@@ -442,20 +443,20 @@ Float_t TEveCalo3DGL::RenderBarrelCell(const TEveCaloData::CellGeom_t &cellData,
 
    RenderBox(box);
 
-   return offset + towerH*Sin(cellData.ThetaMin());
+   offset += towerH*Sin(cellData.ThetaMin());
 
 }// end RenderBarrelCell
 
 //______________________________________________________________________________
-Float_t TEveCalo3DGL::RenderEndCapCell(const TEveCaloData::CellGeom_t &cellData, Float_t towerH, Float_t offset ) const
+void TEveCalo3DGL::RenderEndCapCell(const TEveCaloData::CellGeom_t &cellData, Float_t towerH, Float_t& offset ) const
 {
    // Render an endcap cell.
 
    using namespace TMath;
    Float_t z1, r1In, r1Out, z2, r2In, r2Out;
 
-   z1    = TMath::Sign(fM->fEndCapPos + offset, cellData.Eta());
-   z2    = z1 + TMath::Sign(towerH, cellData.Eta());
+   z1    = TMath::Sign(fM->fEndCapPos + offset, cellData.EtaMin());
+   z2    = z1 + TMath::Sign(towerH, cellData.EtaMin());
 
    r1In  = z1*Tan(cellData.ThetaMin());
    r2In  = z2*Tan(cellData.ThetaMin());
@@ -511,7 +512,12 @@ Float_t TEveCalo3DGL::RenderEndCapCell(const TEveCaloData::CellGeom_t &cellData,
    pnts[2] = z2;
 
    RenderBox(box);
-   return offset+towerH*Cos(cellData.ThetaMin());
+
+   if (z1 > 0)
+      offset += towerH * Cos(cellData.ThetaMin());
+   else
+      offset -= towerH * Cos(cellData.ThetaMin());
+
 } // end RenderEndCapCell
 
 
@@ -526,13 +532,14 @@ void TEveCalo3DGL::DirectDraw(TGLRnrCtx &rnrCtx) const
    if (fM->fCellIdCacheOK == kFALSE)
       fM->BuildCellIdCache();
 
-
-   glEnable(GL_LIGHTING);
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
+   glEnable(GL_LIGHTING);
    glEnable(GL_NORMALIZE);
+   glEnable(GL_BLEND);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
    TEveCaloData::CellData_t cellData;
-   Float_t towerH;
+   Float_t towerH = 0;
    Int_t   tower = 0;
    Int_t   prevTower = -1;
    Float_t offset = 0;
@@ -555,11 +562,15 @@ void TEveCalo3DGL::DirectDraw(TGLRnrCtx &rnrCtx) const
 
       if (rnrCtx.SecSelection()) glLoadName(cellID);
 
-      if (TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta())
-         offset = RenderBarrelCell(cellData, towerH, offset);
+      if ((cellData.Eta() > 0 && cellData.Eta() < fM->GetTransitionEta()) ||
+          (cellData.Eta() < 0 && cellData.Eta() > -fM->GetTransitionEta())) 
+      {
+         RenderBarrelCell(cellData, towerH, offset);
+      }
       else
-         offset = RenderEndCapCell(cellData, towerH, offset);
-
+      {
+         RenderEndCapCell(cellData, towerH, offset);
+      }
       ++cellID;
    }
 
@@ -571,80 +582,83 @@ void TEveCalo3DGL::DirectDraw(TGLRnrCtx &rnrCtx) const
 }
 
 //______________________________________________________________________________
-void TEveCalo3DGL::DrawHighlight(TGLRnrCtx & rnrCtx, const TGLPhysicalShape* pshp) const
+void TEveCalo3DGL::DrawHighlight(TGLRnrCtx & rnrCtx, const TGLPhysicalShape* /*pshp*/, Int_t /*lvl*/) const
 {
    // Draw polygons in highlight mode.
 
+   if (fM->fData->GetCellsSelected().empty() && fM->fData->GetCellsHighlighted().empty())
+   {
+      return;
+   }
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
+   glDisable(GL_LIGHTING);
+   glDisable(GL_CULL_FACE);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 
-   if ((pshp->GetSelected() == 2) && fM->fData->GetCellsSelected().size())
+   TGLUtil::LineWidth(2);
+   TGLUtil::LockColor();
+
+   if (!fM->fData->GetCellsHighlighted().empty()) 
+   {
+      glColor4ubv(rnrCtx.ColorSet().Selection(3).CArr());
+      DrawSelectedCells(fM->fData->GetCellsHighlighted());
+   }
+   if (!fM->fData->GetCellsSelected().empty())
    {
-      glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT |GL_POLYGON_BIT );
-      glDisable(GL_LIGHTING);
-      glDisable(GL_CULL_FACE);
-      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+      Float_t dr[2];
+      glGetFloatv(GL_DEPTH_RANGE,dr);
+      glColor4ubv(rnrCtx.ColorSet().Selection(1).CArr());
+      glDepthRange(dr[0], 0.8*dr[1]);
+      DrawSelectedCells(fM->fData->GetCellsSelected());
+      glDepthRange(dr[0], dr[1]);
+   }
+   TGLUtil::UnlockColor();
+   glPopAttrib();
+}
 
-      TGLUtil::LineWidth(2);
-      glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
-      TGLUtil::LockColor();
+//______________________________________________________________________________
+void TEveCalo3DGL::DrawSelectedCells(TEveCaloData::vCellId_t cells) const
+{
+   TEveCaloData::CellData_t cellData;
+   Float_t towerH = 0;
 
-      TEveCaloData::CellData_t cellData;
-      Float_t towerH;
-      Int_t nCells =  fM->fCellList.size();
+   for (TEveCaloData::vCellId_i i = cells.begin(); i != cells.end(); i++)
+   {
+      fM->fData->GetCellData(*i, cellData);
+      fM->SetupColorHeight(cellData.Value(fM->fPlotEt), (*i).fSlice, towerH);
 
-      for (TEveCaloData::vCellId_i i = fM->fData->GetCellsSelected().begin();
-           i != fM->fData->GetCellsSelected().end(); i++)
+      // find tower with offsets
+      Float_t offset = 0;
+      for (Int_t j = 0; j < (Int_t) fM->fCellList.size(); ++j)
       {
-         fM->fData->GetCellData(*i, cellData);
-         fM->SetupColorHeight(cellData.Value(fM->fPlotEt), (*i).fSlice, towerH);
-
-         // find tower with offsets
-         Float_t offset = 0;
-         for (Int_t j = 0; j < nCells; ++j)
+         if (fM->fCellList[j].fTower == i->fTower && fM->fCellList[j].fSlice == i->fSlice )
          {
-            if (fM->fCellList[j].fTower == i->fTower && fM->fCellList[j].fSlice == i->fSlice )
-            {
-               offset = fOffset[j];
-               break;
-            }
+            offset = fOffset[j];
+            break;
          }
-
-         if (fM->CellInEtaPhiRng(cellData)) 
-         {
-            if (TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta())
-               RenderBarrelCell(cellData, towerH, offset);
-            else
-               RenderEndCapCell(cellData, towerH, offset);
-         }  
       }
 
-      TGLUtil::UnlockColor();
-      glPopAttrib();
+      if (fM->CellInEtaPhiRng(cellData)) 
+      {
+         if (TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta())
+            RenderBarrelCell(cellData, towerH, offset);
+         else
+            RenderEndCapCell(cellData, towerH, offset);
+      }  
    }
 }
 
 //______________________________________________________________________________
-void TEveCalo3DGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
+void TEveCalo3DGL::ProcessSelection(TGLRnrCtx& /*rnrCtx*/, TGLSelectRecord& rec)
 {
    // Processes tower selection.
    // Virtual function from TGLogicalShape. Called from TGLViewer.
 
-   Int_t prev = fM->fData->GetCellsSelected().size();
-
-   if (!rec.GetMultiple()) fM->fData->GetCellsSelected().clear();
-   Int_t cellID = -1;
+   TEveCaloData::vCellId_t sel;
    if (rec.GetN() > 1)
    {
-      cellID = rec.GetItem(1);
-      fM->fData->GetCellsSelected().push_back(fM->fCellList[cellID]);
+      sel.push_back(fM->fCellList[rec.GetItem(1)]);
    }
-
-   if (prev == 0 && cellID >= 0)
-      rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
-   else if (prev  && cellID < 0)
-      rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
-   else if (prev  && cellID >= 0)
-      rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
-
-
-   fM->fData->CellSelectionChanged();
+   fM->fData->ProcessSelection(sel, rec);
 }
diff --git a/graf3d/eve/src/TEveCaloData.cxx b/graf3d/eve/src/TEveCaloData.cxx
index 84ceec5..03898d6 100644
--- a/graf3d/eve/src/TEveCaloData.cxx
+++ b/graf3d/eve/src/TEveCaloData.cxx
@@ -12,6 +12,8 @@
 #include "TEveCaloData.h"
 #include "TEveCalo.h"
 
+#include "TGLSelectRecord.h"
+
 #include "TAxis.h"
 #include "THStack.h"
 #include "TH2.h"
@@ -20,7 +22,7 @@
 
 #include <cassert>
 #include <algorithm>
-
+#include <set>
 
 //------------------------------------------------------------------------------
 // TEveCaloData::CellGeom_t
@@ -119,15 +121,46 @@ TEveCaloData::TEveCaloData(const char* n, const char* t):
 }
 
 //______________________________________________________________________________
-void TEveCaloData::SelectElement(Bool_t s)
+void TEveCaloData::UnSelected()
 {
-   // Virtual method TEveElement::SelectElement.
+   // Virtual method TEveElement::UnSelect.
    // Clear selected towers when deselected.
 
-   if (s == kFALSE)
-      fCellsSelected.clear();
+   fCellsSelected.clear();
+}
+
+//______________________________________________________________________________
+void TEveCaloData::UnHighlighted()
+{
+   // Virtual method TEveElement::UnHighlighted.
+
+   fCellsHighlighted.clear();
+}
+
+//______________________________________________________________________________
+TString TEveCaloData::GetHighlightTooltip()
+{
+   if (fCellsHighlighted.empty()) return "";
+
+   CellData_t cellData;
+
+   Bool_t single = fCellsHighlighted.size() == 1;
+   Float_t sum = 0;
+   TString s;
+   for (vCellId_i i = fCellsHighlighted.begin(); i!=fCellsHighlighted.end(); ++i)
+   {
+      GetCellData(*i, cellData);
+      
+      s += TString::Format("%s %.2f (%.3f, %.3f)", 
+                           fSliceInfos[i->fSlice].fName.Data(), cellData.fValue,
+                           cellData.Eta(), cellData.Phi());
 
-   TEveElement::SelectElement(s);
+      if (single) return s;
+      s += "\n";
+      sum += cellData.fValue;
+   }
+   s += TString::Format("Sum = %.2f", sum);
+   return s;
 }
 
 //______________________________________________________________________________
@@ -159,6 +192,113 @@ void TEveCaloData::PrintCellsSelected()
 }
 
 //______________________________________________________________________________
+void TEveCaloData::ProcessSelection(vCellId_t& sel_cells, TGLSelectRecord& rec)
+{
+   // Process newly selected cells with given select-record.
+   // Secondary-select status is set.
+   // CellSelectionChanged() is called if needed.
+
+   typedef std::set<CellId_t>           sCellId_t;
+   typedef std::set<CellId_t>::iterator sCellId_i;
+
+   struct helper
+   {
+      static void fill_cell_set(sCellId_t& cset, vCellId_t& cvec)
+      {
+         for (vCellId_i i = cvec.begin(); i != cvec.end(); ++i)
+            cset.insert(*i);
+      }
+      static void fill_cell_vec(vCellId_t& cvec, sCellId_t& cset)
+      {
+         for (sCellId_i i = cset.begin(); i != cset.end(); ++i)
+            cvec.push_back(*i);
+      }
+   };
+
+   vCellId_t& cells = rec.GetHighlight() ? fCellsHighlighted : fCellsSelected;
+ 
+   if (cells.empty())
+   {
+      if (!sel_cells.empty())
+      {
+         cells.swap(sel_cells);
+         rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
+      }
+   }
+   else
+   {
+      if (!sel_cells.empty())
+      {
+         if (rec.GetMultiple())
+         {
+            sCellId_t cs;
+            helper::fill_cell_set(cs, cells);
+            for (vCellId_i i = sel_cells.begin(); i != sel_cells.end(); ++i)
+            {
+               std::set<CellId_t>::iterator csi = cs.find(*i);
+               if (csi == cs.end())
+                  cs.insert(*i);
+               else
+                  cs.erase(csi);
+            }
+            cells.clear();
+            if (cs.empty())
+            {
+               rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
+            }
+            else
+            {
+               helper::fill_cell_vec(cells, cs);
+               rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
+            }
+         }
+         else
+         {
+            Bool_t differ = kFALSE;
+            if (cells.size() == sel_cells.size())
+            {
+               sCellId_t cs;
+               helper::fill_cell_set(cs, cells);
+               for (vCellId_i i = sel_cells.begin(); i != sel_cells.end(); ++i)
+               {
+                  if (cs.find(*i) == cs.end())
+                  {
+                     differ = kTRUE;
+                     break;
+                  }
+               }
+            }
+            else
+            {
+               differ = kTRUE;
+            }
+            if (differ)
+            {
+               cells.swap(sel_cells);
+               rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
+            }
+         }
+      }
+      else
+      {
+         if (!rec.GetMultiple())
+         {
+            cells.clear();
+            rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
+         }
+      }
+   }
+
+   if (rec.GetSecSelResult() != TGLSelectRecord::kNone)
+   {
+      CellSelectionChanged();
+   }
+}
+
+
+//==============================================================================
+
+//______________________________________________________________________________
 void TEveCaloData::SetSliceThreshold(Int_t slice, Float_t val)
 {
    // Set threshold for given slice.
@@ -196,6 +336,26 @@ Color_t TEveCaloData::GetSliceColor(Int_t slice) const
 }
 
 //______________________________________________________________________________
+void TEveCaloData::SetSliceTransparency(Int_t slice, Char_t t)
+{
+   // Set transparency for given slice.
+
+   fSliceInfos[slice].fTransparency = t;
+   for (List_ci i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      (*i)->AddStamp(TEveElement::kCBObjProps);
+   }
+}
+
+//______________________________________________________________________________
+Char_t TEveCaloData::GetSliceTransparency(Int_t slice) const
+{
+   // Get transparency for given slice.
+
+   return fSliceInfos[slice].fTransparency;
+}
+
+//______________________________________________________________________________
 void TEveCaloData::InvalidateUsersCellIdCache()
 {
    // Invalidate cell ids cache on back ptr references.
@@ -237,7 +397,7 @@ void TEveCaloData::CellSelectionChanged()
    {
       calo = dynamic_cast<TEveCaloViz*>(*i);
       calo->CellSelectionChanged();
-      calo->StampObjProps();
+      calo->StampColorSelection();
    }
 }
 
@@ -290,6 +450,18 @@ TEveCaloDataVec::~TEveCaloDataVec()
 }
 
 //______________________________________________________________________________
+Int_t TEveCaloDataVec::AddSlice()
+{
+  // Add new slice.
+  
+  fSliceInfos.push_back(SliceInfo_t());
+  fSliceVec.push_back(std::vector<Float_t> ()); 
+  fSliceVec.back().resize(fGeomVec.size(), 0.f);
+
+  return fSliceInfos.size() - 1;
+}
+  
+//______________________________________________________________________________
 Int_t TEveCaloDataVec::AddTower(Float_t etaMin, Float_t etaMax, Float_t phiMin, Float_t phiMax)
 {
    // Add tower within eta/phi range.
@@ -307,7 +479,7 @@ Int_t TEveCaloDataVec::AddTower(Float_t etaMin, Float_t etaMax, Float_t phiMin,
 
    if (phiMin < fPhiMin) fPhiMin = phiMin;
    if (phiMax > fPhiMax) fPhiMax = phiMax;
-
+  
    fTower = fGeomVec.size() - 1;
    return fTower;
 }
@@ -359,13 +531,16 @@ void TEveCaloDataVec::GetCellList(Float_t eta, Float_t etaD,
          minQ = cg.fPhiMin;
          maxQ = cg.fPhiMax;
 
-         if (maxQ < phiMin)
+         if (fWrapTwoPi)
          {
-            minQ += TwoPi(); maxQ += TwoPi();
-         }
-         else if (minQ > phiMax)
-         {
-            minQ -= TwoPi(); maxQ -= TwoPi();
+            if (maxQ < phiMin)
+            {
+               minQ += TwoPi(); maxQ += TwoPi();
+            }
+            else if (minQ > phiMax)
+            {
+               minQ -= TwoPi(); maxQ -= TwoPi();
+            }
          }
 
          if (maxQ >= phiMin && minQ <= phiMax)
@@ -636,7 +811,6 @@ void TEveCaloDataHist::GetCellList(Float_t eta, Float_t etaD,
    Int_t nPhi = fPhiAxis->GetNbins();
    Int_t nSlices = GetNSlices();
 
-   TH2F* hist = GetHist(0);
    Int_t bin  = 0;
 
    Bool_t accept;
@@ -661,7 +835,7 @@ void TEveCaloDataHist::GetCellList(Float_t eta, Float_t etaD,
             {
                for (Int_t s = 0; s < nSlices; ++s)
                {
-                  hist = GetHist(s);
+                  TH2F *hist = GetHist(s);
                   bin = hist->GetBin(ieta, iphi);
                   if (hist->GetBinContent(bin) > fSliceInfos[s].fThreshold)
                      out.push_back(TEveCaloData::CellId_t(bin, s));
diff --git a/graf3d/eve/src/TEveCaloLegoEditor.cxx b/graf3d/eve/src/TEveCaloLegoEditor.cxx
index 4626efe..9fdf362 100644
--- a/graf3d/eve/src/TEveCaloLegoEditor.cxx
+++ b/graf3d/eve/src/TEveCaloLegoEditor.cxx
@@ -107,7 +107,7 @@ TEveCaloLegoEditor::TEveCaloLegoEditor(const TGWindow *p, Int_t width, Int_t hei
    f2DMode = MakeLabeledCombo("2DMode:", 4);
    f2DMode->AddEntry("ValColor", TEveCaloLego::kValColor);
    f2DMode->AddEntry("ValSize",  TEveCaloLego::kValSize);
-   f2DMode->AddEntry("ValSize",  TEveCaloLego::kValSizeOutline);
+   f2DMode->AddEntry("ValSizeOutline",  TEveCaloLego::kValSizeOutline);
    f2DMode->Connect("Selected(Int_t)", "TEveCaloLegoEditor", this, "Do2DMode()");
 
    fBoxMode = MakeLabeledCombo("Box:", 4);
@@ -269,7 +269,7 @@ void TEveCaloLegoEditor::DoTransparency()
 {
    // Slot for Transparency.
 
-   fM->SetPlaneTransparency((UChar_t)(fTransparency->GetNumber()));
+   fM->SetPlaneTransparency((Char_t)(fTransparency->GetNumber()));
    Update();
 }
 
diff --git a/graf3d/eve/src/TEveCaloLegoGL.cxx b/graf3d/eve/src/TEveCaloLegoGL.cxx
index 098e308..9228230 100644
--- a/graf3d/eve/src/TEveCaloLegoGL.cxx
+++ b/graf3d/eve/src/TEveCaloLegoGL.cxx
@@ -51,7 +51,11 @@ TEveCaloLegoGL::TEveCaloLegoGL() :
    fZAxis(0),
    fM(0),
    fDLCacheOK(kFALSE),
-   fCells3D(kTRUE)
+   fMaxVal(0),
+   fValToPixel(0),
+   fCurrentPixelsPerBin(0),
+   fCells3D(kTRUE),
+   fBinStep(-1)
 {
    // Constructor.
 
@@ -218,7 +222,8 @@ void TEveCaloLegoGL::Make3DDisplayList(TEveCaloData::vCellId_t& cellList, SliceD
 
       glNewList(dlMap[s], GL_COMPILE);
 
-      for (UInt_t i = 0; i < cellList.size(); ++i) {
+      for (UInt_t i = 0; i < cellList.size(); ++i)
+      {
          if (cellList[i].fSlice > s) continue;
          if (cellList[i].fTower != prevTower) {
             offset = 0;
@@ -226,9 +231,9 @@ void TEveCaloLegoGL::Make3DDisplayList(TEveCaloData::vCellId_t& cellList, SliceD
          }
 
          fM->fData->GetCellData(cellList[i], cellData);
-         if (s == cellList[i].fSlice) {
-            if (selection)
-               glLoadName(i);
+         if (s == cellList[i].fSlice)
+         {
+            if (selection) glLoadName(i);
 
             WrapTwoPi(cellData.fPhiMin, cellData.fPhiMax);
             MakeQuad(cellData.EtaMin(), cellData.PhiMin(), offset,
@@ -248,9 +253,9 @@ void TEveCaloLegoGL::Make3DDisplayListRebin(TEveCaloData::RebinData_t& rebinData
 
    Int_t nSlices = fM->fData->GetNSlices();
    Float_t *vals;
-   Int_t bin;
    Float_t offset;
    Float_t y0, y1;
+
    for (Int_t s = 0; s < nSlices; ++s)
    {
       if (dlMap.empty() || dlMap[s] == 0)
@@ -258,33 +263,30 @@ void TEveCaloLegoGL::Make3DDisplayListRebin(TEveCaloData::RebinData_t& rebinData
 
       glNewList(dlMap[s], GL_COMPILE);
 
-      if (selection) glLoadName(s);
-      if (selection) glPushName(0);
-      for (Int_t i=1; i<= fEtaAxis->GetNbins(); ++i)
+      for (Int_t i = 1; i <= fEtaAxis->GetNbins(); ++i)
       {
-         for (Int_t j=1; j <= fPhiAxis->GetNbins(); ++j)
+         for (Int_t j = 1; j <= fPhiAxis->GetNbins(); ++j)
          {
-            bin = (i)+(j)*(fEtaAxis->GetNbins()+2);
+            const Int_t bin = (i)+(j)*(fEtaAxis->GetNbins()+2);
 
             if (rebinData.fBinData[bin] !=-1)
             {
                vals = rebinData.GetSliceVals(bin);
                offset =0;
-               for (Int_t t=0; t<s; t++)
-                  offset+=vals[t];
+               for (Int_t t = 0; t < s; ++t)
+                  offset += vals[t];
 
                y0 = fPhiAxis->GetBinLowEdge(j);
                y1 = fPhiAxis->GetBinUpEdge(j);
                WrapTwoPi(y0, y1);
-               {
-                  if (selection) glLoadName(bin);
-                  MakeQuad(fEtaAxis->GetBinLowEdge(i), y0, offset,
-                           fEtaAxis->GetBinWidth(i), y1-y0, vals[s]);
-               }
+
+               if (selection) glLoadName(bin);
+
+               MakeQuad(fEtaAxis->GetBinLowEdge(i), y0, offset,
+                        fEtaAxis->GetBinWidth(i), y1-y0, vals[s]);
             }
          }
       }
-      if (selection) glPopName();
       glEndList();
    }
 }
@@ -573,6 +575,9 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
 {
    // Draw XY axis.
 
+   if (fM->GetData()->Empty())
+      fAxisPainter.SetTMNDim(1);
+
    TGLCamera& cam  = rnrCtx.RefCamera();
 
    TAxis ax;
@@ -638,6 +643,8 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
    glTranslatef(fM->GetEtaMin(), 0, 0);
    fAxisPainter.PaintAxis(rnrCtx, &ax);
    glPopMatrix();
+
+   fAxisPainter.SetTMNDim(2); 
 }
 
 //______________________________________________________________________________
@@ -692,12 +699,12 @@ void TEveCaloLegoGL::RebinAxis(TAxis *orig, TAxis *curr) const
    Double_t bc     = orig->GetBinCenter(idx0);
    if (bc > center) --idx0;
 
-   Int_t nbR = TMath::FloorNint(idx0/fM->fBinStep) + TMath::FloorNint((orig->GetNbins() - idx0)/fM->fBinStep);
-   Int_t off = idx0 - TMath::FloorNint(idx0/fM->fBinStep)*fM->fBinStep;
+   Int_t nbR = TMath::FloorNint(idx0/fBinStep) + TMath::FloorNint((orig->GetNbins() - idx0)/fBinStep);
+   Int_t off = idx0 - TMath::FloorNint(idx0/fBinStep)*fBinStep;
    std::vector<Double_t> bins(nbR + 1);
    for (Int_t i = 0; i <= nbR; ++i)
    {
-      bins[i] = orig->GetBinUpEdge(off + i*fM->fBinStep);
+      bins[i] = orig->GetBinUpEdge(off + i*fBinStep);
    }
    curr->Set(nbR, &bins[0]);
 }
@@ -777,8 +784,11 @@ void TEveCaloLegoGL::DrawCells3D(TGLRnrCtx & rnrCtx) const
    // quads
    {
       for (SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i) {
-         TGLUtil::Color(fM->GetDataSliceColor(i->first));
+         TGLUtil::ColorTransparency(fM->GetDataSliceColor(i->first), fM->GetData()->GetSliceTransparency(i->first));
+         glLoadName(i->first);
+         glPushName(0);
          glCallList(i->second);
+         glPopName();
       }
    }
    // outlines
@@ -898,6 +908,8 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
    Float_t bws    = -1; //smallest bin
    Float_t logMax = -1;
 
+   Float_t baseOffset = fM->GetFixedHeightValIn2DMode()*fMaxVal;
+
    if (fM->f2DMode == TEveCaloLego::kValColor)
    {
       fM->AssertPalette();
@@ -907,13 +919,14 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
       {
          if (rnrCtx.SecSelection()) glLoadName(i->fId);
          glBegin(GL_POLYGON);
-         Float_t val = i->fSumVal;
-         fM->fPalette->ColorFromValue(TMath::FloorNint(val), col);
+         fM->fPalette->ColorFromValue(TMath::FloorNint(i->fSumVal), col);
+         col[3] = fM->GetData()->GetSliceTransparency(i->fMaxSlice);
          TGLUtil::Color4ubv(col);
-         glVertex3f(i->fX0, i->fY0, val);
-         glVertex3f(i->fX1, i->fY0, val);
-         glVertex3f(i->fX1, i->fY1, val);
-         glVertex3f(i->fX0, i->fY1, val);
+         Float_t z = fM->GetHasFixedHeightIn2DMode() ? baseOffset : i->fSumVal;
+         glVertex3f(i->fX0, i->fY0, z);
+         glVertex3f(i->fX1, i->fY0, z);
+         glVertex3f(i->fX1, i->fY1, z);
+         glVertex3f(i->fX0, i->fY1, z);
          glEnd();
       }
    }
@@ -939,27 +952,17 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
       {
          for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i)
          {
-            // point
             glLoadName(i->fMaxSlice);
             glPushName(i->fId);
-            TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
-            glBegin(GL_POINTS);
-            glVertex3f(i->X(), i->Y() , i->fSumVal);
-            glEnd();
-            glPopName();
 
-            // polygon
-            glLoadName(i->fMaxSlice);
-            glPushName(i->fId);
             glBegin(GL_QUADS);
-            Float_t bw = fValToPixel*TMath::Log10(i->fSumVal+1);
-            x = i->X();
-            y = i->Y();
-            glVertex3f(x - bw, y - bw, i->fSumVal);
-            glVertex3f(x + bw, y - bw, i->fSumVal);
-            glVertex3f(x + bw, y + bw, i->fSumVal);
-            glVertex3f(x - bw, y + bw, i->fSumVal);
+            Float_t z = fM->GetHasFixedHeightIn2DMode() ? baseOffset : i->fSumVal;
+            glVertex3f(i->fX0, i->fY0, z);
+            glVertex3f(i->fX1, i->fY0, z);
+            glVertex3f(i->fX1, i->fY1, z);
+            glVertex3f(i->fX0, i->fY1, z);
             glEnd();
+
             glPopName();
          }
       }
@@ -970,8 +973,9 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
             glBegin(GL_POINTS);
             for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i)
             {
-               TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
-               glVertex3f(i->X(), i->Y() , i->fSumVal);
+               TGLUtil::ColorTransparency(fM->fData->GetSliceColor(i->fMaxSlice), fM->fData->GetSliceTransparency(i->fMaxSlice));
+               Float_t z = fM->GetHasFixedHeightIn2DMode() ? baseOffset : i->fSumVal;
+               glVertex3f(i->X(), i->Y() , z);
             }
             glEnd();
          }
@@ -979,14 +983,15 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
          glBegin(GL_QUADS);
          for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i)
          {
-            TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
+            TGLUtil::ColorTransparency(fM->fData->GetSliceColor(i->fMaxSlice), fM->fData->GetSliceTransparency(i->fMaxSlice));
             Float_t bw = fValToPixel*TMath::Log10(i->fSumVal+1);
             x = i->X();
             y = i->Y();
-            glVertex3f(x - bw, y - bw, i->fSumVal);
-            glVertex3f(x + bw, y - bw, i->fSumVal);
-            glVertex3f(x + bw, y + bw, i->fSumVal);
-            glVertex3f(x - bw, y + bw, i->fSumVal);
+            Float_t z = fM->GetHasFixedHeightIn2DMode() ? baseOffset : i->fSumVal;
+            glVertex3f(x - bw, y - bw, z);
+            glVertex3f(x + bw, y - bw, z);
+            glVertex3f(x + bw, y + bw, z);
+            glVertex3f(x - bw, y + bw, z);
          }
          glEnd();
 
@@ -994,11 +999,13 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
          { 
             glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
             Float_t z    = 0;
-            Float_t zOff = fDataMax*0.1 ;
+            Float_t zOff = fDataMax*0.001 ; // avoid polygon stpiling
             glBegin(GL_QUADS);
             for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
-               TGLUtil::ColorTransparency(fM->fData->GetSliceColor(i->fMaxSlice), 80);
-               z = i->fSumVal - zOff;
+               Char_t transp = TMath::Min(100, 80 + fM->fData->GetSliceTransparency(i->fMaxSlice) / 5);
+               TGLUtil::ColorTransparency(fM->fData->GetSliceColor(i->fMaxSlice), transp);
+               z = fM->GetHasFixedHeightIn2DMode() ? baseOffset : i->fSumVal;
+               z -=  zOff;
                glVertex3f(i->fX0, i->fY0, z);
                glVertex3f(i->fX1, i->fY0, z);
                glVertex3f(i->fX1, i->fY1, z);
@@ -1010,7 +1017,8 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
             glBegin(GL_QUADS);
             for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
                TGLUtil::ColorTransparency(fM->fData->GetSliceColor(i->fMaxSlice), 60);
-               z = i->fSumVal + zOff;
+               z = fM->GetHasFixedHeightIn2DMode() ? baseOffset : i->fSumVal;
+               z +=  zOff;
                glVertex3f(i->fX0, i->fY0, z);
                glVertex3f(i->fX1, i->fY0, z);
                glVertex3f(i->fX1, i->fY1, z);
@@ -1048,21 +1056,16 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const
+void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* /*pshp*/, Int_t /*lvl*/) const
 {
-   // Draw eta-phi range in highlight mode.
+   // Draw highligted cells.
 
-   if (!fM->fData->GetCellsSelected().size() || pshp->GetSelected() != 2) return;
+   if (fM->fData->GetCellsSelected().empty() && fM->fData->GetCellsHighlighted().empty())
+   {
+      return;
+   }
 
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT );
-   glDisable(GL_LIGHTING);
-   glDisable(GL_CULL_FACE);
-   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
-
-   TGLUtil::LineWidth(2);
-   glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
-   rnrCtx.SetHighlightOutline(kTRUE);
-   TGLUtil::LockColor();
 
    // modelview matrix
    glPushMatrix();
@@ -1072,26 +1075,59 @@ void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps
    Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
    Float_t sx = (eM - em) / fM->GetEtaRng();
    Float_t sy = (pM - pm) / fM->GetPhiRng();
-   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetMaxTowerH() / fDataMax);
+   Float_t sz = (fM->fData->Empty() && (fM->GetScaleAbs() == false)) ? 1 : fM->GetMaxTowerH() / fDataMax;
+   glScalef(sx / unit, sy / unit, sz);
    glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
 
+   glDisable(GL_LIGHTING);
+   glDisable(GL_CULL_FACE);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+
+   TGLUtil::LineWidth(2);
+   TGLUtil::LockColor();
+   if (!fM->fData->GetCellsHighlighted().empty()) 
+   {
+      glColor4ubv(rnrCtx.ColorSet().Selection(3).CArr());
+      DrawSelectedCells(rnrCtx, fM->fData->GetCellsHighlighted());
+   }
+   if (!fM->fData->GetCellsSelected().empty())
+   {
+      Float_t dr[2];
+      glGetFloatv(GL_DEPTH_RANGE,dr);
+      glColor4ubv(rnrCtx.ColorSet().Selection(1).CArr());
+      glDepthRange(dr[0], 0.8*dr[1]);
+      DrawSelectedCells(rnrCtx, fM->fData->GetCellsSelected());
+      glDepthRange(dr[0], dr[1]);
+   }
+
+   TGLUtil::UnlockColor();
+   glPopMatrix();
+   glPopAttrib();
+}
+
+
+//______________________________________________________________________________
+void TEveCaloLegoGL::DrawSelectedCells(TGLRnrCtx & rnrCtx, TEveCaloData::vCellId_t cellsSelectedInput) const
+{
+   // Draw selected cells in highlight mode.
+
    // check eta&phi range of selected cells
-   TEveCaloData::vCellId_t cellsSelected;
+   TEveCaloData::vCellId_t  cellsSelected;
    TEveCaloData::CellData_t cellData;
-   for (TEveCaloData::vCellId_i i = fM->fData->GetCellsSelected().begin(); i != fM->fData->GetCellsSelected().end(); i++)
+   for (TEveCaloData::vCellId_i i = cellsSelectedInput.begin(); i != cellsSelectedInput.end(); ++i)
    {
       fM->fData->GetCellData((*i), cellData);
-      if(fM->CellInEtaPhiRng(cellData))
+      if (fM->CellInEtaPhiRng(cellData))
          cellsSelected.push_back(*i); 
    }
 
    // prepare rebin for 2D or 3D if necessary
    TEveCaloData::RebinData_t rebinDataSelected;
-   if (fM->fBinStep > 1)
+   if (fBinStep > 1)
    {
       fM->fData->Rebin(fEtaAxis, fPhiAxis, cellsSelected, fM->fPlotEt, rebinDataSelected);
       if (fM->fNormalizeRebin) {
-         Float_t scale = 1.f / (fM->fBinStep * fM->fBinStep);
+         Float_t scale = 1.f / (fBinStep * fBinStep);
          for (std::vector<Float_t>::iterator it = rebinDataSelected.fSliceData.begin(); it != rebinDataSelected.fSliceData.end(); it++)
             (*it) *= scale;
       }
@@ -1099,45 +1135,39 @@ void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps
 
    if (fCells3D)
    {
-      Int_t   prevTower = 0;
-      Float_t offset    = 0;
-      Int_t   nSlices   = fM->fData->GetNSlices();
-      if (fM->fBinStep == 1)
+      Float_t offset =  0;
+      if (fBinStep == 1)
       {
-         TEveCaloData::vCellId_i      j = cellsSelected.begin();
-         for (TEveCaloData::vCellId_i i = fM->fCellList.begin(); i != fM->fCellList.end(); ++i) {
-            if (i->fTower != prevTower) {
-               offset = 0;
-               prevTower = i->fTower;
-            }
-
-            // ceheck if this cell is in the list of slected cells
-            if (j->fTower == i->fTower && j->fSlice == i->fSlice)
+         for (TEveCaloData::vCellId_i j = cellsSelected.begin(); j != cellsSelected.end(); ++j)
+         {
+            offset = 0;
             {
-               fM->fData->GetCellData((*j), cellData);
-               WrapTwoPi(cellData.fPhiMin, cellData.fPhiMax);
-               MakeQuad(cellData.EtaMin(), cellData.PhiMin(), offset,
-                        cellData.EtaDelta(), cellData.PhiDelta(), cellData.Value(fM->fPlotEt));
-               j++;
-               if (j == cellsSelected.end())
-                  break;
+               Int_t   orig_slice = j->fSlice;
+               for (Int_t s = 0; s < orig_slice; ++s)
+               {
+                  j->fSlice = s;
+                  fM->fData->GetCellData(*j, cellData);
+                  offset += cellData.Value(fM->fPlotEt);
+               }
+               j->fSlice = orig_slice;
             }
-
-            fM->fData->GetCellData((*i), cellData);
-            offset += cellData.Value(fM->fPlotEt);
+            fM->fData->GetCellData(*j, cellData);
+            WrapTwoPi(cellData.fPhiMin, cellData.fPhiMax);
+            MakeQuad(cellData.EtaMin(), cellData.PhiMin(), offset,
+                     cellData.EtaDelta(), cellData.PhiDelta(), cellData.Value(fM->fPlotEt));
          }
       }
       else
       {
-         Int_t bin;
          Float_t *vals;
          Float_t *valsRef;
-         Float_t y0, y1;
-         for (Int_t i=1; i<= fEtaAxis->GetNbins(); ++i)
+         Float_t  y0, y1;
+         Int_t    nSlices = fM->fData->GetNSlices();
+         for (Int_t i = 1; i <= fEtaAxis->GetNbins(); ++i)
          {
-            for (Int_t j=1; j <= fPhiAxis->GetNbins(); ++j)
+            for (Int_t j = 1; j <= fPhiAxis->GetNbins(); ++j)
             {
-               bin = (i)+(j)*(fEtaAxis->GetNbins()+2);
+               const Int_t bin = (i)+(j)*(fEtaAxis->GetNbins()+2);
                if (rebinDataSelected.fBinData[bin] !=-1)
                {
                   offset  = 0;
@@ -1163,37 +1193,33 @@ void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps
    else
    {
       vCell2D_t cells2DSelected;
-      if (fM->fBinStep == 1)
+      if (fBinStep == 1)
       {
-         // could be exact and call
-         // PrepareCell2DData( fM->fData->GetCellsSelected(), cells2DSelected);
-         // but is confusing since top view does no tdraw all slices at same time
-         TEveCaloData::vCellId_i j    = fM->fData->GetCellsSelected().begin();
-         TEveCaloData::vCellId_i jEnd = fM->fData->GetCellsSelected().end();
-         for ( vCell2D_i i = fCells2D.begin(); i != fCells2D.end(); ++i) {
+         // but is confusing since top view does not draw all slices at same time
+         TEveCaloData::vCellId_i j    = cellsSelectedInput.begin();
+         TEveCaloData::vCellId_i jEnd = cellsSelectedInput.end();
+         std::set<Int_t> towers;
+         while (j != jEnd)
+         {
+            towers.insert(j->fTower);
+            ++j;
+         }
+         for (vCell2D_i i = fCells2D.begin(); i != fCells2D.end(); ++i)
+         {
             TEveCaloData::CellId_t cell = fM->fCellList[i->fId];
-            if (cell.fTower == j->fTower)
+            std::set<Int_t>::iterator ti = towers.find(cell.fTower);
+            if (towers.find(cell.fTower) != towers.end())
             {
                cells2DSelected.push_back(*i);
-               while (cell.fTower == j->fTower && j != jEnd)
-                  j++;
-
             }
-
          }
       }
       else
+      {
          PrepareCell2DDataRebin(rebinDataSelected, cells2DSelected);
-
+      }
       DrawCells2D(rnrCtx, cells2DSelected);
-      fCells2D.clear(); // clear cache
    }
-
-
-   TGLUtil::UnlockColor();
-   rnrCtx.SetHighlightOutline(kFALSE);
-   glPopMatrix();
-   glPopAttrib();
 }
 
 //______________________________________________________________________________
@@ -1216,16 +1242,16 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    Int_t new_bin_step = GetGridStep(rnrCtx);
 
    // rebin data
-   if (fM->AssertCellIdCache() || fM->fBinStep != new_bin_step)
+   if (fM->AssertCellIdCache() || fBinStep != new_bin_step)
    {
-      fM->fBinStep = new_bin_step;
+      fBinStep = new_bin_step;
       fDLCacheOK   = kFALSE;
       fRebinData.Clear();
 
       RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
       RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
 
-      if (fM->fBinStep > 1)
+      if (fBinStep > 1)
       {
          fM->fData->Rebin(fEtaAxis, fPhiAxis, fM->fCellList, fM->fPlotEt, fRebinData);
 
@@ -1242,7 +1268,7 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
          if (fM->fNormalizeRebin)
          {
-            Float_t scale = 1.f / (fM->fBinStep * fM->fBinStep);
+            Float_t scale = 1.f / (fBinStep * fBinStep);
             for (std::vector<Float_t>::iterator it = fRebinData.fSliceData.begin(); it != fRebinData.fSliceData.end(); it++)
             {
                (*it) *= scale;
@@ -1267,10 +1293,10 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    glPushMatrix();
    Float_t sx = (eM - em) / fM->GetEtaRng();
    Float_t sy = (pM - pm) / fM->GetPhiRng();
-   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetMaxTowerH() / fDataMax);
+   Float_t sz = (fM->fData->Empty() && (fM->GetScaleAbs() == false)) ? 1 : fM->GetMaxTowerH() / fDataMax;
+   glScalef(sx / unit, sy / unit, sz);
    glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
 
-
    fFontColor = fM->fFontColor;
    fGridColor = fM->fGridColor;
    if (fGridColor < 0 || fFontColor < 0)
@@ -1295,16 +1321,15 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
    TGLUtil::LineWidth(1);
    glEnable(GL_BLEND);
-
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    if (!fM->fData->Empty())
    {
       glPushName(0);
-      glLoadName(0);
       if (fCells3D)
       {
          if (fDLCacheOK == kFALSE)
          {
-            if (fM->fBinStep == 1)
+            if (fBinStep == 1)
                Make3DDisplayList(fM->fCellList, fDLMap, kTRUE);
             else
                Make3DDisplayListRebin(fRebinData, fDLMap, kTRUE);
@@ -1315,11 +1340,13 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
          glPolygonOffset(0.8, 1);
 
          DrawCells3D(rnrCtx);
-      } else {
+      }
+      else
+      {
          glDisable(GL_LIGHTING);
 
          fCells2D.clear();
-         if (fM->fBinStep == 1)
+         if (fBinStep == 1)
             PrepareCell2DData(fM->fCellList, fCells2D);
          else
             PrepareCell2DDataRebin(fRebinData, fCells2D);
@@ -1360,56 +1387,83 @@ void TEveCaloLegoGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord &
 {
    // Processes tower selection from TGLViewer.
 
-   Int_t prev = fM->fData->GetCellsSelected().size();
-   if (!rec.GetMultiple()) fM->fData->GetCellsSelected().clear();
-
-   Int_t cellID = -1;
-
-   if (rec.GetN() > 1)
+   TEveCaloData::vCellId_t sel;
+   if (rec.GetN() > 2)
    {
-      cellID = rec.GetItem(2);
-      Int_t slice  = rec.GetItem(1);
+      Int_t slice = rec.GetItem(1);
+      Int_t cell  = rec.GetItem(2);
 
-      if (fM->fBinStep == 1)
+      if (fBinStep == 1)
       {
-         Int_t tower = fM->fCellList[cellID].fTower;
-         while (cellID > 0 && tower == fM->fCellList[cellID].fTower)
+         Int_t tower = fM->fCellList[cell].fTower;
+         while (cell > 0 && tower == fM->fCellList[cell].fTower)
          {
-            fM->fData->GetCellsSelected().push_back(fM->fCellList[cellID]);
+            sel.push_back(fM->fCellList[cell]);
             if (fCells3D) break;
-            --cellID;
+            --cell;
          }
       }
-      else  {
-         if (cellID >0)
+      else
+      {
+         if (cell > 0)
          {
             Int_t nEta   = fEtaAxis->GetNbins();
-            Int_t phiBin = Int_t(cellID/(nEta+2));
-            Int_t etaBin = cellID - phiBin*(nEta+2);
+            Int_t phiBin = Int_t(cell/(nEta+2));
+            Int_t etaBin = cell - phiBin*(nEta+2);
             TEveCaloData::vCellId_t sl;
             fM->fData->GetCellList(fEtaAxis->GetBinCenter(etaBin), fEtaAxis->GetBinWidth(etaBin),
                                    fPhiAxis->GetBinCenter(phiBin), fPhiAxis->GetBinWidth(phiBin),
                                    sl);
 
-            for(TEveCaloData::vCellId_i it = sl.begin(); it != sl.end(); ++it)
+            for (TEveCaloData::vCellId_i it = sl.begin(); it != sl.end(); ++it)
             {
                if (fCells3D) {
-                  if ((*it).fSlice == slice )fM->fData->GetCellsSelected().push_back(*it);
+                  if ((*it).fSlice == slice ) sel.push_back(*it);
                } else {
-                  if ((*it).fSlice <= slice )fM->fData->GetCellsSelected().push_back(*it);
+                  if ((*it).fSlice <= slice ) sel.push_back(*it);
                }
-
             }
          }
       }
    }
-
-   if (prev == 0 && cellID >= 0)
-      rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
-   else if (prev  && cellID < 0)
-      rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
-   else if (prev  && cellID >= 0)
-      rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
-
-   fM->fData->CellSelectionChanged();
+   fM->fData->ProcessSelection(sel, rec);
+
+   // if (rec.GetN() > 1)
+   // {
+   //    Int_t cellID = rec.GetItem(2);
+   //    Int_t slice = rec.GetItem(1);
+
+   //    if (fBinStep == 1)
+   //    {
+   //       Int_t tower = fM->fCellList[cellID].fTower;
+   //       while (cellID > 0 && tower == fM->fCellList[cellID].fTower)
+   //       {
+   //          cells.push_back(fM->fCellList[cellID]);
+   //          if (fCells3D) break;
+   //          --cellID;
+   //       }
+   //    }
+   //    else
+   //    {
+   //       if (cellID > 0)
+   //       {
+   //          Int_t nEta   = fEtaAxis->GetNbins();
+   //          Int_t phiBin = Int_t(cellID/(nEta+2));
+   //          Int_t etaBin = cellID - phiBin*(nEta+2);
+   //          TEveCaloData::vCellId_t sl;
+   //          fM->fData->GetCellList(fEtaAxis->GetBinCenter(etaBin), fEtaAxis->GetBinWidth(etaBin),
+   //                                 fPhiAxis->GetBinCenter(phiBin), fPhiAxis->GetBinWidth(phiBin),
+   //                                 sl);
+
+   //          for (TEveCaloData::vCellId_i it = sl.begin(); it != sl.end(); ++it)
+   //          {
+   //             if (fCells3D) {
+   //                if ((*it).fSlice == slice ) cells.push_back(*it);
+   //             } else {
+   //                if ((*it).fSlice <= slice ) cells.push_back(*it);
+   //             }
+   //          }
+   //       }
+   //    }
+   // }
 }
diff --git a/graf3d/eve/src/TEveCaloLegoOverlay.cxx b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
index 45f6072..a55153a 100644
--- a/graf3d/eve/src/TEveCaloLegoOverlay.cxx
+++ b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
@@ -10,6 +10,7 @@
  *************************************************************************/
 
 #include "TEveCaloLegoOverlay.h"
+#include "TEveCaloLegoGL.h"
 
 #include "TAxis.h"
 #include "TColor.h"
@@ -20,6 +21,7 @@
 #include "TGLIncludes.h"
 #include "TGLSelectRecord.h"
 #include "TGLUtil.h"
+#include "TGLViewerBase.h"
 #include "TGLCamera.h"
 #include "TGLAxisPainter.h"
 #include "TGLFontManager.h"
@@ -49,6 +51,7 @@ TEveCaloLegoOverlay::TEveCaloLegoOverlay() :
    fShowScales(kTRUE),
    fScaleColor(-1), fScaleTransparency(0),
    fScaleCoordX(0.85), fScaleCoordY(0.65),
+   fScaleW(0), fScaleH(0),
    fCellX(-1), fCellY(-1),
 
    fFrameColor(-1), fFrameLineTransp(70), fFrameBgTransp(90),
@@ -210,7 +213,7 @@ void TEveCaloLegoOverlay::MouseLeave()
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoOverlay::SetScaleColorTransparency(Color_t colIdx, UChar_t transp)
+void TEveCaloLegoOverlay::SetScaleColorTransparency(Color_t colIdx, Char_t transp)
 {
    // Set color and transparency of scales.
 
@@ -228,7 +231,7 @@ void TEveCaloLegoOverlay::SetScalePosition(Double_t x, Double_t y)
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoOverlay:: SetFrameAttribs(Color_t frameColor, UChar_t lineTransp, UChar_t bgTransp)
+void TEveCaloLegoOverlay:: SetFrameAttribs(Color_t frameColor, Char_t lineTransp, Char_t bgTransp)
 {
    // Set frame attribs.
 
@@ -634,11 +637,13 @@ void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
       TGLVertex3 p;
       TGLVector3 res = cam.WorldDeltaToViewport(p, rng);
 
-      if (fShowScales)
+      TEveCaloLegoGL* lgl = dynamic_cast<TEveCaloLegoGL*>(rnrCtx.RefViewer().FindLogicalInScenes(fCalo));
+      if (fShowScales && lgl)
       {
+
          // get smallest bin
          Double_t sq = 1e4;
-         if (fCalo->fBinStep == 1)
+         if (lgl->fBinStep == 1)
          {
             TEveCaloData::CellData_t cellData;
             for ( TEveCaloData::vCellId_t::iterator i = fCalo->fCellList.begin(); i != fCalo->fCellList.end(); ++i)
@@ -666,7 +671,7 @@ void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
                if (sq > a->GetBinWidth(i)) sq = a->GetBinWidth(i);
             }
 
-            sq *= fCalo->fBinStep;
+            sq *= lgl->fBinStep;
          }
          fCellX = (res.X()*sq)/(fCalo->GetEtaRng()*1.*cam.RefViewport().Width());
          fCellY = (res.Y()*sq)/(fCalo->GetPhiRng()*1.*cam.RefViewport().Height());
diff --git a/graf3d/eve/src/TEveCaloVizEditor.cxx b/graf3d/eve/src/TEveCaloVizEditor.cxx
index 65a2baa..91dcaf0 100644
--- a/graf3d/eve/src/TEveCaloVizEditor.cxx
+++ b/graf3d/eve/src/TEveCaloVizEditor.cxx
@@ -182,6 +182,15 @@ void TEveCaloVizEditor::MakeSliceInfo()
          f->AddFrame(color, new TGLayoutHints(kLHintsLeft|kLHintsTop, 3, 1, 0, 1));
          color->Connect("ColorSelected(Pixel_t)", "TEveCaloVizEditor", this, "DoSliceColor(Pixel_t)");
 
+         TGNumberEntry* transparency = new TGNumberEntry(f, 0., 2, i,
+                                           TGNumberFormat::kNESInteger, TGNumberFormat::kNEANonNegative,
+                                           TGNumberFormat::kNELLimitMinMax, 0, 100);
+         transparency->SetHeight(18);
+         transparency->GetNumberEntry()->SetToolTipText("Transparency: 0 is opaque, 100 fully transparent.");
+         f->AddFrame(transparency, new TGLayoutHints(kLHintsLeft, 0, 0, 0, 0));
+         transparency->Connect("ValueSet(Long_t)", "TEveCaloVizEditor", this, "DoSliceTransparency(Long_t)");
+
+
          fSliceFrame->AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 1, 0));
       }
       nf = ns;
@@ -196,12 +205,14 @@ void TEveCaloVizEditor::MakeSliceInfo()
       {
          TEveCaloData::SliceInfo_t &si = fM->GetData()->RefSliceInfo(i);
 
-         TEveGValuator *threshold = (TEveGValuator*) ((TGFrameElement*) fr->GetList()->First())->fFrame;
-         TGColorSelect *color     = (TGColorSelect*) ((TGFrameElement*) fr->GetList()->Last() )->fFrame;
+         TEveGValuator *threshold = (TEveGValuator*) ((TGFrameElement*) fr->GetList()->At(0))->fFrame;
+         TGColorSelect *color     = (TGColorSelect*) ((TGFrameElement*) fr->GetList()->At(1) )->fFrame;
+         TGNumberEntry *transp    = (TGNumberEntry*) ((TGFrameElement*) fr->GetList()->At(2))->fFrame;
 
          threshold->GetLabel()->SetText(si.fName);
          threshold->SetValue(si.fThreshold);
          color->SetColor(TColor::Number2Pixel(si.fColor), kFALSE);
+         transp->SetNumber(si.fTransparency);
 
          if (! fr->IsMapped()) {
             fr->MapSubwindows();
@@ -359,6 +370,16 @@ void TEveCaloVizEditor::DoSliceColor(Pixel_t pixel)
    Update();
 }
 
+//______________________________________________________________________________
+void TEveCaloVizEditor::DoSliceTransparency(Long_t t)
+{
+   // Slot for slice transparency.
+
+   TGNumberEntry *cs = (TGNumberEntry*) gTQSender;
+   fM->GetData()->SetSliceTransparency(cs->WidgetId(), t);
+   Update();
+}
+
 /**************************************************************************/
 /**************************************************************************/
 /**************************************************************************/
@@ -409,6 +430,6 @@ void TEveCalo3DEditor::DoFrameTransparency()
 {
    // Slot for frame transparency.
 
-   fM->SetFrameTransparency((UChar_t)(fFrameTransparency->GetNumber()));
+   fM->SetFrameTransparency((Char_t)(fFrameTransparency->GetNumber()));
    Update();
 }
diff --git a/graf3d/eve/src/TEveChunkManager.cxx b/graf3d/eve/src/TEveChunkManager.cxx
index 1420d47..19eb37c 100644
--- a/graf3d/eve/src/TEveChunkManager.cxx
+++ b/graf3d/eve/src/TEveChunkManager.cxx
@@ -12,7 +12,6 @@
 #include "TEveChunkManager.h"
 
 //______________________________________________________________________________
-// TEveChunkManager
 //
 // Vector-like container with chunked memory allocation.
 //
@@ -22,9 +21,10 @@
 // The structure can be Refit() to occupy a single contiguous array.
 //
 
-ClassImp(TEveChunkManager)
-ClassImp(TEveChunkManager::iterator)
+ClassImp(TEveChunkManager);
+ClassImp(TEveChunkManager::iterator);
 
+//______________________________________________________________________________
 void TEveChunkManager::ReleaseChunks()
 {
    // Release all memory chunks.
@@ -107,3 +107,53 @@ Char_t* TEveChunkManager::NewChunk()
    fCapacity += fN;
    return fChunks.back()->fArray;
 }
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+Bool_t TEveChunkManager::iterator::next()
+{
+   // Go to next atom.
+
+   if (fSelection == 0)
+   {
+      if (fAtomsToGo <= 0)
+      {
+         if (fNextChunk < fPlex->VecSize())
+         {
+            fCurrent   = fPlex->Chunk(fNextChunk);
+            fAtomsToGo = fPlex->NAtoms(fNextChunk);
+            ++fNextChunk;
+         }
+         else
+         {
+            return kFALSE;
+         }
+      }
+      else
+      {
+         fCurrent += fPlex->S();
+      }
+      ++fAtomIndex;
+      --fAtomsToGo;
+      return kTRUE;
+   }
+   else
+   {
+      if (fAtomIndex == -1)
+         fSelectionIterator = fSelection->begin();
+      else
+         ++fSelectionIterator;
+
+      if (fSelectionIterator != fSelection->end())
+      {
+         fAtomIndex = *fSelectionIterator;
+         fCurrent   =  fPlex->Atom(fAtomIndex);
+         return kTRUE;
+      }
+      else
+      {
+         return kFALSE;
+      }
+   }
+}
diff --git a/graf3d/eve/src/TEveCompound.cxx b/graf3d/eve/src/TEveCompound.cxx
index eea62de..f88b4fa 100644
--- a/graf3d/eve/src/TEveCompound.cxx
+++ b/graf3d/eve/src/TEveCompound.cxx
@@ -24,8 +24,8 @@
 ClassImp(TEveCompound);
 
 //______________________________________________________________________________
-TEveCompound::TEveCompound(const char* n, const char* t, Bool_t doColor) :
-   TEveElementList (n, t, doColor),
+TEveCompound::TEveCompound(const char* n, const char* t, Bool_t doColor, Bool_t doTransparency) :
+   TEveElementList (n, t, doColor, doTransparency),
    fCompoundOpen   (0)
 {
    // Constructor.
@@ -35,17 +35,57 @@ TEveCompound::TEveCompound(const char* n, const char* t, Bool_t doColor) :
 void TEveCompound::SetMainColor(Color_t color)
 {
    // SetMainColor for the compound.
-   // The color is also propagated to children (compouind elements)
-   // whoose current color is the same as the old color.
+   // The color is also propagated to children with compound set to this
+   // whose current color is the same as the old color.
+   //
+   // The following CompoundSelectionColorBits have further influence:
+   //   kCSCBApplyMainColorToAllChildren      - apply color to all children;
+   //   kCSCBApplyMainColorToMatchingChildren - apply color to children who have
+   //                                           matching old color.
 
    Color_t old_color = GetMainColor();
 
    TEveElement::SetMainColor(color);
 
+   Bool_t color_all      = TestCSCBits(kCSCBApplyMainColorToAllChildren);
+   Bool_t color_matching = TestCSCBits(kCSCBApplyMainColorToMatchingChildren);
+
    for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
    {
-      if ((*i)->GetCompound() == this && (*i)->GetMainColor() == old_color)
+      if (color_all || (color_matching && (*i)->GetMainColor() == old_color) ||
+          ((*i)->GetCompound() == this && (*i)->GetMainColor() == old_color))
+      {
          (*i)->SetMainColor(color);
+      }
+   }
+}
+
+//______________________________________________________________________________
+void TEveCompound::SetMainTransparency(Char_t t)
+{
+   // SetMainTransparency for the compound.
+   // The transparenct is also propagated to children with compound set to this
+   // whose current transparency is the same as the old transparency.
+   //
+   // The following CompoundSelectionColorBits have further influence:
+   //   kCSCBApplyMainTransparencyToAllChildren      - apply transparency to all children;
+   //   kCSCBApplyMainTransparencyToMatchingChildren - apply transparency to children who have
+   //                                                  matching transparency.
+
+   Char_t old_t = GetMainTransparency();
+
+   TEveElement::SetMainTransparency(t);
+
+   Bool_t chg_all      = TestCSCBits(kCSCBApplyMainTransparencyToAllChildren);
+   Bool_t chg_matching = TestCSCBits(kCSCBApplyMainTransparencyToMatchingChildren);
+
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      if (chg_all || (chg_matching && (*i)->GetMainTransparency() == old_t) ||
+          ((*i)->GetCompound() == this && (*i)->GetMainTransparency() == old_t))
+      {
+         (*i)->SetMainTransparency(t);
+      }
    }
 }
 
@@ -96,19 +136,23 @@ void TEveCompound::FillImpliedSelectedSet(Set_t& impSelSet)
 {
    // Recurse on all children that are in this compund and
    // call the base-class version.
+   // If SelectionColorBit kSCBImplySelectAllChildren is set, then all
+   // children are added to the set.
    //
    // Note that projected replicas of the compound will be added to
    // the set in base-class function that handles projectables.
 
-   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   Bool_t select_all = TestCSCBits(kCSCBImplySelectAllChildren);
+
+   for (List_i i = fChildren.begin(); i != fChildren.end(); ++i)
    {
-      if ((*i)->GetCompound() == this)
+      if (select_all || (*i)->GetCompound() == this)
       {
-         impSelSet.insert(*i);
-         (*i)->FillImpliedSelectedSet(impSelSet);
+         if (impSelSet.insert(*i).second)
+            (*i)->FillImpliedSelectedSet(impSelSet);
       }
-
    }
+
    TEveElementList::FillImpliedSelectedSet(impSelSet);
 }
 
diff --git a/graf3d/eve/src/TEveDigitSet.cxx b/graf3d/eve/src/TEveDigitSet.cxx
index 46bddd9..1b16d9a 100644
--- a/graf3d/eve/src/TEveDigitSet.cxx
+++ b/graf3d/eve/src/TEveDigitSet.cxx
@@ -14,6 +14,7 @@
 #include "TEveTrans.h"
 
 #include "TColor.h"
+#include "TRefArray.h"
 
 
 //______________________________________________________________________________
@@ -60,11 +61,15 @@ TEveDigitSet::TEveDigitSet(const char* n, const char* t) :
    TEveElement     (fColor),
    TNamed          (n, t),
 
+   fDigitIds       (0),
    fDefaultValue   (kMinInt),
    fValueIsColor   (kFALSE),
+   fSingleColor    (kFALSE),
+   fAntiFlick      (kTRUE),
    fOwnIds         (kFALSE),
    fPlex           (),
    fLastDigit      (0),
+   fLastIdx        (-1),
 
    fColor          (kWhite),
    fFrame          (0),
@@ -73,10 +78,13 @@ TEveDigitSet::TEveDigitSet(const char* n, const char* t) :
    fDisableLigting (kTRUE),
    fHistoButtons   (kTRUE),
    fEmitSignals    (kFALSE),
-   fCallbackFoo    (0)
+   fCallbackFoo    (0),
+   fTooltipCBFoo   (0)
 {
    // Constructor.
 
+   fCanEditMainColor        = kTRUE;
+   fCanEditMainTransparency = kTRUE;
    InitMainTrans();
 }
 
@@ -91,6 +99,7 @@ TEveDigitSet::~TEveDigitSet()
    SetPalette(0);
    if (fOwnIds)
       ReleaseIds();
+   delete fDigitIds;
 }
 
 /******************************************************************************/
@@ -100,6 +109,7 @@ TEveDigitSet::DigitBase_t* TEveDigitSet::NewDigit()
 {
    // Protected method called whenever a new digit is added.
 
+   fLastIdx   = fPlex.Size();
    fLastDigit = new (fPlex.NewAtom()) DigitBase_t(fDefaultValue);
    return fLastDigit;
 }
@@ -110,18 +120,18 @@ void TEveDigitSet::ReleaseIds()
    // Protected method. Release and delete the referenced objects, the
    // ownership is *NOT* checked.
 
-   TEveChunkManager::iterator qi(fPlex);
-   while (qi.next()) {
-      DigitBase_t& q = * (DigitBase_t*) qi();
-      if (q.fId.GetObject()) {
-         delete q.fId.GetObject();
-         q.fId = 0;
-      }
+   if (fDigitIds)
+   {
+      const Int_t N = fDigitIds->GetSize();
+
+      for (Int_t i = 0; i < N; ++i)
+         delete fDigitIds->At(i);
+
+      fDigitIds->Expand(0);
    }
 }
 
-/******************************************************************************/
-/******************************************************************************/
+//------------------------------------------------------------------------------
 
 //______________________________________________________________________________
 void TEveDigitSet::UseSingleColor()
@@ -148,6 +158,55 @@ void TEveDigitSet::SetMainColor(Color_t color)
    }
 }
 
+//______________________________________________________________________________
+void TEveDigitSet::UnSelected()
+{
+   // Virtual function called when both fSelected is false and
+   // fImpliedSelected is 0.
+
+   fSelectedSet.clear();
+   TEveElement::UnSelected();
+}
+
+//______________________________________________________________________________
+void TEveDigitSet::UnHighlighted()
+{
+   // Virtual function called when both fHighlighted is false and
+   // fImpliedHighlighted is 0.
+
+   fHighlightedSet.clear();
+   TEveElement::UnHighlighted();
+}
+
+//______________________________________________________________________________
+TString TEveDigitSet::GetHighlightTooltip()
+{
+   // Return tooltip for highlighted element if always-sec-select is set.
+   // Otherwise return the tooltip for this element.
+
+   if (fHighlightedSet.empty()) return "";
+
+   if (GetAlwaysSecSelect())
+   {
+      if (fTooltipCBFoo)
+      {
+         return (fTooltipCBFoo)(this, *fHighlightedSet.begin());
+      }
+      else if (fDigitIds)
+      {
+         TObject *o = GetId(*fHighlightedSet.begin());
+         if (o)
+            return TString(o->GetName());
+      }
+      return TString::Format("%s; idx=%d", GetElementName(), *fHighlightedSet.begin());
+   }
+   else
+   {
+      return TEveElement::GetHighlightTooltip();
+   }
+}
+
+
 /******************************************************************************/
 /******************************************************************************/
 
@@ -189,6 +248,18 @@ void TEveDigitSet::ScanMinMaxValues(Int_t& min, Int_t& max)
 /******************************************************************************/
 
 //______________________________________________________________________________
+void TEveDigitSet::SetCurrentDigit(Int_t idx)
+{
+   // Set current digit -- the one that will receive calls to
+   // DigitValue/Color/Id/UserData() functions.
+   // Note that various AddXyzz() functions set the current digit to the newly
+   // added one.
+
+   fLastIdx   = idx;
+   fLastDigit = GetDigit(idx);
+}
+
+//______________________________________________________________________________
 void TEveDigitSet::DigitValue(Int_t value)
 {
    // Set signal value for the last digit added.
@@ -205,7 +276,7 @@ void TEveDigitSet::DigitColor(Color_t ci)
 }
 
 //______________________________________________________________________________
-void TEveDigitSet::DigitColor(Color_t ci, UChar_t transparency)
+void TEveDigitSet::DigitColor(Color_t ci, Char_t transparency)
 {
    // Set color for the last digit added.
 
@@ -235,7 +306,53 @@ void TEveDigitSet::DigitId(TObject* id)
 {
    // Set external object reference for the last digit added.
 
-   fLastDigit->fId = id;
+   DigitId(fLastIdx, id);
+}
+
+//______________________________________________________________________________
+void TEveDigitSet::DigitUserData(void* ud)
+{
+   // Set user-data for the last digit added.
+
+   fLastDigit->fUserData = ud;
+}
+
+//______________________________________________________________________________
+void TEveDigitSet::DigitId(Int_t n, TObject* id)
+{
+   // Set external object reference for digit n.
+
+   if (!fDigitIds)
+      fDigitIds = new TRefArray;
+
+   if (fOwnIds && n < fDigitIds->GetSize() && fDigitIds->At(n))
+      delete fDigitIds->At(n);
+
+   fDigitIds->AddAtAndExpand(id, n);
+}
+
+//______________________________________________________________________________
+void TEveDigitSet::DigitUserData(Int_t n, void* ud)
+{
+   // Set user-data for digit n.
+
+   GetDigit(n)->fUserData = ud;
+}
+
+//______________________________________________________________________________
+TObject* TEveDigitSet::GetId(Int_t n) const
+{
+   // Return external TObject associated with digit n.
+
+   return fDigitIds ? fDigitIds->At(n) : 0;
+}
+
+//______________________________________________________________________________
+void* TEveDigitSet::GetUserData(Int_t n) const
+{
+   // Get user-data associated with digit n.
+
+   return GetDigit(n)->fUserData;
 }
 
 /******************************************************************************/
@@ -253,9 +370,10 @@ void TEveDigitSet::Paint(Option_t*)
 void TEveDigitSet::DigitSelected(Int_t idx)
 {
    // Called from renderer when a digit with index idx is selected.
+   // This is by-passed when always-secondary-select is active.
 
    DigitBase_t *qb  = GetDigit(idx);
-   TObject     *obj = qb->fId.GetObject();
+   TObject     *obj = GetId(idx);
 
    if (fCallbackFoo) {
       (fCallbackFoo)(this, idx, obj);
@@ -274,6 +392,7 @@ void TEveDigitSet::DigitSelected(Int_t idx)
 void TEveDigitSet::SecSelected(TEveDigitSet* qs, Int_t idx)
 {
    // Emit a SecSelected signal.
+   // This is by-passed when always-secondary-select is active.
 
    Long_t args[2];
    args[0] = (Long_t) qs;
diff --git a/graf3d/eve/src/TEveDigitSetGL.cxx b/graf3d/eve/src/TEveDigitSetGL.cxx
new file mode 100644
index 0000000..71d4615
--- /dev/null
+++ b/graf3d/eve/src/TEveDigitSetGL.cxx
@@ -0,0 +1,121 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveDigitSetGL.h"
+
+#include "TGLRnrCtx.h"
+#include "TGLSelectRecord.h"
+#include "TGLIncludes.h"
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEveDigitSet.
+//
+
+ClassImp(TEveDigitSetGL);
+
+//______________________________________________________________________________
+TEveDigitSetGL::TEveDigitSetGL() :
+   TGLObject(), fHighlightSet(0)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+Bool_t TEveDigitSetGL::SetupColor(const TEveDigitSet::DigitBase_t& q) const
+{
+   // Set color for rendering of the specified digit.
+
+   TEveDigitSet& DS = * (TEveDigitSet*)fExternalObj;
+
+   if (DS.fSingleColor)
+   {
+      return kTRUE;
+   }
+   else if (DS.fValueIsColor)
+   {
+      if (q.fValue != 0)
+      {
+         TGLUtil::Color4ubv((UChar_t*) & q.fValue);
+         return kTRUE;
+      } else {
+         return kFALSE;
+      }
+   }
+   else
+   {
+      UChar_t c[4];
+      Bool_t visible = DS.fPalette->ColorFromValue(q.fValue, DS.fDefaultValue, c);
+      if (visible)
+         TGLUtil::Color3ubv(c);
+      return visible;
+   }
+}
+
+//______________________________________________________________________________
+void TEveDigitSetGL::SetBBox()
+{
+   // Set bounding box.
+
+   SetAxisAlignedBBox(((TEveDigitSet*)fExternalObj)->AssertBBox());
+}
+
+//______________________________________________________________________________
+void TEveDigitSetGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t /*lvl*/) const
+{
+   // Draw the quad-set in highlight mode.
+   // Incoming lvl is ignored -- physical shape always calls it with -1.
+
+   TEveDigitSet& DS = * (TEveDigitSet*)fExternalObj;
+
+   if (AlwaysSecondarySelect())
+   {
+      Float_t dr[2];
+      glGetFloatv(GL_DEPTH_RANGE,dr);
+
+      if ( ! DS.RefHighlightedSet().empty())
+      {
+         fHighlightSet = & DS.RefHighlightedSet();
+         TGLObject::DrawHighlight(rnrCtx, pshp, 3);
+      }
+      if ( ! DS.RefSelectedSet().empty())
+      {
+         glDepthRange(dr[0], 0.8*dr[1]);
+         fHighlightSet = & DS.RefSelectedSet();
+         TGLObject::DrawHighlight(rnrCtx, pshp, 1);
+         glDepthRange(dr[0], dr[1]);
+      }
+      fHighlightSet = 0;
+   }
+   else
+   {
+      TGLObject::DrawHighlight(rnrCtx, pshp);
+   }
+}
+
+//______________________________________________________________________________
+void TEveDigitSetGL::ProcessSelection(TGLRnrCtx& /*rnrCtx*/, TGLSelectRecord& rec)
+{
+   // Processes secondary selection from TGLViewer.
+   // Calls DigitSelected(Int_t) in the model object with index of
+   // selected point as the argument.
+
+   TEveDigitSet& DS = * (TEveDigitSet*)fExternalObj;
+
+   if (AlwaysSecondarySelect())
+   {
+      DS.ProcessGLSelection(rec);
+   }
+   else
+   {
+      if (rec.GetN() < 2) return;
+      DS.DigitSelected(rec.GetItem(1));
+   }
+}
diff --git a/graf3d/eve/src/TEveElement.cxx b/graf3d/eve/src/TEveElement.cxx
index 391f491..69a0fce 100644
--- a/graf3d/eve/src/TEveElement.cxx
+++ b/graf3d/eve/src/TEveElement.cxx
@@ -72,12 +72,15 @@ TEveElement::TEveElement() :
    fCompound            (0),
    fVizModel            (0),
    fVizTag              (),
+   fNumChildren         (0),
    fParentIgnoreCnt     (0),
    fTopItemCnt          (0),
    fDenyDestroy         (0),
    fDestroyOnZeroRefCnt (kTRUE),
    fRnrSelf             (kTRUE),
    fRnrChildren         (kTRUE),
+   fCanEditMainColor    (kFALSE),
+   fCanEditMainTransparency(kFALSE),
    fCanEditMainTrans    (kFALSE),
    fMainTransparency    (0),
    fMainColorPtr        (0),
@@ -90,6 +93,7 @@ TEveElement::TEveElement() :
    fHighlighted         (kFALSE),
    fImpliedSelected     (0),
    fImpliedHighlighted  (0),
+   fCSCBits             (0),
    fChangeBits          (0),
    fDestructing         (kFALSE)
 {
@@ -103,12 +107,15 @@ TEveElement::TEveElement(Color_t& main_color) :
    fCompound            (0),
    fVizModel            (0),
    fVizTag              (),
+   fNumChildren         (0),
    fParentIgnoreCnt     (0),
    fTopItemCnt          (0),
    fDenyDestroy         (0),
    fDestroyOnZeroRefCnt (kTRUE),
    fRnrSelf             (kTRUE),
    fRnrChildren         (kTRUE),
+   fCanEditMainColor    (kFALSE),
+   fCanEditMainTransparency(kFALSE),
    fCanEditMainTrans    (kFALSE),
    fMainTransparency    (0),
    fMainColorPtr        (&main_color),
@@ -121,6 +128,7 @@ TEveElement::TEveElement(Color_t& main_color) :
    fHighlighted         (kFALSE),
    fImpliedSelected     (0),
    fImpliedHighlighted  (0),
+   fCSCBits             (0),
    fChangeBits          (0),
    fDestructing         (kFALSE)
 {
@@ -134,12 +142,15 @@ TEveElement::TEveElement(const TEveElement& e) :
    fCompound            (0),
    fVizModel            (0),
    fVizTag              (e.fVizTag),
+   fNumChildren         (0),
    fParentIgnoreCnt     (0),
    fTopItemCnt          (0),
    fDenyDestroy         (0),
    fDestroyOnZeroRefCnt (e.fDestroyOnZeroRefCnt),
    fRnrSelf             (e.fRnrSelf),
    fRnrChildren         (e.fRnrChildren),
+   fCanEditMainColor    (e.fCanEditMainColor),
+   fCanEditMainTransparency(e.fCanEditMainTransparency),
    fCanEditMainTrans    (e.fCanEditMainTrans),
    fMainTransparency    (e.fMainTransparency),
    fMainColorPtr        (0),
@@ -152,6 +163,7 @@ TEveElement::TEveElement(const TEveElement& e) :
    fHighlighted         (kFALSE),
    fImpliedSelected     (0),
    fImpliedHighlighted  (0),
+   fCSCBits             (e.fCSCBits),
    fChangeBits          (0),
    fDestructing         (kFALSE)
 {
@@ -186,6 +198,7 @@ TEveElement::~TEveElement()
    {
       (*p)->RemoveElementLocal(this);
       (*p)->fChildren.remove(this);
+      --((*p)->fNumChildren);
    }
    fParents.clear();
 
@@ -243,9 +256,6 @@ void TEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level) const
    }
 }
 
-//==============================================================================
-
-
 
 //==============================================================================
 
@@ -444,14 +454,19 @@ void TEveElement::PropagateVizParamsToElements(TEveElement* el)
 }
 
 //______________________________________________________________________________
-void TEveElement::CopyVizParams(const TEveElement* /* el */)
+void TEveElement::CopyVizParams(const TEveElement* el)
 {
    // Copy visualization parameters from element el.
    // This method needs to be overriden by any class that introduces
    // new parameters.
+   // Color is copied in sub-classes which define it.
    // See, for example, TEvePointSet::CopyVizParams(),
    // TEveLine::CopyVizParams() and TEveTrack::CopyVizParams().
 
+   fCanEditMainColor        = el->fCanEditMainColor;
+   fCanEditMainTransparency = el->fCanEditMainTransparency;
+   fMainTransparency        = el->fMainTransparency;
+
    AddStamp(kCBColorSelection | kCBObjProps);
 }
 
@@ -509,6 +524,9 @@ void TEveElement::WriteVizParams(ostream& out, const TString& var)
 
    out << t << "SetElementName(\""  << GetElementName()  << "\");\n";
    out << t << "SetElementTitle(\"" << GetElementTitle() << "\");\n";
+   out << t << "SetEditMainColor("  << fCanEditMainColor << ");\n";
+   out << t << "SetEditMainTransparency(" << fCanEditMainTransparency << ");\n";
+   out << t << "SetMainTransparency("     << fMainTransparency << ");\n";
 }
 
 //______________________________________________________________________________
@@ -584,16 +602,27 @@ void TEveElement::VizDB_Insert(const char* tag, Bool_t replace, Bool_t update)
 //______________________________________________________________________________
 TEveElement* TEveElement::GetMaster()
 {
-   // Return the master element - that is the upwards compound not
-   // inside another compound.
-   // If this element is not in a compound, this is returned.
-   // For a projected object the projectable->GetMaster() is returned.
+   // Returns the master element - that is:
+   // - master of projectable, if this is a projected;
+   // - master of compound, if fCompound is set;
+   // - master of first compound parent, if kSCBTakeAnyParentAsMaster bit is set;
+   // If non of the above is true, *this* is returned.
 
    TEveProjected* proj = dynamic_cast<TEveProjected*>(this);
    if (proj)
+   {
       return dynamic_cast<TEveElement*>(proj->GetProjectable())->GetMaster();
+   }
    if (fCompound)
+   {
       return fCompound->GetMaster();
+   }
+   if (TestCSCBits(kCSCBTakeAnyParentAsMaster))
+   {
+      for (List_i i = fParents.begin(); i != fParents.end(); ++i)
+         if (dynamic_cast<TEveCompound*>(*i))
+            return (*i)->GetMaster();
+   }
    return this;
 }
 
@@ -1139,11 +1168,14 @@ void TEveElement::PropagateRnrStateToProjecteds()
 void TEveElement::SetMainColor(Color_t color)
 {
    // Set main color of the element.
+   //
+   //
    // List-tree-items are updated.
 
    Color_t old_color = GetMainColor();
 
-   if (fMainColorPtr) {
+   if (fMainColorPtr)
+   {
       *fMainColorPtr = color;
       StampColorSelection();
    }
@@ -1178,8 +1210,7 @@ void TEveElement::SetMainColorRGB(Float_t r, Float_t g, Float_t b)
 //______________________________________________________________________________
 void TEveElement::PropagateMainColorToProjecteds(Color_t color, Color_t old_color)
 {
-   // Convert RGB values to Color_t and call SetMainColor.
-   // Maybe this should be optional on gEve/element level.
+   // Propagate color to projected elements.
 
    TEveProjectable* pable = dynamic_cast<TEveProjectable*>(this);
    if (pable && pable->HasProjecteds())
@@ -1189,14 +1220,18 @@ void TEveElement::PropagateMainColorToProjecteds(Color_t color, Color_t old_colo
 }
 
 //______________________________________________________________________________
-void TEveElement::SetMainTransparency(UChar_t t)
+void TEveElement::SetMainTransparency(Char_t t)
 {
    // Set main-transparency.
    // Transparency is clamped to [0, 100].
 
+   Char_t old_t = GetMainTransparency();
+
    if (t > 100) t = 100;
    fMainTransparency = t;
    StampColorSelection();
+
+   PropagateMainTransparencyToProjecteds(t, old_t);
 }
 
 //______________________________________________________________________________
@@ -1207,9 +1242,22 @@ void TEveElement::SetMainAlpha(Float_t alpha)
 
    if (alpha < 0) alpha = 0;
    if (alpha > 1) alpha = 1;
-   SetMainTransparency((UChar_t) (100.0f*(1.0f - alpha)));
+   SetMainTransparency((Char_t) (100.0f*(1.0f - alpha)));
 }
 
+//______________________________________________________________________________
+void TEveElement::PropagateMainTransparencyToProjecteds(Char_t t, Char_t old_t)
+{
+   // Propagate transparency to projected elements.
+
+   TEveProjectable* pable = dynamic_cast<TEveProjectable*>(this);
+   if (pable && pable->HasProjecteds())
+   {
+      pable->PropagateMainTransparency(t, old_t);
+   }
+}
+
+
 /******************************************************************************/
 
 //______________________________________________________________________________
@@ -1303,7 +1351,7 @@ void TEveElement::AddElement(TEveElement* el)
                       GetElementName(), el->GetElementName()));
 
    el->AddParent(this);
-   fChildren.push_back(el);
+   fChildren.push_back(el); ++fNumChildren;
    el->AddIntoListTrees(this);
    ElementChanged();
 }
@@ -1316,7 +1364,7 @@ void TEveElement::RemoveElement(TEveElement* el)
    el->RemoveFromListTrees(this);
    RemoveElementLocal(el);
    el->RemoveParent(this);
-   fChildren.remove(el);
+   fChildren.remove(el); --fNumChildren;
    ElementChanged();
 }
 
@@ -1350,7 +1398,7 @@ void TEveElement::RemoveElementsInternal()
    {
       (*i)->RemoveParent(this);
    }
-   fChildren.clear();
+   fChildren.clear(); fNumChildren = 0;
 }
 
 //______________________________________________________________________________
@@ -1360,7 +1408,7 @@ void TEveElement::RemoveElements()
    // be done more efficiently then looping over them and removing
    // them one by one.
 
-   if ( ! fChildren.empty())
+   if (HasChildren())
    {
       RemoveElementsInternal();
       ElementChanged();
@@ -1399,12 +1447,40 @@ void TEveElement::ProjectChild(TEveElement* el, Bool_t same_depth)
          Float_t cd = pmgr->GetCurrentDepth();
          if (same_depth) pmgr->SetCurrentDepth((*i)->GetDepth());
 
-         pmgr->SubImportElements(el, dynamic_cast<TEveElement*>(*i));
+         pmgr->SubImportElements(el, (*i)->GetProjectedAsElement());
 
          if (same_depth) pmgr->SetCurrentDepth(cd);
       }
+   }
+}
 
-      
+//______________________________________________________________________________
+void TEveElement::ProjectAllChildren(Bool_t same_depth)
+{
+   // If this is a projectable, loop over all projected replicas and
+   // add the projected image of all children there. This is supposed
+   // to be called after you destroy all children and then add new
+   // ones after this element has already been projected.
+   // You might also want to call RecheckImpliedSelections() on this
+   // element.
+   //
+   // If 'same_depth' flag is true, the same depth as for the
+   // projected element is used in every projection. Otherwise current
+   // depth of each relevant projection-manager is used.
+
+   TEveProjectable* pable = dynamic_cast<TEveProjectable*>(this);
+   if (pable)
+   {
+      for (TEveProjectable::ProjList_i i = pable->BeginProjecteds(); i != pable->EndProjecteds(); ++i)
+      {
+         TEveProjectionManager *pmgr = (*i)->GetManager();
+         Float_t cd = pmgr->GetCurrentDepth();
+         if (same_depth) pmgr->SetCurrentDepth((*i)->GetDepth());
+
+         pmgr->SubImportChildren(this, (*i)->GetProjectedAsElement());
+
+         if (same_depth) pmgr->SetCurrentDepth(cd);
+      }
    }
 }
 
@@ -1509,7 +1585,7 @@ TEveElement* TEveElement::FirstChild() const
 {
    // Returns the first child element or 0 if the list is empty.
 
-   return fChildren.empty() ? 0 : fChildren.front();
+   return HasChildren() ? fChildren.front() : 0;
 }
 
 //______________________________________________________________________________
@@ -1517,7 +1593,7 @@ TEveElement* TEveElement::LastChild () const
 {
    // Returns the last child element or 0 if the list is empty.
 
-   return fChildren.empty() ? 0 : fChildren.back();
+   return HasChildren() ? fChildren.back() : 0;
 }
 
 
@@ -1598,7 +1674,8 @@ void TEveElement::DestroyElements()
 
    static const TEveException eh("TEveElement::DestroyElements ");
 
-   while ( ! fChildren.empty()) {
+   while (HasChildren())
+   {
       TEveElement* c = fChildren.front();
       if (c->fDenyDestroy <= 0)
       {
@@ -1752,6 +1829,8 @@ void TEveElement::SelectElement(Bool_t state)
 
    if (fSelected != state) {
       fSelected = state;
+      if (!fSelected && fImpliedSelected == 0)
+         UnSelected();
       fParentIgnoreCnt += (fSelected) ? 1 : -1;
       StampColorSelection();
    }
@@ -1772,7 +1851,19 @@ void TEveElement::DecImpliedSelected()
    // Decrease element's implied-selection count. Stamp appropriately.
 
    if (--fImpliedSelected == 0)
+   {
+      if (!fSelected)
+         UnSelected();
       StampColorSelection();
+   }
+}
+
+//______________________________________________________________________________
+void TEveElement::UnSelected()
+{
+   // Virtual function called when both fSelected is false and
+   // fImpliedSelected is 0.
+   // Nothing is done in this base-class version
 }
 
 //______________________________________________________________________________
@@ -1782,6 +1873,8 @@ void TEveElement::HighlightElement(Bool_t state)
 
    if (fHighlighted != state) {
       fHighlighted = state;
+      if (!fHighlighted && fImpliedHighlighted == 0)
+         UnHighlighted();
       fParentIgnoreCnt += (fHighlighted) ? 1 : -1;
       StampColorSelection();
    }
@@ -1802,7 +1895,19 @@ void TEveElement::DecImpliedHighlighted()
    // Decrease element's implied-highlight count. Stamp appropriately.
 
    if (--fImpliedHighlighted == 0)
+   {
+      if (!fHighlighted)
+         UnHighlighted();
       StampColorSelection();
+   }
+}
+
+//______________________________________________________________________________
+void TEveElement::UnHighlighted()
+{
+   // Virtual function called when both fHighlighted is false and
+   // fImpliedHighlighted is 0.
+   // Nothing is done in this base-class version
 }
 
 //______________________________________________________________________________
@@ -1810,9 +1915,9 @@ void TEveElement::FillImpliedSelectedSet(Set_t& impSelSet)
 {
    // Populate set impSelSet with derived / dependant elements.
    //
-   // Here we check if class of this is TEveProjectable and add the projected
-   // replicas to the set. Thus it does not have to be reimplemented for
-   // each sub-class of TEveProjected.
+   // If this is a TEveProjectable, the projected replicas are added
+   // to the set. Thus it does not have to be reimplemented for each
+   // sub-class of TEveProjected.
    //
    // Note that this also takes care of projections of TEveCompound
    // class, which is also a projectable.
@@ -1978,7 +2083,7 @@ TObject* TEveElementObjectPtr::GetObject(const TEveException& eh) const
    // Virtual from TEveElement.
 
    if (fObject == 0)
-      throw(eh + "fObject not set.");
+      throw eh + "fObject not set.";
    return fObject;
 }
 
@@ -2024,19 +2129,23 @@ TEveElementObjectPtr::~TEveElementObjectPtr()
 ClassImp(TEveElementList);
 
 //______________________________________________________________________________
-TEveElementList::TEveElementList(const char* n, const char* t, Bool_t doColor) :
+TEveElementList::TEveElementList(const char* n, const char* t, Bool_t doColor, Bool_t doTransparency) :
    TEveElement(),
    TNamed(n, t),
    TEveProjectable(),
    fColor(0),
-   fDoColor(doColor),
    fChildClass(0)
 {
    // Constructor.
 
-   if (fDoColor) {
+   if (doColor) {
+      fCanEditMainColor = kTRUE;
       SetMainColorPtr(&fColor);
    }
+   if (doTransparency)
+   {
+      fCanEditMainTransparency = kTRUE;
+   }
 }
 
 //______________________________________________________________________________
@@ -2045,7 +2154,6 @@ TEveElementList::TEveElementList(const TEveElementList& e) :
    TNamed      (e),
    TEveProjectable(),
    fColor      (e.fColor),
-   fDoColor    (e.fDoColor),
    fChildClass (e.fChildClass)
 {
    // Copy constructor.
@@ -2100,13 +2208,6 @@ TEveElementListProjected::TEveElementListProjected() :
 }
 
 //______________________________________________________________________________
-void TEveElementListProjected::SetDepthLocal(Float_t /*d*/)
-{
-   // This is abstract method from base-class TEveProjected.
-   // No implementation.
-}
-
-//______________________________________________________________________________
 void TEveElementListProjected::UpdateProjection()
 {
    // This is abstract method from base-class TEveProjected.
diff --git a/graf3d/eve/src/TEveElementEditor.cxx b/graf3d/eve/src/TEveElementEditor.cxx
index 4e726ba..c1e4dc9 100644
--- a/graf3d/eve/src/TEveElementEditor.cxx
+++ b/graf3d/eve/src/TEveElementEditor.cxx
@@ -191,6 +191,6 @@ void TEveElementEditor::DoTransparency()
 {
    // Slot for Transparency.
 
-   fRE->SetMainTransparency((UChar_t)(fTransparency->GetNumber()));
+   fRE->SetMainTransparency((Char_t)(fTransparency->GetNumber()));
    Update();
 }
diff --git a/graf3d/eve/src/TEveGedEditor.cxx b/graf3d/eve/src/TEveGedEditor.cxx
index e500bf1..ba896d2 100644
--- a/graf3d/eve/src/TEveGedEditor.cxx
+++ b/graf3d/eve/src/TEveGedEditor.cxx
@@ -52,7 +52,7 @@ TEveGedEditor::TEveGedEditor(TCanvas* canvas, UInt_t width, UInt_t height) :
    TGedFrame* nf = CreateNameFrame(fTabContainer, "Style");
    nf->SetGedEditor(this);
    nf->SetModelClass(0);
-   fTabContainer->AddFrame(nf, nf->GetLayoutHints());
+   fTabContainer->AddFrame(nf, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 2, 2, 2, 2));
 
    // Fix priority for TAttMarkerEditor.
    TClass* amClass = TClass::GetClass("TAttMarker");
diff --git a/graf3d/eve/src/TEveGeoNode.cxx b/graf3d/eve/src/TEveGeoNode.cxx
index c211756..ae50064 100644
--- a/graf3d/eve/src/TEveGeoNode.cxx
+++ b/graf3d/eve/src/TEveGeoNode.cxx
@@ -76,7 +76,7 @@ TEveGeoNode::TEveGeoNode(TGeoNode* node) :
    // Hack!! Should use cint to retrieve TAttLine::fLineColor offset.
    char* l = (char*) dynamic_cast<TAttLine*>(node->GetVolume());
    SetMainColorPtr((Color_t*)(l + sizeof(void*)));
-   SetMainTransparency((UChar_t) fNode->GetVolume()->GetTransparency());
+   SetMainTransparency(fNode->GetVolume()->GetTransparency());
 
    fRnrSelf = fNode->TGeoAtt::IsVisible();
 }
@@ -122,10 +122,12 @@ void TEveGeoNode::ExpandIntoListTree(TGListTree* ltree,
    // Checks if child-nodes have been imported ... imports them if not.
    // Then calls TEveElement::ExpandIntoListTree.
 
-   if (fChildren.empty() && fNode->GetVolume()->GetNdaughters() > 0) {
+   if ( ! HasChildren() && fNode->GetVolume()->GetNdaughters() > 0)
+   {
       TIter next(fNode->GetVolume()->GetNodes());
       TGeoNode* dnode;
-      while ((dnode = (TGeoNode*) next()) != 0) {
+      while ((dnode = (TGeoNode*) next()) != 0)
+      {
          TEveGeoNode* node_re = new TEveGeoNode(dnode);
          AddElement(node_re);
       }
@@ -203,26 +205,20 @@ Bool_t TEveGeoNode::CanEditMainTransparency() const
 }
 
 //______________________________________________________________________________
-UChar_t TEveGeoNode::GetMainTransparency() const
+Char_t TEveGeoNode::GetMainTransparency() const
 {
-   // Get transparency from node, if different propagate to this.
+   // Get transparency -- it is taken from the geo node.
 
-   UChar_t t = (UChar_t) fNode->GetVolume()->GetTransparency();
-   if (fMainTransparency != t)
-   {
-      TEveGeoNode* ncthis = const_cast<TEveGeoNode*>(this);
-      ncthis->SetMainTransparency(t);
-   }
-   return t;
+   return fNode->GetVolume()->GetTransparency();
 }
 
 //______________________________________________________________________________
-void TEveGeoNode::SetMainTransparency(UChar_t t)
+void TEveGeoNode::SetMainTransparency(Char_t t)
 {
    // Set transparency, propagate to volume's transparency.
 
    TEveElement::SetMainTransparency(t);
-   fNode->GetVolume()->SetTransparency((Char_t) t);
+   fNode->GetVolume()->SetTransparency(t);
 }
 
 /******************************************************************************/
@@ -357,27 +353,25 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode*         geon,
          TGLScenePad scene_pad(&pad);
          pad.SetViewer3D(&scene_pad);
 
-         TEveGeoManagerHolder gmgr(tvolume->GetGeoManager());
-         gGeoManager->SetPaintVolume(tvolume);
-         Int_t nseg = gGeoManager->GetNsegments();
-         gGeoManager->SetNsegments(fgCSGExportNSeg);
+         {
+            TEveGeoManagerHolder gmgr(tvolume->GetGeoManager(), fgCSGExportNSeg);
+            gGeoManager->SetPaintVolume(tvolume);
 
-         Bool_t had_null_transform = kFALSE;
-         if (tshape->GetTransform() == 0) {
-            had_null_transform = kTRUE;
-            tshape->SetTransform(gGeoIdentity);
-         }
+            Bool_t had_null_transform = kFALSE;
+            if (tshape->GetTransform() == 0) {
+               had_null_transform = kTRUE;
+               tshape->SetTransform(gGeoIdentity);
+            }
 
-         scene_pad.BeginScene();
-         dynamic_cast<TGeoCompositeShape*>(tshape)->PaintComposite();
-         scene_pad.EndScene();
+            scene_pad.BeginScene();
+            dynamic_cast<TGeoCompositeShape*>(tshape)->PaintComposite();
+            scene_pad.EndScene();
 
-         if (had_null_transform) {
-            tshape->SetTransform(0);
+            if (had_null_transform) {
+               tshape->SetTransform(0);
+            }
          }
 
-         gGeoManager->SetNsegments(nseg);
-
          pad.SetViewer3D(0);
 
          TGLFaceSet* fs = dynamic_cast<TGLFaceSet*>(scene_pad.FindLogical(tvolume));
@@ -412,10 +406,14 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode*         geon,
 
    TEveGeoShapeExtract* gse = new TEveGeoShapeExtract(geon->GetName(), geon->GetTitle());
    gse->SetTrans(trans.Array());
-   Int_t ci = 0;
-   if (tvolume) ci = tvolume->GetLineColor();
+   Int_t  ci = 0;
+   Char_t transp = 0;
+   if (tvolume) {
+      ci = tvolume->GetLineColor();
+      transp = tvolume->GetTransparency();
+   }
    TColor* c = gROOT->GetColor(ci);
-   Float_t rgba[4] = {1, 0, 0, 1};
+   Float_t rgba[4] = {1, 0, 0, 1.0f - transp/100.0f};
    if (c) {
       rgba[0] = c->GetRed();
       rgba[1] = c->GetGreen();
@@ -526,20 +524,35 @@ void TEveGeoTopNode::Paint(Option_t* option)
    // option given in data-members.
    // Uses TGeoPainter internally.
 
-   if (fRnrSelf) {
-      gGeoManager = fManager;
-      TVirtualPad* pad = gPad;
+   if (fRnrSelf)
+   {
+      TEveGeoManagerHolder geo_holder(fManager);
+      TVirtualPad *pad = gPad;
       gPad = 0;
       TGeoVolume* top_volume = fManager->GetTopVolume();
-      fManager->SetVisOption(fVisOption);
       if (fVisLevel > 0)
          fManager->SetVisLevel(fVisLevel);
       else
          fManager->SetMaxVisNodes(fMaxVisNodes);
+      TVirtualGeoPainter* vgp = fManager->GetGeomPainter();
       fManager->SetTopVolume(fNode->GetVolume());
+      switch (fVisOption)
+      {
+         case 0:
+            fNode->GetVolume()->SetVisContainers(kTRUE);
+            fManager->SetTopVisible(kTRUE);
+            break;
+         case 1:
+            fNode->GetVolume()->SetVisLeaves(kTRUE);
+            fManager->SetTopVisible(kFALSE);
+            break;
+         case 2:
+            fNode->GetVolume()->SetVisOnly(kTRUE);
+            break;
+      }
       gPad = pad;
-      TVirtualGeoPainter* vgp = fManager->GetGeomPainter();
       if(vgp != 0) {
+         vgp->SetVisOption(fVisOption);
          TGeoHMatrix geomat;
          if (HasMainTrans()) RefMainTrans().SetGeoHMatrix(geomat);
          vgp->PaintNode(fNode, option, &geomat);
diff --git a/graf3d/eve/src/TEveGeoShape.cxx b/graf3d/eve/src/TEveGeoShape.cxx
index ca25ce8..2b2bbf6 100644
--- a/graf3d/eve/src/TEveGeoShape.cxx
+++ b/graf3d/eve/src/TEveGeoShape.cxx
@@ -35,20 +35,23 @@
 
 namespace
 {
-TGeoManager* init_geo_mangeur()
-{
-   // Create a phony geo manager that can be used for storing free
-   // shapes. Otherwise shapes register themselves to current
-   // geo-manager (or even create one).
-
-   TGeoManager* old = gGeoManager;
-   gGeoManager = 0;
-   TGeoManager* mgr = new TGeoManager();
-   mgr->SetNameTitle("TEveGeoShape::fgGeoMangeur",
-                     "Static geo manager used for wrapped TGeoShapes.");
-   gGeoManager = old;
-   return mgr;
-}
+   TGeoManager* init_geo_mangeur()
+   {
+      // Create a phony geo manager that can be used for storing free
+      // shapes. Otherwise shapes register themselves to current
+      // geo-manager (or even create one).
+
+      TGeoManager  *old    = gGeoManager;
+      TGeoIdentity *old_id = gGeoIdentity;
+      gGeoManager = 0;
+      TGeoManager* mgr = new TGeoManager();
+      mgr->SetNameTitle("TEveGeoShape::fgGeoMangeur",
+                        "Static geo manager used for wrapped TGeoShapes.");
+      gGeoIdentity = new TGeoIdentity("Identity");
+      gGeoManager  = old;
+      gGeoIdentity = old_id;
+      return mgr;
+   }
 }
 
 //==============================================================================
@@ -96,6 +99,8 @@ TEveGeoShape::TEveGeoShape(const char* name, const char* title) :
 {
    // Constructor.
 
+   fCanEditMainColor        = kTRUE;
+   fCanEditMainTransparency = kTRUE;
    InitMainTrans();
 }
 
@@ -373,9 +378,8 @@ void TEveGeoShapeProjected::SetProjection(TEveProjectionManager* mng,
    TEveProjected::SetProjection(mng, model);
 
    TEveGeoShape* gre = dynamic_cast<TEveGeoShape*>(fProjectable);
-
    SetMainColor(gre->GetMainColor());
-   SetMainTransparency(gre->GetMainTransparency());
+   CopyVizParams(gre);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveJetCone.cxx b/graf3d/eve/src/TEveJetCone.cxx
index 1cf9c5c..988e2e4 100644
--- a/graf3d/eve/src/TEveJetCone.cxx
+++ b/graf3d/eve/src/TEveJetCone.cxx
@@ -11,47 +11,56 @@
 
 #include "TEveJetCone.h"
 #include "TEveTrans.h"
+#include "TEveProjectionManager.h"
 
 #include "TMath.h"
 
+
+//==============================================================================
+// TEveJetCone
+//==============================================================================
+
 //______________________________________________________________________________
 //
 // Draws a jet cone with leading particle is specified in (eta,phi) and
 // cone radius is given.
 //
 // If Apex is not set, default is (0.,0.,0.)
-// In case of cylinder was set, cone is cut at the cylinder edges
-// example :
+// In case of cylinder was set, cone is cut at the cylinder edges.
+//
+// Example :
 //
 //  Float_t coneEta    = r.Uniform(-0.9, 0.9);
 //  Float_t conePhi    = r.Uniform(0.0, TwoPi() );
 //  Float_t coneRadius = 0.4;
 //
 //  TEveJetCone* jetCone = new TEveJetCone("JetCone");
-//  jetCone->SetCylinder( 250., 250. );
-//  if ( (jetCone->AddCone( coneEta, conePhi, coneRadius   ) ) != -1)
-//    gEve->AddElement( jetCone );
+//  jetCone->SetCylinder(250, 250);
+//  if (jetCone->AddCone(coneEta, conePhi, coneRadius) != -1)
+//    gEve->AddElement(jetCone);
+//
+//
+// Implementation notes
 //
+// TEveVector fLimits encodes the following information:
+//   fY, fZ:  barrel radius and endcap z-position;
+//            if both are 0, fX encodes the spherical radius
+//   fX    :  scaling for length of the cone
 
 ClassImp(TEveJetCone);
 
 //______________________________________________________________________________
 TEveJetCone::TEveJetCone(const Text_t* n, const Text_t* t) :
-   TEveElementList(n, t, kTRUE),
-   TAttBBox(),
-   fApex( TEveVector(0.,0.,0.) ),
-   fBasePoints(),
-   fCylinderBorder( TEveVector(-1.,0.,-1.) ),
-   fThetaC(0.)
+   TEveShape(n, t),
+   fApex(),
+   fLimits(), fThetaC(10),
+   fEta(0), fPhi(0), fDEta(0), fDPhi(0), fNDiv(72)
 {
    // Constructor.
 
    fColor = kGreen;
 }
 
-
-/******************************************************************************/
-
 //______________________________________________________________________________
 void TEveJetCone::ComputeBBox()
 {
@@ -59,145 +68,186 @@ void TEveJetCone::ComputeBBox()
 
    BBoxInit();
    BBoxCheckPoint(fApex);
-   for (vTEveVector_ci i = fBasePoints.begin(); i != fBasePoints.end(); ++i)
-   {
-      BBoxCheckPoint(*i);
-   }
+   BBoxCheckPoint(CalcBaseVec(0));
+   BBoxCheckPoint(CalcBaseVec(TMath::PiOver2()));
+   BBoxCheckPoint(CalcBaseVec(TMath::Pi()));
+   BBoxCheckPoint(CalcBaseVec(TMath::Pi() + TMath::PiOver2()));
 }
 
 //______________________________________________________________________________
-void TEveJetCone::Paint(Option_t*)
+TClass* TEveJetCone::ProjectedClass(const TEveProjection*) const
 {
-   // Paint object.
-   // This is for direct rendering (using TEveJetConeGL class).
+   // Virtual from TEveProjectable, returns TEveJetConeProjected class.
 
-   PaintStandard(this);
+   return TEveJetConeProjected::Class();
 }
 
+
 //______________________________________________________________________________
-Int_t TEveJetCone::AddCone(Float_t eta, Float_t phi, Float_t coneRadius, Float_t height )
+Int_t TEveJetCone::AddCone(Float_t eta, Float_t phi, Float_t cone_r, Float_t length)
 {
-   // Add jet cone
+   // Add jet cone.
    // parameters are :
    // * (eta,phi)    : of the center/leading particle
-   // * coneRadius   : in eta-phi space
-   // * height       : height of the cone
-   //                  * if cylinder is set and length is adapted to cylinder.
-   //                    - if height is given, it will be used as scalar factor
-   //                  * if cylinder is not set, height is used as height of the cone
-   // Return 0 on sucess
-
-   if ( fCylinderBorder.fZ == -1. && fCylinderBorder.fX == -1. && height == -1 )
-      return -1;
-
-   TEveVector coneAxis;
-   FillTEveVectorFromEtaPhi( coneAxis, eta, phi );
-
-   Float_t angleRad = 0.;
-   for ( Float_t angle = 0.; angle < 360. ; angle+=5. , angleRad=angle*TMath::Pi()/180 ) {
-
-      // -- Get Contour point
-      TEveVector contourPoint;
-      FillTEveVectorFromEtaPhi( contourPoint,
-                                eta + coneRadius * TMath::Cos(angleRad),
-                                phi + coneRadius * TMath::Sin(angleRad) );
-
-      // -- Set length of the contourPoint
-      if ( fCylinderBorder.fZ != -1. && fCylinderBorder.fX != -1. ) {
-         if ( contourPoint.Theta() < fThetaC )
-            contourPoint *= fCylinderBorder.fZ / TMath::Cos( contourPoint.Theta() ) ;
-         else if ( contourPoint.Theta() > ( TMath::Pi() - fThetaC ) )
-            contourPoint *= fCylinderBorder.fZ / TMath::Cos( contourPoint.Theta() - TMath::Pi() ) ;
-         else
-            contourPoint *= fCylinderBorder.fX / TMath::Sin( contourPoint.Theta() ) ;
-
-         if ( height != -1 ) contourPoint *= height;
-      }
-      else {
-         contourPoint *= height / GetArcCosConeOpeningAngle( coneAxis, contourPoint );
-      }
-
-      // -- Add contourPoint
-      fBasePoints.push_back( contourPoint );
-   }
-
-   return 0;
+   // * cone_r       : cone radius in eta-phi space
+   // * length       : length of the cone
+   //   * if cylinder is set and length is adapted to cylinder.
+   //     - if length is given, it will be used as scalar factor
+   //   * if cylinder is not set, length is used as length of the cone
+   // Return 0 on sucess.
+
+   return AddEllipticCone(eta, phi, cone_r, cone_r, length);
 }
 
 //______________________________________________________________________________
-Int_t TEveJetCone::AddEllipticCone(Float_t eta, Float_t phi, Float_t reta, Float_t rphi, Float_t height)
+Int_t TEveJetCone::AddEllipticCone(Float_t eta, Float_t phi, Float_t reta, Float_t rphi, Float_t length)
 {
-   // Add jet cone
+   // Add jet cone.
    // parameters are :
    // * (eta,phi)    : of the center/leading particle
    // * (reta, rphi) : radius of cone in eta-phi space
-   // * height       : height of the cone
-   //                  * if cylinder is set and length is adapted to cylinder.
-   //                    - if height is given, it will be used as scalar factor
-   //                  * if cylinder is not set, height is used as height of the cone
-   // Return 0 on sucess
+   // * length       : length of the cone
+   //   * if cylinder is set and length is adapted to cylinder.
+   //     - if length is given, it will be used as scalar factor
+   //   * if cylinder is not set, length is used as length of the cone
+   // Returns 0 on sucess.
+
+   using namespace TMath;
 
-   if ( fCylinderBorder.fZ == -1. && fCylinderBorder.fX == -1. && height == -1 )
+   if (length != 0) fLimits.fX = length;
+
+   if (fLimits.IsZero())
       return -1;
 
-   TEveVector coneAxis;
-   FillTEveVectorFromEtaPhi( coneAxis, eta, phi );
-
-   Float_t angleRad = 0.;
-   for ( Float_t angle = 0.; angle < 360. ; angle+=5. , angleRad=angle*TMath::Pi()/180 ) {
-
-      // -- Get Contour point
-      TEveVector contourPoint;
-      FillTEveVectorFromEtaPhi( contourPoint,
-                                eta + reta * TMath::Cos(angleRad),
-                                phi + rphi * TMath::Sin(angleRad) );
-
-      // -- Set length of the contourPoint
-      if ( fCylinderBorder.fZ != -1. && fCylinderBorder.fX != -1. ) {
-         if ( contourPoint.Theta() < fThetaC )
-            contourPoint *= fCylinderBorder.fZ / TMath::Cos( contourPoint.Theta() ) ;
-         else if ( contourPoint.Theta() > ( TMath::Pi() - fThetaC ) )
-            contourPoint *= fCylinderBorder.fZ / TMath::Cos( contourPoint.Theta() - TMath::Pi() ) ;
-         else
-            contourPoint *= fCylinderBorder.fX / TMath::Sin( contourPoint.Theta() ) ;
-
-         if ( height != -1 ) contourPoint *= height;
-      }
-      else {
-         contourPoint *= height / GetArcCosConeOpeningAngle( coneAxis, contourPoint );
-      }
-
-      // -- Add contourPoint
-      fBasePoints.push_back( contourPoint );
-   }
+   fEta = eta; fPhi = phi; fDEta = reta; fDPhi = rphi;
 
    return 0;
 }
 
 //______________________________________________________________________________
-void TEveJetCone::FillTEveVectorFromEtaPhi( TEveVector &vec, const Float_t& eta, const Float_t& phi )
+TEveVector TEveJetCone::CalcEtaPhiVec(Float_t eta, Float_t phi) const
 {
-   // Fill TEveVector with eta and phi, with magnitude 1.
+   // Fill TEveVector with eta and phi, magnitude 1.
 
-   vec.Set( TMath::Cos(phi) / TMath::CosH(eta),
-            TMath::Sin(phi) / TMath::CosH(eta),
-            TMath::TanH(eta) );
-   return;
+   using namespace TMath;
+
+   return TEveVector(Cos(phi) / CosH(eta), Sin(phi) / CosH(eta), TanH(eta));
 }
 
 //______________________________________________________________________________
-Float_t TEveJetCone::GetArcCosConeOpeningAngle( const TEveVector& axis, const TEveVector& contour )
+TEveVector TEveJetCone::CalcBaseVec(Float_t eta, Float_t phi) const
 {
-   // Return the arccos of the opening angle between two eve vectors
+   // Returns point on the base of the cone with given eta and phi.
+
+   using namespace TMath;
 
-   Float_t arcCos = 0.;
+   TEveVector vec = CalcEtaPhiVec(eta, phi);
 
-   Float_t tot2 = axis.Mag2() * contour.Mag2();
-   if( tot2 > 0. ) {
-      arcCos = axis.Dot( contour )/ TMath::Sqrt( tot2 );
-      if (arcCos >  1.0) arcCos =  1.0;
-      if (arcCos < -1.0) arcCos = -1.0;
+   // -- Set length of the contourPoint
+   if (fLimits.fY != 0 && fLimits.fZ != 0)
+   {
+      Float_t theta = vec.Theta();
+      if (theta < fThetaC)
+         vec *= fLimits.fZ / Cos(theta);
+      else if (theta > Pi() - fThetaC)
+         vec *= fLimits.fZ / Cos(theta - Pi());
+      else
+         vec *= fLimits.fY / Sin(theta);
+
+      if (fLimits.fX != 0) vec *= fLimits.fX;
+   }
+   else 
+   {
+      vec *= fLimits.fX;
    }
 
-   return arcCos;
+   return vec;
+}
+
+//______________________________________________________________________________
+TEveVector TEveJetCone::CalcBaseVec(Float_t alpha) const
+{
+   // Returns point on the base of the cone with internal angle alpha:
+   // alpha = 0 -> max eta,  alpha = pi/2 -> max phi, ...
+
+   using namespace TMath;
+
+   return CalcBaseVec(fEta + fDEta * Cos(alpha), fPhi + fDPhi * Sin(alpha));
+}
+
+//______________________________________________________________________________
+Bool_t TEveJetCone::IsInTransitionRegion() const
+{
+   // Returns true if the cone is in barrel / endcap transition region.
+
+   using namespace TMath;
+
+   Float_t tm = CalcBaseVec(0).Theta();
+   Float_t tM = CalcBaseVec(Pi()).Theta();
+
+   return (tM > fThetaC        && tm < fThetaC) ||
+          (tM > Pi() - fThetaC && tm < Pi() - fThetaC);
+}
+
+//==============================================================================
+// TEveJetConeProjected
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Projection of TEveJetCone.
+
+//______________________________________________________________________________
+TEveJetConeProjected::TEveJetConeProjected(const char* n, const char* t) :
+   TEveShape(n, t)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+TEveJetConeProjected::~TEveJetConeProjected()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TEveJetConeProjected::ComputeBBox()
+{
+   // Compute bounding-box, virtual from TAttBBox.
+
+   BBoxInit();
+
+   TEveJetCone    *cone = dynamic_cast<TEveJetCone*>(fProjectable);
+//______________________________________________________________________________
+   TEveProjection *proj = GetManager()->GetProjection();
+   TEveVector v;
+   v = cone->fApex;                                       proj->ProjectVector(v, fDepth); BBoxCheckPoint(v);
+   v = cone->CalcBaseVec(0);                              proj->ProjectVector(v, fDepth); BBoxCheckPoint(v);
+   v = cone->CalcBaseVec(TMath::PiOver2());               proj->ProjectVector(v, fDepth); BBoxCheckPoint(v);
+   v = cone->CalcBaseVec(TMath::Pi());                    proj->ProjectVector(v, fDepth); BBoxCheckPoint(v);
+   v = cone->CalcBaseVec(TMath::Pi() + TMath::PiOver2()); proj->ProjectVector(v, fDepth); BBoxCheckPoint(v);
+}
+
+//______________________________________________________________________________
+void TEveJetConeProjected::SetDepthLocal(Float_t d)
+{
+   // This is virtual method from base-class TEveProjected.
+
+   SetDepthCommon(d, this, fBBox);
+}
+
+//______________________________________________________________________________
+void TEveJetConeProjected::SetProjection(TEveProjectionManager* mng, TEveProjectable* model)
+{
+   // This is virtual method from base-class TEveProjected.
+
+   TEveProjected::SetProjection(mng, model);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
+}
+
+//______________________________________________________________________________
+void TEveJetConeProjected::UpdateProjection()
+{
+   // Re-project the jet-cone.
+
 }
diff --git a/graf3d/eve/src/TEveJetConeGL.cxx b/graf3d/eve/src/TEveJetConeGL.cxx
index 4e92d71..ebf41bf 100644
--- a/graf3d/eve/src/TEveJetConeGL.cxx
+++ b/graf3d/eve/src/TEveJetConeGL.cxx
@@ -11,12 +11,17 @@
 
 #include "TEveJetConeGL.h"
 #include "TEveJetCone.h"
+#include "TEveProjectionManager.h"
 
 #include "TMath.h"
 
 #include "TGLRnrCtx.h"
 #include "TGLIncludes.h"
 
+//==============================================================================
+// TEveJetConeGL
+//==============================================================================
+
 //______________________________________________________________________________
 // OpenGL renderer class for TEveJetCone.
 //
@@ -25,22 +30,20 @@ ClassImp(TEveJetConeGL);
 
 //______________________________________________________________________________
 TEveJetConeGL::TEveJetConeGL() :
-   TGLObject(), fM(0)
+   TGLObject(), fC(0)
 {
    // Constructor.
 
-   fDLCache = kFALSE; // Disable display list.
+   // fDLCache = kFALSE; // Disable display list.
 }
 
-/******************************************************************************/
-
 //______________________________________________________________________________
 Bool_t TEveJetConeGL::SetModel(TObject* obj, const Option_t* /*opt*/)
 {
    // Set model object.
 
    if (SetModelCheckClass(obj, TEveJetCone::Class())) {
-      fM = dynamic_cast<TEveJetCone*>(obj);
+      fC = dynamic_cast<TEveJetCone*>(obj);
       return kTRUE;
    }
    return kFALSE;
@@ -51,11 +54,76 @@ void TEveJetConeGL::SetBBox()
 {
    // Set bounding box.
 
-   // !! This ok if master sub-classed from TAttBBox
    SetAxisAlignedBBox(((TEveJetCone*)fExternalObj)->AssertBBox());
 }
 
-/******************************************************************************/
+//______________________________________________________________________________
+void TEveJetConeGL::DLCacheClear()
+{
+   // Clear DL cache and reset internal point array.
+
+   fP.clear();
+   TGLObject::DLCacheClear();
+}
+
+//______________________________________________________________________________
+void TEveJetConeGL::CalculatePoints() const
+{
+   // Calculate points for drawing.
+
+   assert(fC->fNDiv > 2);
+
+   const Int_t  NP = fC->fNDiv;
+   fP.resize(NP);
+   {
+      Float_t angle_step = TMath::TwoPi() / NP;
+      Float_t angle      = 0;
+      for (Int_t i = 0; i < NP; ++i, angle += angle_step)
+      {
+         fP[i] = fC->CalcBaseVec(angle);
+      }
+   }
+}
+
+//______________________________________________________________________________
+void TEveJetConeGL::Draw(TGLRnrCtx& rnrCtx) const
+{
+   // Draw the cone.
+
+   if (fP.empty()) CalculatePoints();
+
+   if (fC->fHighlightFrame && rnrCtx.Highlight())
+   {
+      glPushAttrib(GL_ENABLE_BIT);
+      glDisable(GL_LIGHTING);
+
+      if (fC->fDrawFrame)
+      {
+         TGLUtil::LineWidth(fC->fLineWidth);
+         TGLUtil::Color(fC->fLineColor);
+      }
+
+      const Int_t NP = fP.size();
+      glBegin(GL_LINE_LOOP);
+      for (Int_t i = 0; i < NP; ++i)
+         glVertex3fv(fP[i]);
+      glEnd();
+      glBegin(GL_LINES);
+      Double_t angle = 0;
+      for (Int_t i = 0; i < 4; ++i, angle += TMath::PiOver2())
+      {
+         glVertex3fv(fC->fApex);
+         glVertex3fv(fC->CalcBaseVec(angle));
+      }
+      glEnd();
+
+      glPopAttrib();
+   }
+   else
+   {
+      TGLObject::Draw(rnrCtx);
+   }
+}
 
 //______________________________________________________________________________
 void TEveJetConeGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
@@ -64,41 +132,243 @@ void TEveJetConeGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
 
    // printf("TEveJetConeGL::DirectDraw LOD %d\n", rnrCtx.CombiLOD());
 
-   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
+   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LIGHTING_BIT);
 
    glDisable(GL_CULL_FACE);
    glEnable(GL_NORMALIZE);
+   Int_t lmts = 1;
+   glLightModeliv(GL_LIGHT_MODEL_TWO_SIDE, &lmts);
+
+   const Int_t  NP = fC->fNDiv;
+   Int_t prev = NP - 1;
+   Int_t i    = 0;
+   Int_t next = 1;
+
+   TEveVector curr_normal;
+   TEveVector prev_normal;
+   TMath::Cross((fP[next] - fP[prev]).Arr(), (fP[i] - fC->fApex).Arr(), prev_normal.Arr());
+
+   prev = i; i = next; ++next;
+
+   glBegin(GL_TRIANGLES);
+   do
+   {
+      TMath::Cross((fP[next] - fP[prev]).Arr(), (fP[i] - fC->fApex).Arr(), curr_normal.Arr());
+
+      glNormal3fv(prev_normal);
+      glVertex3fv(fP[prev]);
+
+      glNormal3fv(prev_normal + curr_normal);
+      glVertex3fv(fC->fApex);
+
+      glNormal3fv(curr_normal);
+      glVertex3fv(fP[i]);
+         
+      prev_normal = curr_normal;
+
+      prev = i;
+      i    = next;
+      ++next; if (next >= NP) next = 0;
+   } while (prev != 0);
+   glEnd();
+
+   glPopAttrib();
+}
+
+
+//==============================================================================
+// TEveJetConeProjectedGL
+//==============================================================================
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEveJetConeProjected.
+//
+
+ClassImp(TEveJetConeProjectedGL);
+
+//______________________________________________________________________________
+TEveJetConeProjectedGL::TEveJetConeProjectedGL() :
+   TEveJetConeGL(), fM(0)
+{
+   // Constructor.
+
+   // fDLCache = kFALSE; // Disable display list.
+}
+
+//______________________________________________________________________________
+Bool_t TEveJetConeProjectedGL::SetModel(TObject* obj, const Option_t* /*opt*/)
+{
+   // Set model object.
+
+   if (SetModelCheckClass(obj, TEveJetConeProjected::Class())) {
+      fM = dynamic_cast<TEveJetConeProjected*>(obj);
+      fC = dynamic_cast<TEveJetCone*>(fM->GetProjectable());
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TEveJetConeProjectedGL::SetBBox()
+{
+   // Set bounding box.
+
+   SetAxisAlignedBBox(((TEveJetConeProjected*)fExternalObj)->AssertBBox());
+}
 
-   glBegin(GL_TRIANGLE_FAN);
-   glVertex3fv(fM->fApex);
-   if ( fM->fBasePoints.size() > 2)
+namespace
+{
+   struct less_eve_vec_phi_t
    {
-      TEveJetCone::vTEveVector_ci prev = fM->fBasePoints.end(); --prev;
-      TEveJetCone::vTEveVector_ci i    = fM->fBasePoints.begin();
-      TEveJetCone::vTEveVector_ci next = i; ++next;
+      bool operator()(const TEveVector& a, const TEveVector& b)
+      { return a.Phi() < b.Phi(); }
+   };
+}
 
-      TEveVector norm_buf;
-      TEveVector beg_normal = TMath::Cross((*i - fM->fApex).Arr(), (*next - *prev).Arr(), norm_buf.Arr());
+//______________________________________________________________________________
+void TEveJetConeProjectedGL::CalculatePoints() const
+{
+   // Calculate points for drawing.
 
-      glNormal3fv(beg_normal);
-      glVertex3fv(fM->fBasePoints.front());
+   static const TEveException kEH("TEveJetConeProjectedGL::CalculatePoints ");
 
-      prev = i;  i = next;  ++next;
+   fP.resize(3);
 
-      while (i != fM->fBasePoints.begin())
+   TEveProjection *proj = fM->GetManager()->GetProjection();
+
+   switch (proj->GetType())
+   {
+      case TEveProjection::kPT_RPhi:
+      {
+         fP[0] = fC->fApex;
+         fP[1] = fC->CalcBaseVec(TMath::Pi() + TMath::PiOver2());
+         fP[2] = fC->CalcBaseVec(TMath::PiOver2());
+
+         for (Int_t i = 0; i < 3; ++i)
+            proj->ProjectVector(fP[i], fM->fDepth);
+
+         break;
+      }
+
+      case TEveProjection::kPT_RhoZ:
       {
-         glNormal3fv(TMath::Cross((*i - fM->fApex).Arr(), (*next - *prev).Arr(), norm_buf.Arr()));
-         glVertex3fv(*i);
+         fP[0] = fC->fApex;
+         fP[1] = fC->CalcBaseVec(0);
+         fP[2] = fC->CalcBaseVec(TMath::Pi());
+
+         Float_t tm = fP[1].Theta();
+         Float_t tM = fP[2].Theta();
 
-         prev = i;
-         i    = next;
-         ++next; if (next == fM->fBasePoints.end()) next = fM->fBasePoints.begin();
+         if (tM > fC->fThetaC && tm < fC->fThetaC)
+         {
+            fP.reserve(fP.size() + 1);
+            TEveVector v(0, fC->fLimits.fY, fC->fLimits.fZ);
+            fP.push_back(fC->CalcBaseVec(v.Eta(), fC->fPhi));
+         }
+
+         if (tM > TMath::Pi() - fC->fThetaC && tm < TMath::Pi() - fC->fThetaC)
+         {
+            fP.reserve(fP.size() + 1);
+            TEveVector v(0, fC->fLimits.fY, -fC->fLimits.fZ);
+            fP.push_back(fC->CalcBaseVec(v.Eta(), fC->fPhi));
+         }
+
+         const Int_t NP = fP.size();
+         for (Int_t i = 0; i < NP; ++i)
+            proj->ProjectVector(fP[i], fM->fDepth);
+
+         std::sort(fP.begin() + 1, fP.end(), less_eve_vec_phi_t());
+
+         break;
       }
 
-      glNormal3fv(beg_normal);
-      glVertex3fv(fM->fBasePoints.front());
+      default:
+         throw kEH + "Unsupported projection type.";
+   }
+
+}
+
+//______________________________________________________________________________
+void TEveJetConeProjectedGL::RenderOutline() const
+{
+   // Draw jet outline.
+
+   const Int_t NP = fP.size();
+   glBegin(GL_LINE_LOOP);
+   for (Int_t i = 0; i < NP; ++i)
+   {
+      glVertex3fv(fP[i].Arr());
    }
    glEnd();
+}
 
-   glPopAttrib();
+//______________________________________________________________________________
+void TEveJetConeProjectedGL::RenderPolygon() const
+{
+   // Draw jet surface.
+
+   const Int_t NP = fP.size();
+   glBegin(GL_POLYGON);
+   for (Int_t i = 0; i < NP; ++i)
+   {
+      glVertex3fv(fP[i].Arr());
+   }
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveJetConeProjectedGL::Draw(TGLRnrCtx& rnrCtx) const
+{
+   // Draw the cone.
+
+   if (fP.empty()) CalculatePoints();
+
+   if (rnrCtx.IsDrawPassOutlineLine())
+   {
+      RenderOutline();
+   }
+   else if (fM->fHighlightFrame && rnrCtx.Highlight())
+   {
+      if (fM->fDrawFrame)
+      {
+         TGLUtil::LineWidth(fM->fLineWidth);
+         TGLUtil::Color(fM->fLineColor);
+      }
+      RenderOutline();
+   }
+   else
+   {
+      TGLObject::Draw(rnrCtx);
+   }
+}
+
+
+//______________________________________________________________________________
+void TEveJetConeProjectedGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
+{
+   // Render with OpenGL.
+
+   // printf("TEveJetConeProjectedGL::DirectDraw LOD %d\n", rnrCtx.CombiLOD());
+
+   fMultiColor = (fM->fDrawFrame && fM->fFillColor != fM->fLineColor);
+
+   if (fM->fDrawFrame)
+   {
+      glPushAttrib(GL_ENABLE_BIT);
+      glEnable(GL_POLYGON_OFFSET_FILL);
+      glPolygonOffset(1.0f, 1.0f);
+   }
+
+   RenderPolygon();
+
+   if (fM->fDrawFrame)
+   {
+      glEnable(GL_LINE_SMOOTH);
+
+      TGLUtil::Color(fM->fLineColor);
+      TGLUtil::LineWidth(fM->fLineWidth);
+      RenderOutline();
+
+      glPopAttrib();
+   }
 }
diff --git a/graf3d/eve/src/TEveLine.cxx b/graf3d/eve/src/TEveLine.cxx
index 54f2a49..533c109 100644
--- a/graf3d/eve/src/TEveLine.cxx
+++ b/graf3d/eve/src/TEveLine.cxx
@@ -329,8 +329,7 @@ void TEveLineProjected::SetProjection(TEveProjectionManager* mng,
    // Virtual from TEveProjected.
 
    TEveProjected::SetProjection(mng, model);
-   * (TAttMarker*)this = * dynamic_cast<TAttMarker*>(fProjectable);
-   * (TAttLine*)  this = * dynamic_cast<TAttLine*>  (fProjectable);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveLineGL.cxx b/graf3d/eve/src/TEveLineGL.cxx
index 28242a4..1dbe6ac 100644
--- a/graf3d/eve/src/TEveLineGL.cxx
+++ b/graf3d/eve/src/TEveLineGL.cxx
@@ -63,13 +63,14 @@ void TEveLineGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    TGLUtil::LockColor(); // Keep color from TGLPhysicalShape.
    if (q.fRnrLine) {
-      TGLCapabilitySwitch sw_smooth(GL_LINE_SMOOTH, q.fSmooth);
-      TGLCapabilitySwitch sw_blend(GL_BLEND, q.fSmooth);
-      TGLUtil::RenderPolyLine(q, q.GetP(), q.Size());
+      TGLCapabilityEnabler sw_smooth(GL_LINE_SMOOTH, q.fSmooth);
+      TGLCapabilityEnabler sw_blend(GL_BLEND, q.fSmooth);
+      TGLUtil::RenderPolyLine(q, q.GetMainTransparency(), q.GetP(), q.Size());
    }
    TGLUtil::UnlockColor();
-   if (q.fRnrPoints)
-      TGLUtil::RenderPolyMarkers(q, q.GetP(), q.Size(),
+   if (q.fRnrPoints) {
+      TGLUtil::RenderPolyMarkers(q, 0,q.GetP(), q.Size(),
                                  rnrCtx.GetPickRadius(),
                                  rnrCtx.Selection());
+   }
 }
diff --git a/graf3d/eve/src/TEveManager.cxx b/graf3d/eve/src/TEveManager.cxx
index d07ac0f..a5c8bc2 100644
--- a/graf3d/eve/src/TEveManager.cxx
+++ b/graf3d/eve/src/TEveManager.cxx
@@ -20,15 +20,18 @@
 #include "TEveBrowser.h"
 #include "TEveGedEditor.h"
 
+#include "TGFrame.h"
 #include "TGStatusBar.h"
 
 #include "TGLSAViewer.h"
 
 #include "TGeoManager.h"
+#include "TGeoMatrix.h"
 #include "TObjString.h"
 #include "TROOT.h"
 #include "TFile.h"
 #include "TMap.h"
+#include "TExMap.h"
 #include "TMacro.h"
 #include "TFolder.h"
 #include "TBrowser.h"
@@ -79,7 +82,7 @@ TEveManager::TEveManager(UInt_t w, UInt_t h, Bool_t map_window, Option_t* opt) :
    fTimerActive    (kFALSE),
    fRedrawTimer    (),
 
-   fStampedElements(),
+   fStampedElements(0),
    fSelection      (0),
    fHighlight      (0),
 
@@ -111,6 +114,8 @@ TEveManager::TEveManager(UInt_t w, UInt_t h, Bool_t map_window, Option_t* opt) :
    fGeometryAliases = new TMap; fGeometryAliases->SetOwnerKeyValue();
    fVizDB           = new TMap; fVizDB->SetOwnerKeyValue();
 
+   fStampedElements = new TExMap;
+
    fSelection = new TEveSelection("Global Selection");
    fSelection->IncDenyDestroy();
    fHighlight = new TEveSelection("Global Highlight");
@@ -154,7 +159,6 @@ TEveManager::TEveManager(UInt_t w, UInt_t h, Bool_t map_window, Option_t* opt) :
 
    fViewers = new TEveViewerList("Viewers");
    fViewers->IncDenyDestroy();
-   fViewers->Connect();
    AddToListTree(fViewers, kFALSE);
 
    fScenes  = new TEveSceneList ("Scenes");
@@ -221,10 +225,17 @@ TEveManager::~TEveManager()
    fSelection->DecDenyDestroy();
 
    delete fMacroFolder;
+   delete fStampedElements;
    delete fGeometryAliases;
    delete fGeometries;
    delete fVizDB;
    delete fExcHandler;
+
+   fLTEFrame->DeleteWindow();
+
+   fBrowser->Disconnect("CloseWindow()", this, "CloseEveWindow()");
+   fBrowser->DontCallClose();
+   fBrowser->CloseWindow(); 
 }
 
 //______________________________________________________________________________
@@ -390,11 +401,14 @@ void TEveManager::DoRedraw3D()
    // Process element visibility changes, mark relevant scenes as changed.
    {
       TEveElement::List_t scenes;
-      for (TEveElement::Set_i i = fStampedElements.begin(); i != fStampedElements.end(); ++i)
+      Long_t     key, value;
+      TExMapIter stamped_elements(fStampedElements);
+      while (stamped_elements.Next(key, value))
       {
-         if ((*i)->GetChangeBits() & TEveElement::kCBVisibility)
+         TEveElement *el = reinterpret_cast<TEveElement*>(key);
+         if (el->GetChangeBits() & TEveElement::kCBVisibility)
          {
-            (*i)->CollectSceneParents(scenes);
+            el->CollectSceneParents(scenes);
          }
       }
       ScenesChanged(scenes);
@@ -406,15 +420,20 @@ void TEveManager::DoRedraw3D()
 
    // Process changed elements again, update GUI (just editor so far,
    // but more can come).
-   for (TEveElement::Set_i i = fStampedElements.begin(); i != fStampedElements.end(); ++i)
    {
-      if (GetEditor()->GetModel() == (*i)->GetEditorObject(eh))
-         EditElement(*i);
-      TEveGedEditor::ElementChanged(*i);
+      Long_t     key, value;
+      TExMapIter stamped_elements(fStampedElements);
+      while (stamped_elements.Next(key, value))
+      {
+         TEveElement *el = reinterpret_cast<TEveElement*>(key);
+         if (GetEditor()->GetModel() == el->GetEditorObject(eh))
+            EditElement(el);
+         TEveGedEditor::ElementChanged(el);
 
-      (*i)->ClearStamps();
+         el->ClearStamps();
+      }
    }
-   fStampedElements.clear();
+   fStampedElements->Delete();
    GetListTree()->ClearViewPort(); // Fix this when several list-trees can be added.
 
    fResetCameras = kFALSE;
@@ -465,6 +484,18 @@ void TEveManager::ScenesChanged(TEveElement::List_t& scenes)
       ((TEveScene*)*s)->Changed();
 }
 
+//______________________________________________________________________________
+void TEveManager::ElementStamped(TEveElement* element)
+{
+   // Mark element as changed -- it will be processed on next redraw.
+
+   UInt_t slot;
+   if (fStampedElements->GetValue((ULong_t) element, (Long_t) element, slot) == 0)
+   {
+      fStampedElements->AddAt(slot, (ULong_t) element, (Long_t) element, 1);
+   }
+}
+
 
 /******************************************************************************/
 // GUI interface
@@ -571,9 +602,8 @@ void TEveManager::PreDeleteElement(TEveElement* element)
    if (fScenes)
       fScenes->DestroyElementRenderers(element);
 
-   TEveElement::Set_i sei = fStampedElements.find(element);
-   if (sei != fStampedElements.end())
-      fStampedElements.erase(sei);
+   if (fStampedElements->GetValue((ULong_t) element, (Long_t) element) != 0)
+      fStampedElements->Remove((ULong_t) element, (Long_t) element);
 
    if (element->fImpliedSelected > 0)
       fSelection->RemoveImpliedSelected(element);
@@ -780,7 +810,12 @@ TGeoManager* TEveManager::GetGeometry(const TString& filename)
           filename.Data(), exp_filename.Data());
 
    gGeoManager = (TGeoManager*) fGeometries->GetValue(filename);
-   if (!gGeoManager) {
+   if (gGeoManager)
+   {
+      gGeoIdentity = (TGeoIdentity*) gGeoManager->GetListOfMatrices()->At(0);
+   }
+   else
+   {
       Bool_t locked = TGeoManager::IsLocked();
       if (locked) {
          Warning(eh, "TGeoManager is locked ... unlocking it.");
@@ -939,14 +974,7 @@ void TEveManager::Terminate()
 
    TEveGedEditor::DestroyEditors();
 
-   TEveGListTreeEditorFrame *lf = gEve->fLTEFrame;
-   TEveBrowser              *b  = gEve->GetBrowser();
-
    delete gEve;
-
-   delete lf;
-   delete b;
-
    gEve = 0;
 }
 
diff --git a/graf3d/eve/src/TEvePathMark.cxx b/graf3d/eve/src/TEvePathMark.cxx
new file mode 100644
index 0000000..b0df7f3
--- /dev/null
+++ b/graf3d/eve/src/TEvePathMark.cxx
@@ -0,0 +1,49 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEvePathMark.h"
+
+//==============================================================================
+// TEvePathMark
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Special-point on track:
+//  kDaughter  - daughter creation; fP is momentum of the daughter, it is subtracted from
+//               momentum of the track
+//  kReference - position/momentum reference
+//  kDecay     - decay point, fP not used
+//  kCluster2D - measurement with large error in one direction (like strip detectors):
+//               fP - normal to detector plane,
+//               fE - large error direction, must be normalized.
+//               Track is propagated to plane and correction in fE direction is discarded.
+
+ClassImp(TEvePathMarkT<Float_t>);
+ClassImp(TEvePathMarkT<Double_t>);
+
+//______________________________________________________________________________
+template<typename TT> const char* TEvePathMarkT<TT>::TypeName()
+{
+   // Return the name of path-mark type.
+
+   switch (fType)
+   {
+      case kDaughter:  return "Daughter";
+      case kReference: return "Reference";
+      case kDecay:     return "Decay";
+      case kCluster2D: return "Cluster2D";
+      default:         return "Unknown";
+   }
+}
+
+template class TEvePathMarkT<Float_t>;
+template class TEvePathMarkT<Double_t>;
diff --git a/graf3d/eve/src/TEvePointSet.cxx b/graf3d/eve/src/TEvePointSet.cxx
index 286686c..1e45b3b 100644
--- a/graf3d/eve/src/TEvePointSet.cxx
+++ b/graf3d/eve/src/TEvePointSet.cxx
@@ -149,14 +149,6 @@ const TGPicture* TEvePointSet::GetListTreeIcon(Bool_t)
 }
 
 //______________________________________________________________________________
-void TEvePointSet::ComputeBBox()
-{
-   // Override of virtual method from TAttBBox.
-
-   TPointSet3D::ComputeBBox();
-}
-
-//______________________________________________________________________________
 void TEvePointSet::Reset(Int_t n_points, Int_t n_int_ids)
 {
    // Drop all data and set-up the data structures to recive new data.
@@ -788,7 +780,7 @@ void TEvePointSetProjected::SetProjection(TEveProjectionManager* proj,
    // Virtual from TEveProjected.
 
    TEveProjected::SetProjection(proj, model);
-   * (TAttMarker*)this = * dynamic_cast<TAttMarker*>(fProjectable);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
index f5a5453..aa52058 100644
--- a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
@@ -163,10 +163,13 @@ void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
 }
 
 //______________________________________________________________________________
-void TEvePolygonSetProjectedGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const
+void TEvePolygonSetProjectedGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl) const
 {
    // Draw polygons in highlight mode.
 
+   // XXXX to support highlight AND selection ...
+   if (lvl < 0) lvl = pshp->GetSelected();
+
    TEvePolygonSetProjected& refPS = * (TEvePolygonSetProjected*) fExternalObj;
 
    if (refPS.GetHighlightFrame())
diff --git a/graf3d/eve/src/TEveProjectionBases.cxx b/graf3d/eve/src/TEveProjectionBases.cxx
index 5822ea2..200f234 100644
--- a/graf3d/eve/src/TEveProjectionBases.cxx
+++ b/graf3d/eve/src/TEveProjectionBases.cxx
@@ -51,7 +51,7 @@ TEveProjectable::~TEveProjectable()
    {
       TEveProjected* p = fProjectedList.front();
       p->UnRefProjectable(this);
-      TEveElement* el = dynamic_cast<TEveElement*>(p);
+      TEveElement* el = p->GetProjectedAsElement();
       assert(el);
       // if (el)
       {
@@ -69,7 +69,7 @@ void TEveProjectable::AddProjectedsToSet(std::set<TEveElement*>& set)
 
    for (ProjList_i i=fProjectedList.begin(); i!=fProjectedList.end(); ++i)
    {
-      set.insert(dynamic_cast<TEveElement*>(*i));
+      set.insert((*i)->GetProjectedAsElement());
    }
 }
 
@@ -87,7 +87,7 @@ void TEveProjectable::PropagateVizParams(TEveElement* el)
 
    for (ProjList_i i=fProjectedList.begin(); i!=fProjectedList.end(); ++i)
    {
-      dynamic_cast<TEveElement*>(*i)->CopyVizParams(el);
+      (*i)->GetProjectedAsElement()->CopyVizParams(el);
    }
 }
 
@@ -98,9 +98,8 @@ void TEveProjectable::PropagateRenderState(Bool_t rnr_self, Bool_t rnr_children)
 
    for (ProjList_i i=fProjectedList.begin(); i!=fProjectedList.end(); ++i)
    {
-      TEveElement* el = dynamic_cast<TEveElement*>(*i);
-      if (el->SetRnrSelfChildren(rnr_self, rnr_children))
-         el->ElementChanged();
+      if ((*i)->GetProjectedAsElement()->SetRnrSelfChildren(rnr_self, rnr_children))
+         (*i)->GetProjectedAsElement()->ElementChanged();
    }
 }
 
@@ -111,9 +110,21 @@ void TEveProjectable::PropagateMainColor(Color_t color, Color_t old_color)
 
    for (ProjList_i i=fProjectedList.begin(); i!=fProjectedList.end(); ++i)
    {
-      TEveElement* el = dynamic_cast<TEveElement*>(*i);
-      if (el->GetMainColor() == old_color)
-         el->SetMainColor(color);
+      if ((*i)->GetProjectedAsElement()->GetMainColor() == old_color)
+         (*i)->GetProjectedAsElement()->SetMainColor(color);
+   }
+}
+
+//______________________________________________________________________________
+void TEveProjectable::PropagateMainTransparency(Char_t t, Char_t old_t)
+{
+   // Set main transparency of projecteds if their transparecy is the
+   // same as the old one.
+
+   for (ProjList_i i=fProjectedList.begin(); i!=fProjectedList.end(); ++i)
+   {
+      if ((*i)->GetProjectedAsElement()->GetMainTransparency() == old_t)
+         (*i)->GetProjectedAsElement()->SetMainTransparency(t);
    }
 }
 
@@ -153,11 +164,11 @@ TEveProjected::~TEveProjected()
 }
 
 //______________________________________________________________________________
-TEveElement* TEveProjected::GetProjectableAsElement() const
+TEveElement* TEveProjected::GetProjectedAsElement()
 {
    // Returns fProjectable dynamic-casted to TEveElement.
 
-   return dynamic_cast<TEveElement*>(fProjectable);
+   return dynamic_cast<TEveElement*>(this);
 }
 
 //______________________________________________________________________________
@@ -218,3 +229,11 @@ void TEveProjected::SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox)
       el->StampTransBBox();
    }
 }
+
+//______________________________________________________________________________
+void TEveProjected::SetDepthLocal(Float_t d)
+{
+   // Base-class implementation -- just sets fDepth.
+
+   fDepth = d;
+}
diff --git a/graf3d/eve/src/TEveProjectionManager.cxx b/graf3d/eve/src/TEveProjectionManager.cxx
index 2136d50..196db3d 100644
--- a/graf3d/eve/src/TEveProjectionManager.cxx
+++ b/graf3d/eve/src/TEveProjectionManager.cxx
@@ -311,6 +311,44 @@ TEveElement* TEveProjectionManager::SubImportElements(TEveElement* el,
 }
 
 //______________________________________________________________________________
+Int_t TEveProjectionManager::SubImportChildren(TEveElement* el, TEveElement* proj_parent)
+{
+   // Recursively import childer elements of el and apply projection
+   // to the newly imported objects.
+   //
+   // The proj_parent argument should be a projected replica of
+   // element 'el'. This allows to insert projected children of
+   // a given element when they are added after the projection has
+   // been already performed on the parent.
+   // This is called from TEveElement::ProjectChild().
+   //
+   // Returns the projected replica of el. Can be 0, if el and none of
+   // its children are projectable.
+
+   List_t new_els;
+   for (List_i i = el->BeginChildren(); i != el->EndChildren(); ++i)
+   {
+      TEveElement* new_el = ImportElementsRecurse(*i, proj_parent);
+      if (new_el)
+         new_els.push_back(new_el);
+   }
+
+   if ( ! new_els.empty())
+   {
+      AssertBBox();
+      for (List_i i = new_els.begin(); i != new_els.end(); ++i)
+      {
+         ProjectChildrenRecurse(*i);
+      }
+      AssertBBoxExtents(0.1);
+      StampTransBBox();
+
+      UpdateDependentElsAndScenes(proj_parent);
+   }
+   return (Int_t) new_els.size();
+}
+
+//______________________________________________________________________________
 void TEveProjectionManager::ProjectChildrenRecurse(TEveElement* el)
 {
    // Project el (via TEveProjected::UpdateProjection()) and recurse
diff --git a/graf3d/eve/src/TEveProjections.cxx b/graf3d/eve/src/TEveProjections.cxx
index e9d9ebd..ed089f3 100644
--- a/graf3d/eve/src/TEveProjections.cxx
+++ b/graf3d/eve/src/TEveProjections.cxx
@@ -327,6 +327,33 @@ void TEveProjection::SetPastFixZFac(Float_t x)
 }
 
 //______________________________________________________________________________
+void TEveProjection::BisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr)
+{
+   // Find break-point on both sides of the discontinuity.
+   // They still need to be projected.
+
+   TEveVector vM, vLP, vMP;
+   while ((vL-vR).Mag2() > eps_sqr)
+   {
+      vM.Mult(vL+vR, 0.5f);
+      vLP.Set(vL); ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
+      vMP.Set(vM); ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
+
+      if (IsOnSubSpaceBoundrary(vMP))
+      {
+         vL.Set(vM);
+         vR.Set(vM);
+         return;
+      }
+
+      if (AcceptSegment(vLP, vMP, 0.0f))
+         vL.Set(vM);
+      else
+         vR.Set(vM);
+   }
+}
+
+//______________________________________________________________________________
 void TEveProjection::SetDirectionalVector(Int_t screenAxis, TEveVector& vec)
 {
    // Get vector for axis in a projected space.
@@ -556,6 +583,13 @@ Int_t TEveRhoZProjection::SubSpaceId(const TEveVector& v) const
    return v.fY > fProjectedCenter.fY ? 0 : 1;
 }
 
+//______________________________________________________________________________
+Bool_t TEveRhoZProjection::IsOnSubSpaceBoundrary(const TEveVector& v) const
+{
+   // Checks if point is on sub-space boundrary.
+
+   return v.fY == fProjectedCenter.fY;
+}
 
 //==============================================================================
 //==============================================================================
diff --git a/graf3d/eve/src/TEveQuadSet.cxx b/graf3d/eve/src/TEveQuadSet.cxx
index e5fa884..a8a7ef1 100644
--- a/graf3d/eve/src/TEveQuadSet.cxx
+++ b/graf3d/eve/src/TEveQuadSet.cxx
@@ -47,8 +47,7 @@ TEveQuadSet::TEveQuadSet(const char* n, const char* t) :
    fQuadType  (kQT_Undef),
    fDefWidth  (1),
    fDefHeight (1),
-   fDefCoord  (0),
-   fAntiFlick (kTRUE)
+   fDefCoord  (0)
 {
    // Constructor.
 }
@@ -61,8 +60,7 @@ TEveQuadSet::TEveQuadSet(EQuadType_e quadType, Bool_t valIsCol, Int_t chunkSize,
    fQuadType  (kQT_Undef),
    fDefWidth  (1),
    fDefHeight (1),
-   fDefCoord  (0),
-   fAntiFlick (kTRUE)
+   fDefCoord  (0)
 {
    // Constructor.
 
diff --git a/graf3d/eve/src/TEveQuadSetGL.cxx b/graf3d/eve/src/TEveQuadSetGL.cxx
index 1cc1328..575aa2b 100644
--- a/graf3d/eve/src/TEveQuadSetGL.cxx
+++ b/graf3d/eve/src/TEveQuadSetGL.cxx
@@ -15,7 +15,6 @@
 #include "TEveFrameBoxGL.h"
 
 #include "TGLRnrCtx.h"
-#include "TGLSelectRecord.h"
 #include "TGLIncludes.h"
 
 //==============================================================================
@@ -31,7 +30,7 @@ ClassImp(TEveQuadSetGL);
 /******************************************************************************/
 
 //______________________________________________________________________________
-TEveQuadSetGL::TEveQuadSetGL() : TGLObject(), fM(0)
+TEveQuadSetGL::TEveQuadSetGL() : TEveDigitSetGL(), fM(0)
 {
    // Constructor.
 
@@ -46,43 +45,11 @@ Bool_t TEveQuadSetGL::SetModel(TObject* obj, const Option_t* /*opt*/)
 {
    // Set model object.
 
-   Bool_t ok = SetModelCheckClass(obj, TEveQuadSet::Class());
-   fM = ok ? dynamic_cast<TEveQuadSet*>(obj) : 0;
-   return ok;
-}
-
-//______________________________________________________________________________
-void TEveQuadSetGL::SetBBox()
-{
-   // Setup bounding box.
-
-   SetAxisAlignedBBox(fM->AssertBBox());
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-inline Bool_t TEveQuadSetGL::SetupColor(const TEveDigitSet::DigitBase_t& q) const
-{
-   // Set color for rendering of the specified quad.
-
-   if (fM->fSingleColor)
-   {
+   if (SetModelCheckClass(obj, TEveQuadSet::Class())) {
+      fM  = dynamic_cast<TEveQuadSet*>(obj);
       return kTRUE;
    }
-   else if (fM->fValueIsColor)
-   {
-      TGLUtil::Color4ubv((UChar_t*) & q.fValue);
-      return kTRUE;
-   }
-   else
-   {
-      UChar_t c[4];
-      Bool_t visible = fM->fPalette->ColorFromValue(q.fValue, fM->fDefaultValue, c);
-      if (visible)
-         TGLUtil::Color3ubv(c);
-      return visible;
-   }
+   return kFALSE;
 }
 
 /******************************************************************************/
@@ -135,14 +102,15 @@ void TEveQuadSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
       glPopAttrib();
    }
 
-   if (mQ.fFrame != 0 && ! rnrCtx.SecSelection())
+   if (mQ.fFrame != 0 && ! rnrCtx.SecSelection() && 
+       ! (rnrCtx.Highlight() && AlwaysSecondarySelect()))
    {
       TEveFrameBoxGL::Render(mQ.fFrame);
    }
 }
 
 //______________________________________________________________________________
-void TEveQuadSetGL::RenderQuads(TGLRnrCtx & rnrCtx) const
+void TEveQuadSetGL::RenderQuads(TGLRnrCtx& rnrCtx) const
 {
    // GL rendering for free-quads and rectangles.
 
@@ -163,6 +131,8 @@ void TEveQuadSetGL::RenderQuads(TGLRnrCtx & rnrCtx) const
    }
 
    TEveChunkManager::iterator qi(mQ.fPlex);
+   if (rnrCtx.Highlight() && fHighlightSet)
+      qi.fSelection = fHighlightSet;
 
    if (rnrCtx.SecSelection()) glPushName(0);
 
@@ -428,6 +398,8 @@ void TEveQuadSetGL::RenderLines(TGLRnrCtx & rnrCtx) const
    TEveQuadSet& mQ = * fM;
 
    TEveChunkManager::iterator qi(mQ.fPlex);
+   if (rnrCtx.Highlight() && fHighlightSet)
+      qi.fSelection = fHighlightSet;
 
    if (rnrCtx.SecSelection()) glPushName(0);
 
@@ -493,6 +465,8 @@ void TEveQuadSetGL::RenderHexagons(TGLRnrCtx & rnrCtx) const
    glNormal3f(0, 0, 1);
 
    TEveChunkManager::iterator qi(mQ.fPlex);
+   if (rnrCtx.Highlight() && fHighlightSet)
+      qi.fSelection = fHighlightSet;
 
    if (rnrCtx.SecSelection()) glPushName(0);
 
@@ -554,16 +528,3 @@ void TEveQuadSetGL::RenderHexagons(TGLRnrCtx & rnrCtx) const
 
    if (rnrCtx.SecSelection()) glPopName();
 }
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEveQuadSetGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
-{
-   // Processes secondary selection from TGLViewer.
-   // Calls DigitSelected(Int_t) in the model object with index of
-   // selected point as the argument.
-
-   if (rec.GetN() < 2) return;
-   fM->DigitSelected(rec.GetItem(1));
-}
diff --git a/graf3d/eve/src/TEveRGBAPalette.cxx b/graf3d/eve/src/TEveRGBAPalette.cxx
index b635c85..f9b056a 100644
--- a/graf3d/eve/src/TEveRGBAPalette.cxx
+++ b/graf3d/eve/src/TEveRGBAPalette.cxx
@@ -25,7 +25,7 @@
 //  false - MinValue -> MaxValue
 
 
-ClassImp(TEveRGBAPalette)
+ClassImp(TEveRGBAPalette);
 
 //______________________________________________________________________________
 TEveRGBAPalette::TEveRGBAPalette() :
diff --git a/graf3d/eve/src/TEveScene.cxx b/graf3d/eve/src/TEveScene.cxx
index 5940e39..16744c0 100644
--- a/graf3d/eve/src/TEveScene.cxx
+++ b/graf3d/eve/src/TEveScene.cxx
@@ -15,11 +15,14 @@
 #include "TEveTrans.h"
 #include "TEvePad.h"
 
-#include "TList.h"
 #include "TGLScenePad.h"
 #include "TGLLogicalShape.h"
 #include "TGLPhysicalShape.h"
 
+#include "TList.h"
+#include "TExMap.h"
+
+
 //==============================================================================
 //==============================================================================
 // TEveScene
@@ -291,7 +294,7 @@ void TEveSceneList::DestroyElementRenderers(TEveElement* element)
 }
 
 //______________________________________________________________________________
-void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
+void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, TExMap* stampMap)
 {
    // Loop over all scenes and update them accordingly:
    //   a) if scene is marked as changed, it is repainted;
@@ -301,6 +304,24 @@ void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
    // This allows much finer update granularity without resetting of
    // complex GL-viewer and GL-scene state.
 
+   // We need changed elements sorted by their "render object" as we do
+   // parallel iteration over this list and the list of logical shapes
+   // in every scene.
+
+   typedef std::map<TObject*, TEveElement*> mObjectElement_t;
+   typedef mObjectElement_t::iterator       mObjectElement_i;
+
+   mObjectElement_t changed_objects;
+   {
+      Long_t     key, value;
+      TExMapIter stamped_elements(stampMap);
+      while (stamped_elements.Next(key, value))
+      {
+         TEveElement *el = reinterpret_cast<TEveElement*>(key);
+         changed_objects.insert(std::make_pair(el->GetRenderObject(), el));
+      }
+   }
+
    for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
    {
       TEveScene* s = (TEveScene*) *i;
@@ -318,18 +339,14 @@ void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
          s->GetGLScene()->BeginUpdate();
 
          // Process stamps.
-         TGLScene::LogicalShapeMap_t& logs = s->GetGLScene()->RefLogicalShapes();
-         TGLScene::LogicalShapeMapIt_t li = logs.begin();
-
-         Set_i ei = stampSet.begin();
+         TGLScene::LogicalShapeMap_t   &logs = s->GetGLScene()->RefLogicalShapes();
+         TGLScene::LogicalShapeMapIt_t  li   = logs.begin();
 
-         TObject* eobj = 0;
+         mObjectElement_i ei = changed_objects.begin();
 
-         while (li != logs.end() && ei != stampSet.end())
+         while (li != logs.end() && ei != changed_objects.end())
          {
-            if (!eobj) eobj = (*ei)->GetRenderObject();
-
-            if (li->first == eobj)
+            if (li->first == ei->first)
             {
                if (li->second->Ref() != 1)
                   Warning("TEveSceneList::ProcessSceneChanges",
@@ -337,7 +354,7 @@ void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
 
                TGLLogicalShape  *lshp = li->second;
                TGLPhysicalShape *pshp = const_cast<TGLPhysicalShape*>(lshp->GetFirstPhysical());
-               TEveElement      *el   = *ei;
+               TEveElement      *el   = ei->second;
                UChar_t           bits = el->GetChangeBits();
 
                if (bits & kCBColorSelection)
@@ -361,16 +378,16 @@ void TEveSceneList::ProcessSceneChanges(Bool_t dropLogicals, Set_t& stampSet)
                   lshp->DLCacheClear();
                }
 
-               ++li; ++ei; eobj = 0;
+               ++li; ++ei;
                updateViewers = kTRUE;
             }
-            else if (li->first < eobj)
+            else if (li->first < ei->first)
             {
                ++li;
             }
             else
             {
-               ++ei; eobj = 0;
+               ++ei;
             }
          }
 
diff --git a/graf3d/eve/src/TEveSecondarySelectable.cxx b/graf3d/eve/src/TEveSecondarySelectable.cxx
new file mode 100644
index 0000000..0480438
--- /dev/null
+++ b/graf3d/eve/src/TEveSecondarySelectable.cxx
@@ -0,0 +1,113 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveSecondarySelectable.h"
+#include "TEveElement.h"
+
+#include "TGLSelectRecord.h"
+
+//______________________________________________________________________________
+//
+// Semi-abstract interface for classes supporting secondary-selection.
+//
+// Element class that inherits from this, should also implement the
+// following virtuals from TEveElement:
+//    virtual void UnSelected();
+//    virtual void UnHighlighted();
+// and clear corresponding selection-set from there.
+//
+// To support tooltips for sub-elements, implement:
+//    virtual TString GetHighlightTooltip();
+// and return tooltip for the entry in the fHighlightedSet.
+// There should always be a single entry there.
+
+
+ClassImp(TEveSecondarySelectable);
+
+//______________________________________________________________________________
+TEveSecondarySelectable::TEveSecondarySelectable() :
+   fAlwaysSecSelect(kFALSE)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+void TEveSecondarySelectable::ProcessGLSelection(TGLSelectRecord& rec)
+{
+   // Process secondary GL selection and populate selected set accordingly.
+
+   if (rec.GetHighlight())
+      ProcessGLSelectionInternal(rec, fHighlightedSet);
+   else
+      ProcessGLSelectionInternal(rec, fSelectedSet);
+}
+
+//______________________________________________________________________________
+void TEveSecondarySelectable::ProcessGLSelectionInternal(TGLSelectRecord& rec,
+                                                         SelectionSet_t& sset)
+{
+   // Process secondary GL selection and populate given set accordingly.
+
+   Int_t id = (rec.GetN() > 1) ? (Int_t) rec.GetItem(1) : -1;
+
+   if (sset.empty())
+   {
+      if (id >= 0)
+      {
+         sset.insert(id);
+         rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
+      }  
+   }
+   else
+   {
+      if (id >= 0)
+      {
+         if (rec.GetMultiple())
+         {
+            if (sset.find(id) == sset.end())
+            {
+               sset.insert(id);
+               rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
+            }
+            else
+            {
+               sset.erase(id);
+               if (sset.empty())
+                  rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
+               else
+                  rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
+           }
+         }
+         else
+         {
+            if (sset.size() != 1 || sset.find(id) == sset.end())
+            {
+               sset.clear();
+               sset.insert(id);
+               rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
+            }
+         }
+      }
+      else
+      {
+         if (!rec.GetMultiple())
+         {
+            sset.clear();
+            rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
+         }
+      }
+   }
+
+   if (rec.GetSecSelResult() != TGLSelectRecord::kNone)
+   {
+      dynamic_cast<TEveElement*>(this)->StampColorSelection();
+   }
+}
diff --git a/graf3d/eve/src/TEveShape.cxx b/graf3d/eve/src/TEveShape.cxx
index eddbb74..2686115 100644
--- a/graf3d/eve/src/TEveShape.cxx
+++ b/graf3d/eve/src/TEveShape.cxx
@@ -35,6 +35,8 @@ TEveShape::TEveShape(const char* n, const char* t) :
 {
    // Constructor.
 
+   fCanEditMainColor        = kTRUE;
+   fCanEditMainTransparency = kTRUE;
    SetMainColorPtr(&fFillColor);
 }
 
@@ -102,7 +104,7 @@ void TEveShape::Paint(Option_t*)
 //==============================================================================
 
 //______________________________________________________________________________
-Int_t TEveShape::FindConvexHull(const vPoint_t& pin, vPoint_t& pout, TEveElement* caller)
+Int_t TEveShape::FindConvexHull(const vVector2_t& pin, vVector2_t& pout, TEveElement* caller)
 {
    // Determines the convex-hull of points in pin.
    //
@@ -202,7 +204,7 @@ Int_t TEveShape::FindConvexHull(const vPoint_t& pin, vPoint_t& pout, TEveElement
    // Print the hull.
    // for (Int_t i = 0; i < N; ++i)
    // {
-   //    const TEvePoint &p = pin[hull[i]];
+   //    const TEveVector2 &p = pin[hull[i]];
    //    printf("%d [%d] (%5.1f, %5.1f) %f\n", i, hull[i], p.fX, p.fY, angles[hull[i]]);
    // }
 
diff --git a/graf3d/eve/src/TEveStraightLineSet.cxx b/graf3d/eve/src/TEveStraightLineSet.cxx
index 43be6c7..326558c 100644
--- a/graf3d/eve/src/TEveStraightLineSet.cxx
+++ b/graf3d/eve/src/TEveStraightLineSet.cxx
@@ -54,20 +54,56 @@ TEveStraightLineSet::TEveStraightLineSet(const char* n, const char* t):
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveStraightLineSet::AddLine(Float_t x1, Float_t y1, Float_t z1,
-                                  Float_t x2, Float_t y2, Float_t z2)
+TEveStraightLineSet::Line_t*
+TEveStraightLineSet::AddLine(Float_t x1, Float_t y1, Float_t z1,
+                             Float_t x2, Float_t y2, Float_t z2)
 {
    // Add a line.
 
    fLastLine = new (fLinePlex.NewAtom()) Line_t(x1, y1, z1, x2, y2, z2);
+   fLastLine->fId = fLinePlex.Size() - 1;
+   return fLastLine;
 }
 
 //______________________________________________________________________________
-void TEveStraightLineSet::AddMarker(Int_t line, Float_t pos)
+TEveStraightLineSet::Line_t*
+TEveStraightLineSet::AddLine(const TEveVector& p1, const TEveVector& p2)
+{
+   // Add a line.
+
+   return AddLine(p1.fX, p1.fY, p1.fZ, p2.fX, p2.fY, p2.fZ);
+}
+
+//______________________________________________________________________________
+TEveStraightLineSet::Marker_t*
+TEveStraightLineSet::AddMarker(Float_t x, Float_t y, Float_t z, Int_t line_id)
+{
+   // Add a marker with given position.
+
+   Marker_t* marker = new (fMarkerPlex.NewAtom()) Marker_t(x, y, z, line_id);
+   return marker;
+}
+
+//______________________________________________________________________________
+TEveStraightLineSet::Marker_t*
+TEveStraightLineSet::AddMarker(const TEveVector& p, Int_t line_id)
+{
+   // Add a marker with given position.
+
+   return AddMarker(p.fX, p.fY, p.fZ, line_id);
+}
+
+//______________________________________________________________________________
+TEveStraightLineSet::Marker_t*
+TEveStraightLineSet::AddMarker(Int_t line_id, Float_t pos)
 {
    // Add a marker for line with given index on relative position pos.
 
-   /*Marker_t* marker = */new (fMarkerPlex.NewAtom()) Marker_t(line, pos);
+   Line_t& l = * (Line_t*) fLinePlex.Atom(line_id);
+   return AddMarker(l.fV1[0] + (l.fV2[0] - l.fV1[0])*pos,
+                    l.fV1[1] + (l.fV2[1] - l.fV1[1])*pos,
+                    l.fV1[2] + (l.fV2[2] - l.fV1[2])*pos,
+                    line_id);
 }
 
 /******************************************************************************/
@@ -124,7 +160,6 @@ void TEveStraightLineSet::ComputeBBox()
    // Compute bounding-box.
    // Virtual from TAttBBox.
 
-   static const TEveException eH("TEveStraightLineSet::ComputeBBox ");
    if(fLinePlex.Size() == 0) {
       BBoxZero();
       return;
@@ -137,6 +172,12 @@ void TEveStraightLineSet::ComputeBBox()
       BBoxCheckPoint(((Line_t*)li())->fV1);
       BBoxCheckPoint(((Line_t*)li())->fV2);
    }
+
+   TEveChunkManager::iterator mi(fMarkerPlex);
+   while (mi.next())
+   {
+      BBoxCheckPoint(((Marker_t*)mi())->fV);
+   }
 }
 
 /******************************************************************************/
@@ -178,9 +219,7 @@ void TEveStraightLineSetProjected::SetProjection(TEveProjectionManager* mng,
 
    TEveProjected::SetProjection(mng, model);
 
-   // copy line and marker attributes
-   * (TAttMarker*)this = * dynamic_cast<TAttMarker*>(fProjectable);
-   * (TAttLine*)  this = * dynamic_cast<TAttLine*>(fProjectable);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
 }
 
 //______________________________________________________________________________
@@ -197,6 +236,13 @@ void TEveStraightLineSetProjected::SetDepthLocal(Float_t d)
       l.fV1[2] = fDepth;
       l.fV2[2] = fDepth;
    }
+
+   TEveChunkManager::iterator mi(fMarkerPlex);
+   while (mi.next())
+   {
+      Marker_t& m = * (Marker_t*) mi();
+      m.fV[2] = fDepth;
+   }
 }
 
 //______________________________________________________________________________
@@ -213,44 +259,50 @@ void TEveStraightLineSetProjected::UpdateProjection()
    BBoxClear();
 
    // Lines
-   fLinePlex.Reset(sizeof(Line_t), orig.GetLinePlex().Size());
-   Float_t p1[3];
-   Float_t p2[3];
+   Int_t num_lines = orig.GetLinePlex().Size();
+   if (proj.HasSeveralSubSpaces())
+      num_lines += TMath::Max(1, num_lines/10);
+   fLinePlex.Reset(sizeof(Line_t), num_lines);
+   TEveVector p1, p2;
    TEveChunkManager::iterator li(orig.GetLinePlex());
-
-   TEveTrans& origTrans = orig.RefMainTrans();
-   Double_t s1, s2, s3;
-   Double_t x, y, z;
-   origTrans.GetScale(s1, s2, s3);
-   origTrans.GetPos(x, y, z);
-
-   TEveTrans mx;
-   mx.Scale(s1, s2, s3);
    while (li.next())
    {
-      Line_t* l = (Line_t*) li();
+      Line_t *l = (Line_t*) li();
 
       proj.ProjectPointfv(trans, l->fV1, p1, fDepth);
       proj.ProjectPointfv(trans, l->fV2, p2, fDepth);
 
-      AddLine(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
+      if (proj.AcceptSegment(p1, p2, 0.1f))
+      {
+         AddLine(p1, p2)->fId = l->fId;
+      }
+      else
+      {
+         TEveVector bp1(l->fV1), bp2(l->fV2);
+         if (trans) {
+            trans->MultiplyIP(bp1);
+            trans->MultiplyIP(bp2);
+         }
+         proj.BisectBreakPoint(bp1, bp2, 1e-10f);
+         proj.ProjectVector(bp1, fDepth);
+         proj.ProjectVector(bp2, fDepth);
+
+         AddLine(p1, bp1)->fId = l->fId;
+         AddLine(bp2, p2)->fId = l->fId;
+      }
    }
+   if (proj.HasSeveralSubSpaces())
+      fLinePlex.Refit();
 
    // Markers
    fMarkerPlex.Reset(sizeof(Marker_t), orig.GetMarkerPlex().Size());
    TEveChunkManager::iterator mi(orig.GetMarkerPlex());
+   TEveVector pp;
    while (mi.next())
    {
-      Marker_t *m = (Marker_t*) mi();
-      Line_t  *lo = (Line_t*) orig.GetLinePlex().Atom(m->fLineID);
-      Line_t  *lp = (Line_t*) fLinePlex.Atom(m->fLineID);
-
-      TEveVector t1, d, xx;
-
-      t1.Set(lo->fV1); xx.Set(lo->fV2); xx -= t1; xx *= m->fPos; xx += t1;
-      proj.ProjectVector(trans, xx, 0);
-      t1.Set(lp->fV1); d.Set(lp->fV2); d -= t1; xx -= t1;
+      Marker_t &m = * (Marker_t*) mi();
 
-      AddMarker(m->fLineID, d.Dot(xx) / d.Mag2());
+      proj.ProjectPointfv(trans, m.fV, pp, fDepth);
+      AddMarker(pp, m.fLineId);
    }
 }
diff --git a/graf3d/eve/src/TEveStraightLineSetGL.cxx b/graf3d/eve/src/TEveStraightLineSetGL.cxx
index 3af1429..77a252c 100644
--- a/graf3d/eve/src/TEveStraightLineSetGL.cxx
+++ b/graf3d/eve/src/TEveStraightLineSetGL.cxx
@@ -91,7 +91,6 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
 
    TEveStraightLineSet& mL = * fM;
 
-   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    if (mL.GetDepthTest() == kFALSE)
    {
       glPushAttrib(GL_VIEWPORT_BIT);
@@ -102,6 +101,7 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
    if (mL.GetRnrLines() && mL.GetLinePlex().Size() > 0)
    {
       glPushAttrib(GL_LINE_BIT | GL_ENABLE_BIT);
+      glDisable(GL_LIGHTING);
       TGLUtil::LineWidth(mL.GetLineWidth());
       if (mL.GetLineStyle() > 1) {
          Int_t    fac = 1;
@@ -135,7 +135,7 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
          while (li.next())
          {
             TEveStraightLineSet::Line_t& l = * (TEveStraightLineSet::Line_t*) li();
-            glLoadName(name);
+            glLoadName(l.fId);
             {
                glBegin(GL_LINES);
                glVertex3f(l.fV1[0], l.fV1[1], l.fV1[2]);
@@ -172,19 +172,16 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
       TEveChunkManager::iterator mi(mL.GetMarkerPlex());
       Float_t* pnts = new Float_t[mL.GetMarkerPlex().Size()*3];
       Float_t* pnt  = pnts;
-      Int_t lidx = -1;
       while (mi.next())
       {
          TEveStraightLineSet::Marker_t& m = * (TEveStraightLineSet::Marker_t*) mi();
-         lidx = m.fLineID;
-         TEveStraightLineSet::Line_t& l = * (TEveStraightLineSet::Line_t*) mL.GetLinePlex().Atom(lidx);
-         pnt[0] = l.fV1[0] + (l.fV2[0] - l.fV1[0])*m.fPos;
-         pnt[1] = l.fV1[1] + (l.fV2[1] - l.fV1[1])*m.fPos;
-         pnt[2] = l.fV1[2] + (l.fV2[2] - l.fV1[2])*m.fPos;
+         pnt[0] = m.fV[0];
+         pnt[1] = m.fV[1];
+         pnt[2] = m.fV[2];
          pnt   += 3;
       }
       if (rnrCtx.SecSelection()) glPushName(2);
-      TGLUtil::RenderPolyMarkers((TAttMarker&)mL,
+      TGLUtil::RenderPolyMarkers((TAttMarker&)mL, mL.GetMainTransparency(),
                                  pnts, mL.GetMarkerPlex().Size(),
                                  rnrCtx.GetPickRadius(),
                                  rnrCtx.Selection(),
@@ -213,6 +210,6 @@ void TEveStraightLineSetGL::ProcessSelection(TGLRnrCtx& /*rnrCtx*/,
    else
    {
       TEveStraightLineSet::Marker_t& m = * (TEveStraightLineSet::Marker_t*) fM->GetMarkerPlex().Atom(rec.GetItem(2));
-      printf("Selected point %d on line %d\n", rec.GetItem(2), m.fLineID);
+      printf("Selected point %d on line %d\n", rec.GetItem(2), m.fLineId);
    }
 }
diff --git a/graf3d/eve/src/TEveText.cxx b/graf3d/eve/src/TEveText.cxx
index e51432a..d52102f 100644
--- a/graf3d/eve/src/TEveText.cxx
+++ b/graf3d/eve/src/TEveText.cxx
@@ -53,6 +53,8 @@ TEveText::TEveText(const char* txt) :
    fPolygonOffset[0] = 0;
    fPolygonOffset[1] = 0;
 
+   fCanEditMainColor        = kTRUE;
+   fCanEditMainTransparency = kTRUE;
    InitMainTrans();
    SetFontMode(TGLFont::kPixmap);
 }
diff --git a/graf3d/eve/src/TEveTrack.cxx b/graf3d/eve/src/TEveTrack.cxx
index 380a171..0dfdc96 100644
--- a/graf3d/eve/src/TEveTrack.cxx
+++ b/graf3d/eve/src/TEveTrack.cxx
@@ -42,8 +42,6 @@
 
 ClassImp(TEveTrack);
 
-Bool_t TEveTrack::fgDefaultBreakProjectedTracks = kTRUE;
-
 //______________________________________________________________________________
 TEveTrack::TEveTrack() :
    TEveLine(),
@@ -60,8 +58,7 @@ TEveTrack::TEveTrack() :
    fLockPoints(kFALSE),
    fPathMarks(),
    fLastPMIdx(0),
-   fPropagator(0),
-   fBreakProjectedTracks(kBPTDefault)
+   fPropagator(0)
 {
    // Default constructor.
 }
@@ -82,8 +79,7 @@ TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop):
    fLockPoints(kFALSE),
    fPathMarks(),
    fLastPMIdx(0),
-   fPropagator(0),
-   fBreakProjectedTracks(kBPTDefault)
+   fPropagator(0)
 {
    // Constructor from TParticle.
 
@@ -115,8 +111,7 @@ TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* prop):
    fLockPoints(kFALSE),
    fPathMarks(),
    fLastPMIdx(0),
-   fPropagator(0),
-   fBreakProjectedTracks(kBPTDefault)
+   fPropagator(0)
 {
    // Constructor from TEveUtil Monte Carlo track.
 
@@ -148,8 +143,7 @@ TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop) :
    fLockPoints(kFALSE),
    fPathMarks(),
    fLastPMIdx(0),
-   fPropagator(0),
-   fBreakProjectedTracks(kBPTDefault)
+   fPropagator(0)
 {
    // Constructor from TEveUtil reconstructed track.
 
@@ -174,8 +168,7 @@ TEveTrack::TEveTrack(const TEveTrack& t) :
    fLockPoints(t.fLockPoints),
    fPathMarks(),
    fLastPMIdx(t.fLastPMIdx),
-   fPropagator(0),
-   fBreakProjectedTracks(t.fBreakProjectedTracks)
+   fPropagator(0)
 {
    // Copy constructor. Track paremeters are copied but the
    // extrapolation is not perfermed so you should still call
@@ -185,16 +178,10 @@ TEveTrack::TEveTrack(const TEveTrack& t) :
    if (fLockPoints)
       ClonePoints(t);
 
-   SetMainColor(t.GetMainColor());
-   // TEveLine
-   fRnrLine   = t.fRnrLine;
-   fRnrPoints = t.fRnrPoints;
-   // TLineAttrib
-   fLineColor = t.fLineColor;
-   fLineStyle = t.fLineStyle;
-   fLineWidth = t.fLineWidth;
    SetPathMarks(t);
    SetPropagator (t.fPropagator);
+
+   CopyVizParams(&t);
 }
 
 //______________________________________________________________________________
@@ -214,8 +201,32 @@ const TGPicture* TEveTrack::GetListTreeIcon(Bool_t)
    return fgListTreeIcons[4];
 }
 
+//______________________________________________________________________________
+void TEveTrack::ComputeBBox()
+{
+   // Compute the bounding box of the track.
+
+   if (Size() > 0 || ! fPathMarks.empty())
+   {
+      BBoxInit();
+      Int_t    n = Size();
+      Float_t* p = TPolyMarker3D::fP;
+      for (Int_t i = 0; i < n; ++i, p += 3)
+      {
+         BBoxCheckPoint(p);
+      }
+      for (vPathMark_ci i = fPathMarks.begin(); i != fPathMarks.end(); ++i)
+      {
+         BBoxCheckPoint(i->fV);
+      }
+   }
+   else
+   {
+      BBoxZero();
+   }
+}
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrack::SetStdTitle()
@@ -248,20 +259,6 @@ void TEveTrack::SetTrackParams(const TEveTrack& t)
 
    fPathMarks.clear();
    SetPropagator(t.fPropagator);
-   fBreakProjectedTracks = t.fBreakProjectedTracks;
-
-   SetMainColor(t.GetMainColor());
-   // TEveLine
-   fRnrLine   = t.fRnrLine;
-   fRnrPoints = t.fRnrPoints;
-   // TMarkerAttrib
-   fMarkerColor = t.fMarkerColor;
-   fMarkerSize  = t.fMarkerSize;
-   fMarkerStyle = t.fMarkerStyle;
-   // TLineAttrib
-   fLineColor = t.fLineColor;
-   fLineStyle = t.fLineStyle;
-   fLineWidth = t.fLineWidth;
 }
 
 //______________________________________________________________________________
@@ -273,7 +270,7 @@ void TEveTrack::SetPathMarks(const TEveTrack& t)
              std::back_insert_iterator<vPathMark_t>(fPathMarks));
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrack::SetPropagator(TEveTrackPropagator* prop)
@@ -287,7 +284,7 @@ void TEveTrack::SetPropagator(TEveTrackPropagator* prop)
    if (fPropagator) prop->IncRefCount(this);
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrack::SetAttLineAttMarker(TEveTrackList* tl)
@@ -305,7 +302,7 @@ void TEveTrack::SetAttLineAttMarker(TEveTrackList* tl)
    SetMarkerSize(tl->GetMarkerSize());
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrack::MakeTrack(Bool_t recurse)
@@ -413,7 +410,7 @@ void TEveTrack::MakeTrack(Bool_t recurse)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrack::CopyVizParams(const TEveElement* el)
@@ -422,11 +419,9 @@ void TEveTrack::CopyVizParams(const TEveElement* el)
 
    // No local parameters.
 
-   const TEveTrack* t = dynamic_cast<const TEveTrack*>(el);
-   if (t)
-   {
-      fBreakProjectedTracks = t->fBreakProjectedTracks;
-   }
+   // const TEveTrack* t = dynamic_cast<const TEveTrack*>(el);
+   // if (t)
+   // {}
 
    TEveLine::CopyVizParams(el);
 }
@@ -438,8 +433,7 @@ void TEveTrack::WriteVizParams(ostream& out, const TString& var)
 
    TEveLine::WriteVizParams(out, var);
 
-   TString t = "   " + var + "->";
-   out << t << "SetBreakProjectedTracks(" << fBreakProjectedTracks << ");\n";
+   // TString t = "   " + var + "->";
 }
 
 //______________________________________________________________________________
@@ -450,30 +444,15 @@ TClass* TEveTrack::ProjectedClass(const TEveProjection*) const
    return TEveTrackProjected::Class();
 }
 
-//______________________________________________________________________________
-Bool_t TEveTrack::ShouldBreakTrack() const
-{
-   // Should this track be broken in projections.
-
-   switch (fBreakProjectedTracks)
-   {
-      default:
-      case kBPTDefault: return fgDefaultBreakProjectedTracks;
-      case kBPTAlways:  return kTRUE;
-      case kBPTNever:   return kFALSE;
-   }
-}
-
-/******************************************************************************/
-
-namespace {
+//==============================================================================
 
-struct Cmp_pathmark_t
+namespace
 {
-   bool operator()(TEvePathMark const & a, TEvePathMark const & b)
-   { return a.fTime < b.fTime; }
-};
-
+   struct Cmp_pathmark_t
+   {
+      bool operator()(TEvePathMark const & a, TEvePathMark const & b)
+      { return a.fTime < b.fTime; }
+   };
 }
 
 //______________________________________________________________________________
@@ -518,24 +497,48 @@ void TEveTrack::SecSelected(TEveTrack* track)
 //------------------------------------------------------------------------------
 
 //______________________________________________________________________________
+Bool_t TEveTrack::ShouldBreakTrack() const
+{
+   // Should this track be broken in projections.
+
+   Error("ShouldBreakTrack", "Deprected -- use TEveTrackPropagator functions.");
+   return fPropagator->GetProjTrackBreaking() == TEveTrackPropagator::kPTB_Break;
+}
+
+//______________________________________________________________________________
+UChar_t TEveTrack::GetBreakProjectedTracks() const
+{
+   // Deprected -- use TEveTrackPropagator functions.
+   Error("GetBreakProjectedTracks", "Deprected -- use TEveTrackPropagator functions.");
+   return 0;
+}
+
+//______________________________________________________________________________
+void TEveTrack::SetBreakProjectedTracks(UChar_t)
+{
+   // Deprected -- use TEveTrackPropagator functions.
+
+   Error("SetBreakProjectedTracks", "Deprected -- use TEveTrackPropagator functions.");
+}
+
+//______________________________________________________________________________
 Bool_t TEveTrack::GetDefaultBreakProjectedTracks()
 {
+   // Deprected -- use TEveTrackPropagator functions.
    // Return true if tracks get broken into several segments when the
    // projected space consists of separate domains (like Rho-Z).
    // Static function.
 
-   return fgDefaultBreakProjectedTracks;
+   ::Error("TEveTrack::GetDefaultBreakProjectedTracks", "Deprected -- use TEveTrackPropagator functions.");
+   return kTRUE;
 }
 
 //______________________________________________________________________________
-void TEveTrack::SetDefaultBreakProjectedTracks(Bool_t bt)
+void TEveTrack::SetDefaultBreakProjectedTracks(Bool_t)
 {
-   // Specify whether 2D projected tracks get broken into several
-   // segments when the projected space consists of separate domains
-   // (like Rho-Z). This is true by default.
-   // Static function.
+   // Deprected -- use TEveTrackPropagator functions.
 
-   fgDefaultBreakProjectedTracks = bt;
+   ::Error("TEveTrack::SetDefaultBreakProjectedTracks", "Deprected -- use TEveTrackPropagator functions.");
 }
 
 
@@ -609,7 +612,7 @@ TEveTrackList::~TEveTrackList()
    SetPropagator(0);
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetPropagator(TEveTrackPropagator* prop)
@@ -624,7 +627,7 @@ void TEveTrackList::SetPropagator(TEveTrackPropagator* prop)
    if (fPropagator) prop->IncRefCount();
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::MakeTracks(Bool_t recurse)
@@ -723,7 +726,7 @@ void TEveTrackList::SanitizeMinMaxCuts()
    fMaxP  = fMaxP  == 0 ? fLimP  : Min(fMaxP,  fLimP);
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetRnrLine(Bool_t rnr)
@@ -757,7 +760,7 @@ void TEveTrackList::SetRnrLine(Bool_t rnr, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetRnrPoints(Bool_t rnr)
@@ -792,7 +795,7 @@ void TEveTrackList::SetRnrPoints(Bool_t rnr, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetMainColor(Color_t col)
@@ -826,7 +829,7 @@ void TEveTrackList::SetLineColor(Color_t col, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetLineWidth(Width_t width)
@@ -860,7 +863,7 @@ void TEveTrackList::SetLineWidth(Width_t width, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetLineStyle(Style_t style)
@@ -894,7 +897,7 @@ void TEveTrackList::SetLineStyle(Style_t style, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetMarkerStyle(Style_t style)
@@ -928,7 +931,7 @@ void TEveTrackList::SetMarkerStyle(Style_t style, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetMarkerColor(Color_t col)
@@ -962,7 +965,7 @@ void TEveTrackList::SetMarkerColor(Color_t col, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SetMarkerSize(Size_t size)
@@ -996,7 +999,7 @@ void TEveTrackList::SetMarkerSize(Size_t size, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::SelectByPt(Float_t min_pt, Float_t max_pt)
@@ -1088,7 +1091,7 @@ void TEveTrackList::SelectByP(Float_t min_p, Float_t max_p, TEveElement* el)
    }
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 TEveTrack* TEveTrackList::FindTrackByLabel(Int_t label)
@@ -1136,7 +1139,7 @@ TEveTrack* TEveTrackList::FindTrackByIndex(Int_t index)
    return 0;
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveTrackList::CopyVizParams(const TEveElement* el)
diff --git a/graf3d/eve/src/TEveTrackEditor.cxx b/graf3d/eve/src/TEveTrackEditor.cxx
index ca6b087..fc79f14 100644
--- a/graf3d/eve/src/TEveTrackEditor.cxx
+++ b/graf3d/eve/src/TEveTrackEditor.cxx
@@ -177,10 +177,10 @@ void TEveTrackListEditor::SetModel(TObject* obj)
 
    Float_t llim;
    fPtRange->SetValues(fTC->fMinPt, fTC->fMaxPt);
-   llim = TMath::Log10(fTC->fLimPt);
+   llim = fTC->fLimPt > 1 ? TMath::Log10(fTC->fLimPt) : 0;
    fPtRange->SetLimits(0, fTC->fLimPt, llim < 2 ? TGNumberFormat::kNESRealTwo : (llim < 3 ? TGNumberFormat::kNESRealOne : TGNumberFormat::kNESInteger));
    fPRange ->SetValues(fTC->fMinP, fTC->fMaxP);
-   llim = TMath::Log10(fTC->fLimP);
+   llim = fTC->fLimP > 1 ? TMath::Log10(fTC->fLimP) : 0;
    fPRange ->SetLimits(0, fTC->fLimP, llim < 2 ? TGNumberFormat::kNESRealTwo : (llim < 3 ? TGNumberFormat::kNESRealOne : TGNumberFormat::kNESInteger));
 
    fRSSubEditor->SetModel(fTC->GetPropagator());
diff --git a/graf3d/eve/src/TEveTrackGL.cxx b/graf3d/eve/src/TEveTrackGL.cxx
index 32fa812..d24b9fd 100644
--- a/graf3d/eve/src/TEveTrackGL.cxx
+++ b/graf3d/eve/src/TEveTrackGL.cxx
@@ -90,6 +90,7 @@ void TEveTrackGL::RenderPathMarksAndFirstVertex(TGLRnrCtx& rnrCtx) const
    if ( ! pms.empty())
    {
       Float_t *pnts = new Float_t[3*pms.size()]; // maximum
+      Int_t    cnt  = 0;
       Int_t    n    = 0;
       for (Int_t i = 0; i < fTrack->fLastPMIdx; ++i)
       {
@@ -99,13 +100,14 @@ void TEveTrackGL::RenderPathMarksAndFirstVertex(TGLRnrCtx& rnrCtx) const
              (pm.fType == TEvePathMark::kDecay     && rTP.GetRnrDecay())      ||
              (pm.fType == TEvePathMark::kCluster2D && rTP.GetRnrCluster2Ds()))
          {
-            pnts[3*n  ] = pm.fV.fX;
-            pnts[3*n+1] = pm.fV.fY;
-            pnts[3*n+2] = pm.fV.fZ;
-            ++n;
+            pnts[n  ] = pm.fV.fX;
+            pnts[n+1] = pm.fV.fY;
+            pnts[n+2] = pm.fV.fZ;
+            n += 3;
+            ++cnt;
          }
       }
-      TGLUtil::RenderPolyMarkers(rTP.RefPMAtt(), pnts, n,
+      TGLUtil::RenderPolyMarkers(rTP.RefPMAtt(), 0, pnts, cnt,
                                  rnrCtx.GetPickRadius(),
                                  rnrCtx.Selection());
       delete [] pnts;
@@ -113,7 +115,7 @@ void TEveTrackGL::RenderPathMarksAndFirstVertex(TGLRnrCtx& rnrCtx) const
 
    // fist vertex
    if (rTP.GetRnrFV() && fTrack->GetLastPoint())
-      TGLUtil::RenderPolyMarkers(rTP.RefFVAtt(), fTrack->GetP(), 1,
+      TGLUtil::RenderPolyMarkers(rTP.RefFVAtt(), 0, fTrack->GetP(), 1,
                                  rnrCtx.GetPickRadius(),
                                  rnrCtx.Selection());
 }
diff --git a/graf3d/eve/src/TEveTrackProjected.cxx b/graf3d/eve/src/TEveTrackProjected.cxx
index f24520f..b111aa7 100644
--- a/graf3d/eve/src/TEveTrackProjected.cxx
+++ b/graf3d/eve/src/TEveTrackProjected.cxx
@@ -41,6 +41,7 @@ void TEveTrackProjected::SetProjection(TEveProjectionManager* mng, TEveProjectab
    // This is virtual method from base-class TEveProjected.
 
    TEveProjected::SetProjection(mng, model);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
 
    TEveTrack* otrack = dynamic_cast<TEveTrack*>(fProjectable);
    SetTrackParams(*otrack);
@@ -88,7 +89,7 @@ void TEveTrackProjected::GetBreakPoint(Int_t idx, Bool_t back,
    TEveVector vL = fOrigPnts[idx];
    TEveVector vR = fOrigPnts[idx+1];
    TEveVector vM, vLP, vMP;
-   while ((vL-vR).Mag() > 0.01)
+   while ((vL-vR).Mag2() > 1e-10f)
    {
       vM.Mult(vL+vR, 0.5f);
       vLP.Set(vL); projection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
@@ -103,7 +104,7 @@ void TEveTrackProjected::GetBreakPoint(Int_t idx, Bool_t back,
       }
    }
 
-   if(back) {
+   if (back) {
       x = vL.fX; y = vL.fY; z = vL.fZ;
    } else {
       x = vR.fX; y = vR.fY; z = vR.fZ;
@@ -185,38 +186,57 @@ void TEveTrackProjected::MakeTrack(Bool_t recurse)
 
    Float_t x, y, z;
    Int_t   bL = 0, bR = GetBreakPointIdx(0);
-   Int_t   sign = 1;
-   Bool_t  break_track = ShouldBreakTrack();
    std::vector<TEveVector> vvec;
    while (kTRUE)
    {
-      for(Int_t i=bL; i<=bR; i++)
+      for (Int_t i=bL; i<=bR; i++)
       {
          GetPoint(i, x, y, z);
-         vvec.push_back(TEveVector(x, sign*y, z));
+         vvec.push_back(TEveVector(x, y, z));
       }
       if (bR == fLastPoint)
          break;
 
-      if (break_track)
-      {
-         GetBreakPoint(bR, kTRUE,  x, y, z); vvec.push_back(TEveVector(x, y, z));
-         fBreakPoints.push_back((Int_t)vvec.size());
-         GetBreakPoint(bR, kFALSE, x, y, z); vvec.push_back(TEveVector(x, y, z));
-      }
-      else
-      {
-         sign = -sign;
-      }
+      GetBreakPoint(bR, kTRUE,  x, y, z); vvec.push_back(TEveVector(x, y, z));
+      fBreakPoints.push_back((Int_t)vvec.size());
+      GetBreakPoint(bR, kFALSE, x, y, z); vvec.push_back(TEveVector(x, y, z));
+
       bL = bR + 1;
       bR = GetBreakPointIdx(bL);
    }
    fBreakPoints.push_back((Int_t)vvec.size()); // Mark the track-end for drawing.
 
+   // Decide if points need to be fixed.
+   // This (and the fixing itself) should really be done in TEveProjection but
+   // for now we do it here as RhoZ is the only one that needs it.
+   Bool_t  fix_y  = kFALSE;
+   Float_t sign_y = 0;
+   if (projection->HasSeveralSubSpaces())
+   {
+      switch (fPropagator->GetProjTrackBreaking())
+      {
+         case TEveTrackPropagator::kPTB_UseFirstPointPos:
+         {
+            fix_y  = kTRUE;
+            sign_y = vvec.front().fY;
+            break;
+         }
+         case TEveTrackPropagator::kPTB_UseLastPointPos:
+         {
+            fix_y  = kTRUE;
+            sign_y = vvec.back().fY;
+            break;
+         }
+      }
+   }
+
    Reset((Int_t)vvec.size());
    for (std::vector<TEveVector>::iterator i=vvec.begin(); i!=vvec.end(); ++i)
    {
-      SetNextPoint((*i).fX, (*i).fY, (*i).fZ);
+      if (fix_y)
+         SetNextPoint((*i).fX, TMath::Sign((*i).fY, sign_y), (*i).fZ);
+      else
+         SetNextPoint((*i).fX, (*i).fY, (*i).fZ);
    }
    delete [] fOrigPnts;
 
@@ -294,17 +314,9 @@ void TEveTrackListProjected::SetProjection(TEveProjectionManager* proj, TEveProj
    // This is virtual method from base-class TEveProjected.
 
    TEveProjected::SetProjection(proj, model);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
 
    TEveTrackList& tl = * dynamic_cast<TEveTrackList*>(model);
-   SetLineColor(tl.GetLineColor());
-   SetLineStyle(tl.GetLineStyle());
-   SetLineWidth(tl.GetLineWidth());
-   SetMarkerColor(tl.GetMarkerColor());
-   SetMarkerStyle(tl.GetMarkerStyle());
-   SetMarkerSize (tl.GetMarkerSize());
-   SetRnrLine  (tl.GetRnrLine());
-   SetRnrPoints(tl.GetRnrPoints());
-
    SetPropagator(tl.GetPropagator());
 }
 
diff --git a/graf3d/eve/src/TEveTrackProjectedGL.cxx b/graf3d/eve/src/TEveTrackProjectedGL.cxx
index 0c490dd..60afbb9 100644
--- a/graf3d/eve/src/TEveTrackProjectedGL.cxx
+++ b/graf3d/eve/src/TEveTrackProjectedGL.cxx
@@ -64,8 +64,8 @@ void TEveTrackProjectedGL::DirectDraw(TGLRnrCtx& rnrCtx) const
    // lines
    if (fM->fRnrLine)
    {
-      TGLCapabilitySwitch sw_smooth(GL_LINE_SMOOTH, fM->fSmooth);
-      TGLCapabilitySwitch sw_blend(GL_BLEND, fM->fSmooth);
+      TGLCapabilityEnabler sw_smooth(GL_LINE_SMOOTH, fM->fSmooth);
+      TGLCapabilityEnabler sw_blend(GL_BLEND, fM->fSmooth);
       Int_t start = 0;
       Float_t* p  = fM->GetP();
       TGLUtil::LockColor(); // Keep color from TGLPhysicalShape.
@@ -73,7 +73,7 @@ void TEveTrackProjectedGL::DirectDraw(TGLRnrCtx& rnrCtx) const
            bpi != fM->fBreakPoints.end(); ++bpi)
       {
          Int_t size = *bpi - start;
-         TGLUtil::RenderPolyLine(*fM, p, size);
+         TGLUtil::RenderPolyLine(*fM, fM->GetMainTransparency(), p, size);
          p     += 3*size;
          start +=   size;
       }
@@ -83,7 +83,32 @@ void TEveTrackProjectedGL::DirectDraw(TGLRnrCtx& rnrCtx) const
    // markers on lines
    if (fM->fRnrPoints)
    {
-      TGLUtil::RenderPolyMarkers(*fM, fM->GetP(), fM->Size(),
+      TGLUtil::RenderPolyMarkers(*fM, 0,
+				 fM->GetP(), fM->Size(),
+                                 rnrCtx.GetPickRadius(),
+                                 rnrCtx.Selection());
+   }
+
+   // break-points
+   if (fM->fBreakPoints.size() > 1 && fM->fPropagator->GetRnrPTBMarkers())
+   {
+      // Last break-point is last point on track, do not draw it.
+      Int_t  nbp   = fM->fBreakPoints.size() - 1;
+      Bool_t bmb   = fM->fPropagator->GetProjTrackBreaking() == TEveTrackPropagator::kPTB_Break;
+      Int_t  nbptd = bmb ? 2*nbp : nbp;
+      std::vector<Float_t> pnts(3*nbptd);
+      Int_t n = 0;
+      for (Int_t i = 0; i < nbp; ++i, n+=3)
+      {
+         fM->GetPoint(fM->fBreakPoints[i] - 1, pnts[n], pnts[n+1], pnts[n+2]);
+         if (bmb)
+         {
+            n += 3;
+            fM->GetPoint(fM->fBreakPoints[i], pnts[n], pnts[n+1], pnts[n+2]);
+         }
+      }
+      TGLUtil::RenderPolyMarkers(fM->fPropagator->RefPTBAtt(), 0,
+				 &pnts[0], nbptd,
                                  rnrCtx.GetPickRadius(),
                                  rnrCtx.Selection());
    }
diff --git a/graf3d/eve/src/TEveTrackPropagator.cxx b/graf3d/eve/src/TEveTrackPropagator.cxx
index 1306898..821ebb6 100644
--- a/graf3d/eve/src/TEveTrackPropagator.cxx
+++ b/graf3d/eve/src/TEveTrackPropagator.cxx
@@ -169,6 +169,10 @@ void TEveTrackPropagator::Helix_t::Step(const TEveVector4& v, const TEveVector&
 //
 // TEveTrackList has Get/Set methods for RnrStlye. TEveTrackEditor and
 // TEveTrackListEditor provide editor access.
+//
+// Specify whether 2D projected tracks get broken into several
+// segments when the projected space consists of separate domains
+// (like Rho-Z). This is true by default.
 
 ClassImp(TEveTrackPropagator);
 
@@ -181,32 +185,26 @@ Float_t             TEveTrackPropagator::fgEditorMaxZ  = 4000;
 
 //______________________________________________________________________________
 TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
-                                         TEveMagField *field) :
+                                         TEveMagField *field, Bool_t own_field) :
    TEveElementList(n, t),
    TEveRefBackPtr(),
 
    fStepper(kHelix),
    fMagFieldObj(field),
-   fMaxR    (350),
-   fMaxZ    (450),
+   fOwnMagFiledObj(own_field),
 
-   fNMax    (4096),
-   fMaxOrbs (0.5),
+   fMaxR    (350),   fMaxZ    (450),
+   fNMax    (4096),  fMaxOrbs (0.5),
 
    fEditPathMarks (kTRUE),
-   fFitDaughters  (kTRUE),
-   fFitReferences (kTRUE),
-   fFitDecay      (kTRUE),
-   fFitCluster2Ds (kTRUE),
-
-   fRnrDaughters  (kFALSE),
-   fRnrReferences (kFALSE),
-   fRnrDecay      (kFALSE),
-   fRnrCluster2Ds (kFALSE),
+   fFitDaughters  (kTRUE),   fFitReferences (kTRUE),
+   fFitDecay      (kTRUE),   fFitCluster2Ds (kTRUE),
+   fRnrDaughters  (kFALSE),  fRnrReferences (kFALSE),
+   fRnrDecay      (kFALSE),  fRnrCluster2Ds (kFALSE),
    fRnrFV         (kFALSE),
+   fPMAtt(), fFVAtt(),
 
-   fPMAtt(),
-   fFVAtt(),
+   fProjTrackBreaking(kPTB_Break), fRnrPTBMarkers(kFALSE), fPTBAtt(),
 
    fV()
 {
@@ -220,9 +218,14 @@ TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
    fFVAtt.SetMarkerStyle(4);
    fFVAtt.SetMarkerSize(1.5);
 
+   fPTBAtt.SetMarkerColor(kBlue);
+   fPTBAtt.SetMarkerStyle(4);
+   fPTBAtt.SetMarkerSize(0.8);
 
-   if (fMagFieldObj == 0)
+   if (fMagFieldObj == 0) {
       fMagFieldObj = new TEveMagFieldConst(0., 0., fgDefMagField);
+      fOwnMagFiledObj = kTRUE;
+   }
 }
 
 //______________________________________________________________________________
@@ -230,7 +233,10 @@ TEveTrackPropagator::~TEveTrackPropagator()
 {
    // Destructor.
 
-   delete fMagFieldObj;
+   if (fOwnMagFiledObj)
+   {
+      delete fMagFieldObj;
+   }
 }
 
 //______________________________________________________________________________
@@ -346,24 +352,31 @@ void TEveTrackPropagator::Update(const TEveVector4& v, const TEveVector& p,
          using namespace TMath;
 
          Float_t a = fgkB2C * fMagFieldObj->GetMaxFieldMag() * Abs(fH.fCharge);
-         fH.fR = p.Mag() / a;
-
-         // get phi step, compare fDelta with MaxAng
-         fH.fPhiStep = fH.fMaxAng * DegToRad();
-         if (fH.fR > fH.fDelta )
-         {
-            Float_t ang  = 2.0 * ACos(1.0f - fH.fDelta/fH.fR);
-            if (ang < fH.fPhiStep)
-               fH.fPhiStep = ang;
-         }
-
-         // check against maximum step-size
-         fH.fRKStep = fH.fR * fH.fPhiStep * Sqrt(1 + fH.fLam*fH.fLam);
-         if (fH.fRKStep > fH.fMaxStep || enforce_max_step)
-         {
-            fH.fPhiStep *= fH.fMaxStep / fH.fRKStep;
-            fH.fRKStep   = fH.fMaxStep;
-         }
+	 if (a > kAMin)
+	 {
+            fH.fR = p.Mag() / a;
+
+            // get phi step, compare fDelta with MaxAng
+            fH.fPhiStep = fH.fMaxAng * DegToRad();
+            if (fH.fR > fH.fDelta )
+            {
+               Float_t ang  = 2.0 * ACos(1.0f - fH.fDelta/fH.fR);
+               if (ang < fH.fPhiStep)
+                  fH.fPhiStep = ang;
+            }
+
+            // check against maximum step-size
+            fH.fRKStep = fH.fR * fH.fPhiStep * Sqrt(1 + fH.fLam*fH.fLam);
+            if (fH.fRKStep > fH.fMaxStep || enforce_max_step)
+            {
+               fH.fPhiStep *= fH.fMaxStep / fH.fRKStep;
+               fH.fRKStep   = fH.fMaxStep;
+            }
+	 }
+	 else
+	 {
+            fH.fRKStep = fH.fMaxStep; 
+	 }
       }
    }
 }
@@ -512,8 +525,9 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
    {
       TEveVector d1 = v;
       d1 -= currV;
+      Float_t d1_mag = d1.Mag();
 
-      if (d1.Mag() > kStepEps)
+      if (d1_mag > kStepEps)
       {
          Float_t step_frac = prod0 / (prod0 - prod1);
          if (step_frac > 0)
@@ -521,7 +535,7 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
             // Step for fraction of previous step size.
             // We pass 'enforce_max_step' flag to Update().
             Float_t orig_max_step = fH.fMaxStep;
-            fH.fMaxStep *= step_frac;
+            fH.fMaxStep = d1_mag * step_frac;
             Update(currV, p, kTRUE, kTRUE);
             Step(currV, p, forwV, forwP);
             p     = forwP;
@@ -753,20 +767,19 @@ void TEveTrackPropagator::SetMagField(Float_t bX, Float_t bY, Float_t bZ)
 {
    // Set constant magnetic field and rebuild tracks.
 
-   if (fMagFieldObj) delete fMagFieldObj;
-
-   fMagFieldObj = new TEveMagFieldConst(bX, bY, bZ);
-   RebuildTracks();
+   SetMagFieldObj(new TEveMagFieldConst(bX, bY, bZ));
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMagFieldObj(TEveMagField *mff)
+void TEveTrackPropagator::SetMagFieldObj(TEveMagField* field, Bool_t own_field)
 {
    // Set constant magnetic field and rebuild tracks.
 
-   if (fMagFieldObj) delete fMagFieldObj;
+   if (fMagFieldObj && fOwnMagFiledObj) delete fMagFieldObj;
+
+   fMagFieldObj    = field;
+   fOwnMagFiledObj = own_field;
 
-   fMagFieldObj = mff;
    RebuildTracks();
 }
 
@@ -922,6 +935,33 @@ void TEveTrackPropagator::SetRnrReferences(Bool_t rnr)
 }
 
 //______________________________________________________________________________
+void TEveTrackPropagator::SetRnrFV(Bool_t x)
+{
+   // Set first-vertex rendering and rebuild tracks.
+
+   fRnrFV = x;
+   RebuildTracks();
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::SetProjTrackBreaking(UChar_t x)
+{
+   // Set projection break-point mode and rebuild tracks.
+
+   fProjTrackBreaking = x;
+   RebuildTracks();
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::SetRnrPTBMarkers(Bool_t x)
+{
+   // Set projection break-point rendering and rebuild tracks.
+
+   fRnrPTBMarkers = x;
+   RebuildTracks();
+}
+
+//______________________________________________________________________________
 void TEveTrackPropagator::StepRungeKutta(Double_t step,
                                          Double_t* vect, Double_t* vout)
 {
@@ -964,9 +1004,9 @@ void TEveTrackPropagator::StepRungeKutta(Double_t step,
   Double_t yt;
   Double_t zt;
 
-  // Double_t maxit = 1992;
-  Double_t maxit = 10;
-  Double_t maxcut = 11;
+  // const Int_t maxit = 1992;
+  const Int_t maxit  = 500;
+  const Int_t maxcut = 11;
 
   const Double_t hmin   = 1e-4; // !!! MT ADD,  should be member
   const Double_t kdlt   = 1e-3; // !!! MT CHANGE from 1e-4, should be member
diff --git a/graf3d/eve/src/TEveTrackPropagatorEditor.cxx b/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
index b318e22..ac60c22 100644
--- a/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
+++ b/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
@@ -24,6 +24,7 @@
 #include "TGButton.h"
 #include "TGNumberEntry.h"
 #include "TGColorSelect.h"
+#include "TGComboBox.h"
 #include "TGDoubleSlider.h"
 #include "TGComboBox.h"
 #include "TAttMarkerEditor.h"
@@ -33,34 +34,23 @@
 //
 // Sub-editor for TEveTrackPropagator class.
 
-ClassImp(TEveTrackPropagatorSubEditor)
+ClassImp(TEveTrackPropagatorSubEditor);
 
 //______________________________________________________________________________
 TEveTrackPropagatorSubEditor::TEveTrackPropagatorSubEditor(const TGWindow *p):
    TGVerticalFrame(p),
    fM (0),
 
-   fMaxR(0),
-   fMaxZ(0),
-   fMaxOrbits(0),
-   fMaxAng(0),
-   fDelta(0),
+   fMaxR(0),   fMaxZ(0),   fMaxOrbits(0),   fMaxAng(0),   fDelta(0),
 
+   fRefsCont(0),      fPMFrame(0),
+   fFitDaughters(0),  fFitReferences(0),
+   fFitDecay(0),      fFitCluster2Ds(0),
+   fRnrDaughters(0),  fRnrReferences(0),
+   fRnrDecay(0),      fRnrCluster2Ds(0),
    fRnrFV(0),
-
-   fPMFrame(0),
-   fFitDaughters(0),
-   fFitReferences(0),
-   fFitDecay(0),
-   fFitCluster2Ds(0),
-   fRnrDaughters(0),
-   fRnrReferences(0),
-   fRnrDecay(0),
-   fRnrCluster2Ds(0),
-
-   fRefsCont(0),
-   fPMAtt(0),
-   fFVAtt(0)
+   fPMAtt(0), fFVAtt(0),
+   fProjTrackBreaking(0), fRnrPTBMarkers(0), fPTBAtt(0)
 {
    // Constructor.
 
@@ -151,7 +141,7 @@ void TEveTrackPropagatorSubEditor::CreateRefsContainer(TGVerticalFrame* p)
       rnrPM->SetTitlePos(TGGroupFrame::kLeft);
       fPMFrame->AddFrame( rnrPM, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 3, 3, 3, 3));
 
-      TGMatrixLayout *ml = new TGMatrixLayout(rnrPM, 0,1,6);
+      TGMatrixLayout *ml = new TGMatrixLayout(rnrPM, 0, 1, 6);
       rnrPM->SetLayoutManager(ml);
 
       fRnrDaughters  = new TGCheckButton(rnrPM, "Rnr Daughters",   TEvePathMark::kDaughter);
@@ -179,30 +169,70 @@ void TEveTrackPropagatorSubEditor::CreateRefsContainer(TGVerticalFrame* p)
       f->DestroyWindow(); delete f;
       fRefsCont->AddFrame(fPMAtt, new TGLayoutHints(kLHintsTop, 1, 1, 3, 1));
    }
-
    // First vertex.
-   TGCompositeFrame *title1 = new TGCompositeFrame(fRefsCont, 145, 10,
-                                                   kHorizontalFrame |
-                                                   kLHintsExpandX   |
-                                                   kFixedWidth      |
-                                                   kOwnBackground);
-   title1->AddFrame(new TGLabel(title1, "FirstVertex"),
-                    new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
-   title1->AddFrame(new TGHorizontal3DLine(title1),
-                    new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 5));
-   fRefsCont->AddFrame(title1, new TGLayoutHints(kLHintsTop, 0, 0, 2, 0));
-
-   fRnrFV = new TGCheckButton(fRefsCont, "Rnr");
-   fRnrFV->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoRnrFV()");
-   fRefsCont->AddFrame(fRnrFV, new TGLayoutHints(kLHintsTop, 5, 1, 2, 0));
    {
-      fFVAtt = new TAttMarkerEditor(fRefsCont);
-      TGFrameElement *el = (TGFrameElement*) fFVAtt->GetList()->First();
-      TGFrame *f = el->fFrame; fFVAtt->RemoveFrame(f);
-      f->DestroyWindow(); delete f;
-      fRefsCont->AddFrame(fFVAtt, new TGLayoutHints(kLHintsTop, 1, 1, 3, 1));
+      TGCompositeFrame *vf = new TGCompositeFrame
+         (fRefsCont, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
+      vf->AddFrame(new TGLabel(vf, "FirstVertex"),
+                   new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
+      vf->AddFrame(new TGHorizontal3DLine(vf),
+                   new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 5));
+      fRefsCont->AddFrame(vf, new TGLayoutHints(kLHintsTop, 0, 0, 4, 0));
+
+      fRnrFV = new TGCheckButton(fRefsCont, "Rnr");
+      fRnrFV->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoRnrFV()");
+      fRefsCont->AddFrame(fRnrFV, new TGLayoutHints(kLHintsTop, 5, 1, 2, 0));
+      {
+         fFVAtt = new TAttMarkerEditor(fRefsCont);
+         TGFrameElement *el = (TGFrameElement*) fFVAtt->GetList()->First();
+         TGFrame *f = el->fFrame; fFVAtt->RemoveFrame(f);
+         f->DestroyWindow(); delete f;
+         fRefsCont->AddFrame(fFVAtt, new TGLayoutHints(kLHintsTop, 1, 1, 3, 1));
+      }
+   }
+   // Break-points of projected tracks
+   {
+      TGCompositeFrame *vf = new TGCompositeFrame
+         (fRefsCont, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
+      vf->AddFrame(new TGLabel(vf, "BreakPoints"),
+                   new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
+      vf->AddFrame(new TGHorizontal3DLine(vf),
+                   new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 5));
+      fRefsCont->AddFrame(vf, new TGLayoutHints(kLHintsTop, 0, 0, 4, 0));
+
+      {
+         UInt_t labelW = 40;
+         UInt_t labelH = 20;
+         TGHorizontalFrame* hf = new TGHorizontalFrame(fRefsCont);
+         // label
+         TGCompositeFrame *labfr = new TGHorizontalFrame(hf, labelW, labelH, kFixedSize);
+         TGLabel* label = new TGLabel(labfr, "Mode:");
+         labfr->AddFrame(label, new TGLayoutHints(kLHintsLeft  | kLHintsBottom));
+         hf->AddFrame(labfr, new TGLayoutHints(kLHintsLeft));
+         // combo
+         fProjTrackBreaking = new TGComboBox(hf);
+         fProjTrackBreaking->AddEntry("Break tracks",         TEveTrackPropagator::kPTB_Break);
+         fProjTrackBreaking->AddEntry("First point position", TEveTrackPropagator::kPTB_UseFirstPointPos);
+         fProjTrackBreaking->AddEntry("Last point position",  TEveTrackPropagator::kPTB_UseLastPointPos);
+         fProjTrackBreaking->Connect("Selected(Int_t)", "TEveTrackPropagatorSubEditor", this, "DoModePTB(UChar_t)");
+         fProjTrackBreaking->Resize(140, labelH);
+         hf->AddFrame(fProjTrackBreaking, new TGLayoutHints(kLHintsLeft, 0,0,2,0));
+         fRefsCont->AddFrame(hf, new TGLayoutHints(kLHintsTop, 4, 1, 1, 1));
+      }
+
+      fRnrPTBMarkers = new TGCheckButton(fRefsCont, "Rnr");
+      fRnrPTBMarkers->Connect("Clicked()","TEveTrackPropagatorSubEditor", this, "DoRnrPTB()");
+      fRefsCont->AddFrame(fRnrPTBMarkers, new TGLayoutHints(kLHintsTop, 5, 1, 2, 0));
+      {
+         fPTBAtt = new TAttMarkerEditor(fRefsCont);
+         TGFrameElement *el = (TGFrameElement*) fPTBAtt->GetList()->First();
+         TGFrame *f = el->fFrame; fPTBAtt->RemoveFrame(f);
+         f->DestroyWindow(); delete f;
+         fRefsCont->AddFrame(fPTBAtt, new TGLayoutHints(kLHintsTop, 1, 1, 3, 1));
+      }
    }
-   p->AddFrame(fRefsCont,new TGLayoutHints(kLHintsTop| kLHintsExpandX));
+
+   p->AddFrame(fRefsCont, new TGLayoutHints(kLHintsTop| kLHintsExpandX));
 }
 
 //______________________________________________________________________________
@@ -240,6 +270,10 @@ void TEveTrackPropagatorSubEditor::SetModel(TEveTrackPropagator* m)
 
    fRnrFV->SetState(fM->fRnrFV ? kButtonDown : kButtonUp);
    fFVAtt->SetModel(&fM->fFVAtt);
+
+   fProjTrackBreaking->Select(fM->fProjTrackBreaking, kFALSE);
+   fRnrPTBMarkers->SetState(fM->fRnrPTBMarkers ? kButtonDown : kButtonUp);
+   fPTBAtt->SetModel(&fM->fPTBAtt);
 }
 
 /******************************************************************************/
@@ -367,20 +401,41 @@ void TEveTrackPropagatorSubEditor::DoRnrFV()
    Changed();
 }
 
+//______________________________________________________________________________
+void TEveTrackPropagatorSubEditor::DoModePTB(UChar_t mode)
+{
+   // Slot for PTBMode.
+
+   fM->SetProjTrackBreaking(mode);
+   Changed();
+}
 
 //______________________________________________________________________________
+void TEveTrackPropagatorSubEditor::DoRnrPTB()
+{
+   // Slot for RnrPTBMarkers.
+
+   fM->SetRnrPTBMarkers(fRnrPTBMarkers->IsOn());
+   Changed();
+}
+
+
+//==============================================================================
 // TEveTrackPropagatorEditor
+//==============================================================================
+
+//______________________________________________________________________________
 //
 // GUI editor for TEveTrackPropagator.
 // It's only a wrapper around a TEveTrackPropagatorSubEditor that holds actual
 // widgets.
 
-ClassImp(TEveTrackPropagatorEditor)
+ClassImp(TEveTrackPropagatorEditor);
 
 //______________________________________________________________________________
 TEveTrackPropagatorEditor::TEveTrackPropagatorEditor(const TGWindow *p,
-                                                 Int_t width, Int_t height,
-                                                 UInt_t options, Pixel_t back) :
+                                                     Int_t width, Int_t height,
+                                                     UInt_t options, Pixel_t back) :
    TGedFrame(p, width, height, options | kVerticalFrame, back),
    fM(0),
    fRSSubEditor(0)
@@ -394,16 +449,15 @@ TEveTrackPropagatorEditor::TEveTrackPropagatorEditor(const TGWindow *p,
    AddFrame(fRSSubEditor, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 2, 0,0,0));
 
    TGVerticalFrame* refsFrame = CreateEditorTabSubFrame("Refs");
-   TGCompositeFrame *title1 = new TGCompositeFrame(refsFrame, 145, 10,
-                                                   kHorizontalFrame |
-                                                   kLHintsExpandX   |
-                                                   kFixedWidth      |
-                                                   kOwnBackground);
-   title1->AddFrame(new TGLabel(title1, "PathMarks"),
-                    new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
-   title1->AddFrame(new TGHorizontal3DLine(title1),
-                    new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 7));
-   refsFrame->AddFrame(title1, new TGLayoutHints(kLHintsTop, 0, 0, 2, 0));
+   {
+      TGCompositeFrame *cf = new TGCompositeFrame
+         (refsFrame, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
+      cf->AddFrame(new TGLabel(cf, "PathMarks"),
+                   new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
+      cf->AddFrame(new TGHorizontal3DLine(cf),
+                   new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 7));
+      refsFrame->AddFrame(cf, new TGLayoutHints(kLHintsTop, 0, 0, 2, 0));
+   }
 
    // path marks
    fRSSubEditor->CreateRefsContainer(refsFrame);
diff --git a/graf3d/eve/src/TEveTrans.cxx b/graf3d/eve/src/TEveTrans.cxx
index 15abe7b..6777118 100644
--- a/graf3d/eve/src/TEveTrans.cxx
+++ b/graf3d/eve/src/TEveTrans.cxx
@@ -11,7 +11,7 @@
 
 #include "TEveTrans.h"
 #include "TEveUtil.h"
-#include "TEveVector.h"
+
 #include "TMath.h"
 #include "TClass.h"
 
diff --git a/graf3d/eve/src/TEveTriangleSet.cxx b/graf3d/eve/src/TEveTriangleSet.cxx
index 76584e3..05010f2 100644
--- a/graf3d/eve/src/TEveTriangleSet.cxx
+++ b/graf3d/eve/src/TEveTriangleSet.cxx
@@ -155,6 +155,8 @@ TEveTriangleSet* TEveTriangleSet::ReadTrivialFile(const char* file)
 {
    // Read a simple ascii input file describing vertices and triangles.
 
+   static const TEveException kEH("TEveTriangleSet::ReadTrivialFile ");
+
    FILE* f = fopen(file, "r");
    if (f == 0) {
       ::Error("TEveTriangleSet::ReadTrivialFile", Form("file '%s' not found.", file));
@@ -163,6 +165,9 @@ TEveTriangleSet* TEveTriangleSet::ReadTrivialFile(const char* file)
 
    Int_t nv, nt;
    fscanf(f, "%d %d", &nv, &nt);
+   if (nv < 0 || nt < 0)
+      throw kEH + "Negative number of vertices / triangles specified.";
+
 
    TEveTriangleSet* ts = new TEveTriangleSet(nv, nt);
 
diff --git a/graf3d/eve/src/TEveUtil.cxx b/graf3d/eve/src/TEveUtil.cxx
index 98cd01c..8a109e1 100644
--- a/graf3d/eve/src/TEveUtil.cxx
+++ b/graf3d/eve/src/TEveUtil.cxx
@@ -15,6 +15,7 @@
 
 #include "TError.h"
 #include "TGeoManager.h"
+#include "TGeoMatrix.h"
 #include "TClass.h"
 #include "TMath.h"
 
@@ -217,7 +218,7 @@ void TEveUtil::ColorFromIdx(Color_t ci, UChar_t col[4], Bool_t alpha)
 }
 
 //______________________________________________________________________________
-void TEveUtil::ColorFromIdx(Color_t ci, UChar_t col[4], UChar_t transparency)
+void TEveUtil::ColorFromIdx(Color_t ci, UChar_t col[4], Char_t transparency)
 {
    // Fill col with RGBA values corresponding to index ci and transparency.
    // ROOT's indexed color palette does not support transparency.
@@ -507,10 +508,18 @@ TEveGeoManagerHolder::TEveGeoManagerHolder(TGeoManager* new_gmgr, Int_t n_seg) :
    // NSegments is set to this value.
 
    gGeoManager = new_gmgr;
-   if (gGeoManager && n_seg > 2)
+   if (gGeoManager)
    {
-      fNSegments = gGeoManager->GetNsegments();
-      gGeoManager->SetNsegments(n_seg);
+      gGeoIdentity = (TGeoIdentity*) gGeoManager->GetListOfMatrices()->At(0);
+      if (n_seg > 2)
+      {
+         fNSegments = gGeoManager->GetNsegments();
+         gGeoManager->SetNsegments(n_seg);
+      }
+   }
+   else
+   {
+      gGeoIdentity = 0;
    }
 }
 
@@ -524,6 +533,14 @@ TEveGeoManagerHolder::~TEveGeoManagerHolder()
       gGeoManager->SetNsegments(fNSegments);
    }
    gGeoManager = fManager;
+   if (gGeoManager)
+   {
+      gGeoIdentity = (TGeoIdentity*) gGeoManager->GetListOfMatrices()->At(0);
+   }
+   else
+   {
+      gGeoIdentity = 0;
+   }
 }
 
 
diff --git a/graf3d/eve/src/TEveVector.cxx b/graf3d/eve/src/TEveVector.cxx
index b94bf5b..b2db37c 100644
--- a/graf3d/eve/src/TEveVector.cxx
+++ b/graf3d/eve/src/TEveVector.cxx
@@ -18,53 +18,57 @@
 
 //______________________________________________________________________________
 //
-// Float three-vector; a inimal Float_t copy of TVector3 used to
-// represent points and momenta (also used in VSD).
+// Minimal, templated three-vector.
+// No TObject inheritance and virtual functions.
+// Also used in VSD.
 
-ClassImp(TEveVector);
+ClassImp(TEveVectorT<Float_t>);
+ClassImp(TEveVectorT<Double_t>);
 
 //______________________________________________________________________________
-void TEveVector::Set(const TVector3& v)
+template<typename TT> void TEveVectorT<TT>::Dump() const
 {
-   // Set from TVector3.
+   // Dump to stdout as "(x, y, z)\n".
 
-   fX = v.x(); fY = v.y(); fZ = v.z();
+   printf("(%f, %f, %f)\n", fX, fY, fZ);
 }
 
 //______________________________________________________________________________
-void TEveVector::Dump() const
+template<typename TT> void TEveVectorT<TT>::Set(const TVector3& v)
 {
-   // Dump to stdout as "(x, y, z)\n".
+   // Set from TVector3.
 
-   printf("(%f, %f, %f)\n", fX, fY, fZ);
+   fX = v.x(); fY = v.y(); fZ = v.z();
 }
 
 //______________________________________________________________________________
-Float_t TEveVector::Eta() const
+template<typename TT> TT TEveVectorT<TT>::Eta() const
 {
    // Calculate eta of the point, pretending it's a momentum vector.
 
-   Float_t cosTheta = CosTheta();
+   TT cosTheta = CosTheta();
    if (cosTheta*cosTheta < 1) return -0.5* TMath::Log( (1.0-cosTheta)/(1.0+cosTheta) );
    Warning("Eta","transverse momentum = 0, returning +/- 1e10");
    return (fZ >= 0) ? 1e10 : -1e10;
 }
 
 //______________________________________________________________________________
-void TEveVector::Normalize(Float_t length)
+template<typename TT> TT TEveVectorT<TT>::Normalize(TT length)
 {
    // Normalize the vector to length if current length is non-zero.
+   // Returns the old magnitude.
 
-   Float_t m = Mag();
+   TT m = Mag();
    if (m != 0)
    {
-      m = length / m;
-      fX *= m; fY *= m; fZ *= m;
+      length /= m;
+      fX *= length; fY *= length; fZ *= length;
    }
+   return m;
 }
 
 //______________________________________________________________________________
-TEveVector TEveVector::Orthogonal() const
+template<typename TT> TEveVectorT<TT> TEveVectorT<TT>::Orthogonal() const
 {
    // Returns an orthogonal vector (not normalized).
 
@@ -72,14 +76,14 @@ TEveVector TEveVector::Orthogonal() const
    Float_t yy = fY < 0 ? -fY : fY;
    Float_t zz = fZ < 0 ? -fZ : fZ;
    if (xx < yy) {
-      return xx < zz ? TEveVector(0,fZ,-fY) : TEveVector(fY,-fX,0);
+      return xx < zz ? TEveVectorT<TT>(0,fZ,-fY) : TEveVectorT<TT>(fY,-fX,0);
    } else {
-      return yy < zz ? TEveVector(-fZ,0,fX) : TEveVector(fY,-fX,0);
+      return yy < zz ? TEveVectorT<TT>(-fZ,0,fX) : TEveVectorT<TT>(fY,-fX,0);
    }
 }
 
 //______________________________________________________________________________
-void TEveVector::OrthoNormBase(TEveVector& a, TEveVector& b) const
+template<typename TT> void TEveVectorT<TT>::OrthoNormBase(TEveVectorT<TT>& a, TEveVectorT<TT>& b) const
 {
    // Set vectors a and b to be normal to this and among themselves,
    // both of length 1.
@@ -90,29 +94,8 @@ void TEveVector::OrthoNormBase(TEveVector& a, TEveVector& b) const
    b.Normalize();
 }
 
-//______________________________________________________________________________
-TEveVector TEveVector::operator + (const TEveVector & b) const
-{
-   // Vector addition.
-
-   return TEveVector(fX + b.fX, fY + b.fY, fZ + b.fZ);
-}
-
-//______________________________________________________________________________
-TEveVector TEveVector::operator - (const TEveVector & b) const
-{
-   // Vector subtraction.
-
-   return TEveVector(fX - b.fX, fY - b.fY, fZ - b.fZ);
-}
-
-//______________________________________________________________________________
-TEveVector TEveVector::operator * (Float_t a) const
-{
-   // Multiplication with scalar.
-
-   return TEveVector(a*fX, a*fY, a*fZ);
-}
+template class TEveVectorT<Float_t>;
+template class TEveVectorT<Double_t>;
 
 
 //==============================================================================
@@ -121,31 +104,40 @@ TEveVector TEveVector::operator * (Float_t a) const
 
 //______________________________________________________________________________
 //
-// Float four-vector.
+// Minimal, templated four-vector.
+// No TObject inheritance and virtual functions.
+// Also used in VSD.
 
-ClassImp(TEveVector4);
+ClassImp(TEveVector4T<Float_t>);
+ClassImp(TEveVector4T<Double_t>);
 
 //______________________________________________________________________________
-void TEveVector4::Dump() const
+template<typename TT> void TEveVector4T<TT>::Dump() const
 {
    // Dump to stdout as "(x, y, z; t)\n".
 
-   printf("(%f, %f, %f; %f)\n", fX, fY, fZ, fT);
+   printf("(%f, %f, %f; %f)\n", TP::fX, TP::fY, TP::fZ, fT);
 }
 
+template class TEveVector4T<Float_t>;
+template class TEveVector4T<Double_t>;
+
 
 //==============================================================================
-// TEvePoint
+// TEveVector2T
 //==============================================================================
 
 //______________________________________________________________________________
 //
-// Float two-vector.
+// Minimal, templated two-vector.
+// No TObject inheritance and virtual functions.
+// Also used in VSD.
 
-ClassImp(TEvePoint);
+ClassImp(TEveVector2T<Float_t>);
+ClassImp(TEveVector2T<Double_t>);
 
 //______________________________________________________________________________
-void TEvePoint::Normalize(Float_t length)
+template<typename TT> void TEveVector2T<TT>::Normalize(TT length)
 {
    // Normalize the vector to length if current length is non-zero.
 
@@ -158,67 +150,12 @@ void TEvePoint::Normalize(Float_t length)
 }
 
 //______________________________________________________________________________
-TEvePoint TEvePoint::operator + (const TEvePoint & b) const
-{
-   // Vector addition.
-
-   return TEvePoint(fX + b.fX, fY + b.fY);
-}
-
-//______________________________________________________________________________
-TEvePoint TEvePoint::operator - (const TEvePoint & b) const
-{
-   // Vector subtraction.
-
-   return TEvePoint(fX - b.fX, fY - b.fY);
-}
-
-//______________________________________________________________________________
-TEvePoint TEvePoint::operator * (Float_t a) const
-{
-   // Multiplication with scalar.
-
-   return TEvePoint(a*fX, a*fY);
-}
-
-//______________________________________________________________________________
-void TEvePoint::Dump() const
+template<typename TT> void TEveVector2T<TT>::Dump() const
 {
    // Dump to stdout as "(x, y)\n".
 
    printf("(%f, %f)\n", fX, fY);
 }
 
-
-//==============================================================================
-// TEvePathMark
-//==============================================================================
-
-//______________________________________________________________________________
-//
-// Special-point on track:
-//  kDaughter  - daughter creation; fP is momentum of the daughter, it is subtracted from
-//               momentum of the track
-//  kReference - position/momentum reference
-//  kDecay     - decay point, fP not used
-//  kCluster2D - measurement with large error in one direction (like strip detectors):
-//               fP - normal to detector plane,
-//               fE - large error direction, must be normalized.
-//               Track is propagated to plane and correction in fE direction is discarded.
-
-ClassImp(TEvePathMark);
-
-//______________________________________________________________________________
-const char* TEvePathMark::TypeName()
-{
-   // Return the name of path-mark type.
-
-   switch (fType)
-   {
-      case kDaughter:  return "Daughter";
-      case kReference: return "Reference";
-      case kDecay:     return "Decay";
-      case kCluster2D: return "Cluster2D";
-      default:         return "Unknown";
-   }
-}
+template class TEveVector2T<Float_t>;
+template class TEveVector2T<Double_t>;
diff --git a/graf3d/eve/src/TEveViewer.cxx b/graf3d/eve/src/TEveViewer.cxx
index 6f8b371..7369f94 100644
--- a/graf3d/eve/src/TEveViewer.cxx
+++ b/graf3d/eve/src/TEveViewer.cxx
@@ -21,8 +21,6 @@
 #include "TGLEmbeddedViewer.h"
 #include "TGLScenePad.h"
 
-#include "TGLPhysicalShape.h" // For handling OnMouseIdle signal
-#include "TGLLogicalShape.h"  // For handling OnMouseIdle signal
 #include "TGLEventHandler.h"
 
 #include "TApplication.h"
@@ -371,6 +369,15 @@ TEveViewerList::TEveViewerList(const char* n, const char* t) :
    // Constructor.
 
    SetChildClass(TEveViewer::Class());
+   Connect();
+}
+
+//______________________________________________________________________________
+TEveViewerList::~TEveViewerList()
+{
+   // Destructor.
+
+   Disconnect();
 }
 
 //==============================================================================
@@ -415,8 +422,14 @@ void TEveViewerList::Connect()
 {
    // Connect to TGLViewer class-signals.
 
-   TQObject::Connect("TGLViewer", "MouseOver(TGLPhysicalShape*,UInt_t)",
-                     "TEveViewerList", this, "OnMouseOver(TGLPhysicalShape*,UInt_t)");
+   TQObject::Connect("TGLViewer", "MouseOver(TObject*,UInt_t)",
+                     "TEveViewerList", this, "OnMouseOver(TObject*,UInt_t)");
+
+   TQObject::Connect("TGLViewer", "ReMouseOver(TObject*,UInt_t)",
+                     "TEveViewerList", this, "OnReMouseOver(TObject*,UInt_t)");
+
+   TQObject::Connect("TGLViewer", "UnMouseOver(TObject*,UInt_t)",
+                     "TEveViewerList", this, "OnUnMouseOver(TObject*,UInt_t)");
 
    TQObject::Connect("TGLViewer", "Clicked(TObject*,UInt_t,UInt_t)",
                      "TEveViewerList", this, "OnClicked(TObject*,UInt_t,UInt_t)");
@@ -428,6 +441,30 @@ void TEveViewerList::Connect()
                      "TEveViewerList", this, "OnUnClicked(TObject*,UInt_t,UInt_t)");
 }
 
+//______________________________________________________________________________
+void TEveViewerList::Disconnect()
+{
+   // Disconnect from TGLViewer class-signals.
+
+   TQObject::Disconnect("TGLViewer", "MouseOver(TObject*,UInt_t)",
+                        this, "OnMouseOver(TObject*,UInt_t)");
+
+   TQObject::Disconnect("TGLViewer", "ReMouseOver(TObject*,UInt_t)",
+                        this, "OnReMouseOver(TObject*,UInt_t)");
+
+   TQObject::Disconnect("TGLViewer", "UnMouseOver(TObject*,UInt_t)",
+                        this, "OnUnMouseOver(TObject*,UInt_t)");
+
+   TQObject::Disconnect("TGLViewer", "Clicked(TObject*,UInt_t,UInt_t)",
+                        this, "OnClicked(TObject*,UInt_t,UInt_t)");
+
+   TQObject::Disconnect("TGLViewer", "ReClicked(TObject*,UInt_t,UInt_t)",
+                        this, "OnReClicked(TObject*,UInt_t,UInt_t)");
+
+   TQObject::Disconnect("TGLViewer", "UnClicked(TObject*,UInt_t,UInt_t)",
+                        this, "OnUnClicked(TObject*,UInt_t,UInt_t)");
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
@@ -511,9 +548,31 @@ void TEveViewerList::SceneDestructing(TEveScene* scene)
 // Processing of events from TGLViewers.
 /******************************************************************************/
 
+//______________________________________________________________________________
+void TEveViewerList::HandleTooltip()
+{
+   // Show / hide tooltip for various MouseOver events.
+   // Must be called from slots where sender is TGLEventHandler.
+
+   if (fShowTooltip)
+   {
+      TGLViewer       *glw = dynamic_cast<TGLViewer*>((TQObject*) gTQSender);
+      TGLEventHandler *glh = (TGLEventHandler*) glw->GetEventHandler();
+      if (gEve->GetHighlight()->NumChildren() == 1)
+      {
+         TString title(gEve->GetHighlight()->FirstChild()->GetHighlightTooltip());
+         if ( ! title.IsNull())
+            glh->TriggerTooltip(title);
+      }
+      else
+      {
+         glh->RemoveTooltip();
+      }
+   }
+}
 
 //______________________________________________________________________________
-void TEveViewerList::OnMouseOver(TGLPhysicalShape *pshape, UInt_t state)
+void TEveViewerList::OnMouseOver(TObject *obj, UInt_t /*state*/)
 {
    // Slot for global TGLViewer::MouseOver() signal.
    //
@@ -523,39 +582,53 @@ void TEveViewerList::OnMouseOver(TGLPhysicalShape *pshape, UInt_t state)
    //
    // If TEveElement::IsPickable() returns false, the element is not
    // highlighted.
+   //
+   // Highlight is always in single-selection mode.
 
-   if (state & kKeyShiftMask || state & kKeyMod1Mask)
-      return;
+   TEveElement *el = dynamic_cast<TEveElement*>(obj);
+   if (el && !el->IsPickable())
+      el = 0;
+   gEve->GetHighlight()->UserPickedElement(el, kFALSE);
+
+   HandleTooltip();
+}
 
-   TObject     *obj = 0;
-   TEveElement *el  = 0;
+//______________________________________________________________________________
+void TEveViewerList::OnReMouseOver(TObject *obj, UInt_t /*state*/)
+{
+   // Slot for global TGLViewer::ReMouseOver().
+   //
+   // The obj is dyn-casted to the TEveElement and global selection is
+   // updated accordingly.
+   //
+   // If TEveElement::IsPickable() returns false, the element is not
+   // selected.
 
-   if (pshape)
-   {
-      TGLLogicalShape* lshape = const_cast<TGLLogicalShape*>(pshape->GetLogical());
-      obj = lshape->GetExternal();
-      el  = dynamic_cast<TEveElement*>(obj);
-   }
+   TEveElement* el = dynamic_cast<TEveElement*>(obj);
+   if (el && !el->IsPickable())
+      el = 0;
+   gEve->GetHighlight()->UserRePickedElement(el);
+
+   HandleTooltip();
+}
+
+//______________________________________________________________________________
+void TEveViewerList::OnUnMouseOver(TObject *obj, UInt_t /*state*/)
+{
+   // Slot for global TGLViewer::UnMouseOver().
+   //
+   // The obj is dyn-casted to the TEveElement and global selection is
+   // updated accordingly.
+   //
+   // If TEveElement::IsPickable() returns false, the element is not
+   // selected.
 
+   TEveElement* el = dynamic_cast<TEveElement*>(obj);
    if (el && !el->IsPickable())
       el = 0;
-   gEve->GetHighlight()->UserPickedElement(el, kFALSE);
+   gEve->GetHighlight()->UserUnPickedElement(el);
 
-   if (fShowTooltip)
-   {
-      TGLViewer       *glw = dynamic_cast<TGLViewer*>((TQObject*) gTQSender);
-      TGLEventHandler *glh = (TGLEventHandler*) glw->GetEventHandler();
-      if (gEve->GetHighlight()->NumChildren() == 1)
-      {
-         TString title(gEve->GetHighlight()->FirstChild()->GetElementTitle());
-         if ( ! title.IsNull())
-            glh->TriggerTooltip(title);
-      }
-      else
-      {
-         glh->RemoveTooltip();
-      }
-   }
+   HandleTooltip();
 }
 
 //______________________________________________________________________________
@@ -589,7 +662,6 @@ void TEveViewerList::OnReClicked(TObject *obj, UInt_t /*button*/, UInt_t /*state
    TEveElement* el = dynamic_cast<TEveElement*>(obj);
    if (el && !el->IsPickable())
       el = 0;
-
    gEve->GetSelection()->UserRePickedElement(el);
 }
 
diff --git a/graf3d/g3d/src/TPointSet3D.cxx b/graf3d/g3d/src/TPointSet3D.cxx
index 7f717f9..d3179e6 100644
--- a/graf3d/g3d/src/TPointSet3D.cxx
+++ b/graf3d/g3d/src/TPointSet3D.cxx
@@ -86,13 +86,13 @@ TPointSet3D& TPointSet3D::operator=(const TPointSet3D& t)
 void TPointSet3D::ComputeBBox()
 {
    // Compute the bounding box of this points set.
+
    if (Size() > 0) {
+      BBoxInit();
       Int_t    n = Size();
       Float_t* p = fP;
-      BBoxInit();
-      while (n--) {
+      for (Int_t i = 0; i < n; ++i, p += 3) {
          BBoxCheckPoint(p);
-         p += 3;
       }
    } else {
       BBoxZero();
diff --git a/graf3d/gl/inc/LinkDef.h b/graf3d/gl/inc/LinkDef.h
index d9d0a0d..d542211 100644
--- a/graf3d/gl/inc/LinkDef.h
+++ b/graf3d/gl/inc/LinkDef.h
@@ -63,6 +63,7 @@
 #pragma link C++ class TGLOrthoCamera;
 #pragma link C++ class TGLPerspectiveCamera;
 #pragma link C++ class TGLCameraOverlay;
+#pragma link C++ class TGLCameraGuide;
 #pragma link C++ class TGLPlotCamera+;
 
 #pragma link C++ class TGLSceneBase+;
diff --git a/graf3d/gl/inc/TGLCamera.h b/graf3d/gl/inc/TGLCamera.h
index b92a721..5dbbbac 100644
--- a/graf3d/gl/inc/TGLCamera.h
+++ b/graf3d/gl/inc/TGLCamera.h
@@ -75,8 +75,10 @@ protected:
    TGLMatrix   fCamBase;         //! tranformation to center and rotation from up to x vector
    TGLMatrix   fCamTrans;        //! transformation relative to fCamTrans
    Bool_t      fExternalCenter;  //! use external center insead of scene center
+   Bool_t      fFixDefCenter;    //! use fixed default center
    TGLVector3  fExtCenter;       //! external camera center
    TGLVector3  fDefCenter;       //! deafult camera center
+   TGLVector3  fFDCenter;        //! fixed deafult camera center
    TGLVector3 *fCenter;          //! current camera center
 
    mutable Double_t fNearClip;   //! last applied near-clip
@@ -120,8 +122,9 @@ public:
    void   IncTimeStamp()       { fCacheDirty = kTRUE; ++fTimeStamp; }
    UInt_t TimeStamp()    const { return fTimeStamp; }
 
-   void SetViewport(const TGLRect & viewport);
-   TGLRect& RefViewport() { return fViewport; }
+   void           SetViewport(const TGLRect & viewport);
+   TGLRect&       RefViewport()       { return fViewport; }
+   const TGLRect& RefViewport() const { return fViewport; }
 
    // Camera manipulation interface (GL coord - origin bottom left)
    virtual void   Setup(const TGLBoundingBox & box, Bool_t reset=kTRUE) = 0;
@@ -149,6 +152,10 @@ public:
    void    SetCenterVecWarp(Double_t x, Double_t y, Double_t z);
    Double_t* GetCenterVec() { return fCenter->Arr(); }
 
+   void    SetFixDefCenter(Bool_t x) { fFixDefCenter = x; } 
+   void    SetFixDefCenterVec(Double_t x, Double_t y, Double_t z) { fFDCenter.Set(x, y, z); }
+   Double_t* GetFixDefCenterVec() { return fFDCenter.Arr(); }
+
    Double_t GetNearClip() const { return fNearClip; }
    Double_t GetFarClip()  const { return fFarClip;  }
 
@@ -189,8 +196,6 @@ public:
    void WindowToViewport(TGLRect & rect)             const { rect.Y() = fViewport.Height() - rect.Y(); }
    void WindowToViewport(TGLVertex3 & vertex)        const { vertex.Y() = fViewport.Height() - vertex.Y(); }
 
-   const TGLRect& RefViewport() const { return fViewport; }
-
    Float_t GetVAxisMinAngle(){return fVAxisMinAngle;}
    void    SetVAxisMinAngle(Float_t x){fVAxisMinAngle = x;}
 
diff --git a/graf3d/gl/inc/TGLCameraGuide.h b/graf3d/gl/inc/TGLCameraGuide.h
new file mode 100644
index 0000000..c515eb4
--- /dev/null
+++ b/graf3d/gl/inc/TGLCameraGuide.h
@@ -0,0 +1,51 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TGLCameraGuide
+#define ROOT_TGLCameraGuide
+
+#include "TGLOverlay.h"
+
+class TGLCameraGuide : public TGLOverlayElement
+{
+private:
+   TGLCameraGuide(const TGLCameraGuide&);            // Not implemented
+   TGLCameraGuide& operator=(const TGLCameraGuide&); // Not implemented
+
+protected:
+   Float_t fXPos;
+   Float_t fYPos;
+   Float_t fSize;
+
+   Int_t   fSelAxis;
+   Bool_t  fInDrag;
+
+public:
+   TGLCameraGuide(Float_t x, Float_t y, Float_t s,
+                  ERole role=kUser, EState state=kActive);
+   virtual ~TGLCameraGuide() {}
+
+   void SetX(Float_t x) { fXPos = x; }
+   void SetY(Float_t y) { fYPos = y; }
+   void SetXY(Float_t x, Float_t y) { fXPos = x; fYPos = y; }
+   void SetSize(Float_t s) { fSize = s; }
+
+   virtual Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
+   virtual Bool_t Handle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec,
+                         Event_t* event);
+   virtual void   MouseLeave();
+
+   virtual void Render(TGLRnrCtx& rnrCtx);
+
+   ClassDef(TGLCameraGuide, 0); // Short description.
+};
+
+#endif
diff --git a/graf3d/gl/inc/TGLEventHandler.h b/graf3d/gl/inc/TGLEventHandler.h
index 62f5556..29c8463 100644
--- a/graf3d/gl/inc/TGLEventHandler.h
+++ b/graf3d/gl/inc/TGLEventHandler.h
@@ -50,12 +50,22 @@ protected:
    Bool_t            fTooltipShown;
    Int_t             fTooltipPixelTolerance;
    Int_t             fSecSelType; // secondary selection type
+   Bool_t            fDoInternalSelection;
+   Bool_t            fViewerCentricControls;
+   Float_t           fArrowKeyFactor;
+   Float_t           fMouseDragFactor;
+   Float_t           fMouseWheelFactor;
 
    virtual Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
 
    virtual void   GrabMouse();
    virtual void   UnGrabMouse();
 
+   virtual void   SelectForClicked(Event_t *event);
+   virtual void   SelectForMouseOver();
+
+   Int_t ControlValue(Int_t v) { return fViewerCentricControls ? -v : v; }
+
 public:
    TGLEventHandler(TGWindow *w, TObject *obj);
    virtual ~TGLEventHandler();
@@ -76,11 +86,13 @@ public:
    virtual void   ClearMouseOver();
    virtual void   Repaint();
 
+   virtual void   PopupContextMenu(TGLPhysicalShape* pshp, Event_t *event, Int_t gx, Int_t gy);
+
    virtual void   TriggerTooltip(const char* text);
    virtual void   RemoveTooltip();
 
-   void SetMouseOverSelectDelay(Int_t ms);
-   void SetMouseOverTooltipDelay(Int_t ms);
+   void  SetMouseOverSelectDelay(Int_t ms);
+   void  SetMouseOverTooltipDelay(Int_t ms);
 
    Int_t GetTooltipPixelTolerance()  const { return fTooltipPixelTolerance; }
    void  SetTooltipPixelTolerance(Int_t t) { fTooltipPixelTolerance = t; }
@@ -88,6 +100,9 @@ public:
    Int_t GetSecSelType()  const { return fSecSelType; }
    void  SetSecSelType(Int_t t) { fSecSelType = t; }
 
+   Bool_t GetDoInternalSelection() const { return fDoInternalSelection; }
+   void   SetDoInternalSelection(Bool_t x) { fDoInternalSelection = x; }
+
    ClassDef(TGLEventHandler, 0); // Base-class and default implementation of event-handler for TGLViewer.
 };
 
diff --git a/graf3d/gl/inc/TGLFaceSet.h b/graf3d/gl/inc/TGLFaceSet.h
index 95644aa..d1e78e7 100644
--- a/graf3d/gl/inc/TGLFaceSet.h
+++ b/graf3d/gl/inc/TGLFaceSet.h
@@ -30,18 +30,23 @@ private:
    std::vector<Int_t>    fPolyDesc;
    UInt_t                fNbPols;
 
+   static Bool_t fgEnforceTriangles;
+
 public:
    TGLFaceSet(const TBuffer3D & buffer);
 
    virtual void DirectDraw(TGLRnrCtx & rnrCtx) const;
 
    void SetFromMesh(const RootCsg::TBaseMesh *m);
+   void EnforceTriangles();
 
    std::vector<Double_t>& GetVertices() { return fVertices; }
    std::vector<Double_t>& GetNormals()  { return fNormals;  }
    std::vector<Int_t>&    GetPolyDesc() { return fPolyDesc; }
    UInt_t                 GetNbPols()   { return fNbPols;   }
 
+   static Bool_t GetEnforceTriangles();
+   static void   SetEnforceTriangles(Bool_t e);
 
 private:
    void GLDrawPolys()const;
diff --git a/graf3d/gl/inc/TGLLogicalShape.h b/graf3d/gl/inc/TGLLogicalShape.h
index 9dff862..46c1da4 100644
--- a/graf3d/gl/inc/TGLLogicalShape.h
+++ b/graf3d/gl/inc/TGLLogicalShape.h
@@ -97,7 +97,7 @@ public:
    virtual void     Draw(TGLRnrCtx& rnrCtx) const;
    virtual void     DirectDraw(TGLRnrCtx& rnrCtx) const = 0; // Actual draw method (non DL cached)
 
-   virtual void     DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const;
+   virtual void     DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl=-1) const;
 
    virtual Bool_t IgnoreSizeForOfInterest() const { return kFALSE; }
 
diff --git a/graf3d/gl/inc/TGLManip.h b/graf3d/gl/inc/TGLManip.h
index 6ddd148..4c35825 100644
--- a/graf3d/gl/inc/TGLManip.h
+++ b/graf3d/gl/inc/TGLManip.h
@@ -44,19 +44,14 @@ protected:
    TPoint             fFirstMouse;        //! first (start) mouse position (in WINDOW coords)
    TPoint             fLastMouse;         //! last (latest) mouse position (in WINDOW coords)
 
-   static Float_t     fgRed[4];
-   static Float_t     fgGreen[4];
-   static Float_t     fgBlue[4];
-   static Float_t     fgYellow[4];
-   static Float_t     fgWhite[4];
-   static Float_t     fgGrey[4];
-
    TGLManip(const TGLManip&);
    TGLManip& operator=(const TGLManip&);
 
    void CalcDrawScale(const TGLBoundingBox& box, const TGLCamera& camera,
                       Double_t& base, TGLVector3 axis[3]) const;
 
+   const UChar_t* ColorFor(UInt_t widget) const; 
+
 public:
    TGLManip();
    TGLManip(TGLPhysicalShape* shape);
diff --git a/graf3d/gl/inc/TGLObject.h b/graf3d/gl/inc/TGLObject.h
index 8dfca95..73204fc 100644
--- a/graf3d/gl/inc/TGLObject.h
+++ b/graf3d/gl/inc/TGLObject.h
@@ -37,7 +37,7 @@ public:
    TGLObject() : TGLLogicalShape(0), fMultiColor(kFALSE) {}
    virtual ~TGLObject() {}
 
-   virtual Bool_t ShouldDLCache(const TGLRnrCtx & rnrCtx) const;
+   virtual Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const;
 
    // Kept from TGLLogicalShape
    // virtual ELODAxes SupportedLODAxes() const { return kLODAxesNone; }
diff --git a/graf3d/gl/inc/TGLOverlay.h b/graf3d/gl/inc/TGLOverlay.h
index 77b3bc1..0baf376 100644
--- a/graf3d/gl/inc/TGLOverlay.h
+++ b/graf3d/gl/inc/TGLOverlay.h
@@ -22,7 +22,10 @@ class TGLOvlSelectRecord;
 class TGLOverlayElement
 {
 public:
-   enum ERole { kUser, kViewer, kAnnotation, kAll };
+   enum ERole  { kUser, kViewer, kAnnotation, kAll };
+
+   enum EState { kInvisible = 1, kDisabled = 2, kActive = 4,
+                 kAllVisible = kDisabled | kActive };
 
 private:
    TGLOverlayElement(const TGLOverlayElement&);            // Not implemented
@@ -30,9 +33,13 @@ private:
 
 protected:
    ERole   fRole;
-    
+   EState  fState;
+
+   void ProjectionMatrixPushIdentity();
+
 public:
-   TGLOverlayElement(ERole r = kUser):fRole(r) {}
+   TGLOverlayElement(ERole r=kUser, EState s=kActive) :
+      fRole(r), fState(s) {}
    virtual ~TGLOverlayElement() {}
 
    virtual Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
@@ -43,9 +50,14 @@ public:
 
    virtual void Render(TGLRnrCtx& rnrCtx) = 0;
 
-   ERole   GetRole() const { return fRole; }
+   ERole   GetRole() const  { return fRole; }
    void    SetRole(ERole r) { fRole = r; }
 
+   EState  GetState() const   { return fState; }
+   void    SetState(EState s) { fState = s; }
+
+   void    SetBinaryState(Bool_t s) { SetState(s ? kActive : kInvisible); }
+
    ClassDef(TGLOverlayElement, 0) // Base class for GL overlay elements.
 };
 
diff --git a/graf3d/gl/inc/TGLRnrCtx.h b/graf3d/gl/inc/TGLRnrCtx.h
index 16154af..80ccff4 100644
--- a/graf3d/gl/inc/TGLRnrCtx.h
+++ b/graf3d/gl/inc/TGLRnrCtx.h
@@ -265,6 +265,10 @@ public:
    UChar_t* GetGrabbedImage() const { return fGrabbedImage; }
    void     SetGrabbedImage(UChar_t* img) { fGrabbedImage = img; }
 
+   // Matrix manipulation helpers
+   void ProjectionMatrixPushIdentity();
+   void ProjectionMatrixPop();
+
    ClassDef(TGLRnrCtx, 0); // Collection of objects and data passes along all rendering calls.
 };
 
diff --git a/graf3d/gl/inc/TGLSceneBase.h b/graf3d/gl/inc/TGLSceneBase.h
index 95e22e9..f756eb7 100644
--- a/graf3d/gl/inc/TGLSceneBase.h
+++ b/graf3d/gl/inc/TGLSceneBase.h
@@ -23,6 +23,7 @@ class TGLViewerBase;
 class TGLSceneInfo;
 class TGLClip;
 class TGLRnrCtx;
+class TGLLogicalShape;
 class TGLSelectRecord;
 
 // Avoid TObject inheritance due to clash with TObject::Draw as well
@@ -99,6 +100,8 @@ public:
    virtual void PostRender(TGLRnrCtx & rnrCtx);
    virtual void PostDraw  (TGLRnrCtx & rnrCtx);
 
+   virtual TGLLogicalShape* FindLogical(TObject*) const { return 0; }
+
    // Selection interface
    virtual Bool_t ResolveSelectRecord(TGLSelectRecord& rec, Int_t curIdx);
 
diff --git a/graf3d/gl/inc/TGLSelectRecord.h b/graf3d/gl/inc/TGLSelectRecord.h
index dc802b9..4c21840 100644
--- a/graf3d/gl/inc/TGLSelectRecord.h
+++ b/graf3d/gl/inc/TGLSelectRecord.h
@@ -77,13 +77,14 @@ public:
 
 protected:
    // Secondary data (scene dependent) - use
-   // TGLSceneBase::ResolveSelectRecord to fill.
+   // TGLSceneBase::ResolveSelectRecord() to fill.
    Bool_t            fTransparent;
    TGLSceneInfo     *fSceneInfo; // SceneInfo
    TGLPhysicalShape *fPhysShape; // PhysicalShape, if applicable
    TObject          *fObject;    // Master TObject, if applicable
    void             *fSpecific;  // Scene specific, if applicable
-   Bool_t            fMultiple;  // Mutliple selection, requested by event handler
+   Bool_t            fMultiple;  // Mutliple selection requested (set by event-handler).
+   Bool_t            fHighlight; // Requested for highlight (set by event-handler).
 
    ESecSelResult     fSecSelRes; // Result of ProcessSelection;
 
@@ -104,6 +105,7 @@ public:
    TObject          * GetObject()      const { return fObject; }
    void             * GetSpecific()    const { return fSpecific; }
    Bool_t             GetMultiple()    const { return fMultiple; }
+   Bool_t             GetHighlight()   const { return fHighlight; }
 
    ESecSelResult      GetSecSelResult() const { return fSecSelRes; }
 
@@ -113,6 +115,7 @@ public:
    void SetObject     (TObject* obj)           { fObject = obj; }
    void SetSpecific   (void* spec)             { fSpecific = spec; }
    void SetMultiple   (Bool_t multi)           { fMultiple = multi; }
+   void SetHighlight  (Bool_t hlt)             { fHighlight = hlt; }
 
    void SetSecSelResult(ESecSelResult r)       { fSecSelRes = r; }
 
diff --git a/graf3d/gl/inc/TGLUtil.h b/graf3d/gl/inc/TGLUtil.h
index 7827393..f7eb858 100644
--- a/graf3d/gl/inc/TGLUtil.h
+++ b/graf3d/gl/inc/TGLUtil.h
@@ -966,9 +966,9 @@ public:
    static Bool_t IsColorLocked();
 
    static void Color(const TGLColor& color);
-   static void Color(const TGLColor& color, UChar_t alpha);
-   static void Color(const TGLColor& color, Float_t alpha);
-   static void Color(Color_t color_index, Float_t alpha=1);
+   static void ColorAlpha(const TGLColor& color, UChar_t alpha);
+   static void ColorAlpha(const TGLColor& color, Float_t alpha);
+   static void ColorAlpha(Color_t color_index, Float_t alpha=1);
    static void ColorTransparency(Color_t color_index, Char_t transparency=0);
    static void Color3ub(UChar_t r, UChar_t g, UChar_t b);
    static void Color4ub(UChar_t r, UChar_t g, UChar_t b, UChar_t a);
@@ -993,33 +993,41 @@ public:
    static void BeginExtendPickRegion(Float_t scale);
    static void EndExtendPickRegion();
 
-   static void RenderPolyMarkers(const TAttMarker& marker, Float_t* p, Int_t n,
+   static void RenderPolyMarkers(const TAttMarker& marker, Char_t transp,
+                                 Float_t* p, Int_t n,
                                  Int_t pick_radius=0, Bool_t selection=kFALSE,
                                  Bool_t sec_selection=kFALSE);
-   static void RenderPoints(const TAttMarker& marker, Float_t* p, Int_t n,
+
+   static void RenderPoints(const TAttMarker& marker,
+                            Float_t* p, Int_t n,
                             Int_t pick_radius=0, Bool_t selection=kFALSE,
                             Bool_t sec_selection=kFALSE);
-   static void RenderCrosses(const TAttMarker& marker, Float_t* p, Int_t n,
+
+   static void RenderCrosses(const TAttMarker& marker,
+                             Float_t* p, Int_t n,
                              Bool_t sec_selection=kFALSE);
-   static void RenderPolyLine(const TAttLine& aline, Float_t* p, Int_t n,
+
+   static void RenderPolyLine(const TAttLine& aline, Char_t transp,
+                              Float_t* p, Int_t n,
                               Int_t pick_radius=0, Bool_t selection=kFALSE);
 
-   static void BeginAttLine(const TAttLine& aline, Int_t pick_radius=0, Bool_t selection=kFALSE);
+   static void BeginAttLine(const TAttLine& aline, Char_t transp,
+                            Int_t pick_radius=0, Bool_t selection=kFALSE);
    static void EndAttLine(Int_t pick_radius=0, Bool_t selection=kFALSE);
 
    // TODO: These draw routines should take LOD hints
-   static void SetDrawColors(const Float_t rgba[4]);
-   static void DrawSphere(const TGLVertex3 & position, Double_t radius, const Float_t rgba[4]);
-   static void DrawLine(const TGLLine3 & line, ELineHeadShape head, Double_t size, const Float_t rgba[4]);
+   static void SetDrawColors(const UChar_t rgba[4]);
+   static void DrawSphere(const TGLVertex3 & position, Double_t radius, const UChar_t rgba[4]);
+   static void DrawLine(const TGLLine3 & line, ELineHeadShape head, Double_t size, const UChar_t rgba[4]);
    static void DrawLine(const TGLVertex3 & start, const TGLVector3 & vector, ELineHeadShape head,
-                        Double_t size, const Float_t rgba[4]);
+                        Double_t size, const UChar_t rgba[4]);
    static void DrawRing(const TGLVertex3 & center, const TGLVector3 & normal,
-                        Double_t radius, const Float_t* rgba);
+                        Double_t radius, const UChar_t* rgba);
 
    static void DrawReferenceMarker(const TGLCamera  & camera,
                                    const TGLVertex3 & pos,
                                          Float_t      radius = 3,
-                                   const Float_t    * rgba   = 0);
+                                   const UChar_t    * rgba   = 0);
    static void DrawSimpleAxes(const TGLCamera      & camera,
                               const TGLBoundingBox & bbox,
                                     Int_t            axesType);
@@ -1027,6 +1035,14 @@ public:
                           const TGLVertex3 & pos,
                                 Bool_t       center = kFALSE);
 
+   // Frequently used colors.
+   static const UChar_t fgRed[4];
+   static const UChar_t fgGreen[4];
+   static const UChar_t fgBlue[4];
+   static const UChar_t fgYellow[4];
+   static const UChar_t fgWhite[4];
+   static const UChar_t fgGrey[4];
+
    ClassDef(TGLUtil,0); // Wrapper class for misc GL pieces
 };
 
@@ -1049,6 +1065,20 @@ public:
    ~TGLCapabilitySwitch();
 };
 
+class TGLCapabilityEnabler
+{
+private:
+   TGLCapabilityEnabler(const TGLCapabilityEnabler &);
+   TGLCapabilityEnabler &operator = (const TGLCapabilityEnabler &);
+
+   Int_t    fWhat;
+   Bool_t   fFlip;
+
+public:
+   TGLCapabilityEnabler(Int_t what, Bool_t state);
+   ~TGLCapabilityEnabler();
+};
+
 class TGLFloatHolder
 {
    TGLFloatHolder(const TGLFloatHolder&);            // Not implemented
diff --git a/graf3d/gl/inc/TGLViewer.h b/graf3d/gl/inc/TGLViewer.h
index 8414e3d..a9d51c3 100644
--- a/graf3d/gl/inc/TGLViewer.h
+++ b/graf3d/gl/inc/TGLViewer.h
@@ -61,7 +61,10 @@ public:
                       kCameraOrthoXOY,  kCameraOrthoXOZ,  kCameraOrthoZOY,
                       kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY };
 
-   enum ESecSelType { kOnRequest, kOnKeyMod1 };
+   enum ESecSelType { // When to do secondary-selection:
+      kOnRequest,     // - on request - when Mod1 is pressed or logical-shape requests it;
+      kOnKeyMod1      // - only when Mod1 is pressed.
+   };
 
 private:
    TGLViewer(const TGLViewer &);             // Not implemented
@@ -337,7 +340,7 @@ public:
    void         AutoFade(Float_t fade, Float_t time=1, Int_t steps=10);
 
    // Update/camera-reset
-   void   UpdateScene();
+   void   UpdateScene(Bool_t redraw=kTRUE);
    Bool_t GetIgnoreSizesOnUpdate() const        { return fIgnoreSizesOnUpdate; }
    void   SetIgnoreSizesOnUpdate(Bool_t v)      { fIgnoreSizesOnUpdate = v; }
    void   ResetCurrentCamera();
@@ -346,10 +349,15 @@ public:
 
    virtual void PostSceneBuildSetup(Bool_t resetCameras);
 
+   virtual void Activated() { Emit("Activated()"); } // *SIGNAL*
+
    virtual void MouseIdle(TGLPhysicalShape*,UInt_t,UInt_t); // *SIGNAL*
    virtual void MouseOver(TGLPhysicalShape*); // *SIGNAL*
    virtual void MouseOver(TGLPhysicalShape*, UInt_t state); // *SIGNAL*
-   virtual void Activated() { Emit("Activated()"); } // *SIGNAL*
+   virtual void MouseOver(TObject *obj, UInt_t state); // *SIGNAL*
+   virtual void ReMouseOver(TObject *obj, UInt_t state); // *SIGNAL*
+   virtual void UnMouseOver(TObject *obj, UInt_t state); // *SIGNAL*
+
    virtual void Clicked(TObject *obj); //*SIGNAL*
    virtual void Clicked(TObject *obj, UInt_t button, UInt_t state); //*SIGNAL*
    virtual void ReClicked(TObject *obj, UInt_t button, UInt_t state); //*SIGNAL*
diff --git a/graf3d/gl/inc/TGLViewerBase.h b/graf3d/gl/inc/TGLViewerBase.h
index 98d0836..1220e52 100644
--- a/graf3d/gl/inc/TGLViewerBase.h
+++ b/graf3d/gl/inc/TGLViewerBase.h
@@ -26,6 +26,7 @@ class TGLSceneInfo;
 class TGLCamera;
 class TGLClip;
 class TGLRnrCtx;
+class TGLLogicalShape;
 class TGLSelectRecord;
 class TGLOvlSelectRecord;
 class TGLOverlayElement;
@@ -93,6 +94,8 @@ public:
 
    TGLSceneInfo* GetSceneInfo(TGLSceneBase* scene);
 
+   TGLLogicalShape* FindLogicalInScenes(TObject* id);
+
    virtual void AddOverlayElement(TGLOverlayElement* el);
    virtual void RemoveOverlayElement(TGLOverlayElement* el);
    virtual void DeleteOverlayAnnotations();
@@ -127,7 +130,7 @@ public:
    virtual void Render();
    virtual void RenderNonSelected();
    virtual void RenderSelected();
-   virtual void RenderOverlay();
+   virtual void RenderOverlay(Int_t state, Bool_t selection);
    virtual void PostRender();
 
    virtual void PreRenderOverlaySelection();
diff --git a/graf3d/gl/src/TGLAnnotation.cxx b/graf3d/gl/src/TGLAnnotation.cxx
index 3aa0512..368ca99 100644
--- a/graf3d/gl/src/TGLAnnotation.cxx
+++ b/graf3d/gl/src/TGLAnnotation.cxx
@@ -246,17 +246,8 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
    }
 
    // reset matrix
-   glMatrixMode(GL_PROJECTION);
-   glPushMatrix();
-   glLoadIdentity();
-   if (rnrCtx.Selection())
-   {
-      TGLRect rect(*rnrCtx.GetPickRectangle());
-      rnrCtx.GetCamera()->WindowToViewport(rect);
-      gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
-                    (Int_t*) rnrCtx.GetCamera()->RefViewport().CArr());
-   }
-   glMatrixMode(GL_MODELVIEW);
+   rnrCtx.ProjectionMatrixPushIdentity();
+
    glPushMatrix();
    // set ortho camera to [0,1] [0.1]
    glLoadIdentity();
@@ -471,10 +462,8 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
       }
    }
 
-   glMatrixMode(GL_PROJECTION);
-   glPopMatrix();
-   glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
+   rnrCtx.ProjectionMatrixPop();
 
    glDepthRange(old_depth_range[0], old_depth_range[1]);
    glPopAttrib();
diff --git a/graf3d/gl/src/TGLAxisPainter.cxx b/graf3d/gl/src/TGLAxisPainter.cxx
index 67328c3..53e4592 100644
--- a/graf3d/gl/src/TGLAxisPainter.cxx
+++ b/graf3d/gl/src/TGLAxisPainter.cxx
@@ -46,8 +46,8 @@ TGLAxisPainter::TGLAxisPainter():
    fFontMode(TGLFont::kTexture),
    fDir(1, 0, 0),
    fTMNDim(1),
-   fLabelPixelFontSize(14),
-   fTitlePixelFontSize(14),
+   fLabelPixelFontSize(14), fLabel3DFontSize(1.0),
+   fTitlePixelFontSize(14), fTitle3DFontSize(1.0),
 
    fLabelAlignH(TGLFont::kCenterH),
    fLabelAlignV(TGLFont::kCenterV),
diff --git a/graf3d/gl/src/TGLCamera.cxx b/graf3d/gl/src/TGLCamera.cxx
index 8bc8d08..c74d5cc 100644
--- a/graf3d/gl/src/TGLCamera.cxx
+++ b/graf3d/gl/src/TGLCamera.cxx
@@ -43,6 +43,7 @@ UInt_t         TGLCamera::fgDollyDeltaSens       = 500;
 //______________________________________________________________________________
 TGLCamera::TGLCamera() :
    fExternalCenter(kFALSE),
+   fFixDefCenter(kFALSE),
    fCenter(&fDefCenter),
    fNearClip(0), fFarClip(0),
    fDollyDefault(1.0), fDollyDistance(1.0),
@@ -64,6 +65,7 @@ TGLCamera::TGLCamera() :
 //______________________________________________________________________________
 TGLCamera::TGLCamera(const TGLVector3 & hAxis, const TGLVector3 & vAxis) :
    fExternalCenter(kFALSE),
+   fFixDefCenter(kFALSE),
    fCenter(&fDefCenter),
    fNearClip(0), fFarClip(0),
    fDollyDefault(1.0), fDollyDistance(1.0),
diff --git a/graf3d/gl/src/TGLCameraGuide.cxx b/graf3d/gl/src/TGLCameraGuide.cxx
new file mode 100644
index 0000000..d0a15c3
--- /dev/null
+++ b/graf3d/gl/src/TGLCameraGuide.cxx
@@ -0,0 +1,160 @@
+// @(#)root/eve:$Id: root-5.22-00d-fireworks8.patch,v 1.4 2010/10/08 09:55:32 eulisse Exp $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TGLCameraGuide.h"
+#include "TGLRnrCtx.h"
+#include "TGLCamera.h"
+#include "TGLUtil.h"
+#include "TGLIncludes.h"
+#include "TGLSelectRecord.h"
+
+#include "TMath.h"
+
+//______________________________________________________________________________
+//
+// Draws arrows showing camera orientation in the overlay.
+// X, Y position is in range 0, 1.
+
+ClassImp(TGLCameraGuide);
+
+//______________________________________________________________________________
+TGLCameraGuide::TGLCameraGuide(Float_t x, Float_t y, Float_t s,
+                               ERole role, EState state) :
+   TGLOverlayElement(role, state),
+   fXPos(x), fYPos(y), fSize(s),
+   fSelAxis(-1), fInDrag(kFALSE)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+Bool_t TGLCameraGuide::MouseEnter(TGLOvlSelectRecord& /*rec*/)
+{
+   // Mouse has entered overlay area.
+
+   return kTRUE;
+}
+
+
+//______________________________________________________________________
+Bool_t TGLCameraGuide::Handle(TGLRnrCtx&          rnrCtx,
+                              TGLOvlSelectRecord&  selRec,
+                              Event_t*             event)
+{
+   // Handle overlay event.
+   // Return TRUE if event was handled.
+
+   if (selRec.GetN() < 2) return kFALSE;
+   Int_t recID = selRec.GetItem(1);
+
+   if (recID == 4)
+      fSelAxis = 4;
+   else
+      fSelAxis = 0;
+
+   switch (event->fType)
+   {
+      case kButtonPress:
+      {
+         if (recID == 4)
+            fInDrag = kTRUE;
+         return kTRUE;
+      }
+      case kButtonRelease:
+      {
+         fInDrag = kFALSE;
+         return kTRUE;
+      }
+      case kMotionNotify:
+      {
+         if (fInDrag)
+         {
+            const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+            if (vp.Width() == 0 || vp.Height() == 0) return kFALSE;
+
+            fXPos = TMath::Range(0.0f, 1.0f, (Float_t)(event->fX) / vp.Width());
+            fYPos = TMath::Range(0.0f, 1.0f, 1.0f - (Float_t)(event->fY) / vp.Height());
+         }
+         return kTRUE;
+      }
+      default:
+      {
+         return kFALSE;
+      }
+   }
+}
+
+//______________________________________________________________________
+void TGLCameraGuide::MouseLeave()
+{
+   // Mouse has left overlay area.
+
+   fSelAxis = -1;
+   fInDrag  = kFALSE;
+}
+
+//______________________________________________________________________________
+void TGLCameraGuide::Render(TGLRnrCtx& rnrCtx)
+{
+   // Render the camera axis arrows.
+
+   TGLCapabilitySwitch lgt_off(GL_LIGHTING, kFALSE);
+
+   rnrCtx.ProjectionMatrixPushIdentity();
+   glPushMatrix();
+   glLoadIdentity();
+   glTranslatef(-1.0f, -1.0f, 0.0f);
+   glScalef(2.0f, 2.0f, -2.0f);
+   glTranslatef(fXPos, fYPos, -0.25f);
+
+   Float_t aspect= rnrCtx.RefCamera().RefViewport().Aspect();
+   if (aspect > 1)
+      glScalef(1.0f / aspect, 1.0f, 1.0f);
+   else if (aspect < 1)
+      glScalef(1.0f, aspect, 1.0f);
+
+   Float_t dr[2];
+   glGetFloatv(GL_DEPTH_RANGE, dr);
+   glDepthRange(0, 0.01);
+
+   TGLVertex3 c;
+   TGLVector3 e;
+   const TGLMatrix &mv = rnrCtx.RefCamera().RefModelViewMatrix();
+
+   glPushName(1);
+   mv.GetBaseVec(1, e);
+   e *= fSize;
+   TGLUtil::DrawLine(c, e, TGLUtil::kLineHeadArrow, 0.1*fSize,
+                     fSelAxis == 1 ? TGLUtil::fgYellow : TGLUtil::fgRed);
+
+   glLoadName(2);
+   mv.GetBaseVec(2, e);
+   e *= fSize;
+   TGLUtil::DrawLine(c, e, TGLUtil::kLineHeadArrow, 0.1*fSize,
+                     fSelAxis == 2 ? TGLUtil::fgYellow : TGLUtil::fgGreen);
+
+   glLoadName(3);
+   mv.GetBaseVec(3, e);
+   e *= fSize;
+   TGLUtil::DrawLine(c, e, TGLUtil::kLineHeadArrow, 0.1*fSize,
+                     fSelAxis == 3 ? TGLUtil::fgYellow : TGLUtil::fgBlue);
+
+   glLoadName(4);
+   TGLUtil::DrawSphere(c, 0.08*fSize,
+                       fSelAxis == 4 ? TGLUtil::fgYellow : rnrCtx.ColorSet().Foreground().CArr());
+
+   glPopName();
+
+   glDepthRange(dr[0], dr[1]);
+
+   glPopMatrix();
+   rnrCtx.ProjectionMatrixPop();
+}
diff --git a/graf3d/gl/src/TGLClip.cxx b/graf3d/gl/src/TGLClip.cxx
index d473a76..7b70f89 100644
--- a/graf3d/gl/src/TGLClip.cxx
+++ b/graf3d/gl/src/TGLClip.cxx
@@ -336,6 +336,7 @@ ClassImp(TGLClipSet);
 
 //______________________________________________________________________________
 TGLClipSet::TGLClipSet() :
+   TGLOverlayElement(kViewer), 
    fClipPlane   (new TGLClipPlane),
    fClipBox     (new TGLClipBox),
    fCurrentClip (0),
diff --git a/graf3d/gl/src/TGLEventHandler.cxx b/graf3d/gl/src/TGLEventHandler.cxx
index f029823..efbd75e 100644
--- a/graf3d/gl/src/TGLEventHandler.cxx
+++ b/graf3d/gl/src/TGLEventHandler.cxx
@@ -33,6 +33,8 @@
 #include "TGToolTip.h"
 #include "KeySymbols.h"
 #include "TGLAnnotation.h"
+#include "TEnv.h"
+#include "TMath.h"
 
 //______________________________________________________________________________
 //
@@ -45,7 +47,12 @@
 // The signals about object being selected or hovered above are
 // emitted via the TGLViewer itself.
 //
-// This class is still under development.
+// The following rootrc settings influence the behaviour:
+// OpenGL.EventHandler.ViewerCentricControls:  1
+// OpenGL.EventHandler.ArrowKeyFactor:        -1.0
+// OpenGL.EventHandler.MouseDragFactor:       -1.0
+// OpenGL.EventHandler.MouseWheelFactor:      -1.0
+
 
 ClassImp(TGLEventHandler);
 
@@ -65,13 +72,19 @@ TGLEventHandler::TGLEventHandler(TGWindow *w, TObject *obj) :
    fMouseTimerRunning  (kFALSE),
    fTooltipShown       (kFALSE),
    fTooltipPixelTolerance (3),
-   fSecSelType(TGLViewer::kOnRequest)
+   fSecSelType(TGLViewer::kOnRequest),
+   fDoInternalSelection(kTRUE),
+   fViewerCentricControls(kFALSE)
 {
    // Constructor.
 
    fMouseTimer = new TTimer(this, 80);
    fTooltip    = new TGToolTip(0, 0, "", 650);
    fTooltip->Hide();
+   fViewerCentricControls = gEnv->GetValue("OpenGL.EventHandler.ViewerCentricControls", 0) != 0;
+   fArrowKeyFactor   = gEnv->GetValue("OpenGL.EventHandler.ArrowKeyFactor",   1.0);
+   fMouseDragFactor  = gEnv->GetValue("OpenGL.EventHandler.MouseDragFactor",  1.0);
+   fMouseWheelFactor = gEnv->GetValue("OpenGL.EventHandler.MouseWheelFactor", 1.0);
 }
 
 //______________________________________________________________________________
@@ -110,6 +123,99 @@ void TGLEventHandler::UnGrabMouse()
 }
 
 //______________________________________________________________________________
+void TGLEventHandler::SelectForClicked(Event_t *event)
+{
+   // Run selection (optionally with on secondary selection) and emit
+   // corresponding Clicked() signals.
+   // Protected method.
+
+   fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
+
+   TGLPhysicalShape *pshp = fGLViewer->fSelRec.GetPhysShape();
+   TGLLogicalShape  *lshp = pshp ? const_cast<TGLLogicalShape*>(pshp->GetLogical()) : 0;
+   TObject          *obj  = lshp ? lshp->GetExternal() : 0;
+      
+   // secondary selection
+   if (lshp && (event->fState & kKeyMod1Mask || (fSecSelType == TGLViewer::kOnRequest && lshp->AlwaysSecondarySelect())))
+   {
+      fGLViewer->RequestSecondarySelect(fLastPos.fX, fLastPos.fY);
+      fGLViewer->fSecSelRec.SetMultiple(event->fState & kKeyControlMask);
+
+      lshp->ProcessSelection(*fGLViewer->fRnrCtx, fGLViewer->fSecSelRec);
+
+      switch (fGLViewer->fSecSelRec.GetSecSelResult())
+      {
+         case TGLSelectRecord::kEnteringSelection:
+            fGLViewer->Clicked(obj, event->fCode, event->fState);
+            break;
+         case TGLSelectRecord::kLeavingSelection:
+            fGLViewer->UnClicked(obj, event->fCode, event->fState);
+            break;
+         case TGLSelectRecord::kModifyingInternalSelection:
+            fGLViewer->ReClicked(obj, event->fCode, event->fState);
+            break;
+         default:
+            break;
+      }
+   }
+   else
+   {
+      fGLViewer->Clicked(obj);
+      fGLViewer->Clicked(obj, event->fCode, event->fState);
+   }
+}
+
+//______________________________________________________________________________
+void TGLEventHandler::SelectForMouseOver()
+{
+   // Run selection (optionally with on secondary selection) and emit
+   // corresponding MouseOver() signals.
+   // Protected method.
+
+   fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
+
+   TGLPhysicalShape *pshp = fGLViewer->fSelRec.GetPhysShape();
+   TGLLogicalShape  *lshp = pshp ? const_cast<TGLLogicalShape*>(pshp->GetLogical()) : 0;
+   TObject          *obj  = lshp ? lshp->GetExternal() : 0;
+
+   if (lshp && (fSecSelType == TGLViewer::kOnRequest && lshp->AlwaysSecondarySelect()))
+   {
+      fGLViewer->RequestSecondarySelect(fLastPos.fX, fLastPos.fY);
+      fGLViewer->fSecSelRec.SetMultiple(kFALSE);
+      fGLViewer->fSecSelRec.SetHighlight(kTRUE);
+
+      lshp->ProcessSelection(*fGLViewer->fRnrCtx, fGLViewer->fSecSelRec);
+
+      fGLViewer->fSecSelRec.SetHighlight(kFALSE);
+
+      switch (fGLViewer->fSecSelRec.GetSecSelResult())
+      {
+         case TGLSelectRecord::kEnteringSelection:
+            fGLViewer->MouseOver(obj, fLastEventState);
+            break;
+         case TGLSelectRecord::kModifyingInternalSelection:
+            fGLViewer->ReMouseOver(obj, fLastEventState);
+            break;
+         case TGLSelectRecord::kLeavingSelection:
+            fGLViewer->UnMouseOver(obj, fLastEventState);
+            break;
+         default:
+            break;
+      }
+   }
+   else if (fLastMouseOverShape != pshp)
+   {
+      fGLViewer->MouseOver(pshp);
+      fGLViewer->MouseOver(pshp, fLastEventState);
+      fGLViewer->MouseOver(obj,  fLastEventState);
+   }
+   fLastMouseOverShape = pshp;
+   fLastMouseOverPos   = fLastPos;
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
 void TGLEventHandler::ExecuteEvent(Int_t event, Int_t px, Int_t py)
 {
    // Process event of type 'event' - one of EEventType types,
@@ -342,20 +448,20 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
       // On Win32 only button release events come for mouse wheel.
       // Note: Modifiers (ctrl/shift) disabled as fState doesn't seem to
       // have correct modifier flags with mouse wheel under Windows.
-      // TODO: Put '50' into some static const.
 
       if (event->fType == kButtonRelease)
       {
          Bool_t redraw = kFALSE;
 
+         Int_t zoom = TMath::Nint(fMouseWheelFactor * ControlValue(50));
          switch(event->fCode)
          {
             case kButton5: // Zoom out (dolly or adjust camera FOV).
-               redraw = fGLViewer->CurrentCamera().Zoom(50, kFALSE, kFALSE);
+               redraw = fGLViewer->CurrentCamera().Zoom(zoom, kFALSE, kFALSE);
                break;
 
             case kButton4: // Zoom in (dolly or adjust camera FOV).
-               redraw = fGLViewer->CurrentCamera().Zoom(-50, kFALSE, kFALSE);
+               redraw = fGLViewer->CurrentCamera().Zoom(-zoom, kFALSE, kFALSE);
                break;
 
             case kButton6:
@@ -430,6 +536,7 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
             fGLViewer->RequestDraw();
          }
       }
+
       if ( ! handled)
       {
          switch(event->fCode)
@@ -437,44 +544,15 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
             // LEFT mouse button
             case kButton1:
             {
-               if (event->fState & kKeyShiftMask)
+               fGLViewer->fDragAction = TGLViewer::kDragCameraRotate;
+               if (fMouseTimer)
                {
-                  if (fGLViewer->RequestSelect(event->fX, event->fY))
-                  {
-                     fGLViewer->ApplySelection();
-                     handled = kTRUE;
-                     fIgnoreButtonUp = kTRUE;
-                  }
-               }
-               else if ((fSecSelType == TGLViewer::kOnRequest ||
-                         fSecSelType == TGLViewer::kOnKeyMod1) &&
-                        event->fState & kKeyMod1Mask)
-               {
-                  fGLViewer->RequestSelect(event->fX, event->fY);
-                  fGLViewer->RequestSecondarySelect(event->fX, event->fY);
-
-                  if (fGLViewer->fSecSelRec.GetPhysShape() != 0)
-                  {
-                     TGLLogicalShape& lshape = const_cast<TGLLogicalShape&>
-                        (*fGLViewer->fSecSelRec.GetPhysShape()->GetLogical());
-                     lshape.ProcessSelection(*fGLViewer->fRnrCtx, fGLViewer->fSecSelRec);
-                  }
-                  handled = kTRUE;
-                  fIgnoreButtonUp = kTRUE;
-               }
-
-               if ( ! handled)
-               {
-                  fGLViewer->fDragAction = TGLViewer::kDragCameraRotate;
-                  if (fMouseTimer)
-                  {
-                     fMouseTimer->TurnOff();
-                     fMouseTimer->Reset();
-                  }
+                  fMouseTimer->TurnOff();
+                  fMouseTimer->Reset();
                }
                break;
             }
-            // MID mouse button
+            // MIDDLE mouse button
             case kButton2:
             {
                fGLViewer->fDragAction = TGLViewer::kDragCameraTruck;
@@ -483,36 +561,7 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
             // RIGHT mouse button
             case kButton3:
             {
-               // Shift + Right mouse - select+context menu
-               if (event->fState & kKeyShiftMask)
-               {
-                  fGLViewer->RequestSelect(event->fX, event->fY);
-                  if (!fGLViewer->fContextMenu) {
-                     fGLViewer->fContextMenu = new TContextMenu("glcm", "GL Viewer Context Menu");
-                  }
-                  Int_t    x, y;
-                  Window_t childdum;
-                  gVirtualX->TranslateCoordinates(fGLViewer->fGLWidget->GetId(),
-                                                  gClient->GetDefaultRoot()->GetId(),
-                                                  event->fX, event->fY, x, y, childdum);
-                  const TGLPhysicalShape * selected = fGLViewer->fSelRec.GetPhysShape();
-                  if (selected)
-                  {
-                     fActiveButtonID = 0;
-                     UnGrabMouse();
-
-                     selected->InvokeContextMenu(*fGLViewer->fContextMenu, x, y);
-                  }
-                  // This is dangerous ... should have special menu.
-                  // else 
-                  // {
-                  //    fGLViewer->fContextMenu->Popup(x, y, fGLViewer);
-                  // }
-               }
-               else
-               {
-                  fGLViewer->fDragAction = TGLViewer::kDragCameraDolly;
-               }
+               fGLViewer->fDragAction = TGLViewer::kDragCameraDolly;
                break;
             }
          }
@@ -567,47 +616,33 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
 
       if (event->fX == fButtonPushPos.fX && event->fY == fButtonPushPos.fY)
       {
-         TObject *obj = 0;
-         fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
-         TGLPhysicalShape *phys_shape = fGLViewer->fSelRec.GetPhysShape();
-
-         if (phys_shape) obj = phys_shape->GetLogical()->GetExternal();
-      
-         // secondary selection
-         if (phys_shape && fSecSelType == TGLViewer::kOnRequest &&
-             phys_shape->GetLogical()->AlwaysSecondarySelect())
+         if (event->fCode == kButton1)
          {
-            fGLViewer->RequestSecondarySelect(fLastPos.fX, fLastPos.fY);
-            fGLViewer->fSecSelRec.SetMultiple(event->fState & kKeyControlMask);
-
-            if (fGLViewer->fSecSelRec.GetPhysShape() != 0)
+            if (event->fState & kKeyShiftMask && fDoInternalSelection)
             {
-               TGLLogicalShape& lshape = const_cast<TGLLogicalShape&>
-                  (*fGLViewer->fSecSelRec.GetPhysShape()->GetLogical());
-
-               lshape.ProcessSelection(*fGLViewer->fRnrCtx, fGLViewer->fSecSelRec);
-               switch (fGLViewer->fSecSelRec.GetSecSelResult())
+               if (fGLViewer->RequestSelect(event->fX, event->fY))
                {
-                  case TGLSelectRecord::kEnteringSelection:
-                     fGLViewer->Clicked(obj, event->fCode, event->fState);
-                     break;
-                  case TGLSelectRecord::kLeavingSelection:
-                     fGLViewer->UnClicked(obj, event->fCode, event->fState);
-                     break;
-                  case TGLSelectRecord::kModifyingInternalSelection:
-                     fGLViewer->ReClicked(obj, event->fCode, event->fState);
-                     break;
-                  default:
-                     break;
-               };
+                  fGLViewer->ApplySelection();
+               }
+            }
+            else
+            {
+               SelectForClicked(event);
             }
          }
-         else
+         else if (event->fCode == kButton3)
          {
-            fGLViewer->Clicked(obj);
-            fGLViewer->Clicked(obj, event->fCode, event->fState);
+            Int_t    x, y;
+            Window_t childdum;
+            gVirtualX->TranslateCoordinates(fGLViewer->fGLWidget->GetId(), gClient->GetDefaultRoot()->GetId(),
+                                            event->fX, event->fY, x, y, childdum);
+
+            fGLViewer->RequestSelect(event->fX, event->fY);
+
+            PopupContextMenu(fGLViewer->fSelRec.GetPhysShape(), event, x, y);
          }
       }
+
       if (event->fCode == kButton1 && fMouseTimer)
       {
          fMouseTimer->TurnOn();
@@ -694,13 +729,20 @@ Bool_t TGLEventHandler::HandleKey(Event_t *event)
 {
    // Handle keyboard 'event'.
 
+   // We only handle key-press events.
+   if (event->fType == kKeyRelease)
+      return kTRUE;
+
+   if (fTooltipShown)
+      fTooltip->Hide();
+
    fLastEventState = event->fState;
 
    fGLViewer->MouseIdle(0, 0, 0);
    if (fGLViewer->IsLocked()) {
       if (gDebug>3) {
          Info("TGLEventHandler::HandleKey", "ignored - viewer is %s",
-            fGLViewer->LockName(fGLViewer->CurrentLock()));
+              fGLViewer->LockName(fGLViewer->CurrentLock()));
       }
       return kFALSE;
    }
@@ -722,8 +764,10 @@ Bool_t TGLEventHandler::HandleKey(Event_t *event)
    }
    else
    {
-      Bool_t mod1 = event->fState & kKeyControlMask;
-      Bool_t mod2 = event->fState & kKeyShiftMask;
+      const Bool_t mod1 = event->fState & kKeyControlMask;
+      const Bool_t mod2 = event->fState & kKeyShiftMask;
+
+      const Int_t shift = TMath::Nint(fArrowKeyFactor * ControlValue(10));
 
       switch (keysym)
       {
@@ -757,39 +801,44 @@ Bool_t TGLEventHandler::HandleKey(Event_t *event)
          case kKey_Plus:
          case kKey_J:
          case kKey_j:
-            redraw = fGLViewer->CurrentCamera().Dolly(10, mod1, mod2);
+            redraw = fGLViewer->CurrentCamera().Dolly(shift, mod1, mod2);
             break;
          case kKey_Minus:
          case kKey_K:
          case kKey_k:
-            redraw = fGLViewer->CurrentCamera().Dolly(-10, mod1, mod2);
+            redraw = fGLViewer->CurrentCamera().Dolly(-shift, mod1, mod2);
             break;
          case kKey_Up:
-            redraw = fGLViewer->CurrentCamera().Truck(0, 10, mod1, mod2);
+            redraw = fGLViewer->CurrentCamera().Truck(0, shift, mod1, mod2);
             break;
          case kKey_Down:
-            redraw = fGLViewer->CurrentCamera().Truck(0, -10, mod1, mod2);
+            redraw = fGLViewer->CurrentCamera().Truck(0, -shift, mod1, mod2);
             break;
          case kKey_Left:
-            redraw = fGLViewer->CurrentCamera().Truck(-10, 0, mod1, mod2);
+            redraw = fGLViewer->CurrentCamera().Truck(-shift, 0, mod1, mod2);
             break;
          case kKey_Right:
-            redraw = fGLViewer->CurrentCamera().Truck(10, 0, mod1, mod2);
+            redraw = fGLViewer->CurrentCamera().Truck(shift, 0, mod1, mod2);
             break;
          case kKey_Home:
-            fGLViewer->ResetCurrentCamera();
+            if (mod1) {
+               TGLCamera &cam = fGLViewer->CurrentCamera();
+               cam.SetExternalCenter(!cam.GetExternalCenter());
+               fGLViewer->RefreshPadEditor(fGLViewer);
+            } else {
+               fGLViewer->ResetCurrentCamera();
+            }
             redraw = kTRUE;
             break;
 
             // Toggle debugging mode
-         case kKey_D:
          case kKey_d:
             fGLViewer->fDebugMode = !fGLViewer->fDebugMode;
             redraw = kTRUE;
             Info("OpenGL viewer debug mode : ", fGLViewer->fDebugMode ? "ON" : "OFF");
             break;
             // Forced rebuild for debugging mode
-         case kKey_Space:
+         case kKey_D:
             if (fGLViewer->fDebugMode) {
                Info("OpenGL viewer FORCED rebuild", "");
                fGLViewer->UpdateScene();
@@ -825,8 +874,8 @@ Bool_t TGLEventHandler::HandleMotion(Event_t * event)
    Short_t lod = TGLRnrCtx::kLODMed;
 
    // Camera interface requires GL coords - Y inverted
-   Int_t  xDelta = event->fX - fLastPos.fX;
-   Int_t  yDelta = event->fY - fLastPos.fY;
+   Int_t  xDelta = TMath::Nint(fMouseDragFactor * ControlValue(event->fX - fLastPos.fX));
+   Int_t  yDelta = TMath::Nint(fMouseDragFactor * ControlValue(event->fY - fLastPos.fY));
    Bool_t mod1   = event->fState & kKeyControlMask;
    Bool_t mod2   = event->fState & kKeyShiftMask;
 
@@ -863,7 +912,7 @@ Bool_t TGLEventHandler::HandleMotion(Event_t * event)
    }
    else if (fGLViewer->fDragAction == TGLViewer::kDragCameraDolly)
    {
-      processed = fGLViewer->CurrentCamera().Dolly(xDelta - yDelta, mod1, mod2);
+      processed = fGLViewer->CurrentCamera().Dolly(yDelta - xDelta, mod1, mod2);
    }
    else if (fGLViewer->fDragAction == TGLViewer::kDragOverlay)
    {
@@ -916,14 +965,7 @@ Bool_t TGLEventHandler::HandleTimer(TTimer *t)
    {
       if (fLastMouseOverPos != fLastPos)
       {
-         fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
-         if (fLastMouseOverShape != fGLViewer->fSelRec.GetPhysShape())
-         {
-            fLastMouseOverShape = fGLViewer->fSelRec.GetPhysShape();
-            fGLViewer->MouseOver(fLastMouseOverShape);
-            fGLViewer->MouseOver(fLastMouseOverShape, fLastEventState);
-         }
-         fLastMouseOverPos = fLastPos;
+         SelectForMouseOver();
       }
    }
    return kTRUE;
@@ -957,6 +999,7 @@ void TGLEventHandler::ClearMouseOver()
    fLastMouseOverShape = 0;
    fGLViewer->MouseOver(fLastMouseOverShape);
    fGLViewer->MouseOver(fLastMouseOverShape, fLastEventState);
+   fGLViewer->MouseOver((TObject*)0, fLastEventState);
 
    fGLViewer->ClearCurrentOvlElm();
 }
@@ -977,6 +1020,33 @@ void TGLEventHandler::Repaint()
 }
 
 //______________________________________________________________________________
+void TGLEventHandler::PopupContextMenu(TGLPhysicalShape* pshp, Event_t */*event*/,
+                                       Int_t gx, Int_t gy)
+{
+   // Popup context menu.
+
+   if (!fGLViewer->fContextMenu)
+   {
+      fGLViewer->fContextMenu = new TContextMenu("glcm", "GL Viewer Context Menu");
+   }
+
+   if (pshp)
+   {
+      fActiveButtonID = 0;
+      UnGrabMouse();
+
+      pshp->InvokeContextMenu(*fGLViewer->fContextMenu, gx, gy);
+   }
+
+   // This is dangerous ... should have special menu, probably even
+   // tool / context specific.
+   // else 
+   // {
+   //    fGLViewer->fContextMenu->Popup(x, y, fGLViewer);
+   // }
+}
+
+//______________________________________________________________________________
 void TGLEventHandler::TriggerTooltip(const char* text)
 {
    // Trigger display of tooltip.
diff --git a/graf3d/gl/src/TGLFaceSet.cxx b/graf3d/gl/src/TGLFaceSet.cxx
index d25fc11..a936423 100644
--- a/graf3d/gl/src/TGLFaceSet.cxx
+++ b/graf3d/gl/src/TGLFaceSet.cxx
@@ -22,6 +22,27 @@
 #include "TClass.h"
 #include "TError.h"
 
+#include <stdexcept>
+
+// Clone from TGLUtil -- typedefs needed for portable tesselator function typedef.
+
+#ifndef CALLBACK
+#define CALLBACK
+#endif
+
+extern "C"
+{
+#if defined(__APPLE_CC__) && __APPLE_CC__ > 4000 && __APPLE_CC__ < 5450 && !defined(__INTEL_COMPILER)
+    typedef GLvoid (*tessfuncptr_t)(...);
+#elif defined(__mips) || defined(__linux__) || defined(__FreeBSD__) || defined( __OpenBSD__ ) || defined(__sun) || defined (__CYGWIN__) || defined (__APPLE__)
+    typedef GLvoid (*tessfuncptr_t)();
+#elif defined (WIN32)
+    typedef GLvoid (CALLBACK *tessfuncptr_t)();
+#else
+    #error "Error - need to define type tessfuncptr_t for this platform/compiler"
+#endif
+}
+
 //______________________________________________________________________________
 //
 // Implementss a native ROOT-GL representation of an arbitrary set of
@@ -29,15 +50,19 @@
 
 ClassImp(TGLFaceSet);
 
+Bool_t TGLFaceSet::fgEnforceTriangles = kFALSE;
+
 //______________________________________________________________________________
 TGLFaceSet::TGLFaceSet(const TBuffer3D & buffer) :
    TGLLogicalShape(buffer),
    fVertices(buffer.fPnts, buffer.fPnts + 3 * buffer.NbPnts()),
-   fNormals(3 * buffer.NbPols())
+   fNormals(0)
 {
    // constructor
    fNbPols = buffer.NbPols();
 
+   if (fNbPols == 0) return;
+
    Int_t *segs = buffer.fSegs;
    Int_t *pols = buffer.fPols;
 
@@ -95,8 +120,11 @@ TGLFaceSet::TGLFaceSet(const TBuffer3D & buffer) :
       j += segmentCol + 2;
    }
    }
-   CalculateNormals();
-
+   //if (fgEnforceTriangles) {
+   //   EnforceTriangles();
+   //} else {
+      CalculateNormals();
+      //}
 }
 
 //______________________________________________________________________________
@@ -131,6 +159,153 @@ void TGLFaceSet::SetFromMesh(const RootCsg::TBaseMesh *mesh)
       for(i = 0; i < polySize; ++i) fPolyDesc.push_back(mesh->GetVertexIndex(polyIndex, i));
    }
 
+   if (fgEnforceTriangles) {
+      EnforceTriangles();
+   } else {
+      CalculateNormals();
+   }
+}
+
+//______________________________________________________________________________
+void TGLFaceSet::EnforceTriangles()
+{
+   // Use GLU tesselator to replace all polygons with N > 3 with triangles.
+   // After this call polygon descriptions are changed.
+   // New vertices are not expected -- exception is thrown if this is
+   // requested by the triangulator. Support for addin of new vertices can be
+   // provided.
+   // Normals are automatically recalculated at the end.
+
+   class TriangleCollector
+   {
+   protected:
+      Int_t              fNTriangles;
+      Int_t              fNVertices;
+      Int_t              fV0, fV1;
+      GLenum             fType;
+      std::vector<Int_t> fPolyDesc;
+
+      void add_triangle(Int_t v0, Int_t v1, Int_t v2)
+      {
+         fPolyDesc.push_back(3);
+         fPolyDesc.push_back(v0);
+         fPolyDesc.push_back(v1);
+         fPolyDesc.push_back(v2);
+         ++fNTriangles;
+      }
+
+      void process_vertex(Int_t vi)
+      {
+         ++fNVertices;
+
+         if (fV0 == -1) {
+            fV0 = vi;
+            return;
+         }
+         if (fV1 == -1) {
+            fV1 = vi;
+            return;
+         }
+
+         switch (fType)
+         {
+            case GL_TRIANGLES:
+            {
+               add_triangle(fV0, fV1, vi);
+               fV0 = fV1 = -1;
+               break;
+            }
+            case GL_TRIANGLE_STRIP:
+            {
+               if (fNVertices % 2 == 0)
+                  add_triangle(fV1, fV0, vi);
+               else
+                  add_triangle(fV0, fV1, vi);
+               fV0 = fV1;
+               fV1 = vi;
+               break;
+            }
+            case GL_TRIANGLE_FAN:
+            {
+               add_triangle(fV0, fV1, vi);
+               fV1 = vi;
+               break;
+            }
+            default:
+            {
+               throw std::runtime_error("TGLFaceSet::EnforceTriangles unexpected type in tess_vertex callback.");
+            }
+         }
+      }
+
+   public:
+      TriangleCollector(GLUtesselator* ts) :
+         fNTriangles(0), fNVertices(0), fV0(-1), fV1(-1), fType(GL_NONE)
+      {
+         gluTessCallback(ts, (GLenum)GLU_TESS_BEGIN_DATA,   (tessfuncptr_t) tess_begin);
+         gluTessCallback(ts, (GLenum)GLU_TESS_VERTEX_DATA,  (tessfuncptr_t) tess_vertex);
+         gluTessCallback(ts, (GLenum)GLU_TESS_COMBINE_DATA, (tessfuncptr_t) tess_combine);
+         gluTessCallback(ts, (GLenum)GLU_TESS_END_DATA,     (tessfuncptr_t) tess_end);
+      }
+
+      Int_t               GetNTrianlges() { return fNTriangles; }
+      std::vector<Int_t>& RefPolyDesc()   { return fPolyDesc; }
+
+      static void tess_begin(GLenum type, TriangleCollector* tc)
+      {
+         tc->fNVertices = 0;
+         tc->fV0 = tc->fV1 = -1;
+         tc->fType = type;
+      }
+
+      static void tess_vertex(Int_t* vi, TriangleCollector* tc)
+      {
+         tc->process_vertex(*vi);
+      }
+
+      static void tess_combine(GLdouble /*coords*/[3], void* /*vertex_data*/[4], 
+                               GLfloat  /*weight*/[4], void** /*outData*/, 
+                               TriangleCollector* /*tc*/)
+      {
+         throw std::runtime_error("TGLFaceSet::EnforceTriangles tesselator requested vertex combining -- not supported yet.");
+      }
+
+      static void tess_end(TriangleCollector* tc)
+      {
+         tc->fType = GL_NONE;
+      }
+   };
+
+   GLUtesselator *tess = gluNewTess();
+   if (!tess) throw std::bad_alloc();
+
+   TriangleCollector tc(tess);
+
+   // Loop ...
+   const Double_t *pnts = &fVertices[0];
+   const Int_t    *pols = &fPolyDesc[0];
+
+   for (UInt_t i = 0, j = 0; i < fNbPols; ++i)
+   {
+      Int_t npoints = pols[j++];
+
+      gluTessBeginPolygon(tess, &tc);
+      gluTessBeginContour(tess);
+
+      for (Int_t k = 0; k < npoints; ++k, ++j)
+      {
+         gluTessVertex(tess, (Double_t*) pnts + pols[j] * 3, (GLvoid*) &pols[j]);
+      }
+
+      gluTessEndContour(tess);
+      gluTessEndPolygon(tess);
+   }
+
+   gluDeleteTess(tess);
+
+   fPolyDesc.swap(tc.RefPolyDesc());
+   fNbPols = tc.GetNTrianlges();
+
    CalculateNormals();
 }
 
@@ -220,6 +395,7 @@ void TGLFaceSet::CalculateNormals()
 {
    // CalculateNormals
 
+   fNormals.resize(3 *fNbPols);
    if (fNbPols == 0) return;
    Double_t *pnts = &fVertices[0];
    for (UInt_t i = 0, j = 0; i < fNbPols; ++i) {
@@ -247,3 +423,23 @@ void TGLFaceSet::CalculateNormals()
       }
    }
 }
+
+//______________________________________________________________________________
+Bool_t TGLFaceSet::GetEnforceTriangles()
+{
+   // Get current state of static flag EnforceTriangles.
+
+   return fgEnforceTriangles;
+}
+
+//______________________________________________________________________________
+void TGLFaceSet::SetEnforceTriangles(Bool_t e)
+{
+   // Set state of static flag EnforceTriangles.
+   // When this is set, all tesselations will be automatically converted into
+   // triangle-only meshes.
+   // This is needed to export TGeo shapes and CSG meshes to external
+   // triangle-mesh libraries that can not handle arbitrary polygons.
+
+   fgEnforceTriangles = e;
+}
diff --git a/graf3d/gl/src/TGLFontManager.cxx b/graf3d/gl/src/TGLFontManager.cxx
index 305b4d9..347c116 100644
--- a/graf3d/gl/src/TGLFontManager.cxx
+++ b/graf3d/gl/src/TGLFontManager.cxx
@@ -33,6 +33,7 @@
 # include "FTGLBitmapFont.h"
 #endif
 
+
 //______________________________________________________________________________
 // TGLFont
 //
@@ -316,14 +317,17 @@ void TGLFontManager::RegisterFont(Int_t sizeIn, Int_t fileID, TGLFont::EMode mod
    FontMap_i it = fFontMap.find(TGLFont(size, fileID, mode));
    if (it == fFontMap.end())
    {
-      TString ttpath;
+      TString ttpath, file;
 # ifdef TTFFONTDIR
       ttpath = gEnv->GetValue("Root.TTGLFontPath", TTFFONTDIR );
 # else
       ttpath = gEnv->GetValue("Root.TTGLFontPath", "$(ROOTSYS)/fonts");
 # endif
-      TObjString* name = (TObjString*)fgFontFileArray[fileID];
-      TString file = gSystem->Which(ttpath.Data(), Form("%s.ttf", name->GetString().Data()));
+      {
+         char *fp = gSystem->Which(ttpath, ((TObjString*)fgFontFileArray[fileID])->String() + ".ttf");
+         file = fp;
+         delete [] fp;
+      }
 
       FTFont* ftfont = 0;
       switch (mode)
diff --git a/graf3d/gl/src/TGLLightSet.cxx b/graf3d/gl/src/TGLLightSet.cxx
index d63ab9a..199ad18 100644
--- a/graf3d/gl/src/TGLLightSet.cxx
+++ b/graf3d/gl/src/TGLLightSet.cxx
@@ -108,7 +108,9 @@ void TGLLightSet::StdSetupLights(const TGLBoundingBox& bbox,
       glLoadIdentity();
 
       // 0: Front, 1: Top, 2: Bottom, 3: Left, 4: Right
-      TGLVertex3 center = bbox.Center();
+      TGLVertex3 c = bbox.Center();
+      TGLVector3 center(c.X(), c.Y(), c.Z());
+      camera.RefModelViewMatrix().MultiplyIP(center);
       // Float_t pos0[] = { center.X(), center.Y(), frontLightZ, 1.0 };
       Float_t pos0[] = { 0.0,        0.0,                      frontLightZ, 1.0 };
       Float_t pos1[] = { center.X(), center.Y() + lightRadius, sideLightsZ, 1.0 };
@@ -149,12 +151,11 @@ void TGLLightSet::StdSetupLights(const TGLBoundingBox& bbox,
          {
             // Lighting itself needs to be disable so a single one can show...!
             glDisable(GL_LIGHTING);
-            Float_t yellow[4] = { 1.0, 1.0, 0.0, 1.0 };
             Float_t position[4]; // Only float parameters for lights (no double)....
             glGetLightfv(GLenum(GL_LIGHT0 + light), GL_POSITION, position);
             Double_t size = bbox.Extents().Mag() / 10.0;
             TGLVertex3 dPosition(position[0], position[1], position[2]);
-            TGLUtil::DrawSphere(dPosition, size, yellow);
+            TGLUtil::DrawSphere(dPosition, size, TGLUtil::fgYellow);
             glEnable(GL_LIGHTING);
          }
       }
diff --git a/graf3d/gl/src/TGLLogicalShape.cxx b/graf3d/gl/src/TGLLogicalShape.cxx
index d0a89a1..e87fe3a 100644
--- a/graf3d/gl/src/TGLLogicalShape.cxx
+++ b/graf3d/gl/src/TGLLogicalShape.cxx
@@ -417,22 +417,26 @@ entry_point:
 }
 
 //______________________________________________________________________________
-void TGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx,const TGLPhysicalShape* pshp) const
+void TGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl) const
 {
    // Draw the logical shape in highlight mode.
+   // If lvl argument is less than 0 (-1 by default), the index into color-set
+   // is taken from the physical shape itself.
 
    const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
    Int_t inner[4][2] = { { 0,-1}, { 1, 0}, { 0, 1}, {-1, 0} };
    Int_t outer[8][2] = { {-1,-1}, { 1,-1}, { 1, 1}, {-1, 1},
                          { 0,-2}, { 2, 0}, { 0, 2}, {-2, 0} };
 
+   if (lvl < 0) lvl = pshp->GetSelected();
+
    rnrCtx.SetHighlightOutline(kTRUE);
    TGLUtil::LockColor();
    Int_t first_outer = (rnrCtx.CombiLOD() == TGLRnrCtx::kLODHigh) ? 0 : 4;
    for (int i = first_outer; i < 8; ++i)
    {
       glViewport(vp.X() + outer[i][0], vp.Y() + outer[i][1], vp.Width(), vp.Height());
-      glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
+      glColor4ubv(rnrCtx.ColorSet().Selection(lvl).CArr());
       Draw(rnrCtx);
    }
    TGLUtil::UnlockColor();
diff --git a/graf3d/gl/src/TGLManip.cxx b/graf3d/gl/src/TGLManip.cxx
index 6da4ad3..850e208 100644
--- a/graf3d/gl/src/TGLManip.cxx
+++ b/graf3d/gl/src/TGLManip.cxx
@@ -31,13 +31,6 @@
 
 ClassImp(TGLManip);
 
-Float_t TGLManip::fgRed[4]    = { 0.8, 0.0, 0.0, 1.0 };
-Float_t TGLManip::fgGreen[4]  = { 0.0, 0.8, 0.0, 1.0 };
-Float_t TGLManip::fgBlue[4]   = { 0.0, 0.0, 0.8, 1.0 };
-Float_t TGLManip::fgYellow[4] = { 0.8, 0.8, 0.0, 1.0 };
-Float_t TGLManip::fgWhite[4]  = { 1.0, 1.0, 1.0, 1.0 };
-Float_t TGLManip::fgGrey[4]   = { 0.5, 0.5, 0.5, 0.4 };
-
 //______________________________________________________________________________
 TGLManip::TGLManip() :
    fShape(0),
@@ -83,14 +76,6 @@ TGLManip& TGLManip::operator=(const TGLManip& gm)
       fActive=gm.fActive;
       fFirstMouse=gm.fFirstMouse;
       fLastMouse=gm.fLastMouse;
-      for(Int_t i=0; i<4; i++) {
-         fgRed[i]=gm.fgRed[i];
-         fgGreen[i]=gm.fgGreen[i];
-         fgBlue[i]=gm.fgBlue[i];
-         fgYellow[i]=gm.fgYellow[i];
-         fgWhite[i]=gm.fgWhite[i];
-         fgGrey[i]=gm.fgGrey[i];
-      }
    }
    return *this;
 }
@@ -102,6 +87,27 @@ TGLManip::~TGLManip()
 }
 
 //______________________________________________________________________________
+const UChar_t* TGLManip::ColorFor(UInt_t widget) const
+{
+   // Returns color to be used for given widget.
+
+   if (widget == fSelectedWidget)
+   {
+      return TGLUtil::fgYellow;
+   }
+   else
+   {
+      switch (widget)
+      {
+         case 1:  return TGLUtil::fgRed;
+         case 2:  return TGLUtil::fgGreen;
+         case 3:  return TGLUtil::fgBlue;
+         default: return TGLUtil::fgGrey;
+      }
+   }
+}
+
+//______________________________________________________________________________
 Bool_t TGLManip::HandleButton(const Event_t& event, const TGLCamera& /*camera*/)
 {
    // Handle a mouse button event - return kTRUE if processed, kFALSE otherwise
diff --git a/graf3d/gl/src/TGLObject.cxx b/graf3d/gl/src/TGLObject.cxx
index ff20690..90e9f1e 100644
--- a/graf3d/gl/src/TGLObject.cxx
+++ b/graf3d/gl/src/TGLObject.cxx
@@ -40,7 +40,7 @@ ClassImp(TGLObject);
 TMap TGLObject::fgGLClassMap;
 
 //______________________________________________________________________________
-Bool_t TGLObject::ShouldDLCache(const TGLRnrCtx & rnrCtx) const
+Bool_t TGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const
 {
    // Decide if display-list should be used for this pass rendering,
    // as determined by rnrCtx.
@@ -48,7 +48,8 @@ Bool_t TGLObject::ShouldDLCache(const TGLRnrCtx & rnrCtx) const
    if (!fDLCache ||
        !fScene   ||
        (rnrCtx.SecSelection() && SupportsSecondarySelect()) ||
-       (fMultiColor && (rnrCtx.HighlightOutline() || rnrCtx.IsDrawPassOutlineLine())))
+       (fMultiColor && (rnrCtx.HighlightOutline() || rnrCtx.IsDrawPassOutlineLine())) ||
+       (AlwaysSecondarySelect() && rnrCtx.Highlight()))
    {
       return kFALSE;
    }
diff --git a/graf3d/gl/src/TGLOrthoCamera.cxx b/graf3d/gl/src/TGLOrthoCamera.cxx
index c538751..a5f8c3f 100644
--- a/graf3d/gl/src/TGLOrthoCamera.cxx
+++ b/graf3d/gl/src/TGLOrthoCamera.cxx
@@ -65,8 +65,15 @@ void TGLOrthoCamera::Setup(const TGLBoundingBox & box, Bool_t reset)
 
    if (fExternalCenter == kFALSE)
    {
-      TGLVertex3 center = box.Center();
-      SetCenterVec(center.X(), center.Y(), center.Z());
+      if (fFixDefCenter)
+      {
+         SetCenterVec(fFDCenter.X(), fFDCenter.Y(), fFDCenter.Z());
+      }
+      else
+      {
+         TGLVertex3 center = box.Center();
+         SetCenterVec(center.X(), center.Y(), center.Z());
+      }
    }
    if (reset)
       Reset();
diff --git a/graf3d/gl/src/TGLOverlayButton.cxx b/graf3d/gl/src/TGLOverlayButton.cxx
index 2642e9b..310e7bd 100644
--- a/graf3d/gl/src/TGLOverlayButton.cxx
+++ b/graf3d/gl/src/TGLOverlayButton.cxx
@@ -81,50 +81,54 @@ void TGLOverlayButton::Render(TGLRnrCtx& rnrCtx)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glShadeModel(GL_FLAT);
    glClearColor(0.0, 0.0, 0.0, 0.0);
-   glPushName(0);
-
-   // Text rendering
-   rnrCtx.RegisterFontNoScale(TMath::Nint(fHeight*0.8), "arial",  TGLFont::kPixmap, fFont);
-   fFont.PreRender(kFALSE);
-
-   TColor::Pixel2RGB(fTextColor, r, g, b);
-   (fActiveID == 1) ? TGLUtil::Color4f(r, g, b, fHighAlpha):TGLUtil::Color4f(r, g, b, fNormAlpha);
-   glPushMatrix();
-   glTranslatef(fPosX+(fWidth/2.0), offset+fPosY+(fHeight/2.0), 0);
-   Float_t llx, lly, llz, urx, ury, urz;
-   fFont.BBox(fText.Data(), llx, lly, llz, urx, ury, urz);
-   glRasterPos2i(0, 0);
-   glBitmap(0, 0, 0, 0, -urx*0.5f, -ury*0.4f, 0);
-   fFont.Render(fText.Data());
-   fFont.PostRender();
-   glPopMatrix();
+   glPushName(1);
 
    // Button rendering
-   glPushMatrix();
-   glTranslatef(fPosX, offset+fPosY, 0);
-   glLoadName(1);
-   // First the border, same color as text
-   TColor::Pixel2RGB(fTextColor, r, g, b);
-   (fActiveID == 1) ? TGLUtil::Color4f(r, g, b, fHighAlpha):TGLUtil::Color4f(r, g, b, fNormAlpha);
-   TGLUtil::LineWidth(1);
-   glBegin(GL_LINE_LOOP);
-   glVertex2f(0.0, 0.0);
-   glVertex2f(0.0, fHeight);
-   glVertex2f(fWidth, fHeight);
-   glVertex2f(fWidth, 0.0);
-   glEnd();
-   // then the button itself, with its own color
-   // decrease a bit the highlight, to avoid bad effects...
-   TColor::Pixel2RGB(fBackColor, r, g, b);
-   (fActiveID == 1) ? TGLUtil::Color4f(r, g, b, fHighAlpha * 0.8):TGLUtil::Color4f(r, g, b, fNormAlpha);
-   glBegin(GL_QUADS);
-   glVertex2f(0.0, 0.0);
-   glVertex2f(0.0, fHeight);
-   glVertex2f(fWidth, fHeight);
-   glVertex2f(fWidth, 0.0);
-   glEnd();
-   glPopMatrix();
+   {
+      TGLCapabilitySwitch move_to_back(GL_POLYGON_OFFSET_FILL, kTRUE);
+      glPolygonOffset(0.5f, 0.5f);
+      glPushMatrix();
+      glTranslatef(fPosX, offset+fPosY, 0);
+      // First the border, same color as text
+      TColor::Pixel2RGB(fTextColor, r, g, b);
+      (fActiveID == 1) ? TGLUtil::Color4f(r, g, b, fHighAlpha):TGLUtil::Color4f(r, g, b, fNormAlpha);
+      TGLUtil::LineWidth(1);
+      glBegin(GL_LINE_LOOP);
+      glVertex2f(0.0, 0.0);
+      glVertex2f(0.0, fHeight);
+      glVertex2f(fWidth, fHeight);
+      glVertex2f(fWidth, 0.0);
+      glEnd();
+      // then the button itself, with its own color
+      // decrease a bit the highlight, to avoid bad effects...
+      TColor::Pixel2RGB(fBackColor, r, g, b);
+      (fActiveID == 1) ? TGLUtil::Color4f(r, g, b, fHighAlpha * 0.8):TGLUtil::Color4f(r, g, b, fNormAlpha);
+      glBegin(GL_QUADS);
+      glVertex2f(0.0, 0.0);
+      glVertex2f(0.0, fHeight);
+      glVertex2f(fWidth, fHeight);
+      glVertex2f(fWidth, 0.0);
+      glEnd();
+      glPopMatrix();
+   }
 
+   // Text rendering
+   {
+      rnrCtx.RegisterFontNoScale(TMath::Nint(fHeight*0.8), "arial",  TGLFont::kPixmap, fFont);
+      fFont.PreRender(kFALSE);
+
+      TColor::Pixel2RGB(fTextColor, r, g, b);
+      (fActiveID == 1) ? TGLUtil::Color4f(r, g, b, fHighAlpha):TGLUtil::Color4f(r, g, b, fNormAlpha);
+      glPushMatrix();
+      glTranslatef(fPosX+(fWidth/2.0), offset+fPosY+(fHeight/2.0), 0);
+      Float_t llx, lly, llz, urx, ury, urz;
+      fFont.BBox(fText.Data(), llx, lly, llz, urx, ury, urz);
+      glRasterPos2i(0, 0);
+      glBitmap(0, 0, 0, 0, -urx*0.5f, -ury*0.5f, 0);
+      fFont.Render(fText.Data());
+      fFont.PostRender();
+      glPopMatrix();
+   }
    glPopName();
 
    glMatrixMode(GL_PROJECTION);
diff --git a/graf3d/gl/src/TGLPerspectiveCamera.cxx b/graf3d/gl/src/TGLPerspectiveCamera.cxx
index 42ff238..1720d34 100644
--- a/graf3d/gl/src/TGLPerspectiveCamera.cxx
+++ b/graf3d/gl/src/TGLPerspectiveCamera.cxx
@@ -60,8 +60,15 @@ void TGLPerspectiveCamera::Setup(const TGLBoundingBox & box, Bool_t reset)
 
    if (fExternalCenter == kFALSE)
    {
-      TGLVertex3 center = box.Center();
-      SetCenterVec(center.X(), center.Y(), center.Z());
+      if (fFixDefCenter)
+      {
+         SetCenterVec(fFDCenter.X(), fFDCenter.Y(), fFDCenter.Z());
+      }
+      else
+      {
+         TGLVertex3 center = box.Center();
+         SetCenterVec(center.X(), center.Y(), center.Z());
+      }
    }
 
    // At default FOV, the dolly should be set so as to encapsulate the scene.
diff --git a/graf3d/gl/src/TGLPhysicalShape.cxx b/graf3d/gl/src/TGLPhysicalShape.cxx
index 60e764c..bd1c093 100644
--- a/graf3d/gl/src/TGLPhysicalShape.cxx
+++ b/graf3d/gl/src/TGLPhysicalShape.cxx
@@ -320,7 +320,7 @@ void TGLPhysicalShape::SetupGLColors(TGLRnrCtx & rnrCtx, const Float_t* color) c
       {
          // Outline also needs grey wireframe but respecting
          // transparency of main diffuse color.
-         TGLUtil::Color(rnrCtx.ColorSet().Outline(), 0.5f*color[3]);
+         TGLUtil::ColorAlpha(rnrCtx.ColorSet().Outline(), 0.5f*color[3]);
          break;
       }
       default:
diff --git a/graf3d/gl/src/TGLPolyMarker.cxx b/graf3d/gl/src/TGLPolyMarker.cxx
index 2663c36..6469124 100644
--- a/graf3d/gl/src/TGLPolyMarker.cxx
+++ b/graf3d/gl/src/TGLPolyMarker.cxx
@@ -69,6 +69,7 @@ void TGLPolyMarker::DirectDraw(TGLRnrCtx & rnrCtx) const
    switch (fStyle) {
    case 27:
       stacks = 2, slices = 4;
+      // intentionaly no break
    case 4:case 8:case 20:case 24:
       for (UInt_t i = 0; i < size; i += 3) {
          glPushMatrix();
@@ -79,6 +80,7 @@ void TGLPolyMarker::DirectDraw(TGLRnrCtx & rnrCtx) const
       break;
    case 22:case 26:
       topRadius = 0.;
+      // intentionaly no break
    case 21:case 25:
       for (UInt_t i = 0; i < size; i += 3) {
          glPushMatrix();
@@ -101,8 +103,10 @@ void TGLPolyMarker::DirectDraw(TGLRnrCtx & rnrCtx) const
       break;
    case 7:
       pixelSize += 1;
+      // intentionaly no break
    case 6:
       pixelSize += 1;
+      // intentionaly no break
    case 1: case 9: case 10: case 11: default:
       TGLUtil::PointSize(pixelSize);
       glBegin(GL_POINTS);
diff --git a/graf3d/gl/src/TGLRnrCtx.cxx b/graf3d/gl/src/TGLRnrCtx.cxx
index d5b0072..4be78ed 100644
--- a/graf3d/gl/src/TGLRnrCtx.cxx
+++ b/graf3d/gl/src/TGLRnrCtx.cxx
@@ -18,6 +18,7 @@
 #include "TGLSelectBuffer.h"
 #include "TGLIncludes.h"
 #include "TGLUtil.h"
+#include "TGLCamera.h"
 #include "TGLFontManager.h"
 #include "TGLContext.h"
 
@@ -398,6 +399,34 @@ void TGLRnrCtx::RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont&
   RegisterFontNoScale(TMath::Nint(size*fRenderScale), name, mode, out);
 }
 
+
+/******************************************************************************/
+// Matrix manipulation helpers
+/******************************************************************************/
+
+void TGLRnrCtx::ProjectionMatrixPushIdentity()
+{
+   glMatrixMode(GL_PROJECTION);
+   glPushMatrix();
+   glLoadIdentity();
+   if (Selection())
+   {
+      TGLRect rect(*GetPickRectangle());
+      GetCamera()->WindowToViewport(rect);
+      gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
+                    (Int_t*) GetCamera()->RefViewport().CArr());
+   }
+   glMatrixMode(GL_MODELVIEW);
+}
+
+void TGLRnrCtx::ProjectionMatrixPop()
+{
+   glMatrixMode(GL_PROJECTION);
+   glPopMatrix();
+   glMatrixMode(GL_MODELVIEW);
+}
+
+
 /**************************************************************************/
 // Static helpers
 /**************************************************************************/
diff --git a/graf3d/gl/src/TGLRotateManip.cxx b/graf3d/gl/src/TGLRotateManip.cxx
index db8b91b..6980ba2 100644
--- a/graf3d/gl/src/TGLRotateManip.cxx
+++ b/graf3d/gl/src/TGLRotateManip.cxx
@@ -110,30 +110,27 @@ void TGLRotateManip::Draw(const TGLCamera& camera) const
    // GL name loading for hit testing - 0 reserved for no selection
    if (manip & TGLPhysicalShape::kRotateX) {
       glPushName(1);
-      TGLUtil::DrawRing(box.Center(), box.Axis(0, kTRUE), ringRadius*1.004,
-                        fSelectedWidget == 1 ? fgYellow : fgRed);
+      TGLUtil::DrawRing(box.Center(), box.Axis(0, kTRUE), ringRadius*1.004, ColorFor(1));
       glPopName();
    } else {
-      TGLUtil::DrawRing(box.Center(), box.Axis(0, kTRUE), ringRadius*1.004, fgGrey);
+      TGLUtil::DrawRing(box.Center(), box.Axis(0, kTRUE), ringRadius*1.004, TGLUtil::fgGrey);
    }
    if (manip & TGLPhysicalShape::kRotateY) {
       glPushName(2);
-      TGLUtil::DrawRing(box.Center(), box.Axis(1, kTRUE), ringRadius*1.002,
-                        fSelectedWidget == 2 ? fgYellow : fgGreen);
+      TGLUtil::DrawRing(box.Center(), box.Axis(1, kTRUE), ringRadius*1.002, ColorFor(2));
       glPopName();
    } else {
-      TGLUtil::DrawRing(box.Center(), box.Axis(1, kTRUE), ringRadius*1.002, fgGrey);
+      TGLUtil::DrawRing(box.Center(), box.Axis(1, kTRUE), ringRadius*1.002, TGLUtil::fgGrey);
    }
    if (manip & TGLPhysicalShape::kRotateZ) {
       glPushName(3);
-      TGLUtil::DrawRing(box.Center(), box.Axis(2, kTRUE), ringRadius,
-                        fSelectedWidget == 3 ? fgYellow : fgBlue);
+      TGLUtil::DrawRing(box.Center(), box.Axis(2, kTRUE), ringRadius, ColorFor(3));
       glPopName();
    } else {
-      TGLUtil::DrawRing(box.Center(), box.Axis(2, kTRUE), ringRadius, fgGrey);
+      TGLUtil::DrawRing(box.Center(), box.Axis(2, kTRUE), ringRadius, TGLUtil::fgGrey);
    }
    // Draw white center sphere
-   TGLUtil::DrawSphere(box.Center(), ringRadius/20.0, fgWhite);
+   TGLUtil::DrawSphere(box.Center(), ringRadius/20.0, TGLUtil::fgWhite);
 
    // Indicate we are in ring follow (non-shallow) mode
    // by drawing line from center to dragged ring point
@@ -149,14 +146,14 @@ void TGLRotateManip::Draw(const TGLCamera& camera) const
          eyeOnRing = fActiveRingPlane.NearestOn(eyeOnRing);
          TGLVector3 arrowDir = Cross(fActiveRingPlane.Norm(), eyeOnRing - fActiveRingCenter);
          arrowDir.Normalise();
-         TGLUtil::DrawLine(eyeOnRing, arrowDir*ringRadius*1.3, TGLUtil::kLineHeadArrow, baseScale, fgYellow);
-         TGLUtil::DrawLine(eyeOnRing, -arrowDir*ringRadius*1.3, TGLUtil::kLineHeadArrow, baseScale, fgYellow);
+         TGLUtil::DrawLine(eyeOnRing,  arrowDir*ringRadius*1.3, TGLUtil::kLineHeadArrow, baseScale, TGLUtil::fgYellow);
+         TGLUtil::DrawLine(eyeOnRing, -arrowDir*ringRadius*1.3, TGLUtil::kLineHeadArrow, baseScale, TGLUtil::fgYellow);
       } else {
          TGLVector3 activeVector = fRingLine.Vector();
          activeVector.Normalise();
          activeVector *= ringRadius;
          TGLUtil::DrawLine(fRingLine.Start(), activeVector,
-                           TGLUtil::kLineHeadNone, baseScale, fgYellow);
+                           TGLUtil::kLineHeadNone, baseScale, TGLUtil::fgYellow);
       }
    }
 
diff --git a/graf3d/gl/src/TGLSAViewer.cxx b/graf3d/gl/src/TGLSAViewer.cxx
index 1126553..c9a8ab3 100644
--- a/graf3d/gl/src/TGLSAViewer.cxx
+++ b/graf3d/gl/src/TGLSAViewer.cxx
@@ -65,6 +65,7 @@ DIRECT SCENE INTERACTIONS\n\n\
    \tk          --- ZOOM out\n\
    \tArrow Keys --- PAN (TRUCK) across scene\n\
    \tHome       --- reset current camera\n\
+   \tCtrl-Home  --- switch external/automatic camera center\n\
 \n\
    LEFT mouse button -- ROTATE (ORBIT) the scene by holding the mouse button and moving\n\
    the mouse (perspective camera, needs to be enabled in menu for orthograpic cameras).\n\
@@ -87,6 +88,10 @@ DIRECT SCENE INTERACTIONS\n\n\
      orthographic -- zoom,\n\
      perspective  -- change field-of-view (focal length)\n\
 \n\
+   To invert direction of mouse and key actions from scene-centric\n\
+   to viewer-centric, set in your .rootrc file:\n\
+      OpenGL.EventHandler.ViewerCentricControls: 1\n\
+\n\
    Double clik will show GUI editor of the viewer (if assigned).\n\
 \n\
    RESET the camera via the button in viewer-editor or Home key.\n\
diff --git a/graf3d/gl/src/TGLScaleManip.cxx b/graf3d/gl/src/TGLScaleManip.cxx
index 78d7beb..f557540 100644
--- a/graf3d/gl/src/TGLScaleManip.cxx
+++ b/graf3d/gl/src/TGLScaleManip.cxx
@@ -75,32 +75,32 @@ void TGLScaleManip::Draw(const TGLCamera & camera) const
    if (manip & TGLPhysicalShape::kScaleX) {
       glPushName(1);
       TGLUtil::DrawLine(box.Center(), axisScale[0], TGLUtil::kLineHeadBox,
-                        baseScale, fSelectedWidget == 1 ? fgYellow : fgRed);
+                        baseScale, ColorFor(1));
       glPopName();
    } else {
       TGLUtil::DrawLine(box.Center(), axisScale[0], TGLUtil::kLineHeadBox,
-                        baseScale, fgGrey);
+                        baseScale, TGLUtil::fgGrey);
    }
    if (manip & TGLPhysicalShape::kScaleY) {
       glPushName(2);
       TGLUtil::DrawLine(box.Center(), axisScale[1], TGLUtil::kLineHeadBox,
-                        baseScale, fSelectedWidget == 2 ? fgYellow : fgGreen);
+                        baseScale, ColorFor(2));
       glPopName();
    } else {
       TGLUtil::DrawLine(box.Center(), axisScale[1], TGLUtil::kLineHeadBox,
-                        baseScale, fgGrey);
+                        baseScale, TGLUtil::fgGrey);
    }
    if (manip & TGLPhysicalShape::kScaleZ) {
       glPushName(3);
       TGLUtil::DrawLine(box.Center(), axisScale[2], TGLUtil::kLineHeadBox,
-                        baseScale, fSelectedWidget == 3 ? fgYellow : fgBlue);
+                        baseScale, ColorFor(3));
       glPopName();
    } else {
       TGLUtil::DrawLine(box.Center(), axisScale[2], TGLUtil::kLineHeadBox,
-                        baseScale, fgGrey);
+                        baseScale, TGLUtil::fgGrey);
    }
    // Draw white center sphere
-   TGLUtil::DrawSphere(box.Center(), baseScale/2.0, fgWhite);
+   TGLUtil::DrawSphere(box.Center(), baseScale/2.0, TGLUtil::fgWhite);
 
    glEnable(GL_CULL_FACE);
    glDisable(GL_BLEND);
diff --git a/graf3d/gl/src/TGLScene.cxx b/graf3d/gl/src/TGLScene.cxx
index 69c1b68..d047681 100644
--- a/graf3d/gl/src/TGLScene.cxx
+++ b/graf3d/gl/src/TGLScene.cxx
@@ -1427,7 +1427,7 @@ UInt_t TGLScene::SizeOfScene() const
    // Warning: NOT CORRECT at present - doesn't correctly calculate size.
    // of logical shapes with dynamic internal contents.
 
-   UInt_t size = sizeof(this);
+   UInt_t size = sizeof(*this);
 
    printf("Size: Scene Only %u\n", size);
 
diff --git a/graf3d/gl/src/TGLSelectRecord.cxx b/graf3d/gl/src/TGLSelectRecord.cxx
index 0f97838..8e60946 100644
--- a/graf3d/gl/src/TGLSelectRecord.cxx
+++ b/graf3d/gl/src/TGLSelectRecord.cxx
@@ -14,15 +14,18 @@
 
 #include <string.h>
 
-//______________________________________________________________________
+//==============================================================================
 // TGLSelectRecordBase
+//==============================================================================
+
+//______________________________________________________________________
 //
 // Base class for select records.
 // Supports initialization from a raw GL record (UInt_t*) and
 // copies the name-data into internal array.
 //
 
-ClassImp(TGLSelectRecordBase)
+ClassImp(TGLSelectRecordBase);
 
 //______________________________________________________________________________
 TGLSelectRecordBase::TGLSelectRecordBase() :
@@ -136,18 +139,18 @@ void TGLSelectRecordBase::Reset()
 }
 
 
-/**************************************************************************/
-/**************************************************************************/
+//==============================================================================
+// TGLSelectRecord
+//==============================================================================
 
 //______________________________________________________________________
-// TGLSelectRecord
 //
 // Standard selection record including information about containing
 // scene and details ob out selected object (TGLPhysicalShape*,
 // TObject* or simply a void* for foreign scenes).
 //
 
-ClassImp(TGLSelectRecord)
+ClassImp(TGLSelectRecord);
 
 //______________________________________________________________________________
 TGLSelectRecord::TGLSelectRecord() :
@@ -157,7 +160,8 @@ TGLSelectRecord::TGLSelectRecord() :
    fPhysShape   (0),
    fObject      (0),
    fSpecific    (0),
-   fMultiple    (0),
+   fMultiple    (kFALSE),
+   fHighlight   (kFALSE),
    fSecSelRes   (kNone)
 {
    // Default constructor.
@@ -171,7 +175,8 @@ TGLSelectRecord::TGLSelectRecord(UInt_t* data) :
    fPhysShape   (0),
    fObject      (0),
    fSpecific    (0),
-   fMultiple    (0),
+   fMultiple    (kFALSE),
+   fHighlight   (kFALSE),
    fSecSelRes   (kNone)
 {
    // Constructor from raw GL-select record.
@@ -186,6 +191,7 @@ TGLSelectRecord::TGLSelectRecord(const TGLSelectRecord& rec) :
    fObject      (rec.fObject),
    fSpecific    (rec.fSpecific),
    fMultiple    (rec.fMultiple),
+   fHighlight   (rec.fHighlight),
    fSecSelRes   (kNone)
 {
    // Copy constructor.
@@ -211,6 +217,7 @@ TGLSelectRecord& TGLSelectRecord::operator=(const TGLSelectRecord& rec)
       fObject      = rec.fObject;
       fSpecific    = rec.fSpecific;
       fMultiple    = rec.fMultiple;
+      fHighlight   = rec.fHighlight;
       fSecSelRes   = rec.fSecSelRes;
    }
    return *this;
@@ -228,7 +235,8 @@ void TGLSelectRecord::Set(UInt_t* data)
    fPhysShape   = 0;
    fObject      = 0;
    fSpecific    = 0;
-   fMultiple    = 0;
+   fMultiple    = kFALSE;
+   fHighlight   = kFALSE;
    fSecSelRes   = kNone;
 }
 
@@ -243,7 +251,8 @@ void TGLSelectRecord::Reset()
    fPhysShape   = 0;
    fObject      = 0;
    fSpecific    = 0;
-   fMultiple    = 0;
+   fMultiple    = kFALSE;
+   fHighlight   = kFALSE;
    fSecSelRes   = kNone;
 }
 
@@ -273,16 +282,16 @@ Bool_t TGLSelectRecord::AreSameSelectionWise(const TGLSelectRecord& r1,
 }
 
 
-/**************************************************************************/
-/**************************************************************************/
+//==============================================================================
+// TGLOvlSelectRecord
+//==============================================================================
 
 //______________________________________________________________________
-// TGLOvlSelectRecord
 //
 // Selection record for overlay objects.
 //
 
-ClassImp(TGLOvlSelectRecord)
+ClassImp(TGLOvlSelectRecord);
 
 //______________________________________________________________________________
 TGLOvlSelectRecord::TGLOvlSelectRecord() :
diff --git a/graf3d/gl/src/TGLTransManip.cxx b/graf3d/gl/src/TGLTransManip.cxx
index 8bcf83d..558510d 100644
--- a/graf3d/gl/src/TGLTransManip.cxx
+++ b/graf3d/gl/src/TGLTransManip.cxx
@@ -75,32 +75,32 @@ void TGLTransManip::Draw(const TGLCamera & camera) const
    if (manip & TGLPhysicalShape::kTranslateX) {
       glPushName(1);
       TGLUtil::DrawLine(box.Center(), axisScale[0], TGLUtil::kLineHeadArrow,
-                        baseScale, fSelectedWidget == 1 ? fgYellow : fgRed);
+                        baseScale, ColorFor(1));
       glPopName();
    } else {
       TGLUtil::DrawLine(box.Center(), axisScale[0], TGLUtil::kLineHeadArrow,
-                        baseScale, fgGrey);
+                        baseScale, TGLUtil::fgGrey);
    }
    if (manip & TGLPhysicalShape::kTranslateY) {
       glPushName(2);
       TGLUtil::DrawLine(box.Center(), axisScale[1], TGLUtil::kLineHeadArrow,
-                        baseScale, fSelectedWidget == 2 ? fgYellow : fgGreen);
+                        baseScale, ColorFor(2));
       glPopName();
    } else {
       TGLUtil::DrawLine(box.Center(), axisScale[1], TGLUtil::kLineHeadArrow,
-                        baseScale, fgGrey);
+                        baseScale, TGLUtil::fgGrey);
    }
    if (manip & TGLPhysicalShape::kTranslateZ) {
       glPushName(3);
       TGLUtil::DrawLine(box.Center(), axisScale[2], TGLUtil::kLineHeadArrow,
-                        baseScale, fSelectedWidget == 3 ? fgYellow : fgBlue);
+                        baseScale, ColorFor(3));
       glPopName();
    } else {
       TGLUtil::DrawLine(box.Center(), axisScale[2], TGLUtil::kLineHeadArrow,
-                        baseScale, fgGrey);
+                        baseScale, TGLUtil::fgGrey);
    }
    // Draw white center sphere
-   TGLUtil::DrawSphere(box.Center(), baseScale/2.0, fgWhite);
+   TGLUtil::DrawSphere(box.Center(), baseScale/2.0, TGLUtil::fgWhite);
 
    glEnable(GL_CULL_FACE);
    glDisable(GL_BLEND);
diff --git a/graf3d/gl/src/TGLUtil.cxx b/graf3d/gl/src/TGLUtil.cxx
index 5febcf3..ce958ee 100644
--- a/graf3d/gl/src/TGLUtil.cxx
+++ b/graf3d/gl/src/TGLUtil.cxx
@@ -1381,13 +1381,25 @@ Float_t TGLUtil::fgLineWidth      = 1.0f;
 Float_t TGLUtil::fgPointSizeScale = 1.0f;
 Float_t TGLUtil::fgLineWidthScale = 1.0f;
 
+const UChar_t TGLUtil::fgRed[4]    = { 230,   0,   0, 255 };
+const UChar_t TGLUtil::fgGreen[4]  = {   0, 230,   0, 255 };
+const UChar_t TGLUtil::fgBlue[4]   = {   0,   0, 230, 255 };
+const UChar_t TGLUtil::fgYellow[4] = { 210, 210,   0, 255 };
+const UChar_t TGLUtil::fgWhite[4]  = { 255, 255, 255, 255 };
+const UChar_t TGLUtil::fgGrey[4]   = { 128, 128, 128, 100 };
+
 #ifndef CALLBACK
 #define CALLBACK
 #endif
 
-extern "C" {
-#if defined(R__AIXGCC) || (defined(__APPLE_CC__) && __APPLE_CC__ > 4000 && __APPLE_CC__ < 5341 && !defined(__INTEL_COMPILER))
-   typedef extern "C" void (*tessfuncptr_t)(...);
+extern "C"
+{
+#if defined(__APPLE_CC__) && __APPLE_CC__ > 4000 && __APPLE_CC__ < 5450 && !defined(__INTEL_COMPILER)
+    typedef GLvoid (*tessfuncptr_t)(...);
+#elif defined(__mips) || defined(__linux__) || defined(__FreeBSD__) || defined( __OpenBSD__ ) || defined(__sun) || defined (__CYGWIN__) || defined (__APPLE__)
+    typedef GLvoid (*tessfuncptr_t)();
+#elif defined (WIN32)
+    typedef GLvoid (CALLBACK *tessfuncptr_t)();
 #else
    typedef void (CALLBACK *tessfuncptr_t)();
 #endif
@@ -1561,7 +1573,7 @@ void TGLUtil::Color(const TGLColor& color)
 }
 
 //______________________________________________________________________________
-void TGLUtil::Color(const TGLColor& color, UChar_t alpha)
+void TGLUtil::ColorAlpha(const TGLColor& color, UChar_t alpha)
 {
    // Set color from TGLColor and alpha value.
 
@@ -1572,7 +1584,7 @@ void TGLUtil::Color(const TGLColor& color, UChar_t alpha)
 }
 
 //______________________________________________________________________________
-void TGLUtil::Color(const TGLColor& color, Float_t alpha)
+void TGLUtil::ColorAlpha(const TGLColor& color, Float_t alpha)
 {
    // Set color from TGLColor and alpha value.
 
@@ -1583,7 +1595,7 @@ void TGLUtil::Color(const TGLColor& color, Float_t alpha)
 }
 
 //______________________________________________________________________________
-void TGLUtil::Color(Color_t color_index, Float_t alpha)
+void TGLUtil::ColorAlpha(Color_t color_index, Float_t alpha)
 {
    // Set color from color_index and GL-style alpha (default 1).
 
@@ -1767,7 +1779,8 @@ void TGLUtil::EndExtendPickRegion()
 }
 
 //______________________________________________________________________________
-void TGLUtil::RenderPolyMarkers(const TAttMarker& marker, Float_t* p, Int_t n,
+void TGLUtil::RenderPolyMarkers(const TAttMarker& marker, Char_t transp,
+                                Float_t* p, Int_t n,
                                 Int_t pick_radius, Bool_t selection,
                                 Bool_t sec_selection)
 {
@@ -1779,7 +1792,7 @@ void TGLUtil::RenderPolyMarkers(const TAttMarker& marker, Float_t* p, Int_t n,
    glPushAttrib(GL_ENABLE_BIT | GL_POINT_BIT | GL_LINE_BIT);
 
    glDisable(GL_LIGHTING);
-   TGLUtil::Color(marker.GetMarkerColor());
+   TGLUtil::ColorTransparency(marker.GetMarkerColor(), transp);
 
    Int_t s = marker.GetMarkerStyle();
    if (s == 2 || s == 3 || s == 5 || s == 28)
@@ -1791,7 +1804,8 @@ void TGLUtil::RenderPolyMarkers(const TAttMarker& marker, Float_t* p, Int_t n,
 }
 
 //______________________________________________________________________________
-void TGLUtil::RenderPoints(const TAttMarker& marker, Float_t* op, Int_t n,
+void TGLUtil::RenderPoints(const TAttMarker& marker,
+                           Float_t* op, Int_t n,
                            Int_t pick_radius, Bool_t selection,
                            Bool_t sec_selection)
 {
@@ -1861,7 +1875,8 @@ void TGLUtil::RenderPoints(const TAttMarker& marker, Float_t* op, Int_t n,
 }
 
 //______________________________________________________________________________
-void TGLUtil::RenderCrosses(const TAttMarker& marker, Float_t* op, Int_t n,
+void TGLUtil::RenderCrosses(const TAttMarker& marker,
+                            Float_t* op, Int_t n,
                             Bool_t sec_selection)
 {
    // Render markers as crosses.
@@ -1934,14 +1949,15 @@ void TGLUtil::RenderCrosses(const TAttMarker& marker, Float_t* op, Int_t n,
 }
 
 //______________________________________________________________________________
-void TGLUtil::RenderPolyLine(const TAttLine& aline, Float_t* p, Int_t n,
+void TGLUtil::RenderPolyLine(const TAttLine& aline, Char_t transp,
+                             Float_t* p, Int_t n,
                              Int_t pick_radius, Bool_t selection)
 {
    // Render poly-line as specified by the p-array.
 
    if (n == 0) return;
 
-   BeginAttLine(aline, pick_radius, selection);
+   BeginAttLine(aline, transp, pick_radius, selection);
 
    Float_t* tp = p;
    glBegin(GL_LINE_STRIP);
@@ -1953,14 +1969,15 @@ void TGLUtil::RenderPolyLine(const TAttLine& aline, Float_t* p, Int_t n,
 }
 
 //______________________________________________________________________________
-void TGLUtil::BeginAttLine(const TAttLine& aline, Int_t pick_radius, Bool_t selection)
+void TGLUtil::BeginAttLine(const TAttLine& aline, Char_t transp,
+                           Int_t pick_radius, Bool_t selection)
 {
    // Setup drawing parrameters according to passed TAttLine.
 
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
 
    glDisable(GL_LIGHTING);
-   TGLUtil::Color(aline.GetLineColor());
+   TGLUtil::ColorTransparency(aline.GetLineColor(), transp);
    TGLUtil::LineWidth(aline.GetLineWidth());
    if (aline.GetLineStyle() > 1)
    {
@@ -2003,7 +2020,7 @@ void TGLUtil::EndAttLine(Int_t pick_radius, Bool_t selection)
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TGLUtil::SetDrawColors(const Float_t rgba[4])
+void TGLUtil::SetDrawColors(const UChar_t rgbai[4])
 {
    // Set basic draw colors from 4 component 'rgba'
    // Used by other TGLUtil drawing routines
@@ -2022,8 +2039,9 @@ void TGLUtil::SetDrawColors(const Float_t rgba[4])
 
 
    // Util function to setup GL color for both unlit and lit material
-   static Float_t ambient[4] = {0.0, 0.0, 0.0, 1.0};
-   static Float_t specular[4] = {0.6, 0.6, 0.6, 1.0};
+   Float_t rgba[4]     = {rgbai[0]/255.f, rgbai[1]/255.f, rgbai[2]/255.f, rgbai[3]/255.f};
+   Float_t ambient[4]  = {0.0, 0.0, 0.0, 1.0};
+   Float_t specular[4] = {0.6, 0.6, 0.6, 1.0};
    Float_t emission[4] = {rgba[0]/4.f, rgba[1]/4.f, rgba[2]/4.f, rgba[3]};
 
    glColor4fv(rgba);
@@ -2036,7 +2054,7 @@ void TGLUtil::SetDrawColors(const Float_t rgba[4])
 
 //______________________________________________________________________________
 void TGLUtil::DrawSphere(const TGLVertex3 & position, Double_t radius,
-                         const Float_t rgba[4])
+                         const UChar_t rgba[4])
 {
    // Draw sphere, centered on vertex 'position', with radius 'radius',
    // color 'rgba'
@@ -2050,7 +2068,7 @@ void TGLUtil::DrawSphere(const TGLVertex3 & position, Double_t radius,
 
 //______________________________________________________________________________
 void TGLUtil::DrawLine(const TGLLine3 & line, ELineHeadShape head, Double_t size,
-                       const Float_t rgba[4])
+                       const UChar_t rgba[4])
 {
    // Draw thick line (tube) defined by 'line', with head at end shape
    // 'head' - box/arrow/none, (head) size 'size', color 'rgba'
@@ -2059,7 +2077,7 @@ void TGLUtil::DrawLine(const TGLLine3 & line, ELineHeadShape head, Double_t size
 
 //______________________________________________________________________________
 void TGLUtil::DrawLine(const TGLVertex3 & start, const TGLVector3 & vector,
-                       ELineHeadShape head, Double_t size, const Float_t rgba[4])
+                       ELineHeadShape head, Double_t size, const UChar_t rgba[4])
 {
    // Draw thick line (tube) running from 'start', length 'vector',
    // with head at end of shape 'head' - box/arrow/none,
@@ -2114,7 +2132,7 @@ void TGLUtil::DrawLine(const TGLVertex3 & start, const TGLVector3 & vector,
 
 //______________________________________________________________________________
 void TGLUtil::DrawRing(const TGLVertex3 & center, const TGLVector3 & normal,
-                       Double_t radius, const Float_t rgba[4])
+                       Double_t radius, const UChar_t rgba[4])
 {
    // Draw ring, centered on 'center', lying on plane defined by 'center' & 'normal'
    // of outer radius 'radius', color 'rgba'
@@ -2156,12 +2174,12 @@ void TGLUtil::DrawRing(const TGLVertex3 & center, const TGLVector3 & normal,
 void TGLUtil::DrawReferenceMarker(const TGLCamera  & camera,
                                   const TGLVertex3 & pos,
                                         Float_t      radius,
-                                  const Float_t    * rgba)
+                                  const UChar_t    * rgba)
 {
    // Draw a sphere- marker on world-coordinate 'pos' with pixel
    // radius 'radius'. Color argument is optional.
 
-   static const Float_t defColor[4] = { 0.98, 0.45, 0.0, 1.0 }; // Orange
+   static const UChar_t defColor[4] = { 250, 110, 0, 255 }; // Orange
 
    radius = camera.ViewportDeltaToWorld(pos, radius, radius).Mag();
    DrawSphere(pos, radius, rgba ? rgba : defColor);
@@ -2178,13 +2196,13 @@ void TGLUtil::DrawSimpleAxes(const TGLCamera      & camera,
    if (axesType == kAxesNone)
       return;
 
-   static const Float_t axesColors[][4] = {
-      {0.5, 0.0, 0.0, 1.0},  // -ive X axis light red
-      {1.0, 0.0, 0.0, 1.0},  // +ive X axis deep red
-      {0.0, 0.5, 0.0, 1.0},  // -ive Y axis light green
-      {0.0, 1.0, 0.0, 1.0},  // +ive Y axis deep green
-      {0.0, 0.0, 0.5, 1.0},  // -ive Z axis light blue
-      {0.0, 0.0, 1.0, 1.0}   // +ive Z axis deep blue
+   static const UChar_t axesColors[][4] = {
+      {128,   0,   0, 255},  // -ive X axis light red
+      {255,   0,   0, 255},  // +ive X axis deep red
+      {  0, 128,   0, 255},  // -ive Y axis light green
+      {  0, 255,   0, 255},  // +ive Y axis deep green
+      {  0,   0, 128, 255},  // -ive Z axis light blue
+      {  0,   0, 255, 255}   // +ive Z axis deep blue
    };
 
    static const UChar_t xyz[][8] = {
@@ -2246,8 +2264,7 @@ void TGLUtil::DrawSimpleAxes(const TGLCamera      & camera,
    // Draw origin sphere(s)
    if (axesType == kAxesOrigin) {
       // Single white origin sphere at 0, 0, 0
-      Float_t white[4] = { 1.0, 1.0, 1.0, 1.0 };
-      DrawSphere(TGLVertex3(0.0, 0.0, 0.0), pixelSize*2.0, white);
+      DrawSphere(TGLVertex3(0.0, 0.0, 0.0), pixelSize*2.0, fgWhite);
    } else {
       for (UInt_t j = 0; j < 3; j++) {
          if (min[j] <= 0.0 && max[j] >= 0.0) {
@@ -2382,13 +2399,34 @@ TGLCapabilitySwitch::~TGLCapabilitySwitch()
 void TGLCapabilitySwitch::SetState(Bool_t s)
 {
    if (s)
-      glEnable (fWhat);
+      glEnable(fWhat);
    else
       glDisable(fWhat);
 }
 
 
 //______________________________________________________________________________
+TGLCapabilityEnabler::TGLCapabilityEnabler(Int_t what, Bool_t state) :
+   fWhat(what)
+{
+   // Constructor - change state only if necessary.
+
+   fFlip = ! glIsEnabled(fWhat) && state;
+   if (fFlip)
+      glEnable(fWhat);
+}
+
+//______________________________________________________________________________
+TGLCapabilityEnabler::~TGLCapabilityEnabler()
+{
+   // Destructor - reset state if changed.
+
+   if (fFlip)
+      glDisable(fWhat);
+}
+
+
+//______________________________________________________________________________
 TGLFloatHolder::TGLFloatHolder(Int_t what, Float_t state, void (*foo)(Float_t)) :
       fWhat(what), fState(0), fFlip(kFALSE), fFoo(foo)
    {
diff --git a/graf3d/gl/src/TGLViewer.cxx b/graf3d/gl/src/TGLViewer.cxx
index f144111..b70055e 100644
--- a/graf3d/gl/src/TGLViewer.cxx
+++ b/graf3d/gl/src/TGLViewer.cxx
@@ -322,7 +322,7 @@ void TGLViewer::PadPaint(TVirtualPad* pad)
 /**************************************************************************/
 
 //______________________________________________________________________________
-void TGLViewer::UpdateScene()
+void TGLViewer::UpdateScene(Bool_t redraw)
 {
    // Force update of pad-scenes. Eventually this could be generalized
    // to all scene-types via a virtual function in TGLSceneBase.
@@ -340,7 +340,8 @@ void TGLViewer::UpdateScene()
    PostSceneBuildSetup(fResetCamerasOnNextUpdate || fResetCamerasOnUpdate);
    fResetCamerasOnNextUpdate = kFALSE;
 
-   RequestDraw();
+   if (redraw)
+      RequestDraw();
 }
 
 //______________________________________________________________________________
@@ -442,10 +443,9 @@ void TGLViewer::RequestDraw(Short_t LODInput)
    // Request is directed via cross thread gVirtualGL object.
 
    fRedrawTimer->Stop();
-   // Ignore request if GL window or context not yet availible - we
-   // will get redraw later
-   if (!fGLWidget && fGLDevice == -1) {
-      fRedrawTimer->RequestDraw(100, LODInput);
+   // Ignore request if GL window or context not yet availible or shown.
+   if ((!fGLWidget && fGLDevice == -1) || (fGLWidget && !fGLWidget->IsMapped()))
+   {
       return;
    }
 
@@ -611,7 +611,7 @@ void TGLViewer::DoDrawMono()
       RenderNonSelected();
       RenderSelected();
       DrawGuides();
-      RenderOverlay();
+      RenderOverlay(TGLOverlayElement::kAllVisible, kFALSE);
 
       glClear(GL_DEPTH_BUFFER_BIT);
       fRnrCtx->SetHighlight(kTRUE);
@@ -684,7 +684,7 @@ void TGLViewer::DoDrawStereo()
       RenderNonSelected();
       RenderSelected();
       DrawGuides();
-      RenderOverlay();
+      RenderOverlay(TGLOverlayElement::kAllVisible, kFALSE);
 
       glClear(GL_DEPTH_BUFFER_BIT);
       fRnrCtx->SetHighlight(kTRUE);
@@ -722,7 +722,7 @@ void TGLViewer::DoDrawStereo()
       RenderNonSelected();
       RenderSelected();
       DrawGuides();
-      RenderOverlay();
+      RenderOverlay(TGLOverlayElement::kAllVisible, kFALSE);
 
       glClear(GL_DEPTH_BUFFER_BIT);
       fRnrCtx->SetHighlight(kTRUE);
@@ -992,7 +992,7 @@ void TGLViewer::DrawGuides()
    {
       glDisable(GL_DEPTH_TEST);
       Float_t radius = fCamera->ViewportDeltaToWorld(TGLVertex3(fCamera->GetCenterVec()), 3, 3).Mag();
-      const Float_t rgba[4] = { 0, 1, 1, 1.0 };
+      const UChar_t rgba[4] = { 0, 255, 255, 255 };
       TGLUtil::DrawSphere(fCamera->GetCenterVec(), radius, rgba);
       disabled = kTRUE;
    }
@@ -1028,11 +1028,9 @@ void TGLViewer::DrawDebugInfo()
       // Scene bounding box center sphere (green) and
       glDisable(GL_DEPTH_TEST);
       Double_t size = fOverallBoundingBox.Extents().Mag() / 200.0;
-      static Float_t white[4] = {1.0, 1.0, 1.0, 1.0};
-      TGLUtil::DrawSphere(TGLVertex3(0.0, 0.0, 0.0), size, white);
-      static Float_t green[4] = {0.0, 1.0, 0.0, 1.0};
+      TGLUtil::DrawSphere(TGLVertex3(0.0, 0.0, 0.0), size, TGLUtil::fgWhite);
       const TGLVertex3 & center = fOverallBoundingBox.Center();
-      TGLUtil::DrawSphere(center, size, green);
+      TGLUtil::DrawSphere(center, size, TGLUtil::fgGreen);
       glEnable(GL_DEPTH_TEST);
 
       glEnable(GL_LIGHTING);
@@ -1105,7 +1103,7 @@ void TGLViewer::FadeView(Float_t alpha)
       TGLCapabilitySwitch blend(GL_BLEND,    kTRUE);
       TGLCapabilitySwitch light(GL_LIGHTING, kFALSE);
       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-      TGLUtil::Color(fRnrCtx->ColorSet().Background(), alpha);
+      TGLUtil::ColorAlpha(fRnrCtx->ColorSet().Background(), alpha);
       glBegin(GL_QUADS);
       glVertex3f(-1, -1, z);  glVertex3f( 1, -1, z);
       glVertex3f( 1,  1, z);  glVertex3f(-1,  1, z);
@@ -1353,7 +1351,7 @@ Bool_t TGLViewer::DoOverlaySelect(Int_t x, Int_t y)
    glRenderMode(GL_SELECT);
 
    PreRenderOverlaySelection();
-   RenderOverlay();
+   RenderOverlay(TGLOverlayElement::kActive, kTRUE);
    PostRenderOverlaySelection();
 
    Int_t nHits = glRenderMode(GL_RENDER);
@@ -1843,6 +1841,40 @@ void TGLViewer::MouseOver(TGLPhysicalShape *shape, UInt_t state)
 }
 
 //______________________________________________________________________________
+void TGLViewer::MouseOver(TObject *obj, UInt_t state)
+{
+   // Emit MouseOver signal.
+
+   Long_t args[2];
+   args[0] = (Long_t)obj;
+   args[1] = state;
+   Emit("MouseOver(TObject*,UInt_t)", args);
+}
+
+//______________________________________________________________________________
+void TGLViewer::ReMouseOver(TObject *obj, UInt_t state)
+{
+   // Emit MouseOver signal.
+
+   Long_t args[2];
+   args[0] = (Long_t)obj;
+   args[1] = state;
+   Emit("ReMouseOver(TObject*,UInt_t)", args);
+}
+
+
+//______________________________________________________________________________
+void TGLViewer::UnMouseOver(TObject *obj, UInt_t state)
+{
+   // Emit UnMouseOver signal.
+
+   Long_t args[2];
+   args[0] = (Long_t)obj;
+   args[1] = state;
+   Emit("UnMouseOver(TObject*,UInt_t)", args);
+}
+
+//______________________________________________________________________________
 void TGLViewer::Clicked(TObject *obj)
 {
    // Emit Clicked signal.
diff --git a/graf3d/gl/src/TGLViewerBase.cxx b/graf3d/gl/src/TGLViewerBase.cxx
index ad0c1ed..5fd18f1 100644
--- a/graf3d/gl/src/TGLViewerBase.cxx
+++ b/graf3d/gl/src/TGLViewerBase.cxx
@@ -183,6 +183,21 @@ TGLSceneInfo* TGLViewerBase::GetSceneInfo(TGLSceneBase* scene)
       return 0;
 }
 
+//______________________________________________________________________________
+TGLLogicalShape* TGLViewerBase::FindLogicalInScenes(TObject* id)
+{
+   // Find logical-shape representing object id in the list of scenes.
+   // Return 0 if not found.
+
+   for (SceneInfoList_i i=fScenes.begin(); i!=fScenes.end(); ++i)
+   {
+      TGLLogicalShape *lshp = (*i)->GetScene()->FindLogical(id);
+      if (lshp)
+         return lshp;
+   }
+   return 0;
+}
+
 //______________________________________________________________________
 void TGLViewerBase::AddOverlayElement(TGLOverlayElement* el)
 {
@@ -328,17 +343,18 @@ void TGLViewerBase::PreRender()
       TGLSceneBase *scene = sinfo->GetScene();
       if (sinfo->GetActive())
       {
-         if (fRnrCtx->Selection() && ! scene->GetSelectable())
-            continue;
-         if ( ! sinfo->GetScene()->TakeLock(kDrawLock))
+         if ( ! fRnrCtx->Selection() || scene->GetSelectable())
          {
-            Warning("TGLViewerBase::PreRender", "locking of scene '%s' failed, skipping.",
-                    sinfo->GetScene()->GetName());
-            continue;
+            if ( ! sinfo->GetScene()->TakeLock(kDrawLock))
+            {
+               Warning("TGLViewerBase::PreRender", "locking of scene '%s' failed, skipping.",
+                       sinfo->GetScene()->GetName());
+               continue;
+            }
+            locked_scenes.push_back(sinfo);
          }
          sinfo->SetupTransformsAndBBox(); // !!! transform not done yet
          fOverallBoundingBox.MergeAligned(sinfo->GetTransformedBBox());
-         locked_scenes.push_back(sinfo);
       }
    }
 
@@ -446,7 +462,7 @@ void TGLViewerBase::RenderSelected()
 }
 
 //______________________________________________________________________
-void TGLViewerBase::RenderOverlay()
+void TGLViewerBase::RenderOverlay(Int_t state, Bool_t selection)
 {
    // Render overlay objects.
 
@@ -454,9 +470,12 @@ void TGLViewerBase::RenderOverlay()
    for (Int_t i = 0; i < nOvl; ++i)
    {
       TGLOverlayElement* el = fOverlay[i];
-      glPushName(i);
-      el->Render(*fRnrCtx);
-      glPopName();
+      if (el->GetState() & state)
+      {
+         if (selection) glPushName(i);
+         el->Render(*fRnrCtx);
+         if (selection) glPopName();
+      }
    }
 }
 
diff --git a/graf3d/gl/src/TGLViewerEditor.cxx b/graf3d/gl/src/TGLViewerEditor.cxx
index df522d4..f93334f 100644
--- a/graf3d/gl/src/TGLViewerEditor.cxx
+++ b/graf3d/gl/src/TGLViewerEditor.cxx
@@ -297,7 +297,7 @@ void TGLViewerEditor::DoCameraCenterExt()
    // Set external camera center.
 
    TGLCamera& cam = fViewer->CurrentCamera();
-   cam.SetExternalCenter(fCameraCenterExt->GetState());
+   cam.SetExternalCenter(fCameraCenterExt->IsDown());
 
    fCameraCenterX->SetState(fCameraCenterExt->IsDown());
    fCameraCenterY->SetState(fCameraCenterExt->IsDown());
diff --git a/graf3d/gl/src/TGLWidget.cxx b/graf3d/gl/src/TGLWidget.cxx
index 3dc41f5..4812d08 100644
--- a/graf3d/gl/src/TGLWidget.cxx
+++ b/graf3d/gl/src/TGLWidget.cxx
@@ -138,10 +138,9 @@ TGLWidget::TGLWidget(Window_t glw, const TGWindow* p, Bool_t selectInput)
    {
       gVirtualX->GrabButton(GetId(), kAnyButton, kAnyModifier,
                             kButtonPressMask | kButtonReleaseMask, kNone, kNone);
-      gVirtualX->SelectInput(GetId(),
-                             kKeyPressMask | kExposureMask | kPointerMotionMask
-                             | kStructureNotifyMask | kFocusChangeMask
-                             | kEnterWindowMask | kLeaveWindowMask);
+      gVirtualX->SelectInput(GetId(), kKeyPressMask | kKeyReleaseMask | kExposureMask |
+                             kPointerMotionMask | kStructureNotifyMask | kFocusChangeMask |
+                             kEnterWindowMask | kLeaveWindowMask);
       gVirtualX->SetInputFocus(GetId());
    }
 }
@@ -431,11 +430,15 @@ Window_t TGLWidget::CreateWindow(const TGWindow* parent, const TGLFormat &format
    fill_format(glxfmt, format);
 
    Display *dpy = reinterpret_cast<Display *>(gVirtualX->GetDisplay());
+   if (!dpy) {
+      ::Error("TGLWidget::CreateWindow", "Display is not set!");
+      throw std::runtime_error("Display is not set!");
+   }
    XVisualInfo *visInfo = glXChooseVisual(dpy, DefaultScreen(dpy), &glxfmt[0]);
 
    if (!visInfo) {
-      ::Error("TGLWidget::CreateGLContainer", "No good visual found!");
-      throw std::runtime_error("No good visual found!");
+      ::Error("TGLWidget::CreateWindow", "No good OpenGL visual found!");
+      throw std::runtime_error("No good OpenGL visual found!");
    }
 
    Window_t winID = parent->GetId();
diff --git a/graf3d/gl/src/TPointSet3DGL.cxx b/graf3d/gl/src/TPointSet3DGL.cxx
index 44f1e16..c1687f4 100644
--- a/graf3d/gl/src/TPointSet3DGL.cxx
+++ b/graf3d/gl/src/TPointSet3DGL.cxx
@@ -76,7 +76,7 @@ void TPointSet3DGL::DirectDraw(TGLRnrCtx& rnrCtx) const
    TPointSet3D& q = * (TPointSet3D*) fExternalObj;
 
    TGLUtil::LockColor(); // Keep color from TGLPhysicalShape.
-   TGLUtil::RenderPolyMarkers(q, q.GetP(), q.Size(),
+   TGLUtil::RenderPolyMarkers(q, 0, q.GetP(), q.Size(),
                               rnrCtx.GetPickRadius(),
                               rnrCtx.Selection(),
                               rnrCtx.SecSelection());
diff --git a/graf3d/gl/src/gl2ps.c b/graf3d/gl/src/gl2ps.c
deleted file mode 100644
index e599963..0000000
--- a/graf3d/gl/src/gl2ps.c
+++ /dev/null
@@ -1,6032 +0,0 @@
-/* $Id: gl2ps.c,v 1.1.1.1 2007/04/04 16:01:45 mtadel Exp $ */
-/*
- * GL2PS, an OpenGL to PostScript Printing Library
- * Copyright (C) 1999-2005 Christophe Geuzaine <geuz@geuz.org>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of either:
- *
- * a) the GNU Library General Public License as published by the Free
- * Software Foundation, either version 2 of the License, or (at your
- * option) any later version; or
- *
- * b) the GL2PS License as published by Christophe Geuzaine, either
- * version 2 of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
- * the GNU Library General Public License or the GL2PS License for
- * more details.
- *
- * You should have received a copy of the GNU Library General Public
- * License along with this library in the file named "COPYING.LGPL";
- * if not, write to the Free Software Foundation, Inc., 675 Mass Ave,
- * Cambridge, MA 02139, USA.
- *
- * You should have received a copy of the GL2PS License with this
- * library in the file named "COPYING.GL2PS"; if not, I will be glad
- * to provide one.
- *
- * Contributors:
- *   Michael Sweet <mike@easysw.com>
- *   Marc Ume <marc.ume@digitalgraphics.be>
- *   Jean-Francois Remacle <remacle@gce.ucl.ac.be>
- *   Bart Kaptein <B.L.Kaptein@lumc.nl>
- *   Quy Nguyen-Dai <quy@nguyendai.org>
- *   Sam Buss <sbuss@ucsd.edu>
- *   Shane Hill <Shane.Hill@dsto.defence.gov.au>
- *   Romain Boman <r_boman@yahoo.fr>
- *   Rouben Rostamian <rostamian@umbc.edu>
- *   Diego Santa Cruz <Diego.SantaCruz@epfl.ch>
- *   Shahzad Muzaffar <Shahzad.Muzaffar@cern.ch>
- *   Lassi Tuura <lassi.tuura@cern.ch>
- *   Guy Barrand <barrand@lal.in2p3.fr>
- *   Prabhu Ramachandran <prabhu@aero.iitm.ernet.in>
- *   Micha Bieber <bieber@traits.de>
- *   Olivier Couet <couet@mail.cern.ch>
- *   Shai Ayal <shaiay@gmail.com>
- *   Fabian Wenzel <wenzel@tu-harburg.de>
- *   Ian D. Gay <gay@sfu.ca>
- *   Cosmin Truta <cosmin@cs.toronto.edu>
- *   Baiju Devani <b.devani@gmail.com>
- *   Alexander Danilov <danilov@lanl.gov>
- *
- * For the latest info about gl2ps, see http://www.geuz.org/gl2ps/.
- * Please report all bugs and problems to <gl2ps@geuz.org>.
- */
-
-#include "gl2ps.h"
-
-#include <math.h>
-#include <string.h>
-#include <sys/types.h>
-#include <stdarg.h>
-#include <time.h>
-#include <float.h>
-
-#if defined(GL2PS_HAVE_ZLIB)
-#include <zlib.h>
-#endif
-
-#if defined(GL2PS_HAVE_LIBPNG)
-#include <png.h>
-#endif
-
-/********************************************************************* 
- *
- * Private definitions, data structures and prototypes
- *
- *********************************************************************/
-
-/* Magic numbers (assuming that the order of magnitude of window
-   coordinates is 10^3) */
-
-#define GL2PS_EPSILON       5.0e-3F
-#define GL2PS_ZSCALE        1000.0F
-#define GL2PS_ZOFFSET       5.0e-2F
-#define GL2PS_ZOFFSET_LARGE 20.0F
-#define GL2PS_ZERO(arg)     (fabs(arg) < 1.e-20)
-
-/* Primitive types */
-
-#define GL2PS_NO_TYPE          -1
-#define GL2PS_TEXT             1
-#define GL2PS_POINT            2
-#define GL2PS_LINE             3
-#define GL2PS_QUADRANGLE       4
-#define GL2PS_TRIANGLE         5
-#define GL2PS_PIXMAP           6
-#define GL2PS_IMAGEMAP         7
-#define GL2PS_IMAGEMAP_WRITTEN 8
-#define GL2PS_IMAGEMAP_VISIBLE 9
-#define GL2PS_SPECIAL          10
-
-/* BSP tree primitive comparison */
-
-#define GL2PS_COINCIDENT  1
-#define GL2PS_IN_FRONT_OF 2
-#define GL2PS_IN_BACK_OF  3
-#define GL2PS_SPANNING    4
-
-/* 2D BSP tree primitive comparison */
-
-#define GL2PS_POINT_COINCIDENT 0
-#define GL2PS_POINT_INFRONT    1
-#define GL2PS_POINT_BACK       2
-
-/* Internal feedback buffer pass-through tokens */
-
-#define GL2PS_BEGIN_OFFSET_TOKEN   1
-#define GL2PS_END_OFFSET_TOKEN     2
-#define GL2PS_BEGIN_BOUNDARY_TOKEN 3
-#define GL2PS_END_BOUNDARY_TOKEN   4
-#define GL2PS_BEGIN_STIPPLE_TOKEN  5
-#define GL2PS_END_STIPPLE_TOKEN    6
-#define GL2PS_POINT_SIZE_TOKEN     7
-#define GL2PS_LINE_WIDTH_TOKEN     8
-#define GL2PS_BEGIN_BLEND_TOKEN    9
-#define GL2PS_END_BLEND_TOKEN      10
-#define GL2PS_SRC_BLEND_TOKEN      11
-#define GL2PS_DST_BLEND_TOKEN      12
-#define GL2PS_IMAGEMAP_TOKEN       13
-#define GL2PS_DRAW_PIXELS_TOKEN    14
-#define GL2PS_TEXT_TOKEN           15
-
-typedef enum {
-  T_UNDEFINED    = -1,
-  T_CONST_COLOR  = 1,
-  T_VAR_COLOR    = 1<<1,
-  T_ALPHA_1      = 1<<2,
-  T_ALPHA_LESS_1 = 1<<3,
-  T_VAR_ALPHA    = 1<<4
-} GL2PS_TRIANGLE_PROPERTY;
-
-typedef GLfloat GL2PSxyz[3];
-typedef GLfloat GL2PSplane[4];
-
-typedef struct _GL2PSbsptree2d GL2PSbsptree2d;
-
-struct _GL2PSbsptree2d {
-  GL2PSplane plane;
-  GL2PSbsptree2d *front, *back;
-};
-
-typedef struct {
-  GLint nmax, size, incr, n;
-  char *array;
-} GL2PSlist;
-
-typedef struct _GL2PSbsptree GL2PSbsptree;
-
-struct _GL2PSbsptree {
-  GL2PSplane plane;
-  GL2PSlist *primitives;
-  GL2PSbsptree *front, *back;
-};
-
-typedef struct {
-  GL2PSxyz xyz;
-  GL2PSrgba rgba;
-} GL2PSvertex;
-
-typedef struct {
-  GL2PSvertex vertex[3];
-  int prop;
-} GL2PStriangle;
-
-typedef struct {
-  GLshort fontsize;
-  char *str, *fontname;
-  /* Note: for a 'special' string, 'alignment' holds the format
-     (PostScript, PDF, etc.) of the special string */
-  GLint alignment;
-  GLfloat angle;
-} GL2PSstring;
-
-typedef struct {
-  GLsizei width, height;
-  /* Note: for an imagemap, 'type' indicates if it has already been
-     written to the file or not, and 'format' indicates if it is
-     visible or not */
-  GLenum format, type;
-  GLfloat *pixels;
-} GL2PSimage;
-
-typedef struct _GL2PSimagemap GL2PSimagemap;
-
-struct _GL2PSimagemap {
-  GL2PSimage *image;
-  GL2PSimagemap *next;
-};
-
-typedef struct {
-  GLshort type, numverts;
-  GLushort pattern;
-  char boundary, offset, culled;
-  GLint factor;
-  GLfloat width;
-  GL2PSvertex *verts;
-  union {
-    GL2PSstring *text;
-    GL2PSimage *image;
-  } data;
-} GL2PSprimitive;
-
-typedef struct {
-#if defined(GL2PS_HAVE_ZLIB)
-  Bytef *dest, *src, *start;
-  uLongf destLen, srcLen;
-#else
-  int dummy;
-#endif
-} GL2PScompress;
-
-typedef struct{
-  GL2PSlist* ptrlist;
-  int gsno, fontno, imno, shno, maskshno, trgroupno;
-  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;
-} GL2PSpdfgroup;
-
-typedef struct {
-  /* General */
-  GLint format, sort, options, colorsize, colormode, buffersize;
-  char *title, *producer, *filename;
-  GLboolean boundary, blending;
-  GLfloat *feedback, offset[2], lastlinewidth;
-  GLint viewport[4], blendfunc[2], lastfactor;
-  GL2PSrgba *colormap, lastrgba, threshold, bgcolor;
-  GLushort lastpattern;
-  GL2PSvertex lastvertex;
-  GL2PSlist *primitives, *auxprimitives;
-  FILE *stream;
-  GL2PScompress *compress;
-  GLboolean header;
-
-  /* BSP-specific */
-  GLint maxbestroot;
-
-  /* Occlusion culling-specific */
-  GLboolean zerosurfacearea;
-  GL2PSbsptree2d *imagetree;
-  GL2PSprimitive *primitivetoadd;
-  
-  /* PDF-specific */
-  int streamlength;
-  GL2PSlist *pdfprimlist, *pdfgrouplist;
-  int *xreflist;
-  int objects_stack; /* available objects */
-  int extgs_stack; /* graphics state object number */
-  int font_stack; /* font object number */
-  int im_stack; /* image object number */
-  int trgroupobjects_stack; /* xobject numbers */
-  int shader_stack; /* shader object numbers */
-  int mshader_stack; /* mask shader object numbers */
-
-  /* for image map list */
-  GL2PSimagemap *imagemap_head;
-  GL2PSimagemap *imagemap_tail;
-} GL2PScontext;
-
-typedef struct {
-  void  (*printHeader)(void);
-  void  (*printFooter)(void);
-  void  (*beginViewport)(GLint viewport[4]);
-  GLint (*endViewport)(void);
-  void  (*printPrimitive)(void *data);
-  void  (*printFinalPrimitive)(void);
-  const char *file_extension;
-  const char *description;
-} GL2PSbackend;
-
-/* The gl2ps context. gl2ps is not thread safe (we should create a
-   local GL2PScontext during gl2psBeginPage) */
-
-static GL2PScontext *gl2ps = NULL;
-
-/* Need to forward-declare this one */
-
-static GLint gl2psPrintPrimitives(void);
-
-/********************************************************************* 
- *
- * Utility routines
- *
- *********************************************************************/
-
-static void gl2psMsg(GLint level, const char *fmt, ...)
-{
-  va_list args;
-
-  if(!(gl2ps->options & GL2PS_SILENT)){
-    switch(level){
-    case GL2PS_INFO : fprintf(stderr, "GL2PS info: "); break;
-    case GL2PS_WARNING : fprintf(stderr, "GL2PS warning: "); break;
-    case GL2PS_ERROR : fprintf(stderr, "GL2PS error: "); break;
-    }
-    va_start(args, fmt);
-    vfprintf(stderr, fmt, args); 
-    va_end(args);
-    fprintf(stderr, "\n");
-  }
-  /* if(level == GL2PS_ERROR) exit(1); */
-}
-
-static void *gl2psMalloc(size_t size)
-{
-  void *ptr;
-
-  if(!size) return(NULL);
-  ptr = malloc(size);
-  if(!ptr){
-    gl2psMsg(GL2PS_ERROR, "Couldn't allocate requested memory");
-    exit(1);
-  }
-  return(ptr);
-}
-
-static void *gl2psRealloc(void *ptr, size_t size)
-{
-  if(!size) return(NULL);
-  ptr = realloc(ptr, size);
-  if(!ptr){
-    gl2psMsg(GL2PS_ERROR, "Couldn't reallocate requested memory");
-    exit(1);
-  }
-  return(ptr);
-}
-
-static void gl2psFree(void *ptr)
-{
-  if(!ptr) return;
-  free(ptr);
-}
-
-static size_t gl2psWriteBigEndian(unsigned long data, size_t bytes)
-{
-  size_t i;
-  size_t size = sizeof(unsigned long);
-  for(i = 1; i <= bytes; ++i){
-    fputc(0xff & (data >> (size-i) * 8), gl2ps->stream);
-  }
-  return bytes;
-}
-
-/* zlib compression helper routines */
-
-#if defined(GL2PS_HAVE_ZLIB)
-
-static void gl2psSetupCompress(void)
-{
-  gl2ps->compress = (GL2PScompress*)gl2psMalloc(sizeof(GL2PScompress));
-  gl2ps->compress->src = NULL;
-  gl2ps->compress->start = NULL;
-  gl2ps->compress->dest = NULL;
-  gl2ps->compress->srcLen = 0;
-  gl2ps->compress->destLen = 0;
-}
-
-static void gl2psFreeCompress(void)
-{
-  if(!gl2ps->compress)
-    return;
-  gl2psFree(gl2ps->compress->start);
-  gl2psFree(gl2ps->compress->dest);
-  gl2ps->compress->src = NULL;
-  gl2ps->compress->start = NULL;
-  gl2ps->compress->dest = NULL;
-  gl2ps->compress->srcLen = 0;
-  gl2ps->compress->destLen = 0;
-}
-
-static int gl2psAllocCompress(unsigned int srcsize)
-{
-  gl2psFreeCompress();
-  
-  if(!gl2ps->compress || !srcsize)
-    return GL2PS_ERROR;
-  
-  gl2ps->compress->srcLen = srcsize;
-  gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
-  gl2ps->compress->src = (Bytef*)gl2psMalloc(gl2ps->compress->srcLen);
-  gl2ps->compress->start = gl2ps->compress->src;
-  gl2ps->compress->dest = (Bytef*)gl2psMalloc(gl2ps->compress->destLen);
-  
-  return GL2PS_SUCCESS;
-}
-
-static void *gl2psReallocCompress(unsigned int srcsize)
-{
-  if(!gl2ps->compress || !srcsize)
-    return NULL;
-  
-  if(srcsize < gl2ps->compress->srcLen)
-    return gl2ps->compress->start;
-  
-  gl2ps->compress->srcLen = srcsize;
-  gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
-  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src, 
-                                              gl2ps->compress->srcLen);
-  gl2ps->compress->start = gl2ps->compress->src;
-  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest, 
-                                               gl2ps->compress->destLen);
-  
-  return gl2ps->compress->start;
-}
-
-static size_t gl2psWriteBigEndianCompress(unsigned long data, size_t bytes)
-{
-  size_t i;
-  size_t size = sizeof(unsigned long);
-  for(i = 1; i <= bytes; ++i){
-    *gl2ps->compress->src = (Bytef)(0xff & (data >> (size-i) * 8));
-    ++gl2ps->compress->src;
-  }
-  return bytes;
-}
-
-static int gl2psDeflate(void)
-{
-  /* For compatibility with older zlib versions, we use compress(...)
-     instead of compress2(..., Z_BEST_COMPRESSION) */
-  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen, 
-                  gl2ps->compress->start, gl2ps->compress->srcLen);  
-}
-
-#endif
-
-static int gl2psPrintf(const char* fmt, ...)
-{
-  int ret;
-  va_list args;
-
-#if defined(GL2PS_HAVE_ZLIB)
-  unsigned int oldsize = 0;
-  static char buf[1000];
-  if(gl2ps->options & GL2PS_COMPRESS){
-    va_start(args, fmt);
-    ret = vsprintf(buf, fmt, args);
-    va_end(args);
-    oldsize = gl2ps->compress->srcLen;
-    gl2ps->compress->start = (Bytef*)gl2psReallocCompress(oldsize + ret);
-    memcpy(gl2ps->compress->start+oldsize, buf, ret);
-    ret = 0;
-  }
-  else{
-#endif
-    va_start(args, fmt);
-    ret = vfprintf(gl2ps->stream, fmt, args);
-    va_end(args);
-#if defined(GL2PS_HAVE_ZLIB)
-  }
-#endif
-  return ret;
-}
-
-static void gl2psPrintGzipHeader()
-{
-#if defined(GL2PS_HAVE_ZLIB)
-  char tmp[10] = {'\x1f', '\x8b', /* magic numbers: 0x1f, 0x8b */
-                  8, /* compression method: Z_DEFLATED */
-                  0, /* flags */
-                  0, 0, 0, 0, /* time */
-                  2, /* extra flags: max compression */
-                  '\x03'}; /* OS code: 0x03 (Unix) */
-
-  if(gl2ps->options & GL2PS_COMPRESS){
-    gl2psSetupCompress();
-    /* add the gzip file header */
-    fwrite(tmp, 10, 1, gl2ps->stream);
-  }
-#endif  
-}
-
-static void gl2psPrintGzipFooter()
-{
-#if defined(GL2PS_HAVE_ZLIB)
-  int n;
-  uLong crc, len;
-  char tmp[8];
-
-  if(gl2ps->options & GL2PS_COMPRESS){
-    if(Z_OK != gl2psDeflate()){
-      gl2psMsg(GL2PS_ERROR, "Zlib deflate error");
-    }
-    else{
-      /* determine the length of the header in the zlib stream */
-      n = 2; /* CMF+FLG */
-      if(gl2ps->compress->dest[1] & (1<<5)){
-        n += 4; /* DICTID */
-      }
-      /* write the data, without the zlib header and footer */
-      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4), 
-             1, gl2ps->stream);
-      /* add the gzip file footer */
-      crc = crc32(0L, gl2ps->compress->start, gl2ps->compress->srcLen);
-      for(n = 0; n < 4; ++n){
-        tmp[n] = (char)(crc & 0xff);
-        crc >>= 8;
-      }
-      len = gl2ps->compress->srcLen;
-      for(n = 4; n < 8; ++n){
-        tmp[n] = (char)(len & 0xff);
-        len >>= 8;
-      }
-      fwrite(tmp, 8, 1, gl2ps->stream);
-    }
-    gl2psFreeCompress();
-    gl2psFree(gl2ps->compress);
-    gl2ps->compress = NULL;
-  }
-#endif 
-}
-
-/* The list handling routines */
-
-static void gl2psListRealloc(GL2PSlist *list, GLint n)
-{
-  if(!list){
-    gl2psMsg(GL2PS_ERROR, "Cannot reallocate NULL list");
-    return;
-  }
-  if(n <= 0) return;
-  if(!list->array){
-    list->nmax = n;
-    list->array = (char*)gl2psMalloc(list->nmax * list->size);
-  }
-  else{
-    if(n > list->nmax){
-      list->nmax = ((n - 1) / list->incr + 1) * list->incr;
-      list->array = (char*)gl2psRealloc(list->array,
-                                        list->nmax * list->size);
-    }
-  }
-}
-
-static GL2PSlist *gl2psListCreate(GLint n, GLint incr, GLint size)
-{
-  GL2PSlist *list;
-
-  if(n < 0) n = 0;
-  if(incr <= 0) incr = 1;
-  list = (GL2PSlist*)gl2psMalloc(sizeof(GL2PSlist));
-  list->nmax = 0;
-  list->incr = incr;
-  list->size = size;
-  list->n = 0;
-  list->array = NULL;
-  gl2psListRealloc(list, n);
-  return(list);
-}
-
-static void gl2psListReset(GL2PSlist *list)
-{
-  if(!list) return;
-  list->n = 0;
-}
-
-static void gl2psListDelete(GL2PSlist *list)
-{
-  if(!list) return;  
-  gl2psFree(list->array);
-  gl2psFree(list);
-}
-
-static void gl2psListAdd(GL2PSlist *list, void *data)
-{
-  if(!list){
-    gl2psMsg(GL2PS_ERROR, "Cannot add into unallocated list");
-    return;
-  }
-  list->n++;
-  gl2psListRealloc(list, list->n);
-  memcpy(&list->array[(list->n - 1) * list->size], data, list->size);
-}
-
-static int gl2psListNbr(GL2PSlist *list)
-{
-  if(!list)
-    return 0;
-  return(list->n);
-}
-
-static void *gl2psListPointer(GL2PSlist *list, GLint index)
-{
-  if(!list){
-    gl2psMsg(GL2PS_ERROR, "Cannot point into unallocated list");
-    return NULL;
-  }
-  if((index < 0) || (index >= list->n)){
-    gl2psMsg(GL2PS_ERROR, "Wrong list index in gl2psListPointer");
-    return NULL;
-  }
-  return(&list->array[index * list->size]);
-}
-
-static void gl2psListSort(GL2PSlist *list,
-                          int (*fcmp)(const void *a, const void *b))
-{
-  if(!list)
-    return;
-  qsort(list->array, list->n, list->size, fcmp);
-}
-
-static void gl2psListAction(GL2PSlist *list, void (*action)(void *data))
-{
-  GLint i;
-
-  for(i = 0; i < gl2psListNbr(list); i++){
-    (*action)(gl2psListPointer(list, i));
-  }
-}
-
-static void gl2psListActionInverse(GL2PSlist *list, void (*action)(void *data))
-{
-  GLint i;
-
-  for(i = gl2psListNbr(list); i > 0; i--){
-    (*action)(gl2psListPointer(list, i-1));
-  }
-}
-
-#if defined(GL2PS_HAVE_LIBPNG)
-
-static void gl2psListRead(GL2PSlist *list, int index, void *data)
-{
-  if((index < 0) || (index >= list->n))
-    gl2psMsg(GL2PS_ERROR, "Wrong list index in gl2psListRead");
-  memcpy(data, &list->array[index * list->size], list->size);
-}
-
-static void gl2psEncodeBase64Block(unsigned char in[3], unsigned char out[4], int len)
-{
-  static const char cb64[] = 
-    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-
-  out[0] = cb64[ in[0] >> 2 ];
-  out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
-  out[2] = (len > 1) ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=';
-  out[3] = (len > 2) ? cb64[ in[2] & 0x3f ] : '=';
-}
-
-static void gl2psListEncodeBase64(GL2PSlist *list)
-{
-  unsigned char *buffer, in[3], out[4];
-  int i, n, index, len;
-
-  n = list->n * list->size;
-  buffer = (unsigned char*)gl2psMalloc(n * sizeof(unsigned char));
-  memcpy(buffer, list->array, n * sizeof(unsigned char));
-  gl2psListReset(list);
-
-  index = 0;
-  while(index < n) {
-    len = 0;
-    for(i = 0; i < 3; i++) {
-      if(index < n){
-        in[i] = buffer[index];
-        len++;
-      }
-      else{
-        in[i] = 0;
-      }
-      index++;
-    }
-    if(len) {
-      gl2psEncodeBase64Block(in, out, len);
-      for(i = 0; i < 4; i++)
-        gl2psListAdd(list, &out[i]);
-    }
-  }
-  gl2psFree(buffer);
-}
-
-#endif
-
-/* Helpers for rgba colors */
-
-static GLboolean gl2psSameColor(GL2PSrgba rgba1, GL2PSrgba rgba2)
-{
-  if(!GL2PS_ZERO(rgba1[0] - rgba2[0]) ||
-     !GL2PS_ZERO(rgba1[1] - rgba2[1]) ||
-     !GL2PS_ZERO(rgba1[2] - rgba2[2]))
-    return GL_FALSE;
-  return GL_TRUE;
-}
-  
-static GLboolean gl2psVertsSameColor(const GL2PSprimitive *prim)
-{
-  int i;
-
-  for(i = 1; i < prim->numverts; i++){
-    if(!gl2psSameColor(prim->verts[0].rgba, prim->verts[i].rgba)){
-      return GL_FALSE;
-    }
-  }
-  return GL_TRUE;
-}
-
-static GLboolean gl2psSameColorThreshold(int n, GL2PSrgba rgba[],
-                                         GL2PSrgba threshold)
-{
-  int i;
-
-  if(n < 2) return GL_TRUE;
-  
-  for(i = 1; i < n; i++){
-    if(fabs(rgba[0][0] - rgba[i][0]) > threshold[0] ||
-       fabs(rgba[0][1] - rgba[i][1]) > threshold[1] ||
-       fabs(rgba[0][2] - rgba[i][2]) > threshold[2])
-      return GL_FALSE;
-  }
-  
-  return GL_TRUE;
-}
-
-static void gl2psSetLastColor(GL2PSrgba rgba)
-{
-  int i;        
-  for(i = 0; i < 3; ++i){
-    gl2ps->lastrgba[i] = rgba[i];
-  }
-}
-
-static GLfloat gl2psGetRGB(GL2PSimage *im, GLuint x, GLuint y,
-                           GLfloat *red, GLfloat *green, GLfloat *blue)
-{
-  
-  GLsizei width = im->width;
-  GLsizei height = im->height;
-  GLfloat *pixels = im->pixels;
-  GLfloat *pimag;
-
-  /* OpenGL image is from down to up, PS image is up to down */  
-  switch(im->format){
-  case GL_RGBA:
-    pimag = pixels + 4 * (width * (height - 1 - y) + x);
-    break;
-  case GL_RGB:
-  default:
-    pimag = pixels + 3 * (width * (height - 1 - y) + x);
-    break;
-  }
-  *red = *pimag; pimag++;
-  *green = *pimag; pimag++;
-  *blue = *pimag; pimag++;
-
-  return (im->format == GL_RGBA) ? *pimag : 1.0F;
-}
-
-/* Helper routines for pixmaps */
-
-static GL2PSimage *gl2psCopyPixmap(GL2PSimage *im)
-{
-  int size;
-  GL2PSimage *image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
-  
-  image->width = im->width;
-  image->height = im->height;
-  image->format = im->format;
-  image->type = im->type;
-
-  switch(image->format){
-  case GL_RGBA:
-    size = image->height * image->width * 4 * sizeof(GLfloat);
-    break;
-  case GL_RGB:
-  default:
-    size = image->height * image->width * 3 * sizeof(GLfloat);
-    break;
-  }
-
-  image->pixels = (GLfloat*)gl2psMalloc(size);
-  memcpy(image->pixels, im->pixels, size);
-  
-  return image;
-}
-
-static void gl2psFreePixmap(GL2PSimage *im)
-{
-  if(!im)
-    return;
-  gl2psFree(im->pixels);
-  gl2psFree(im);
-}
-
-#if defined(GL2PS_HAVE_LIBPNG)
-
-#if !defined(png_jmpbuf)
-#  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
-#endif
-
-static void gl2psUserWritePNG(png_structp png_ptr, png_bytep data, png_size_t length)
-{
-  unsigned int i;
-  GL2PSlist *png = (GL2PSlist*)png_get_io_ptr(png_ptr);
-  for(i = 0; i < length; i++) 
-    gl2psListAdd(png, &data[i]);
-}
-
-static void gl2psUserFlushPNG(png_structp png_ptr)
-{
-}
-
-static void gl2psConvertPixmapToPNG(GL2PSimage *pixmap, GL2PSlist *png)
-{
-  png_structp png_ptr;
-  png_infop info_ptr;
-  unsigned char *row_data;
-  GLfloat dr, dg, db;
-  int row, col;
-
-  if(!(png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL)))
-    return;
-  
-  if(!(info_ptr = png_create_info_struct(png_ptr))){
-    png_destroy_write_struct(&png_ptr, NULL);
-    return;
-  }
-  
-  if(setjmp(png_jmpbuf(png_ptr))) {
-    png_destroy_write_struct(&png_ptr, &info_ptr);
-    return;
-  }
-  
-  png_set_write_fn(png_ptr, (void *)png, gl2psUserWritePNG, gl2psUserFlushPNG);
-  png_set_compression_level(png_ptr, Z_DEFAULT_COMPRESSION);
-  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8, 
-               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, 
-               PNG_FILTER_TYPE_BASE);
-  png_write_info(png_ptr, info_ptr);
-
-  row_data = (unsigned char*)gl2psMalloc(3 * pixmap->width * sizeof(unsigned char));
-  for(row = 0; row < pixmap->height; row++){
-    for(col = 0; col < pixmap->width; col++){
-      gl2psGetRGB(pixmap, col, row, &dr, &dg, &db);
-      row_data[3*col] = (unsigned char)(255. * dr);
-      row_data[3*col+1] = (unsigned char)(255. * dg);
-      row_data[3*col+2] = (unsigned char)(255. * db);
-    }
-    png_write_row(png_ptr, (png_bytep)row_data);
-  }
-  gl2psFree(row_data);
-
-  png_write_end(png_ptr, info_ptr);
-  png_destroy_write_struct(&png_ptr, &info_ptr);
-}
-
-#endif
-
-/* Helper routines for text strings */
-
-static GLint gl2psAddText(GLint type, const char *str, const char *fontname, 
-                          GLshort fontsize, GLint alignment, GLfloat angle)
-{
-  GLfloat pos[4];
-  GL2PSprimitive *prim;
-  GLboolean valid;
-
-  if(!gl2ps || !str || !fontname) return GL2PS_UNINITIALIZED;
-
-  if(gl2ps->options & GL2PS_NO_TEXT) return GL2PS_SUCCESS;
-
-  glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
-  if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */
-
-  glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
-
-  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-  prim->type = type;
-  prim->boundary = 0;
-  prim->numverts = 1;
-  prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
-  prim->verts[0].xyz[0] = pos[0];
-  prim->verts[0].xyz[1] = pos[1];
-  prim->verts[0].xyz[2] = pos[2];
-  prim->culled = 0;
-  prim->offset = 0;
-  prim->pattern = 0;
-  prim->factor = 0;
-  prim->width = 1;
-  glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
-  prim->data.text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
-  prim->data.text->str = (char*)gl2psMalloc((strlen(str)+1)*sizeof(char));
-  strcpy(prim->data.text->str, str); 
-  prim->data.text->fontname = (char*)gl2psMalloc((strlen(fontname)+1)*sizeof(char));
-  strcpy(prim->data.text->fontname, fontname);
-  prim->data.text->fontsize = fontsize;
-  prim->data.text->alignment = alignment;
-  prim->data.text->angle = angle;
-
-  gl2psListAdd(gl2ps->auxprimitives, &prim);
-  glPassThrough(GL2PS_TEXT_TOKEN);
-    
-  return GL2PS_SUCCESS;
-}
-
-static GL2PSstring *gl2psCopyText(GL2PSstring *t)
-{
-  GL2PSstring *text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
-  text->str = (char*)gl2psMalloc((strlen(t->str)+1)*sizeof(char));
-  strcpy(text->str, t->str); 
-  text->fontname = (char*)gl2psMalloc((strlen(t->fontname)+1)*sizeof(char));
-  strcpy(text->fontname, t->fontname);
-  text->fontsize = t->fontsize;
-  text->alignment = t->alignment;
-  text->angle = t->angle;
-  
-  return text;
-}
-
-static void gl2psFreeText(GL2PSstring *text)
-{
-  if(!text)
-    return;
-  gl2psFree(text->str);
-  gl2psFree(text->fontname);
-  gl2psFree(text);
-}
-
-/* Helpers for blending modes */
-
-static GLboolean gl2psSupportedBlendMode(GLenum sfactor, GLenum dfactor)
-{
-  /* returns TRUE if gl2ps supports the argument combination: only two
-     blending modes have been implemented so far */
-
-  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) || 
-      (sfactor == GL_ONE && dfactor == GL_ZERO) )
-    return GL_TRUE;
-  return GL_FALSE;
-}
-
-static void gl2psAdaptVertexForBlending(GL2PSvertex *v)
-{
-  /* Transforms vertex depending on the actual blending function -
-     currently the vertex v is considered as source vertex and his
-     alpha value is changed to 1.0 if source blending GL_ONE is
-     active. This might be extended in the future */
-
-  if(!v || !gl2ps)
-    return;
-
-  if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
-    v->rgba[3] = 1.0F;
-    return;
-  }
-  
-  switch(gl2ps->blendfunc[0]){
-  case GL_ONE:
-    v->rgba[3] = 1.0F;
-    break;
-  default:
-    break;
-  }
-}
-
-static void gl2psAssignTriangleProperties(GL2PStriangle *t)
-{
-  /* int i; */
-
-  t->prop = T_VAR_COLOR;
-
-  /* Uncommenting the following lines activates an even more fine
-     grained distinction between triangle types - please don't delete,
-     a remarkable amount of PDF handling code inside this file depends
-     on it if activated */
-  /*
-  t->prop = T_CONST_COLOR;    
-  for(i = 0; i < 3; ++i){
-    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) || 
-       !GL2PS_ZERO(t->vertex[1].rgba[i] - t->vertex[2].rgba[i])){
-      t->prop = T_VAR_COLOR;
-      break;
-    }
-  }
-  */
-
-  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) || 
-     !GL2PS_ZERO(t->vertex[1].rgba[3] - t->vertex[2].rgba[3])){
-    t->prop |= T_VAR_ALPHA;
-  }
-  else{
-    if(t->vertex[0].rgba[3] < 1)
-      t->prop |= T_ALPHA_LESS_1;
-    else
-      t->prop |= T_ALPHA_1;
-  }
-}
-
-static void gl2psFillTriangleFromPrimitive(GL2PStriangle *t, GL2PSprimitive *p,
-                                           GLboolean assignprops)
-{
-  t->vertex[0] = p->verts[0];
-  t->vertex[1] = p->verts[1];
-  t->vertex[2] = p->verts[2];
-  if(GL_TRUE == assignprops)
-    gl2psAssignTriangleProperties(t);
-}
-
-static void gl2psInitTriangle(GL2PStriangle *t)
-{
-  int i;
-  GL2PSvertex vertex = { {-1.0F, -1.0F, -1.0F}, {-1.0F, -1.0F, -1.0F, -1.0F} };
-  for(i = 0; i < 3; i++)
-    t->vertex[i] = vertex;
-  t->prop = T_UNDEFINED;
-}
-
-/* Miscellaneous helper routines */
-
-static GL2PSprimitive *gl2psCopyPrimitive(GL2PSprimitive *p)
-{
-  GL2PSprimitive *prim;
-
-  if(!p){
-    gl2psMsg(GL2PS_ERROR, "Trying to copy an empty primitive");
-    return NULL;
-  }
-
-  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-  
-  prim->type = p->type;
-  prim->numverts = p->numverts;
-  prim->boundary = p->boundary;
-  prim->offset = p->offset;
-  prim->pattern = p->pattern;
-  prim->factor = p->factor;
-  prim->culled = p->culled;
-  prim->width = p->width;
-  prim->verts = (GL2PSvertex*)gl2psMalloc(p->numverts*sizeof(GL2PSvertex));
-  memcpy(prim->verts, p->verts, p->numverts * sizeof(GL2PSvertex));
-
-  switch(prim->type){
-  case GL2PS_PIXMAP :
-    prim->data.image = gl2psCopyPixmap(p->data.image);
-    break;
-  case GL2PS_TEXT :
-  case GL2PS_SPECIAL :
-    prim->data.text = gl2psCopyText(p->data.text);
-    break;
-  default:
-    break;
-  }
-
-  return prim;
-}
-
-static GLboolean gl2psSamePosition(GL2PSxyz p1, GL2PSxyz p2)
-{
-  if(!GL2PS_ZERO(p1[0] - p2[0]) ||
-     !GL2PS_ZERO(p1[1] - p2[1]) ||
-     !GL2PS_ZERO(p1[2] - p2[2]))
-    return GL_FALSE;
-  return GL_TRUE;
-}
-
-/********************************************************************* 
- *
- * 3D sorting routines 
- *
- *********************************************************************/
-
-static GLfloat gl2psComparePointPlane(GL2PSxyz point, GL2PSplane plane)
-{
-  return(plane[0] * point[0] + 
-         plane[1] * point[1] + 
-         plane[2] * point[2] + 
-         plane[3]);
-}
-
-static GLfloat gl2psPsca(GLfloat *a, GLfloat *b)
-{
-  return(a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
-}
-
-static void gl2psPvec(GLfloat *a, GLfloat *b, GLfloat *c)
-{
-  c[0] = a[1]*b[2] - a[2]*b[1];
-  c[1] = a[2]*b[0] - a[0]*b[2];
-  c[2] = a[0]*b[1] - a[1]*b[0];
-}
-
-static GLfloat gl2psNorm(GLfloat *a)
-{
-  return (GLfloat)sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
-}
-
-static void gl2psGetNormal(GLfloat *a, GLfloat *b, GLfloat *c)
-{
-  GLfloat norm;
-
-  gl2psPvec(a, b, c);
-  if(!GL2PS_ZERO(norm = gl2psNorm(c))){
-    c[0] = c[0] / norm;
-    c[1] = c[1] / norm;
-    c[2] = c[2] / norm;
-  }
-  else{
-    /* The plane is still wrong despite our tests in gl2psGetPlane.
-       Let's return a dummy value for now (this is a hack: we should
-       do more intelligent tests in GetPlane) */
-    c[0] = c[1] = 0.0F;
-    c[2] = 1.0F;
-  }
-}
-
-static void gl2psGetPlane(GL2PSprimitive *prim, GL2PSplane plane)
-{
-  GL2PSxyz v = {0.0F, 0.0F, 0.0F}, w = {0.0F, 0.0F, 0.0F};
-
-  switch(prim->type){
-  case GL2PS_TRIANGLE :
-  case GL2PS_QUADRANGLE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
-    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0]; 
-    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1]; 
-    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2]; 
-    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) || 
-       (GL2PS_ZERO(w[0]) && GL2PS_ZERO(w[1]) && GL2PS_ZERO(w[2]))){
-      plane[0] = plane[1] = 0.0F;
-      plane[2] = 1.0F;
-      plane[3] = -prim->verts[0].xyz[2];
-    }
-    else{
-      gl2psGetNormal(v, w, plane);
-      plane[3] = 
-        - plane[0] * prim->verts[0].xyz[0] 
-        - plane[1] * prim->verts[0].xyz[1] 
-        - plane[2] * prim->verts[0].xyz[2];
-    }
-    break;
-  case GL2PS_LINE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
-    if(GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])){
-      plane[0] = plane[1] = 0.0F;
-      plane[2] = 1.0F;
-      plane[3] = -prim->verts[0].xyz[2];
-    }
-    else{
-      if(GL2PS_ZERO(v[0]))      w[0] = 1.0F;
-      else if(GL2PS_ZERO(v[1])) w[1] = 1.0F;
-      else                      w[2] = 1.0F;
-      gl2psGetNormal(v, w, plane);
-      plane[3] = 
-        - plane[0] * prim->verts[0].xyz[0] 
-        - plane[1] * prim->verts[0].xyz[1] 
-        - plane[2] * prim->verts[0].xyz[2];
-    }
-    break;
-  case GL2PS_POINT :
-  case GL2PS_PIXMAP :
-  case GL2PS_TEXT :
-  case GL2PS_SPECIAL :
-  case GL2PS_IMAGEMAP:
-    plane[0] = plane[1] = 0.0F;
-    plane[2] = 1.0F;
-    plane[3] = -prim->verts[0].xyz[2];
-    break;
-  default :
-    gl2psMsg(GL2PS_ERROR, "Unknown primitive type in BSP tree");
-    plane[0] = plane[1] = plane[3] = 0.0F;
-    plane[2] = 1.0F;
-    break;
-  }
-}
-
-static void gl2psCutEdge(GL2PSvertex *a, GL2PSvertex *b, GL2PSplane plane,
-                         GL2PSvertex *c)
-{
-  GL2PSxyz v;
-  GLfloat sect, psca;
-
-  v[0] = b->xyz[0] - a->xyz[0];
-  v[1] = b->xyz[1] - a->xyz[1];
-  v[2] = b->xyz[2] - a->xyz[2];
-
-  if(!GL2PS_ZERO(psca = gl2psPsca(plane, v)))
-    sect = -gl2psComparePointPlane(a->xyz, plane) / psca;
-  else
-    sect = 0.0F;
-  
-  c->xyz[0] = a->xyz[0] + v[0] * sect;
-  c->xyz[1] = a->xyz[1] + v[1] * sect;
-  c->xyz[2] = a->xyz[2] + v[2] * sect;
-  
-  c->rgba[0] = (1 - sect) * a->rgba[0] + sect * b->rgba[0];
-  c->rgba[1] = (1 - sect) * a->rgba[1] + sect * b->rgba[1];
-  c->rgba[2] = (1 - sect) * a->rgba[2] + sect * b->rgba[2];
-  c->rgba[3] = (1 - sect) * a->rgba[3] + sect * b->rgba[3];
-}
-
-static void gl2psCreateSplitPrimitive(GL2PSprimitive *parent, GL2PSplane plane,
-                                      GL2PSprimitive *child, GLshort numverts,
-                                      GLshort *index0, GLshort *index1)
-{
-  GLshort i;
-
-  if(parent->type == GL2PS_IMAGEMAP){
-    child->type = GL2PS_IMAGEMAP;
-    child->data.image = parent->data.image;
-  }
-  else{
-    if(numverts > 4){
-      gl2psMsg(GL2PS_WARNING, "%d vertices in polygon", numverts);
-      numverts = 4;
-    }
-    switch(numverts){
-    case 1 : child->type = GL2PS_POINT; break; 
-    case 2 : child->type = GL2PS_LINE; break; 
-    case 3 : child->type = GL2PS_TRIANGLE; break; 
-    case 4 : child->type = GL2PS_QUADRANGLE; break;    
-    default: child->type = GL2PS_NO_TYPE; break;
-    }
-  }
-
-  child->boundary = 0; /* FIXME: not done! */
-  child->culled = parent->culled;
-  child->offset = parent->offset;
-  child->pattern = parent->pattern;
-  child->factor = parent->factor;
-  child->width = parent->width;
-  child->numverts = numverts;
-  child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
-
-  for(i = 0; i < numverts; i++){
-    if(index1[i] < 0){
-      child->verts[i] = parent->verts[index0[i]];
-    }
-    else{
-      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]], 
-                   plane, &child->verts[i]);
-    }
-  }
-}
-
-static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb, 
-                          GLshort i, GLshort j)
-{
-  GLint k;
-
-  for(k = 0; k < *nb; k++){
-    if((index0[k] == i && index1[k] == j) ||
-       (index1[k] == i && index0[k] == j)) return;
-  }
-  index0[*nb] = i;
-  index1[*nb] = j;
-  (*nb)++;
-}
-
-static GLshort gl2psGetIndex(GLshort i, GLshort num)
-{
-  return (i < num - 1) ? i + 1 : 0;
-}
-
-static GLint gl2psTestSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane)
-{
-  GLint type = GL2PS_COINCIDENT;
-  GLshort i, j;
-  GLfloat d[5]; 
-
-  for(i = 0; i < prim->numverts; i++){  
-    d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
-  }
-
-  if(prim->numverts < 2){
-    return 0;
-  }
-  else{
-    for(i = 0; i < prim->numverts; i++){
-      j = gl2psGetIndex(i, prim->numverts);
-      if(d[j] > GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) return 1; 
-        if(d[i] < -GL2PS_EPSILON)         return 1;
-      }
-      else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
-        else if(type != GL2PS_IN_FRONT_OF) return 1;
-        if(d[i] > GL2PS_EPSILON)           return 1;
-      }
-    }
-  }
-  return 0;
-}
-
-static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane, 
-                                 GL2PSprimitive **front, GL2PSprimitive **back)
-{
-  GLshort i, j, in = 0, out = 0, in0[5], in1[5], out0[5], out1[5];
-  GLint type;
-  GLfloat d[5]; 
-
-  type = GL2PS_COINCIDENT;
-
-  for(i = 0; i < prim->numverts; i++){  
-    d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
-  }
-
-  switch(prim->type){
-  case GL2PS_POINT :
-    if(d[0] > GL2PS_EPSILON)       type = GL2PS_IN_BACK_OF;
-    else if(d[0] < -GL2PS_EPSILON) type = GL2PS_IN_FRONT_OF;
-    else                           type = GL2PS_COINCIDENT;
-    break;
-  default :
-    for(i = 0; i < prim->numverts; i++){
-      j = gl2psGetIndex(i, prim->numverts);
-      if(d[j] > GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING; 
-        if(d[i] < -GL2PS_EPSILON){
-          gl2psAddIndex(in0, in1, &in, i, j);
-          gl2psAddIndex(out0, out1, &out, i, j);
-          type = GL2PS_SPANNING;
-        }
-        gl2psAddIndex(out0, out1, &out, j, -1);
-      }
-      else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
-        else if(type != GL2PS_IN_FRONT_OF) type = GL2PS_SPANNING;
-        if(d[i] > GL2PS_EPSILON){
-          gl2psAddIndex(in0, in1, &in, i, j);
-          gl2psAddIndex(out0, out1, &out, i, j);
-          type = GL2PS_SPANNING;
-        }
-        gl2psAddIndex(in0, in1, &in, j, -1);
-      }
-      else{
-        gl2psAddIndex(in0, in1, &in, j, -1);
-        gl2psAddIndex(out0, out1, &out, j, -1);
-      }
-    }
-    break;
-  }
-
-  if(type == GL2PS_SPANNING){
-    *back = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-    *front = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-    gl2psCreateSplitPrimitive(prim, plane, *back, out, out0, out1);
-    gl2psCreateSplitPrimitive(prim, plane, *front, in, in0, in1);
-  }
-
-  return type;
-}
-
-static void gl2psDivideQuad(GL2PSprimitive *quad, 
-                            GL2PSprimitive **t1, GL2PSprimitive **t2)
-{
-  *t1 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-  *t2 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-  (*t1)->type = (*t2)->type = GL2PS_TRIANGLE;
-  (*t1)->numverts = (*t2)->numverts = 3;
-  (*t1)->culled = (*t2)->culled = quad->culled;
-  (*t1)->offset = (*t2)->offset = quad->offset;
-  (*t1)->pattern = (*t2)->pattern = quad->pattern;
-  (*t1)->factor = (*t2)->factor = quad->factor;
-  (*t1)->width = (*t2)->width = quad->width;
-  (*t1)->verts = (GL2PSvertex*)gl2psMalloc(3 * sizeof(GL2PSvertex));
-  (*t2)->verts = (GL2PSvertex*)gl2psMalloc(3 * sizeof(GL2PSvertex));
-  (*t1)->verts[0] = quad->verts[0];
-  (*t1)->verts[1] = quad->verts[1];
-  (*t1)->verts[2] = quad->verts[2];
-  (*t1)->boundary = ((quad->boundary & 1) ? 1 : 0) | ((quad->boundary & 2) ? 2 : 0);
-  (*t2)->verts[0] = quad->verts[0];
-  (*t2)->verts[1] = quad->verts[2];
-  (*t2)->verts[2] = quad->verts[3];
-  (*t2)->boundary = ((quad->boundary & 4) ? 2 : 0) | ((quad->boundary & 4) ? 2 : 0);
-}
-
-static int gl2psCompareDepth(const void *a, const void *b)
-{
-  GL2PSprimitive *q, *w;
-  GLfloat dq = 0.0F, dw = 0.0F, diff;
-  int i;
-  
-  q = *(GL2PSprimitive**)a;
-  w = *(GL2PSprimitive**)b;
-
-  for(i = 0; i < q->numverts; i++){
-    dq += q->verts[i].xyz[2]; 
-  }
-  dq /= (GLfloat)q->numverts;
-
-  for(i = 0; i < w->numverts; i++){
-    dw += w->verts[i].xyz[2]; 
-  }
-  dw /= (GLfloat)w->numverts;
-
-  diff = dq - dw;
-  if(diff > 0.){
-    return -1;
-  }
-  else if(diff < 0.){
-    return 1;
-  }
-  else{
-    return 0;
-  }
-}
-
-static int gl2psTrianglesFirst(const void *a, const void *b)
-{
-  GL2PSprimitive *q, *w;
-
-  q = *(GL2PSprimitive**)a;
-  w = *(GL2PSprimitive**)b;
-  return(q->type < w->type ? 1 : -1);
-}
-
-static GLint gl2psFindRoot(GL2PSlist *primitives, GL2PSprimitive **root)
-{
-  GLint i, j, count, best = 1000000, index = 0;
-  GL2PSprimitive *prim1, *prim2;
-  GL2PSplane plane;
-  GLint maxp;
-
-  if(!gl2psListNbr(primitives)){
-    gl2psMsg(GL2PS_ERROR, "Cannot fint root in empty primitive list");
-    return 0;
-  }
-
-  *root = *(GL2PSprimitive**)gl2psListPointer(primitives, 0);
-
-  if(gl2ps->options & GL2PS_BEST_ROOT){
-    maxp = gl2psListNbr(primitives);
-    if(maxp > gl2ps->maxbestroot){
-      maxp = gl2ps->maxbestroot;
-    }
-    for(i = 0; i < maxp; i++){
-      prim1 = *(GL2PSprimitive**)gl2psListPointer(primitives, i);
-      gl2psGetPlane(prim1, plane);
-      count = 0;
-      for(j = 0; j < gl2psListNbr(primitives); j++){
-        if(j != i){
-          prim2 = *(GL2PSprimitive**)gl2psListPointer(primitives, j);
-          count += gl2psTestSplitPrimitive(prim2, plane); 
-        }
-        if(count > best) break;
-      }
-      if(count < best){
-        best = count;
-        index = i;
-        *root = prim1;
-        if(!count) return index;
-      }
-    }
-    /* if(index) gl2psMsg(GL2PS_INFO, "GL2PS_BEST_ROOT was worth it: %d", index); */
-    return index;
-  }
-  else{
-    return 0;
-  }
-}
-
-static void gl2psFreeImagemap(GL2PSimagemap *list){
-  GL2PSimagemap *next;
-  while(list != NULL){
-    next = list->next;
-    gl2psFree(list->image->pixels);
-    gl2psFree(list->image);
-    gl2psFree(list);
-    list = next;
-  }
-}
-
-static void gl2psFreePrimitive(void *data)
-{
-  GL2PSprimitive *q;
-  
-  q = *(GL2PSprimitive**)data;
-  gl2psFree(q->verts);
-  if(q->type == GL2PS_TEXT || q->type == GL2PS_SPECIAL){
-    gl2psFreeText(q->data.text);
-  }
-  else if(q->type == GL2PS_PIXMAP){
-    gl2psFreePixmap(q->data.image);
-  }
-  gl2psFree(q);
-}
-
-static void gl2psAddPrimitiveInList(GL2PSprimitive *prim, GL2PSlist *list)
-{
-  GL2PSprimitive *t1, *t2;
-
-  if(prim->type != GL2PS_QUADRANGLE){
-    gl2psListAdd(list, &prim);
-  }
-  else{
-    gl2psDivideQuad(prim, &t1, &t2);
-    gl2psListAdd(list, &t1);
-    gl2psListAdd(list, &t2);
-    gl2psFreePrimitive(&prim);
-  }
-  
-}
-
-static void gl2psFreeBspTree(GL2PSbsptree **tree)
-{
-  if(*tree){
-    if((*tree)->back) gl2psFreeBspTree(&(*tree)->back);
-    if((*tree)->primitives){
-      gl2psListAction((*tree)->primitives, gl2psFreePrimitive);
-      gl2psListDelete((*tree)->primitives);
-    }
-    if((*tree)->front) gl2psFreeBspTree(&(*tree)->front);
-    gl2psFree(*tree);
-    *tree = NULL;
-  }
-}
-
-static GLboolean gl2psGreater(GLfloat f1, GLfloat f2)
-{
-  if(f1 > f2) return GL_TRUE;
-  else return GL_FALSE;
-}
-
-static GLboolean gl2psLess(GLfloat f1, GLfloat f2)
-{
-  if(f1 < f2) return GL_TRUE;
-  else return GL_FALSE;
-}
-
-static void gl2psBuildBspTree(GL2PSbsptree *tree, GL2PSlist *primitives)
-{
-  GL2PSprimitive *prim, *frontprim = NULL, *backprim = NULL;
-  GL2PSlist *frontlist, *backlist;
-  GLint i, index;
-
-  tree->front = NULL;
-  tree->back = NULL;
-  tree->primitives = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
-  index = gl2psFindRoot(primitives, &prim);
-  gl2psGetPlane(prim, tree->plane);
-  gl2psAddPrimitiveInList(prim, tree->primitives);
-
-  frontlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
-  backlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
-
-  for(i = 0; i < gl2psListNbr(primitives); i++){
-    if(i != index){
-      prim = *(GL2PSprimitive**)gl2psListPointer(primitives,i);
-      switch(gl2psSplitPrimitive(prim, tree->plane, &frontprim, &backprim)){
-      case GL2PS_COINCIDENT:
-        gl2psAddPrimitiveInList(prim, tree->primitives);
-        break;
-      case GL2PS_IN_BACK_OF:
-        gl2psAddPrimitiveInList(prim, backlist);
-        break;
-      case GL2PS_IN_FRONT_OF:
-        gl2psAddPrimitiveInList(prim, frontlist);
-        break;
-      case GL2PS_SPANNING:
-        gl2psAddPrimitiveInList(backprim, backlist);
-        gl2psAddPrimitiveInList(frontprim, frontlist);
-        gl2psFreePrimitive(&prim);
-        break;
-      }
-    }
-  }
-
-  if(gl2psListNbr(tree->primitives)){
-    gl2psListSort(tree->primitives, gl2psTrianglesFirst);
-  }
-
-  if(gl2psListNbr(frontlist)){
-    gl2psListSort(frontlist, gl2psTrianglesFirst);
-    tree->front = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
-    gl2psBuildBspTree(tree->front, frontlist);
-  }
-  else{
-    gl2psListDelete(frontlist);
-  }
-
-  if(gl2psListNbr(backlist)){
-    gl2psListSort(backlist, gl2psTrianglesFirst);
-    tree->back = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
-    gl2psBuildBspTree(tree->back, backlist);
-  }
-  else{
-    gl2psListDelete(backlist);
-  }
-
-  gl2psListDelete(primitives);
-}
-
-static void gl2psTraverseBspTree(GL2PSbsptree *tree, GL2PSxyz eye, GLfloat epsilon,
-                                 GLboolean (*compare)(GLfloat f1, GLfloat f2),
-                                 void (*action)(void *data), int inverse)
-{
-  GLfloat result;
-
-  if(!tree) return;
-
-  result = gl2psComparePointPlane(eye, tree->plane);
-
-  if(GL_TRUE == compare(result, epsilon)){
-    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
-    if(inverse){
-      gl2psListActionInverse(tree->primitives, action);
-    }
-    else{
-      gl2psListAction(tree->primitives, action);
-    }
-    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
-  }
-  else if(GL_TRUE == compare(-epsilon, result)){ 
-    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
-    if(inverse){
-      gl2psListActionInverse(tree->primitives, action);
-    }
-    else{
-      gl2psListAction(tree->primitives, action);
-    }
-    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
-  }
-  else{
-    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
-    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
-  }
-}
-
-static void gl2psRescaleAndOffset()
-{
-  GL2PSprimitive *prim;
-  GLfloat minZ, maxZ, rangeZ, scaleZ;
-  GLfloat factor, units, area, dZ, dZdX, dZdY, maxdZ;
-  int i, j;
-
-  if(!gl2psListNbr(gl2ps->primitives))
-    return;
-
-  /* get z-buffer range */
-  prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, 0);
-  minZ = maxZ = prim->verts[0].xyz[2];
-  for(i = 1; i < prim->numverts; i++){
-    if(prim->verts[i].xyz[2] < minZ) minZ = prim->verts[i].xyz[2];
-    if(prim->verts[i].xyz[2] > maxZ) maxZ = prim->verts[i].xyz[2];
-  }
-  for(i = 1; i < gl2psListNbr(gl2ps->primitives); i++){
-    prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, i);
-    for(j = 0; j < prim->numverts; j++){
-      if(prim->verts[j].xyz[2] < minZ) minZ = prim->verts[j].xyz[2];
-      if(prim->verts[j].xyz[2] > maxZ) maxZ = prim->verts[j].xyz[2];
-    }
-  }
-  rangeZ = (maxZ - minZ);
-
-  /* rescale z-buffer coordinate in [0,GL2PS_ZSCALE], to make it of
-     the same order of magnitude as the x and y coordinates */
-  scaleZ = GL2PS_ZERO(rangeZ) ? GL2PS_ZSCALE : (GL2PS_ZSCALE / rangeZ);
-  /* avoid precision loss (we use floats!) */
-  if(scaleZ > 100000.F) scaleZ = 100000.F;
-
-  /* apply offsets */
-  for(i = 0; i < gl2psListNbr(gl2ps->primitives); i++){
-    prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, i);
-    for(j = 0; j < prim->numverts; j++){
-      prim->verts[j].xyz[2] = (prim->verts[j].xyz[2] - minZ) * scaleZ;
-    }
-    if((gl2ps->options & GL2PS_SIMPLE_LINE_OFFSET) &&
-       (prim->type == GL2PS_LINE)){
-      if(gl2ps->sort == GL2PS_SIMPLE_SORT){
-        prim->verts[0].xyz[2] -= GL2PS_ZOFFSET_LARGE;
-        prim->verts[1].xyz[2] -= GL2PS_ZOFFSET_LARGE;
-      }
-      else{
-        prim->verts[0].xyz[2] -= GL2PS_ZOFFSET;
-        prim->verts[1].xyz[2] -= GL2PS_ZOFFSET;
-      }
-    }
-    else if(prim->offset && (prim->type == GL2PS_TRIANGLE)){
-      factor = gl2ps->offset[0];
-      units = gl2ps->offset[1];
-      area = 
-        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) * 
-        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) - 
-        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) * 
-        (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]);
-      if(!GL2PS_ZERO(area)){
-        dZdX = 
-          ((prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) *
-           (prim->verts[1].xyz[2] - prim->verts[0].xyz[2]) -
-           (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]) *
-           (prim->verts[2].xyz[2] - prim->verts[1].xyz[2])) / area;
-        dZdY = 
-          ((prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
-           (prim->verts[2].xyz[2] - prim->verts[1].xyz[2]) -
-           (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
-           (prim->verts[1].xyz[2] - prim->verts[0].xyz[2])) / area;
-        maxdZ = (GLfloat)sqrt(dZdX * dZdX + dZdY * dZdY);
-      }
-      else{
-        maxdZ = 0.0F;
-      }
-      dZ = factor * maxdZ + units;
-      prim->verts[0].xyz[2] += dZ;
-      prim->verts[1].xyz[2] += dZ;
-      prim->verts[2].xyz[2] += dZ;
-    }
-  }
-}
-
-/********************************************************************* 
- *
- * 2D sorting routines (for occlusion culling) 
- *
- *********************************************************************/
-
-static GLint gl2psGetPlaneFromPoints(GL2PSxyz a, GL2PSxyz b, GL2PSplane plane)
-{
-  GLfloat n; 
-
-  plane[0] = b[1] - a[1];
-  plane[1] = a[0] - b[0];
-  n = (GLfloat)sqrt(plane[0]*plane[0] + plane[1]*plane[1]);
-  plane[2] = 0.0F;
-  if(!GL2PS_ZERO(n)){
-    plane[0] /= n;
-    plane[1] /= n;
-    plane[3] = -plane[0]*a[0]-plane[1]*a[1]; 
-    return 1;
-  }
-  else{
-    plane[0] = -1.0F;
-    plane[1] = 0.0F;
-    plane[3] = a[0];
-    return 0;
-  }
-}
-
-static void gl2psFreeBspImageTree(GL2PSbsptree2d **tree)
-{
-  if(*tree){
-    if((*tree)->back)  gl2psFreeBspImageTree(&(*tree)->back);
-    if((*tree)->front) gl2psFreeBspImageTree(&(*tree)->front);
-    gl2psFree(*tree);
-    *tree = NULL;
-  }
-}
-
-static GLint gl2psCheckPoint(GL2PSxyz point, GL2PSplane plane)
-{
-  GLfloat pt_dis;
-
-  pt_dis = gl2psComparePointPlane(point, plane);
-  if(pt_dis > GL2PS_EPSILON)        return GL2PS_POINT_INFRONT;
-  else if(pt_dis < -GL2PS_EPSILON)  return GL2PS_POINT_BACK;
-  else                              return GL2PS_POINT_COINCIDENT;
-}
-
-static void gl2psAddPlanesInBspTreeImage(GL2PSprimitive *prim,
-                                         GL2PSbsptree2d **tree)
-{
-  GLint ret = 0;
-  GLint i;
-  GLint offset = 0;
-  GL2PSbsptree2d *head = NULL, *cur = NULL;
-
-  if((*tree == NULL) && (prim->numverts > 2)){
-    /* don't cull if transparent
-    for(i = 0; i < prim->numverts - 1; i++)
-      if(prim->verts[i].rgba[3] < 1.0F) return;
-    */
-    head = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
-    for(i = 0; i < prim->numverts-1; i++){
-      if(!gl2psGetPlaneFromPoints(prim->verts[i].xyz,
-                                  prim->verts[i+1].xyz,
-                                  head->plane)){
-        if(prim->numverts-i > 3){
-          offset++;
-        }
-        else{
-          gl2psFree(head);
-          return;
-        }
-      }
-      else{
-        break;
-      }
-    }
-    head->back = NULL;
-    head->front = NULL;
-    for(i = 2+offset; i < prim->numverts; i++){
-      ret = gl2psCheckPoint(prim->verts[i].xyz, head->plane);
-      if(ret != GL2PS_POINT_COINCIDENT) break;
-    }
-    switch(ret){
-    case GL2PS_POINT_INFRONT :
-      cur = head;
-      for(i = 1+offset; i < prim->numverts-1; i++){
-        if(cur->front == NULL){
-          cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
-        }
-        if(gl2psGetPlaneFromPoints(prim->verts[i].xyz,
-                                   prim->verts[i+1].xyz,
-                                   cur->front->plane)){
-          cur = cur->front;
-          cur->front = NULL;
-          cur->back = NULL;
-        }
-      }
-      if(cur->front == NULL){
-        cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
-      }
-      if(gl2psGetPlaneFromPoints(prim->verts[i].xyz,
-                                 prim->verts[offset].xyz,
-                                 cur->front->plane)){
-        cur->front->front = NULL;
-        cur->front->back = NULL;
-      }
-      else{
-        gl2psFree(cur->front);
-        cur->front = NULL;
-      }
-      break;
-    case GL2PS_POINT_BACK :
-      for(i = 0; i < 4; i++){
-        head->plane[i] = -head->plane[i];
-      }
-      cur = head;
-      for(i = 1+offset; i < prim->numverts-1; i++){
-        if(cur->front == NULL){
-          cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
-        }
-        if(gl2psGetPlaneFromPoints(prim->verts[i+1].xyz,
-                                   prim->verts[i].xyz,
-                                   cur->front->plane)){
-          cur = cur->front;
-          cur->front = NULL;
-          cur->back = NULL;
-        }
-      }
-      if(cur->front == NULL){
-        cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
-      }
-      if(gl2psGetPlaneFromPoints(prim->verts[offset].xyz,
-                                 prim->verts[i].xyz,
-                                 cur->front->plane)){
-        cur->front->front = NULL;
-        cur->front->back = NULL;
-      }
-      else{
-        gl2psFree(cur->front);
-        cur->front = NULL;
-      }
-      break;
-    default:
-      gl2psFree(head);
-      return;
-    }
-    (*tree) = head;
-  }
-}
-
-static GLint gl2psCheckPrimitive(GL2PSprimitive *prim, GL2PSplane plane)
-{
-  GLint i;
-  GLint pos;
-
-  pos = gl2psCheckPoint(prim->verts[0].xyz, plane);
-  for(i = 1; i < prim->numverts; i++){
-    pos |= gl2psCheckPoint(prim->verts[i].xyz, plane);
-    if(pos == (GL2PS_POINT_INFRONT | GL2PS_POINT_BACK)) return GL2PS_SPANNING;
-  }
-  if(pos & GL2PS_POINT_INFRONT)   return GL2PS_IN_FRONT_OF;
-  else if(pos & GL2PS_POINT_BACK) return GL2PS_IN_BACK_OF;
-  else                            return GL2PS_COINCIDENT;
-}
-
-static GL2PSprimitive *gl2psCreateSplitPrimitive2D(GL2PSprimitive *parent,
-                                                   GLshort numverts,
-                                                   GL2PSvertex *vertx)
-{
-  GLint i;
-  GL2PSprimitive *child = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-
-  if(parent->type == GL2PS_IMAGEMAP){
-    child->type = GL2PS_IMAGEMAP;
-    child->data.image = parent->data.image;
-  }
-  else {
-    switch(numverts){
-    case 1 : child->type = GL2PS_POINT; break;
-    case 2 : child->type = GL2PS_LINE; break;
-    case 3 : child->type = GL2PS_TRIANGLE; break;
-    case 4 : child->type = GL2PS_QUADRANGLE; break;
-    default: child->type = GL2PS_NO_TYPE; break; /* FIXME */
-    }
-  }
-  child->boundary = 0; /* FIXME: not done! */
-  child->culled = parent->culled;
-  child->offset = parent->offset;
-  child->pattern = parent->pattern;
-  child->factor = parent->factor;
-  child->width = parent->width;
-  child->numverts = numverts;
-  child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
-  for(i = 0; i < numverts; i++){
-    child->verts[i] = vertx[i];
-  }
-  return child;
-}
-
-static void gl2psSplitPrimitive2D(GL2PSprimitive *prim,
-                                  GL2PSplane plane, 
-                                  GL2PSprimitive **front, 
-                                  GL2PSprimitive **back)
-{
-  /* cur will hold the position of the current vertex
-     prev will hold the position of the previous vertex
-     prev0 will hold the position of the vertex number 0
-     v1 and v2 represent the current and previous vertices, respectively
-     flag is set if the current vertex should be checked against the plane */
-  GLint cur = -1, prev = -1, i, v1 = 0, v2 = 0, flag = 1, prev0 = -1;
-  
-  /* list of vertices that will go in front and back primitive */
-  GL2PSvertex *front_list = NULL, *back_list = NULL;
-  
-  /* number of vertices in front and back list */
-  GLshort front_count = 0, back_count = 0;
-
-  for(i = 0; i <= prim->numverts; i++){
-    v1 = i;
-    if(v1 == prim->numverts){
-      if(prim->numverts < 3) break;
-      v1 = 0;
-      v2 = prim->numverts - 1;
-      cur = prev0;
-    }
-    else if(flag){
-      cur = gl2psCheckPoint(prim->verts[v1].xyz, plane);
-      if(i == 0){
-        prev0 = cur;
-      }
-    } 
-    if(((prev == -1) || (prev == cur) || (prev == 0) || (cur == 0)) &&
-       (i < prim->numverts)){
-      if(cur == GL2PS_POINT_INFRONT){
-        front_count++;
-        front_list = (GL2PSvertex*)gl2psRealloc(front_list,
-                                                sizeof(GL2PSvertex)*front_count);
-        front_list[front_count-1] = prim->verts[v1];
-      }
-      else if(cur == GL2PS_POINT_BACK){
-        back_count++;
-        back_list = (GL2PSvertex*)gl2psRealloc(back_list,
-                                               sizeof(GL2PSvertex)*back_count);
-        back_list[back_count-1] = prim->verts[v1];
-      }
-      else{
-        front_count++;
-        front_list = (GL2PSvertex*)gl2psRealloc(front_list,
-                                                sizeof(GL2PSvertex)*front_count);
-        front_list[front_count-1] = prim->verts[v1];
-        back_count++;
-        back_list = (GL2PSvertex*)gl2psRealloc(back_list,
-                                               sizeof(GL2PSvertex)*back_count);
-        back_list[back_count-1] = prim->verts[v1];
-      }
-      flag = 1;
-    }
-    else if((prev != cur) && (cur != 0) && (prev != 0)){
-      if(v1 != 0){
-        v2 = v1-1;
-        i--;
-      }
-      front_count++;
-      front_list = (GL2PSvertex*)gl2psRealloc(front_list,
-                                              sizeof(GL2PSvertex)*front_count);
-      gl2psCutEdge(&prim->verts[v2], &prim->verts[v1],
-                   plane, &front_list[front_count-1]);
-      back_count++;
-      back_list = (GL2PSvertex*)gl2psRealloc(back_list,
-                                             sizeof(GL2PSvertex)*back_count);
-      back_list[back_count-1] = front_list[front_count-1];
-      flag = 0;
-    }
-    prev = cur;
-  }
-  *front = gl2psCreateSplitPrimitive2D(prim, front_count, front_list);
-  *back = gl2psCreateSplitPrimitive2D(prim, back_count, back_list);
-  gl2psFree(front_list);
-  gl2psFree(back_list);
-}
-
-static GLint gl2psAddInBspImageTree(GL2PSprimitive *prim, GL2PSbsptree2d **tree)
-{
-  GLint ret = 0;
-  GL2PSprimitive *frontprim = NULL, *backprim = NULL;
-  
-  /* FIXME: until we consider the actual extent of text strings and
-     pixmaps, never cull them. Otherwise the whole string/pixmap gets
-     culled as soon as the reference point is hidden */
-  if(prim->type == GL2PS_PIXMAP || 
-     prim->type == GL2PS_TEXT || 
-     prim->type == GL2PS_SPECIAL){
-    return 1;
-  }
-
-  if(*tree == NULL){
-    if((prim->type != GL2PS_IMAGEMAP) && (GL_FALSE == gl2ps->zerosurfacearea)){
-      gl2psAddPlanesInBspTreeImage(gl2ps->primitivetoadd, tree);
-    }
-    return 1;
-  }
-  else{
-    switch(gl2psCheckPrimitive(prim, (*tree)->plane)){
-    case GL2PS_IN_BACK_OF: return gl2psAddInBspImageTree(prim, &(*tree)->back);
-    case GL2PS_IN_FRONT_OF: 
-      if((*tree)->front != NULL) return gl2psAddInBspImageTree(prim, &(*tree)->front);
-      else                       return 0;
-    case GL2PS_SPANNING:
-      gl2psSplitPrimitive2D(prim, (*tree)->plane, &frontprim, &backprim);
-      ret = gl2psAddInBspImageTree(backprim, &(*tree)->back);
-      if((*tree)->front != NULL){
-        if(gl2psAddInBspImageTree(frontprim, &(*tree)->front)){
-          ret = 1;
-        }
-      }
-      gl2psFree(frontprim->verts);
-      gl2psFree(frontprim);
-      gl2psFree(backprim->verts);
-      gl2psFree(backprim);
-      return ret;
-    case GL2PS_COINCIDENT:
-      if((*tree)->back != NULL){
-        gl2ps->zerosurfacearea = GL_TRUE;
-        ret = gl2psAddInBspImageTree(prim, &(*tree)->back);
-        gl2ps->zerosurfacearea = GL_FALSE;
-        if(ret) return ret;
-      }
-      if((*tree)->front != NULL){
-        gl2ps->zerosurfacearea = GL_TRUE;
-        ret = gl2psAddInBspImageTree(prim, &(*tree)->front);
-        gl2ps->zerosurfacearea = GL_FALSE;
-        if(ret) return ret;
-      }
-      if(prim->type == GL2PS_LINE) return 1;
-      else                         return 0;
-    }
-  }
-  return 0;
-}
-
-static void gl2psAddInImageTree(void *data)
-{
-  GL2PSprimitive *prim = *(GL2PSprimitive **)data;
-  gl2ps->primitivetoadd = prim;
-  if(prim->type == GL2PS_IMAGEMAP && prim->data.image->format == GL2PS_IMAGEMAP_VISIBLE){
-    prim->culled = 1;
-  }
-  else if(!gl2psAddInBspImageTree(prim, &gl2ps->imagetree)){
-    prim->culled = 1;
-  }
-  else if(prim->type == GL2PS_IMAGEMAP){
-    prim->data.image->format = GL2PS_IMAGEMAP_VISIBLE;
-  }
-}
-
-/* Boundary construction */
-
-static void gl2psAddBoundaryInList(GL2PSprimitive *prim, GL2PSlist *list)
-{
-  GL2PSprimitive *b;
-  GLshort i;
-  GL2PSxyz c;
-
-  c[0] = c[1] = c[2] = 0.0F;
-  for(i = 0; i < prim->numverts; i++){
-    c[0] += prim->verts[i].xyz[0];
-    c[1] += prim->verts[i].xyz[1];
-  }
-  c[0] /= prim->numverts;
-  c[1] /= prim->numverts;
-
-  for(i = 0; i < prim->numverts; i++){
-    if(prim->boundary & (GLint)pow(2., i)){
-      b = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-      b->type = GL2PS_LINE;
-      b->offset = prim->offset;
-      b->pattern = prim->pattern;
-      b->factor = prim->factor;
-      b->culled = prim->culled;
-      b->width = prim->width;
-      b->boundary = 0;
-      b->numverts = 2;
-      b->verts = (GL2PSvertex*)gl2psMalloc(2 * sizeof(GL2PSvertex));
-
-#if 0 /* FIXME: need to work on boundary offset... */
-      v[0] = c[0] - prim->verts[i].xyz[0];
-      v[1] = c[1] - prim->verts[i].xyz[1];
-      v[2] = 0.0F;
-      norm = gl2psNorm(v);
-      v[0] /= norm;
-      v[1] /= norm;
-      b->verts[0].xyz[0] = prim->verts[i].xyz[0] +0.1*v[0];
-      b->verts[0].xyz[1] = prim->verts[i].xyz[1] +0.1*v[1];
-      b->verts[0].xyz[2] = prim->verts[i].xyz[2];
-      v[0] = c[0] - prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[0];
-      v[1] = c[1] - prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[1];
-      norm = gl2psNorm(v);
-      v[0] /= norm;
-      v[1] /= norm;
-      b->verts[1].xyz[0] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[0] +0.1*v[0];
-      b->verts[1].xyz[1] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[1] +0.1*v[1];
-      b->verts[1].xyz[2] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[2];
-#else
-      b->verts[0].xyz[0] = prim->verts[i].xyz[0];
-      b->verts[0].xyz[1] = prim->verts[i].xyz[1];
-      b->verts[0].xyz[2] = prim->verts[i].xyz[2];
-      b->verts[1].xyz[0] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[0];
-      b->verts[1].xyz[1] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[1];
-      b->verts[1].xyz[2] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[2];
-#endif
-
-      b->verts[0].rgba[0] = 0.0F;
-      b->verts[0].rgba[1] = 0.0F;
-      b->verts[0].rgba[2] = 0.0F;
-      b->verts[0].rgba[3] = 0.0F;
-      b->verts[1].rgba[0] = 0.0F;
-      b->verts[1].rgba[1] = 0.0F;
-      b->verts[1].rgba[2] = 0.0F;
-      b->verts[1].rgba[3] = 0.0F;
-      gl2psListAdd(list, &b);
-    }
-  }
-
-}
-
-static void gl2psBuildPolygonBoundary(GL2PSbsptree *tree)
-{
-  GLint i;
-  GL2PSprimitive *prim;
-
-  if(!tree) return;
-  gl2psBuildPolygonBoundary(tree->back);
-  for(i = 0; i < gl2psListNbr(tree->primitives); i++){
-    prim = *(GL2PSprimitive**)gl2psListPointer(tree->primitives, i);
-    if(prim->boundary) gl2psAddBoundaryInList(prim, tree->primitives);
-  }
-  gl2psBuildPolygonBoundary(tree->front);
-}
-
-/********************************************************************* 
- *
- * Feedback buffer parser
- *
- *********************************************************************/
-
-static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts, 
-                                  GL2PSvertex *verts, GLint offset, 
-                                  GLushort pattern, GLint factor,
-                                  GLfloat width, char boundary)
-{
-  GL2PSprimitive *prim;
-
-  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-  prim->type = type;
-  prim->numverts = numverts;
-  prim->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
-  memcpy(prim->verts, verts, numverts * sizeof(GL2PSvertex));
-  prim->boundary = boundary;
-  prim->offset = offset;
-  prim->pattern = pattern;
-  prim->factor = factor;
-  prim->width = width;
-  prim->culled = 0;
-
-  /* FIXME: here we should have an option to split stretched
-     tris/quads to enhance SIMPLE_SORT */
-
-  gl2psListAdd(gl2ps->primitives, &prim);
-}
-
-static GLint gl2psGetVertex(GL2PSvertex *v, GLfloat *p)
-{
-  GLint i;
-
-  v->xyz[0] = p[0];
-  v->xyz[1] = p[1];
-  v->xyz[2] = p[2];
-
-  if(gl2ps->colormode == GL_COLOR_INDEX && gl2ps->colorsize > 0){
-    i = (GLint)(p[3] + 0.5);
-    v->rgba[0] = gl2ps->colormap[i][0];
-    v->rgba[1] = gl2ps->colormap[i][1];
-    v->rgba[2] = gl2ps->colormap[i][2];
-    v->rgba[3] = gl2ps->colormap[i][3];
-    return 4;
-  }
-  else{
-    v->rgba[0] = p[3];
-    v->rgba[1] = p[4];
-    v->rgba[2] = p[5];
-    v->rgba[3] = p[6];
-    return 7;
-  }
-}
-
-static void gl2psParseFeedbackBuffer(GLint used)
-{
-  char flag;
-  GLushort pattern = 0;
-  GLboolean boundary;
-  GLint i, sizeoffloat, count, v, vtot, offset = 0, factor = 0, auxindex = 0;
-  GLfloat lwidth = 1.0F, psize = 1.0F;
-  GLfloat *current;
-  GL2PSvertex vertices[3];
-  GL2PSprimitive *prim;
-  GL2PSimagemap *node;
-
-  current = gl2ps->feedback;
-  boundary = gl2ps->boundary = GL_FALSE;
-
-  while(used > 0){
-
-    if(GL_TRUE == boundary) gl2ps->boundary = GL_TRUE;
-    
-    switch((GLint)*current){
-    case GL_POINT_TOKEN :
-      current ++;
-      used --;
-      i = gl2psGetVertex(&vertices[0], current);
-      current += i;
-      used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0, 
-                            pattern, factor, psize, 0);
-      break;
-    case GL_LINE_TOKEN :
-    case GL_LINE_RESET_TOKEN :
-      current ++;
-      used --;
-      i = gl2psGetVertex(&vertices[0], current);
-      current += i;
-      used    -= i;
-      i = gl2psGetVertex(&vertices[1], current);
-      current += i;
-      used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0, 
-                            pattern, factor, lwidth, 0);
-      break;
-    case GL_POLYGON_TOKEN :
-      count = (GLint)current[1];
-      current += 2;
-      used -= 2;
-      v = vtot = 0;
-      while(count > 0 && used > 0){
-        i = gl2psGetVertex(&vertices[v], current);
-        gl2psAdaptVertexForBlending(&vertices[v]);
-        current += i;
-        used    -= i;
-        count --;
-        vtot++;
-        if(v == 2){
-          if(GL_TRUE == boundary){
-            if(!count && vtot == 2) flag = 1|2|4;
-            else if(!count) flag = 2|4;
-            else if(vtot == 2) flag = 1|2;
-            else flag = 2;
-          }
-          else
-            flag = 0;
-          gl2psAddPolyPrimitive(GL2PS_TRIANGLE, 3, vertices, offset,
-                                pattern, factor, 1, flag);
-          vertices[1] = vertices[2];
-        }
-        else
-          v ++;
-      }
-      break;      
-    case GL_BITMAP_TOKEN :
-    case GL_DRAW_PIXEL_TOKEN :
-    case GL_COPY_PIXEL_TOKEN :
-      current ++;
-      used --;
-      i = gl2psGetVertex(&vertices[0], current);
-      current += i;
-      used    -= i;
-      break;      
-    case GL_PASS_THROUGH_TOKEN :
-      switch((GLint)current[1]){
-      case GL2PS_BEGIN_OFFSET_TOKEN : offset = 1; break;
-      case GL2PS_END_OFFSET_TOKEN : offset = 0; break;
-      case GL2PS_BEGIN_BOUNDARY_TOKEN : boundary = GL_TRUE; break;
-      case GL2PS_END_BOUNDARY_TOKEN : boundary = GL_FALSE; break;
-      case GL2PS_END_STIPPLE_TOKEN : pattern = factor = 0; break;
-      case GL2PS_BEGIN_BLEND_TOKEN : gl2ps->blending = GL_TRUE; break;
-      case GL2PS_END_BLEND_TOKEN : gl2ps->blending = GL_FALSE; break;
-      case GL2PS_BEGIN_STIPPLE_TOKEN : 
-        current += 2;
-        used -= 2; 
-        pattern = (GLushort)current[1]; 
-        current += 2;
-        used -= 2; 
-        factor = (GLint)current[1]; 
-        break;
-      case GL2PS_SRC_BLEND_TOKEN : 
-        current += 2; 
-        used -= 2; 
-        gl2ps->blendfunc[0] = (GLint)current[1];
-        break;
-      case GL2PS_DST_BLEND_TOKEN : 
-        current += 2; 
-        used -= 2; 
-        gl2ps->blendfunc[1] = (GLint)current[1];
-        break;
-      case GL2PS_POINT_SIZE_TOKEN : 
-        current += 2; 
-        used -= 2; 
-        psize = current[1];
-        break;
-      case GL2PS_LINE_WIDTH_TOKEN : 
-        current += 2; 
-        used -= 2; 
-        lwidth = current[1];
-        break;
-      case GL2PS_IMAGEMAP_TOKEN :
-        prim = (GL2PSprimitive *)gl2psMalloc(sizeof(GL2PSprimitive));
-        prim->type = GL2PS_IMAGEMAP;
-        prim->boundary = 0;
-        prim->numverts = 4;
-        prim->verts = (GL2PSvertex *)gl2psMalloc(4 * sizeof(GL2PSvertex));
-        prim->culled = 0;
-        prim->offset = 0;
-        prim->pattern = 0;
-        prim->factor = 0;
-        prim->width = 1;
-        
-        node = (GL2PSimagemap*)gl2psMalloc(sizeof(GL2PSimagemap));
-        node->image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
-        node->image->type = 0;
-        node->image->format = 0;
-        node->next = NULL;
-        
-        if(gl2ps->imagemap_head == NULL)
-          gl2ps->imagemap_head = node;
-        else
-          gl2ps->imagemap_tail->next = node;
-        gl2ps->imagemap_tail = node;
-        prim->data.image = node->image;
-        
-        current += 2; used -= 2;
-        i = gl2psGetVertex(&prim->verts[0], &current[1]);
-        current += i; used -= i;
-        
-        node->image->width = (GLint)current[2];
-        current += 2; used -= 2;
-        node->image->height = (GLint)current[2];
-        prim->verts[0].xyz[0] = prim->verts[0].xyz[0] - (int)(node->image->width / 2) + 0.5;
-        prim->verts[0].xyz[1] = prim->verts[0].xyz[1] - (int)(node->image->height / 2) + 0.5;
-        for(i = 1; i < 4; i++){
-          for(v = 0; v < 3; v++){
-            prim->verts[i].xyz[v] = prim->verts[0].xyz[v];
-            prim->verts[i].rgba[v] = prim->verts[0].rgba[v];
-          }
-          prim->verts[i].rgba[v] = prim->verts[0].rgba[v];
-        }
-        prim->verts[1].xyz[0] = prim->verts[1].xyz[0] + node->image->width;
-        prim->verts[2].xyz[0] = prim->verts[1].xyz[0];
-        prim->verts[2].xyz[1] = prim->verts[2].xyz[1] + node->image->height;
-        prim->verts[3].xyz[1] = prim->verts[2].xyz[1];
-
-        sizeoffloat = sizeof(GLfloat);
-        v = 2 * sizeoffloat;
-        vtot = node->image->height + node->image->height * 
-          ((node->image->width - 1) / 8);
-        node->image->pixels = (GLfloat*)gl2psMalloc(v + vtot);
-        node->image->pixels[0] = prim->verts[0].xyz[0];
-        node->image->pixels[1] = prim->verts[0].xyz[1];
-        
-        for(i = 0; i < vtot; i += sizeoffloat){
-          current += 2; used -= 2;
-          if((vtot - i) >= 4)
-            memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), sizeoffloat);
-          else
-            memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), vtot - i);
-        }
-        current++; used--;
-        gl2psListAdd(gl2ps->primitives, &prim);
-        break;
-      case GL2PS_DRAW_PIXELS_TOKEN :
-      case GL2PS_TEXT_TOKEN :
-        if(auxindex < gl2psListNbr(gl2ps->auxprimitives))
-          gl2psListAdd(gl2ps->primitives, 
-                       gl2psListPointer(gl2ps->auxprimitives, auxindex++));
-        else
-          gl2psMsg(GL2PS_ERROR, "Wrong number of auxiliary tokens in buffer");
-        break;
-      }
-      current += 2; 
-      used -= 2; 
-      break;      
-    default :
-      gl2psMsg(GL2PS_WARNING, "Unknown token in buffer");
-      current ++;
-      used --;
-      break;
-    }
-  }
-
-  gl2psListReset(gl2ps->auxprimitives);
-}
-
-/********************************************************************* 
- *
- * PostScript routines
- *
- *********************************************************************/
-
-static void gl2psWriteByte(unsigned char byte)
-{
-  unsigned char h = byte / 16;
-  unsigned char l = byte % 16;
-  gl2psPrintf("%x%x", h, l);
-}
-
-static void gl2psPrintPostScriptPixmap(GLfloat x, GLfloat y, GL2PSimage *im)
-{
-  GLuint nbhex, nbyte, nrgb, nbits;
-  GLuint row, col, ibyte, icase;
-  GLfloat dr, dg, db, fgrey;
-  unsigned char red = 0, green = 0, blue = 0, b, grey;
-  GLuint width = (GLuint)im->width;
-  GLuint height = (GLuint)im->height;
-
-  /* FIXME: should we define an option for these? Or just keep the
-     8-bit per component case? */
-  int greyscale = 0; /* set to 1 to output greyscale image */
-  int nbit = 8; /* number of bits per color compoment (2, 4 or 8) */
-
-  if((width <= 0) || (height <= 0)) return;
-
-  gl2psPrintf("gsave\n");
-  gl2psPrintf("%.2f %.2f translate\n", x, y); 
-  gl2psPrintf("%d %d scale\n", width, height); 
-
-  if(greyscale){ /* greyscale */
-    gl2psPrintf("/picstr %d string def\n", width); 
-    gl2psPrintf("%d %d %d\n", width, height, 8); 
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
-    gl2psPrintf("{ currentfile picstr readhexstring pop }\n");
-    gl2psPrintf("image\n");
-    for(row = 0; row < height; row++){
-      for(col = 0; col < width; col++){ 
-        gl2psGetRGB(im, col, row, &dr, &dg, &db);
-        fgrey = (0.30 * dr + 0.59 * dg + 0.11 * db);
-        grey = (unsigned char)(255. * fgrey);
-        gl2psWriteByte(grey);
-      }
-      gl2psPrintf("\n");
-    }
-    nbhex = width * height * 2; 
-    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex); 
-  }
-  else if(nbit == 2){ /* color, 2 bits for r and g and b; rgbs following each other */
-    nrgb = width  * 3;
-    nbits = nrgb * nbit;
-    nbyte = nbits / 8;
-    if((nbyte * 8) != nbits) nbyte++;
-    gl2psPrintf("/rgbstr %d string def\n", nbyte);
-    gl2psPrintf("%d %d %d\n", width, height, nbit);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
-    gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
-    gl2psPrintf("false 3\n");
-    gl2psPrintf("colorimage\n");
-    for(row = 0; row < height; row++){
-      icase = 1;
-      col = 0;
-      b = 0;
-      for(ibyte = 0; ibyte < nbyte; ibyte++){
-        if(icase == 1) {
-          if(col < width) {
-            gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
-          else {
-            dr = dg = db = 0;
-          }
-          col++;
-          red = (unsigned char)(3. * dr);
-          green = (unsigned char)(3. * dg);
-          blue = (unsigned char)(3. * db);
-          b = red;
-          b = (b<<2) + green;
-          b = (b<<2) + blue;
-          if(col < width) {
-            gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
-          else {
-            dr = dg = db = 0;
-          }
-          col++;
-          red = (unsigned char)(3. * dr);
-          green = (unsigned char)(3. * dg);
-          blue = (unsigned char)(3. * db);
-          b = (b<<2) + red;
-          gl2psWriteByte(b);
-          b = 0;
-          icase++;
-        } 
-        else if(icase == 2) {
-          b = green;
-          b = (b<<2) + blue;
-          if(col < width) {
-            gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
-          else {
-            dr = dg = db = 0;
-          }
-          col++;
-          red = (unsigned char)(3. * dr);
-          green = (unsigned char)(3. * dg);
-          blue = (unsigned char)(3. * db);
-          b = (b<<2) + red;
-          b = (b<<2) + green;
-          gl2psWriteByte(b);
-          b = 0;
-          icase++;
-        } 
-        else if(icase == 3) {
-          b = blue;
-          if(col < width) {
-            gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
-          else {
-            dr = dg = db = 0;
-          }
-          col++;
-          red = (unsigned char)(3. * dr);
-          green = (unsigned char)(3. * dg);
-          blue = (unsigned char)(3. * db);
-          b = (b<<2) + red;
-          b = (b<<2) + green;
-          b = (b<<2) + blue;
-          gl2psWriteByte(b);
-          b = 0;
-          icase = 1;
-        }
-      }
-      gl2psPrintf("\n");
-    }
-  }
-  else if(nbit == 4){ /* color, 4 bits for r and g and b; rgbs following each other */
-    nrgb = width  * 3;
-    nbits = nrgb * nbit;
-    nbyte = nbits / 8;
-    if((nbyte * 8) != nbits) nbyte++; 
-    gl2psPrintf("/rgbstr %d string def\n", nbyte);
-    gl2psPrintf("%d %d %d\n", width, height, nbit);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
-    gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
-    gl2psPrintf("false 3\n");
-    gl2psPrintf("colorimage\n");
-    for(row = 0; row < height; row++){
-      col = 0;
-      icase = 1;
-      for(ibyte = 0; ibyte < nbyte; ibyte++){
-        if(icase == 1) {
-          if(col < width) {
-            gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
-          else {
-            dr = dg = db = 0;
-          }
-          col++;
-          red = (unsigned char)(15. * dr);
-          green = (unsigned char)(15. * dg);
-          gl2psPrintf("%x%x", red, green);
-          icase++;
-        } 
-        else if(icase == 2) {
-          blue = (unsigned char)(15. * db);
-          if(col < width) {
-            gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
-          else {
-            dr = dg = db = 0;
-          }
-          col++;
-          red = (unsigned char)(15. * dr);
-          gl2psPrintf("%x%x", blue, red);
-          icase++;
-        }
-        else if(icase == 3) {
-          green = (unsigned char)(15. * dg);
-          blue = (unsigned char)(15. * db);
-          gl2psPrintf("%x%x", green, blue);
-          icase = 1;
-        }
-      }
-      gl2psPrintf("\n");
-    }
-  }
-  else{ /* 8 bit for r and g and b */
-    nbyte = width * 3;
-    gl2psPrintf("/rgbstr %d string def\n", nbyte);
-    gl2psPrintf("%d %d %d\n", width, height, 8);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
-    gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
-    gl2psPrintf("false 3\n");
-    gl2psPrintf("colorimage\n");
-    for(row = 0; row < height; row++){
-      for(col = 0; col < width; col++){
-        gl2psGetRGB(im, col, row, &dr, &dg, &db);
-        red = (unsigned char)(255. * dr);
-        gl2psWriteByte(red);
-        green = (unsigned char)(255. * dg);
-        gl2psWriteByte(green);
-        blue = (unsigned char)(255. * db);
-        gl2psWriteByte(blue);
-      }
-      gl2psPrintf("\n");
-    }
-  }
-  
-  gl2psPrintf("grestore\n");
-}
-
-static void gl2psPrintPostScriptImagemap(GLfloat x, GLfloat y,
-                                         GLsizei width, GLsizei height,
-                                         const unsigned char *imagemap){
-  int i, size;
-  
-  if((width <= 0) || (height <= 0)) return;
-  
-  size = height + height * (width - 1) / 8;
-  
-  gl2psPrintf("gsave\n");
-  gl2psPrintf("%.2f %.2f translate\n", x, y);
-  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height); 
-  gl2psPrintf("[ %d 0 0 -%d 0 %d ] {<", width, height);
-  for(i = 0; i < size; i++){
-    gl2psWriteByte(*imagemap);
-    imagemap++;
-  }
-  gl2psPrintf(">} imagemask\ngrestore\n");
-}
-
-static void gl2psPrintPostScriptHeader(void)
-{
-  time_t now;
-
-  /* Since compression is not part of the PostScript standard,
-     compressed PostScript files are just gzipped PostScript files
-     ("ps.gz" or "eps.gz") */
-  gl2psPrintGzipHeader();
-
-  time(&now);
-
-  if(gl2ps->format == GL2PS_PS){
-    gl2psPrintf("%%!PS-Adobe-3.0\n");
-  }
-  else{
-    gl2psPrintf("%%!PS-Adobe-3.0 EPSF-3.0\n");
-  }
-
-  gl2psPrintf("%%%%Title: %s\n"
-              "%%%%Creator: GL2PS %d.%d.%d%s, %s\n"
-              "%%%%For: %s\n"
-              "%%%%CreationDate: %s"
-              "%%%%LanguageLevel: 3\n"
-              "%%%%DocumentData: Clean7Bit\n"
-              "%%%%Pages: 1\n",
-              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, 
-              GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
-              gl2ps->producer, ctime(&now));
-
-  if(gl2ps->format == GL2PS_PS){
-    gl2psPrintf("%%%%Orientation: %s\n"
-                "%%%%DocumentMedia: Default %d %d 0 () ()\n",
-                (gl2ps->options & GL2PS_LANDSCAPE) ? "Landscape" : "Portrait",
-                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
-                (int)gl2ps->viewport[2], 
-                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] : 
-                (int)gl2ps->viewport[3]);
-  }
-
-  gl2psPrintf("%%%%BoundingBox: %d %d %d %d\n"
-              "%%%%EndComments\n",
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] : 
-              (int)gl2ps->viewport[0],
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[0] :
-              (int)gl2ps->viewport[1],
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] : 
-              (int)gl2ps->viewport[2],
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
-              (int)gl2ps->viewport[3]);
-
-  /* RGB color: r g b C (replace C by G in output to change from rgb to gray)
-     Grayscale: r g b G
-     Font choose: size fontname FC
-     Text string: (string) x y size fontname S??
-     Rotated text string: (string) angle x y size fontname S??R
-     Point primitive: x y size P
-     Line width: width W
-     Line start: x y LS
-     Line joining last point: x y L
-     Line end: x y LE
-     Flat-shaded triangle: x3 y3 x2 y2 x1 y1 T
-     Smooth-shaded triangle: x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 ST */
-
-  gl2psPrintf("%%%%BeginProlog\n"
-              "/gl2psdict 64 dict def gl2psdict begin\n"
-              "0 setlinecap 0 setlinejoin\n"
-              "/tryPS3shading %s def %% set to false to force subdivision\n"
-              "/rThreshold %g def %% red component subdivision threshold\n"
-              "/gThreshold %g def %% green component subdivision threshold\n"
-              "/bThreshold %g def %% blue component subdivision threshold\n",
-              (gl2ps->options & GL2PS_NO_PS3_SHADING) ? "false" : "true",
-              gl2ps->threshold[0], gl2ps->threshold[1], gl2ps->threshold[2]);
-
-  gl2psPrintf("/BD { bind def } bind def\n"
-              "/C  { setrgbcolor } BD\n"
-              "/G  { 0.082 mul exch 0.6094 mul add exch 0.3086 mul add neg 1.0 add setgray } BD\n"
-              "/W  { setlinewidth } BD\n");
-
-  gl2psPrintf("/FC { findfont exch /SH exch def SH scalefont setfont } BD\n"
-              "/SW { dup stringwidth pop } BD\n"
-              "/S  { FC moveto show } BD\n"
-              "/SBC{ FC moveto SW -2 div 0 rmoveto show } BD\n"
-              "/SBR{ FC moveto SW neg 0 rmoveto show } BD\n"
-              "/SCL{ FC moveto 0 SH -2 div rmoveto show } BD\n"
-              "/SCC{ FC moveto SW -2 div SH -2 div rmoveto show } BD\n"
-              "/SCR{ FC moveto SW neg SH -2 div rmoveto show } BD\n"
-              "/STL{ FC moveto 0 SH neg rmoveto show } BD\n"
-              "/STC{ FC moveto SW -2 div SH neg rmoveto show } BD\n"
-              "/STR{ FC moveto SW neg SH neg rmoveto show } BD\n");
-
-  /* rotated text routines: same nameanem with R appended */
-
-  gl2psPrintf("/FCT { FC translate 0 0 } BD\n"
-              "/SR  { gsave FCT moveto rotate show grestore } BD\n"  
-              "/SBCR{ gsave FCT moveto rotate SW -2 div 0 rmoveto show grestore } BD\n"
-              "/SBRR{ gsave FCT moveto rotate SW neg 0 rmoveto show grestore } BD\n"
-              "/SCLR{ gsave FCT moveto rotate 0 SH -2 div rmoveto show grestore} BD\n");
-  gl2psPrintf("/SCCR{ gsave FCT moveto rotate SW -2 div SH -2 div rmoveto show grestore} BD\n"
-              "/SCRR{ gsave FCT moveto rotate SW neg SH -2 div rmoveto show grestore} BD\n"
-              "/STLR{ gsave FCT moveto rotate 0 SH neg rmoveto show grestore } BD\n"
-              "/STCR{ gsave FCT moveto rotate SW -2 div SH neg rmoveto show grestore } BD\n"
-              "/STRR{ gsave FCT moveto rotate SW neg SH neg rmoveto show grestore } BD\n");
-
-  gl2psPrintf("/P  { newpath 0.0 360.0 arc closepath fill } BD\n"
-              "/LS { newpath moveto } BD\n"
-              "/L  { lineto } BD\n"
-              "/LE { lineto stroke } BD\n"
-              "/T  { newpath moveto lineto lineto closepath fill } BD\n");
-  
-  /* Smooth-shaded triangle with PostScript level 3 shfill operator:
-        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STshfill */
-
-  gl2psPrintf("/STshfill {\n"
-              "      /b1 exch def /g1 exch def /r1 exch def /y1 exch def /x1 exch def\n"
-              "      /b2 exch def /g2 exch def /r2 exch def /y2 exch def /x2 exch def\n"
-              "      /b3 exch def /g3 exch def /r3 exch def /y3 exch def /x3 exch def\n"
-              "      gsave << /ShadingType 4 /ColorSpace [/DeviceRGB]\n"
-              "      /DataSource [ 0 x1 y1 r1 g1 b1 0 x2 y2 r2 g2 b2 0 x3 y3 r3 g3 b3 ] >>\n"
-              "      shfill grestore } BD\n");
-
-  /* Flat-shaded triangle with middle color:
-        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 Tm */
-
-  gl2psPrintf(/* stack : x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 */
-              "/Tm { 3 -1 roll 8 -1 roll 13 -1 roll add add 3 div\n" /* r = (r1+r2+r3)/3 */
-              /* stack : x3 y3 g3 b3 x2 y2 g2 b2 x1 y1 g1 b1 r */
-              "      3 -1 roll 7 -1 roll 11 -1 roll add add 3 div\n" /* g = (g1+g2+g3)/3 */
-              /* stack : x3 y3 b3 x2 y2 b2 x1 y1 b1 r g b */
-              "      3 -1 roll 6 -1 roll 9 -1 roll add add 3 div" /* b = (b1+b2+b3)/3 */
-              /* stack : x3 y3 x2 y2 x1 y1 r g b */
-              " C T } BD\n");
-
-  /* Split triangle in four sub-triangles (at sides middle points) and call the
-     STnoshfill procedure on each, interpolating the colors in RGB space:
-        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STsplit
-     (in procedure comments key: (Vi) = xi yi ri gi bi) */
-
-  gl2psPrintf("/STsplit {\n"
-              "      4 index 15 index add 0.5 mul\n" /* x13 = (x1+x3)/2 */
-              "      4 index 15 index add 0.5 mul\n" /* y13 = (y1+y3)/2 */
-              "      4 index 15 index add 0.5 mul\n" /* r13 = (r1+r3)/2 */
-              "      4 index 15 index add 0.5 mul\n" /* g13 = (g1+g3)/2 */
-              "      4 index 15 index add 0.5 mul\n" /* b13 = (b1+b3)/2 */
-              "      5 copy 5 copy 25 15 roll\n");
-
-  /* at his point, stack = (V3) (V13) (V13) (V13) (V2) (V1) */
-
-  gl2psPrintf("      9 index 30 index add 0.5 mul\n" /* x23 = (x2+x3)/2 */
-              "      9 index 30 index add 0.5 mul\n" /* y23 = (y2+y3)/2 */
-              "      9 index 30 index add 0.5 mul\n" /* r23 = (r2+r3)/2 */
-              "      9 index 30 index add 0.5 mul\n" /* g23 = (g2+g3)/2 */
-              "      9 index 30 index add 0.5 mul\n" /* b23 = (b2+b3)/2 */
-              "      5 copy 5 copy 35 5 roll 25 5 roll 15 5 roll\n");
-
-  /* stack = (V3) (V13) (V23) (V13) (V23) (V13) (V23) (V2) (V1) */
-
-  gl2psPrintf("      4 index 10 index add 0.5 mul\n" /* x12 = (x1+x2)/2 */
-              "      4 index 10 index add 0.5 mul\n" /* y12 = (y1+y2)/2 */
-              "      4 index 10 index add 0.5 mul\n" /* r12 = (r1+r2)/2 */
-              "      4 index 10 index add 0.5 mul\n" /* g12 = (g1+g2)/2 */
-              "      4 index 10 index add 0.5 mul\n" /* b12 = (b1+b2)/2 */
-              "      5 copy 5 copy 40 5 roll 25 5 roll 15 5 roll 25 5 roll\n");
-  
-  /* stack = (V3) (V13) (V23) (V13) (V12) (V23) (V13) (V1) (V12) (V23) (V12) (V2) */
-
-  gl2psPrintf("      STnoshfill STnoshfill STnoshfill STnoshfill } BD\n");
-  
-  /* Gouraud shaded triangle using recursive subdivision until the difference
-     between corner colors does not exceed the thresholds:
-        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STnoshfill  */
-
-  gl2psPrintf("/STnoshfill {\n"
-              "      2 index 8 index sub abs rThreshold gt\n" /* |r1-r2|>rth */
-              "      { STsplit }\n"
-              "      { 1 index 7 index sub abs gThreshold gt\n" /* |g1-g2|>gth */
-              "        { STsplit }\n"
-              "        { dup 6 index sub abs bThreshold gt\n" /* |b1-b2|>bth */
-              "          { STsplit }\n"
-              "          { 2 index 13 index sub abs rThreshold gt\n" /* |r1-r3|>rht */
-              "            { STsplit }\n"
-              "            { 1 index 12 index sub abs gThreshold gt\n" /* |g1-g3|>gth */
-              "              { STsplit }\n"
-              "              { dup 11 index sub abs bThreshold gt\n" /* |b1-b3|>bth */
-              "                { STsplit }\n"
-              "                { 7 index 13 index sub abs rThreshold gt\n"); /* |r2-r3|>rht */
-  gl2psPrintf("                  { STsplit }\n"
-              "                  { 6 index 12 index sub abs gThreshold gt\n" /* |g2-g3|>gth */
-              "                    { STsplit }\n"
-              "                    { 5 index 11 index sub abs bThreshold gt\n" /* |b2-b3|>bth */
-              "                      { STsplit }\n"
-              "                      { Tm }\n" /* all colors sufficiently similar */
-              "                      ifelse }\n"
-              "                    ifelse }\n"
-              "                  ifelse }\n"
-              "                ifelse }\n"
-              "              ifelse }\n"
-              "            ifelse }\n"
-              "          ifelse }\n"
-              "        ifelse }\n"
-              "      ifelse } BD\n");
-  
-  gl2psPrintf("tryPS3shading\n"
-              "{ /shfill where\n"
-              "  { /ST { STshfill } BD }\n"
-              "  { /ST { STnoshfill } BD }\n"
-              "  ifelse }\n"
-              "{ /ST { STnoshfill } BD }\n"
-              "ifelse\n");
-
-  gl2psPrintf("end\n"
-              "%%%%EndProlog\n"
-              "%%%%BeginSetup\n"
-              "/DeviceRGB setcolorspace\n"
-              "gl2psdict begin\n"
-              "%%%%EndSetup\n"
-              "%%%%Page: 1 1\n"
-              "%%%%BeginPageSetup\n");
-  
-  if(gl2ps->options & GL2PS_LANDSCAPE){
-    gl2psPrintf("%d 0 translate 90 rotate\n",
-                (int)gl2ps->viewport[3]);
-  }
-
-  gl2psPrintf("%%%%EndPageSetup\n"
-              "mark\n"
-              "gsave\n"
-              "1.0 1.0 scale\n");
-          
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    gl2psPrintf("%g %g %g C\n"
-                "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
-                "closepath fill\n",
-                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2], 
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], 
-                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
-  }
-}
-
-static void gl2psPrintPostScriptColor(GL2PSrgba rgba)
-{
-  if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
-    gl2psSetLastColor(rgba);
-    gl2psPrintf("%g %g %g C\n", rgba[0], rgba[1], rgba[2]);
-  }
-}
-
-static void gl2psResetPostScriptColor(void)
-{
-  gl2ps->lastrgba[0] = gl2ps->lastrgba[1] = gl2ps->lastrgba[2] = -1.;
-}
-
-static void gl2psEndPostScriptLine(void)
-{
-  int i;
-  if(gl2ps->lastvertex.rgba[0] >= 0.){
-    gl2psPrintf("%g %g LE\n", gl2ps->lastvertex.xyz[0], gl2ps->lastvertex.xyz[1]);
-    for(i = 0; i < 3; i++)
-      gl2ps->lastvertex.xyz[i] = -1.;
-    for(i = 0; i < 4; i++)
-      gl2ps->lastvertex.rgba[i] = -1.;
-  }
-}
-
-static void gl2psParseStipplePattern(GLushort pattern, GLint factor, 
-                                     int *nb, int array[10])
-{
-  int i, n;
-  int on[8] = {0, 0, 0, 0, 0, 0, 0, 0};
-  int off[8] = {0, 0, 0, 0, 0, 0, 0, 0};
-  char tmp[16];
-
-  /* extract the 16 bits from the OpenGL stipple pattern */
-  for(n = 15; n >= 0; n--){
-    tmp[n] = (char)(pattern & 0x01);
-    pattern >>= 1;
-  }
-  /* compute the on/off pixel sequence */
-  n = 0;
-  for(i = 0; i < 8; i++){
-    while(n < 16 && !tmp[n]){ off[i]++; n++; }
-    while(n < 16 && tmp[n]){ on[i]++; n++; }
-    if(n >= 15){ i++; break; }
-  }
-
-  /* store the on/off array from right to left, starting with off
-     pixels. The PostScript specification allows for at most 11
-     elements in the on/off array, so we limit ourselves to 5 on/off
-     couples (our longest possible array is thus [on4 off4 on3 off3
-     on2 off2 on1 off1 on0 off0]) */
-  *nb = 0;
-  for(n = i - 1; n >= 0; n--){
-    array[(*nb)++] = factor * on[n];
-    array[(*nb)++] = factor * off[n];
-    if(*nb == 10) break;
-  }
-}
-
-static int gl2psPrintPostScriptDash(GLushort pattern, GLint factor, const char *str)
-{
-  int len = 0, i, n, array[10];
-
-  if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
-    return 0;
-  
-  gl2ps->lastpattern = pattern;
-  gl2ps->lastfactor = factor;
-  
-  if(!pattern || !factor){
-    /* solid line */
-    len += gl2psPrintf("[] 0 %s\n", str);
-  }
-  else{
-    gl2psParseStipplePattern(pattern, factor, &n, array);
-    len += gl2psPrintf("[");
-    for(i = 0; i < n; i++){
-      if(i) len += gl2psPrintf(" ");
-      len += gl2psPrintf("%d", array[i]);
-    }
-    len += gl2psPrintf("] 0 %s\n", str);
-  }
-  
-  return len;
-}
-
-static void gl2psPrintPostScriptPrimitive(void *data)
-{
-  int newline;
-  GL2PSprimitive *prim;
-
-  prim = *(GL2PSprimitive**)data;
-
-  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) return;
-
-  /* Every effort is made to draw lines as connected segments (i.e.,
-     using a single PostScript path): this is the only way to get nice
-     line joins and to not restart the stippling for every line
-     segment. So if the primitive to print is not a line we must first
-     finish the current line (if any): */
-  if(prim->type != GL2PS_LINE) gl2psEndPostScriptLine();
-
-  switch(prim->type){
-  case GL2PS_POINT :
-    gl2psPrintPostScriptColor(prim->verts[0].rgba);
-    gl2psPrintf("%g %g %g P\n", 
-                prim->verts[0].xyz[0], prim->verts[0].xyz[1], 0.5 * prim->width);
-    break;
-  case GL2PS_LINE :
-    if(!gl2psSamePosition(gl2ps->lastvertex.xyz, prim->verts[0].xyz) ||
-       !gl2psSameColor(gl2ps->lastrgba, prim->verts[0].rgba) ||
-       gl2ps->lastlinewidth != prim->width ||
-       gl2ps->lastpattern != prim->pattern ||
-       gl2ps->lastfactor != prim->factor){
-      /* End the current line if the new segment does not start where
-         the last one ended, or if the color, the width or the
-         stippling have changed (multi-stroking lines with changing
-         colors is necessary until we use /shfill for lines;
-         unfortunately this means that at the moment we can screw up
-         line stippling for smooth-shaded lines) */
-      gl2psEndPostScriptLine();
-      newline = 1;
-    }
-    else{
-      newline = 0;
-    }
-    if(gl2ps->lastlinewidth != prim->width){
-      gl2ps->lastlinewidth = prim->width;
-      gl2psPrintf("%g W\n", gl2ps->lastlinewidth);
-    }
-    gl2psPrintPostScriptDash(prim->pattern, prim->factor, "setdash");
-    gl2psPrintPostScriptColor(prim->verts[0].rgba);
-    gl2psPrintf("%g %g %s\n", prim->verts[0].xyz[0], prim->verts[0].xyz[1],
-                newline ? "LS" : "L");
-    gl2ps->lastvertex = prim->verts[1];
-    break;
-  case GL2PS_TRIANGLE :
-    if(!gl2psVertsSameColor(prim)){
-      gl2psResetPostScriptColor();
-      gl2psPrintf("%g %g %g %g %g %g %g %g %g %g %g %g %g %g %g ST\n",
-                  prim->verts[2].xyz[0], prim->verts[2].xyz[1],
-                  prim->verts[2].rgba[0], prim->verts[2].rgba[1],
-                  prim->verts[2].rgba[2], prim->verts[1].xyz[0],
-                  prim->verts[1].xyz[1], prim->verts[1].rgba[0],
-                  prim->verts[1].rgba[1], prim->verts[1].rgba[2],
-                  prim->verts[0].xyz[0], prim->verts[0].xyz[1],
-                  prim->verts[0].rgba[0], prim->verts[0].rgba[1],
-                  prim->verts[0].rgba[2]);
-    }
-    else{
-      gl2psPrintPostScriptColor(prim->verts[0].rgba);
-      gl2psPrintf("%g %g %g %g %g %g T\n",
-                  prim->verts[2].xyz[0], prim->verts[2].xyz[1],
-                  prim->verts[1].xyz[0], prim->verts[1].xyz[1],
-                  prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-    }
-    break;
-  case GL2PS_QUADRANGLE :
-    gl2psMsg(GL2PS_WARNING, "There should not be any quad left to print");
-    break;
-  case GL2PS_PIXMAP :
-    gl2psPrintPostScriptPixmap(prim->verts[0].xyz[0], prim->verts[0].xyz[1],
-                               prim->data.image);
-    break;
-  case GL2PS_IMAGEMAP :
-    if(prim->data.image->type != GL2PS_IMAGEMAP_WRITTEN){
-      gl2psPrintPostScriptColor(prim->verts[0].rgba);
-      gl2psPrintPostScriptImagemap(prim->data.image->pixels[0],
-                                   prim->data.image->pixels[1],
-                                   prim->data.image->width, prim->data.image->height,
-                                   (const unsigned char*)(&(prim->data.image->pixels[2])));
-      prim->data.image->type = GL2PS_IMAGEMAP_WRITTEN;
-    }
-    break;
-  case GL2PS_TEXT :
-    gl2psPrintPostScriptColor(prim->verts[0].rgba);
-    gl2psPrintf("(%s) ", prim->data.text->str);
-    if(prim->data.text->angle)
-      gl2psPrintf("%g ", prim->data.text->angle);
-    gl2psPrintf("%g %g %d /%s ",
-                prim->verts[0].xyz[0], prim->verts[0].xyz[1],
-                prim->data.text->fontsize, prim->data.text->fontname);
-    switch(prim->data.text->alignment){
-    case GL2PS_TEXT_C:
-      gl2psPrintf(prim->data.text->angle ? "SCCR\n" : "SCC\n");
-      break;
-    case GL2PS_TEXT_CL:
-      gl2psPrintf(prim->data.text->angle ? "SCLR\n" : "SCL\n");
-      break;
-    case GL2PS_TEXT_CR:
-      gl2psPrintf(prim->data.text->angle ? "SCRR\n" : "SCR\n");
-      break;
-    case GL2PS_TEXT_B:
-      gl2psPrintf(prim->data.text->angle ? "SBCR\n" : "SBC\n");
-      break;
-    case GL2PS_TEXT_BR:
-      gl2psPrintf(prim->data.text->angle ? "SBRR\n" : "SBR\n");
-      break;
-    case GL2PS_TEXT_T:
-      gl2psPrintf(prim->data.text->angle ? "STCR\n" : "STC\n");
-      break;
-    case GL2PS_TEXT_TL:
-      gl2psPrintf(prim->data.text->angle ? "STLR\n" : "STL\n");
-      break;
-    case GL2PS_TEXT_TR:
-      gl2psPrintf(prim->data.text->angle ? "STRR\n" : "STR\n");
-      break;
-    case GL2PS_TEXT_BL:
-    default:
-      gl2psPrintf(prim->data.text->angle ? "SR\n" : "S\n");
-      break;
-    }
-    break;
-  case GL2PS_SPECIAL :
-    /* alignment contains the format for which the special output text
-       is intended */
-    if(prim->data.text->alignment == GL2PS_PS ||
-       prim->data.text->alignment == GL2PS_EPS)
-      gl2psPrintf("%s\n", prim->data.text->str);
-    break;
-  default :
-    break;
-  }
-}
-
-static void gl2psPrintPostScriptFooter(void)
-{
-  gl2psPrintf("grestore\n"
-              "showpage\n"
-              "cleartomark\n"
-              "%%%%PageTrailer\n"
-              "%%%%Trailer\n"
-              "end\n"
-              "%%%%EOF\n");
-
-  gl2psPrintGzipFooter();
-}
-
-static void gl2psPrintPostScriptBeginViewport(GLint viewport[4])
-{
-  GLint index;
-  GLfloat rgba[4];
-  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
-
-  glRenderMode(GL_FEEDBACK);
-
-  if(gl2ps->header){
-    gl2psPrintPostScriptHeader();
-    gl2ps->header = GL_FALSE;
-  }
-
-  gl2psPrintf("gsave\n"
-              "1.0 1.0 scale\n");
-
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
-      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
-    }
-    else{
-      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
-      rgba[0] = gl2ps->colormap[index][0];
-      rgba[1] = gl2ps->colormap[index][1];
-      rgba[2] = gl2ps->colormap[index][2];
-      rgba[3] = 1.0F;
-    }
-    gl2psPrintf("%g %g %g C\n"
-                "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
-                "closepath fill\n",
-                rgba[0], rgba[1], rgba[2], 
-                x, y, x+w, y, x+w, y+h, x, y+h);
-  }
-    
-  gl2psPrintf("newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
-              "closepath clip\n",
-              x, y, x+w, y, x+w, y+h, x, y+h);
-  
-}
-
-static GLint gl2psPrintPostScriptEndViewport(void)
-{
-  GLint res;
-
-  res = gl2psPrintPrimitives();
-  gl2psPrintf("grestore\n");
-  return res;
-}
-
-static void gl2psPrintPostScriptFinalPrimitive(void)
-{
-  /* End any remaining line, if any */
-  gl2psEndPostScriptLine();
-}
-
-/* definition of the PostScript and Encapsulated PostScript backends */
-
-static GL2PSbackend gl2psPS = {
-  gl2psPrintPostScriptHeader,
-  gl2psPrintPostScriptFooter,
-  gl2psPrintPostScriptBeginViewport,
-  gl2psPrintPostScriptEndViewport,
-  gl2psPrintPostScriptPrimitive,
-  gl2psPrintPostScriptFinalPrimitive,
-  "ps",
-  "Postscript"
-};
-
-static GL2PSbackend gl2psEPS = {
-  gl2psPrintPostScriptHeader,
-  gl2psPrintPostScriptFooter,
-  gl2psPrintPostScriptBeginViewport,
-  gl2psPrintPostScriptEndViewport,
-  gl2psPrintPostScriptPrimitive,
-  gl2psPrintPostScriptFinalPrimitive,
-  "eps",
-  "Encapsulated Postscript"
-};
-
-/********************************************************************* 
- *
- * LaTeX routines
- *
- *********************************************************************/
-
-static void gl2psPrintTeXHeader(void)
-{
-  char name[256];
-  time_t now;
-  int i;
-
-  if(gl2ps->filename && strlen(gl2ps->filename) < 256){
-    for(i = strlen(gl2ps->filename)-1; i >= 0; i--){
-      if(gl2ps->filename[i] == '.'){
-        strncpy(name, gl2ps->filename, i);
-        name[i] = '\0';
-        break;
-      }
-    }
-    if(i <= 0) strcpy(name, gl2ps->filename);
-  }
-  else{
-    strcpy(name, "untitled");
-  }
-
-  time(&now);
-
-  fprintf(gl2ps->stream, 
-          "%% Title: %s\n"
-          "%% Creator: GL2PS %d.%d.%d%s, %s\n"
-          "%% For: %s\n"
-          "%% CreationDate: %s",
-          gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
-          GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
-          gl2ps->producer, ctime(&now));
-
-  fprintf(gl2ps->stream, 
-          "\\setlength{\\unitlength}{1pt}\n"
-          "\\begin{picture}(0,0)\n"
-          "\\includegraphics{%s}\n"
-          "\\end{picture}%%\n"
-          "%s\\begin{picture}(%d,%d)(0,0)\n",
-          name, (gl2ps->options & GL2PS_LANDSCAPE) ? "\\rotatebox{90}{" : "",
-          (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-}
-
-static void gl2psPrintTeXPrimitive(void *data)
-{
-  GL2PSprimitive *prim;
-
-  prim = *(GL2PSprimitive**)data;
-
-  switch(prim->type){
-  case GL2PS_TEXT :
-    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont", 
-            prim->data.text->fontsize);
-    fprintf(gl2ps->stream, "\\put(%g,%g){\\makebox(0,0)",
-            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-    switch(prim->data.text->alignment){
-    case GL2PS_TEXT_C:
-      fprintf(gl2ps->stream, "{");
-      break;
-    case GL2PS_TEXT_CL:
-      fprintf(gl2ps->stream, "[l]{");
-      break;
-    case GL2PS_TEXT_CR:
-      fprintf(gl2ps->stream, "[r]{");
-      break;
-    case GL2PS_TEXT_B:
-      fprintf(gl2ps->stream, "[b]{");
-      break;
-    case GL2PS_TEXT_BR:
-      fprintf(gl2ps->stream, "[br]{");
-      break;
-    case GL2PS_TEXT_T:
-      fprintf(gl2ps->stream, "[t]{");
-      break;
-    case GL2PS_TEXT_TL:
-      fprintf(gl2ps->stream, "[tl]{");
-      break;
-    case GL2PS_TEXT_TR:
-      fprintf(gl2ps->stream, "[tr]{");
-      break;
-    case GL2PS_TEXT_BL:
-    default:
-      fprintf(gl2ps->stream, "[bl]{");
-      break;
-    }
-    if(prim->data.text->angle)
-      fprintf(gl2ps->stream, "\\rotatebox{%g}{", prim->data.text->angle);
-    fprintf(gl2ps->stream, "\\textcolor[rgb]{%g,%g,%g}{{%s}}",
-            prim->verts[0].rgba[0], prim->verts[0].rgba[1], prim->verts[0].rgba[2],
-            prim->data.text->str);
-    if(prim->data.text->angle)
-      fprintf(gl2ps->stream, "}");
-    fprintf(gl2ps->stream, "}}\n");
-    break;
-  case GL2PS_SPECIAL :
-    /* alignment contains the format for which the special output text
-       is intended */
-    if (prim->data.text->alignment == GL2PS_TEX)
-      fprintf(gl2ps->stream, "%s\n", prim->data.text->str);
-    break;
-  default :
-    break;
-  }
-}
-
-static void gl2psPrintTeXFooter(void)
-{
-  fprintf(gl2ps->stream, "\\end{picture}%s\n",
-          (gl2ps->options & GL2PS_LANDSCAPE) ? "}" : "");
-}
-
-static void gl2psPrintTeXBeginViewport(GLint /*viewport*/[4])
-{
-  glRenderMode(GL_FEEDBACK);
-  
-  if(gl2ps->header){
-    gl2psPrintTeXHeader();
-    gl2ps->header = GL_FALSE;
-  }
-}
-
-static GLint gl2psPrintTeXEndViewport(void)
-{
-  return gl2psPrintPrimitives();
-}
-
-static void gl2psPrintTeXFinalPrimitive(void)
-{
-}
-
-/* definition of the LaTeX backend */
-
-static GL2PSbackend gl2psTEX = {
-  gl2psPrintTeXHeader,
-  gl2psPrintTeXFooter,
-  gl2psPrintTeXBeginViewport,
-  gl2psPrintTeXEndViewport,
-  gl2psPrintTeXPrimitive,
-  gl2psPrintTeXFinalPrimitive,
-  "tex",
-  "LaTeX text"
-};
-
-/********************************************************************* 
- *
- * PDF routines
- *
- *********************************************************************/
-
-static int gl2psPrintPDFCompressorType(void)
-{
-#if defined(GL2PS_HAVE_ZLIB)
-  if(gl2ps->options & GL2PS_COMPRESS){
-    return fprintf(gl2ps->stream, "/Filter [/FlateDecode]\n");
-  }
-#endif
-  return 0;
-}
-
-static int gl2psPrintPDFStrokeColor(GL2PSrgba rgba)
-{
-  int i, offs = 0;
-
-  gl2psSetLastColor(rgba);
-  for(i = 0; i < 3; ++i){
-    if(GL2PS_ZERO(rgba[i]))
-      offs += gl2psPrintf("%.0f ", 0.);
-    else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
-      offs += gl2psPrintf("%f ", rgba[i]);
-    else
-      offs += gl2psPrintf("%g ", rgba[i]);
-  }
-  offs += gl2psPrintf("RG\n");
-  return offs;
-}
-
-static int gl2psPrintPDFFillColor(GL2PSrgba rgba)
-{
-  int i, offs = 0;
-  
-  for(i = 0; i < 3; ++i){
-    if(GL2PS_ZERO(rgba[i]))
-      offs += gl2psPrintf("%.0f ", 0.);
-    else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
-      offs += gl2psPrintf("%f ", rgba[i]);
-    else
-      offs += gl2psPrintf("%g ", rgba[i]);
-  }
-  offs += gl2psPrintf("rg\n");
-  return offs;
-}
-
-static int gl2psPrintPDFLineWidth(GLfloat lw)
-{
-  if(GL2PS_ZERO(lw))
-    return gl2psPrintf("%.0f w\n", 0.);
-  else if(lw < 1e-4 || lw > 1e6) /* avoid %e formatting */
-    return gl2psPrintf("%f w\n", lw);
-  else
-    return gl2psPrintf("%g w\n", lw);
-}
-
-static void gl2psPutPDFText(GL2PSstring *text, int cnt, GLfloat x, GLfloat y)
-{
-  gl2ps->streamlength += 
-    gl2psPrintf("BT\n"
-                "/F%d %d Tf\n"
-                "%f %f Td\n"
-                "(%s) Tj\n"
-                "ET\n", 
-                cnt, text->fontsize, x, y, text->str);  
-}
-
-static void gl2psPutPDFImage(GL2PSimage *image, int cnt, GLfloat x, GLfloat y)
-{
-  gl2ps->streamlength += 
-    gl2psPrintf("q\n"
-                "%d 0 0 %d %f %f cm\n"
-                "/Im%d Do\n"
-                "Q\n",
-                (int)image->width, (int)image->height, x, y, cnt);
-}
-
-static void gl2psPDFstacksInit(void)
-{
-  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1; 
-  gl2ps->extgs_stack = 0;   
-  gl2ps->font_stack = 0;    
-  gl2ps->im_stack = 0;      
-  gl2ps->trgroupobjects_stack = 0;    
-  gl2ps->shader_stack = 0;  
-  gl2ps->mshader_stack = 0; 
-}
-
-static void gl2psPDFgroupObjectInit(GL2PSpdfgroup *gro)
-{
-  if(!gro)
-    return;
-  
-  gro->ptrlist = NULL;
-  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno 
-    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno 
-    = gro->maskshobjno = gro->gsobjno = gro->trgroupobjno = -1;
-}
-
-/* Build up group objects and assign name and object numbers */
-
-static void gl2psPDFgroupListInit(void)
-{
-  int i;
-  GL2PSprimitive *p = NULL;
-  GL2PSpdfgroup gro;
-  int lasttype = GL2PS_NO_TYPE;
-  GL2PSrgba lastrgba = {-1.0F, -1.0F, -1.0F, -1.0F};
-  GLushort lastpattern = 0;
-  GLint lastfactor = 0;
-  GLfloat lastwidth = 1;
-  GL2PStriangle lastt, tmpt;
-  int lastTriangleWasNotSimpleWithSameColor = 0;
-
-  if(!gl2ps->pdfprimlist)
-    return;
-
-  gl2ps->pdfgrouplist = gl2psListCreate(500, 500, sizeof(GL2PSpdfgroup));
-  gl2psInitTriangle(&lastt);
-
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){  
-    p = *(GL2PSprimitive**)gl2psListPointer(gl2ps->pdfprimlist, i);
-    switch(p->type){
-    case GL2PS_PIXMAP:
-      gl2psPDFgroupObjectInit(&gro);
-      gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
-      gro.imno = gl2ps->im_stack++;
-      gl2psListAdd(gro.ptrlist, &p);
-      gl2psListAdd(gl2ps->pdfgrouplist, &gro);
-      break;
-    case GL2PS_TEXT:
-      gl2psPDFgroupObjectInit(&gro);
-      gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
-      gro.fontno = gl2ps->font_stack++;
-      gl2psListAdd(gro.ptrlist, &p);
-      gl2psListAdd(gl2ps->pdfgrouplist, &gro);
-      break;
-    case GL2PS_LINE:
-      if(lasttype != p->type || lastwidth != p->width || 
-         lastpattern != p->pattern || lastfactor != p->factor ||
-         !gl2psSameColor(p->verts[0].rgba, lastrgba)){
-        gl2psPDFgroupObjectInit(&gro);
-        gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
-        gl2psListAdd(gro.ptrlist, &p);
-        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
-      }
-      else{
-        gl2psListAdd(gro.ptrlist, &p);
-      }
-      lastpattern = p->pattern;
-      lastfactor = p->factor;
-      lastwidth = p->width;
-      lastrgba[0] = p->verts[0].rgba[0];
-      lastrgba[1] = p->verts[0].rgba[1];
-      lastrgba[2] = p->verts[0].rgba[2];
-      break;
-    case GL2PS_POINT:
-      if(lasttype != p->type || lastwidth != p->width || 
-         !gl2psSameColor(p->verts[0].rgba, lastrgba)){
-        gl2psPDFgroupObjectInit(&gro);
-        gro.ptrlist = gl2psListCreate(1,2,sizeof(GL2PSprimitive*));
-        gl2psListAdd(gro.ptrlist, &p);
-        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
-      }
-      else{
-        gl2psListAdd(gro.ptrlist, &p);
-      }
-      lastwidth = p->width;
-      lastrgba[0] = p->verts[0].rgba[0];
-      lastrgba[1] = p->verts[0].rgba[1];
-      lastrgba[2] = p->verts[0].rgba[2];
-      break;
-    case GL2PS_TRIANGLE:
-      gl2psFillTriangleFromPrimitive(&tmpt, p, GL_TRUE);
-      lastTriangleWasNotSimpleWithSameColor = 
-        !(tmpt.prop & T_CONST_COLOR && tmpt.prop & T_ALPHA_1) ||
-        !gl2psSameColor(tmpt.vertex[0].rgba, lastt.vertex[0].rgba);
-      if(lasttype == p->type && tmpt.prop == lastt.prop && 
-         lastTriangleWasNotSimpleWithSameColor){
-        /* TODO Check here for last alpha */
-        gl2psListAdd(gro.ptrlist, &p);
-      }
-      else{
-        gl2psPDFgroupObjectInit(&gro);
-        gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
-        gl2psListAdd(gro.ptrlist, &p);
-        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
-      }
-      lastt = tmpt;
-      break;
-    default:
-      break;
-    } 
-    lasttype = p->type;
-  }
-}
-
-static void gl2psSortOutTrianglePDFgroup(GL2PSpdfgroup *gro)
-{
-  GL2PStriangle t;
-  GL2PSprimitive *prim = NULL;
-  
-  if(!gro)
-    return;
-
-  if(!gl2psListNbr(gro->ptrlist))
-    return;
-
-  prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
-
-  if(prim->type != GL2PS_TRIANGLE)
-    return;
-
-  gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
-  
-  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){        
-    gro->gsno = gl2ps->extgs_stack++; 
-    gro->gsobjno = gl2ps->objects_stack ++;
-  }
-  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){              
-    gro->gsno = gl2ps->extgs_stack++;
-    gro->gsobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
-    gro->trgroupobjno = gl2ps->objects_stack++;
-    gro->maskshno = gl2ps->mshader_stack++;
-    gro->maskshobjno = gl2ps->objects_stack++;
-  }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){          
-    gro->shno = gl2ps->shader_stack++;
-    gro->shobjno = gl2ps->objects_stack++;
-  }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){             
-    gro->gsno = gl2ps->extgs_stack++;
-    gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++; 
-    gro->shobjno = gl2ps->objects_stack++;
-  }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){                
-    gro->gsno = gl2ps->extgs_stack++;
-    gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++; 
-    gro->shobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
-    gro->trgroupobjno = gl2ps->objects_stack++;
-    gro->maskshno = gl2ps->mshader_stack++;
-    gro->maskshobjno = gl2ps->objects_stack++;
-  }
-}
-
-/* Main stream data */
-
-static void gl2psPDFgroupListWriteMainStream(void)
-{
-  int i, j, lastel;
-  GL2PSprimitive *prim = NULL, *prev = NULL;
-  GL2PSpdfgroup *gro;
-  GL2PStriangle t;
-
-  if(!gl2ps->pdfgrouplist)
-    return;
-
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
-
-    lastel = gl2psListNbr(gro->ptrlist) - 1;
-    if(lastel < 0)
-      continue;
-
-    prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
-
-    switch(prim->type){
-    case GL2PS_POINT:
-      gl2ps->streamlength += gl2psPrintf("1 J\n");
-      gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
-      gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
-      for(j = 0; j <= lastel; ++j){  
-        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        gl2ps->streamlength +=
-          gl2psPrintf("%f %f m %f %f l\n",
-                      prim->verts[0].xyz[0], prim->verts[0].xyz[1],
-                      prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-      }
-      gl2ps->streamlength += gl2psPrintf("S\n"); 
-      gl2ps->streamlength += gl2psPrintf("0 J\n");
-      break;
-    case GL2PS_LINE:
-      /* We try to use as few paths as possible to draw lines, in
-         order to get nice stippling even when the individual segments
-         are smaller than the stipple */
-      gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
-      gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
-      gl2ps->streamlength += gl2psPrintPostScriptDash(prim->pattern, prim->factor, "d");
-      /* start new path */
-      gl2ps->streamlength += 
-        gl2psPrintf("%f %f m\n", 
-                    prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-      
-      for(j = 1; j <= lastel; ++j){
-        prev = prim;
-        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        if(!gl2psSamePosition(prim->verts[0].xyz, prev->verts[1].xyz)){
-          /* the starting point of the new segment does not match the
-             end point of the previous line, so we end the current
-             path and start a new one */
-          gl2ps->streamlength += 
-            gl2psPrintf("%f %f l\n", 
-                        prev->verts[1].xyz[0], prev->verts[1].xyz[1]);
-          gl2ps->streamlength += 
-            gl2psPrintf("%f %f m\n", 
-                        prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-        }
-        else{
-          /* the two segements are connected, so we just append to the
-             current path */
-          gl2ps->streamlength += 
-            gl2psPrintf("%f %f l\n",
-                        prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-        }
-      }
-      /* end last path */
-      gl2ps->streamlength += 
-        gl2psPrintf("%f %f l\n", 
-                    prim->verts[1].xyz[0], prim->verts[1].xyz[1]);
-      gl2ps->streamlength += gl2psPrintf("S\n");
-      break;
-    case GL2PS_TRIANGLE:
-      gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
-      gl2psSortOutTrianglePDFgroup(gro);
-      
-      /* No alpha and const color: Simple PDF draw orders  */
-      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){         
-        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);        
-        for(j = 0; j <= lastel; ++j){  
-          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength 
-            += gl2psPrintf("%f %f m\n"
-                           "%f %f l\n"
-                           "%f %f l\n"
-                           "h f\n",
-                           t.vertex[0].xyz[0], t.vertex[0].xyz[1],
-                           t.vertex[1].xyz[0], t.vertex[1].xyz[1],
-                           t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
-        }
-      }
-      /* Const alpha < 1 and const color: Simple PDF draw orders 
-         and an extra extended Graphics State for the alpha const */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){               
-        gl2ps->streamlength += gl2psPrintf("q\n"
-                                           "/GS%d gs\n",
-                                           gro->gsno);
-        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){  
-          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength 
-            += gl2psPrintf("%f %f m\n"
-                           "%f %f l\n"
-                           "%f %f l\n"
-                           "h f\n",
-                           t.vertex[0].xyz[0], t.vertex[0].xyz[1],
-                           t.vertex[1].xyz[0], t.vertex[1].xyz[1],
-                           t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
-        }
-        gl2ps->streamlength += gl2psPrintf("Q\n");
-      }
-      /* Variable alpha and const color: Simple PDF draw orders 
-         and an extra extended Graphics State + Xobject + Shader 
-         object for the alpha mask */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){          
-        gl2ps->streamlength += gl2psPrintf("q\n"
-                                           "/GS%d gs\n"
-                                           "/TrG%d Do\n",
-                                           gro->gsno, gro->trgroupno);
-        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){  
-          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength 
-            += gl2psPrintf("%f %f m\n"
-                           "%f %f l\n"
-                           "%f %f l\n"
-                           "h f\n",
-                           t.vertex[0].xyz[0], t.vertex[0].xyz[1],
-                           t.vertex[1].xyz[0], t.vertex[1].xyz[1],
-                           t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
-        }
-        gl2ps->streamlength += gl2psPrintf("Q\n");
-      }
-      /* Variable color and no alpha: Shader Object for the colored
-         triangle(s) */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){              
-        gl2ps->streamlength += gl2psPrintf("/Sh%d sh\n", gro->shno);
-      }
-      /* Variable color and const alpha < 1: Shader Object for the 
-         colored triangle(s) and an extra extended Graphics State 
-         for the alpha const */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){         
-        gl2ps->streamlength += gl2psPrintf("q\n"
-                                           "/GS%d gs\n"
-                                           "/Sh%d sh\n"
-                                           "Q\n",
-                                           gro->gsno, gro->shno);
-      }
-      /* Variable alpha and color: Shader Object for the colored 
-         triangle(s) and an extra extended Graphics State 
-         + Xobject + Shader object for the alpha mask */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){            
-        gl2ps->streamlength += gl2psPrintf("q\n"
-                                           "/GS%d gs\n"
-                                           "/TrG%d Do\n"
-                                           "/Sh%d sh\n"
-                                           "Q\n",
-                                           gro->gsno, gro->trgroupno, gro->shno);
-      }
-      break;
-    case GL2PS_PIXMAP:
-      for(j = 0; j <= lastel; ++j){
-        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0], 
-                         prim->verts[0].xyz[1]);
-      }
-      break;
-    case GL2PS_TEXT:
-      for(j = 0; j <= lastel; ++j){  
-        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        gl2psPutPDFText(prim->data.text, gro->fontno, prim->verts[0].xyz[0],
-                        prim->verts[0].xyz[1]);
-      }
-      break;
-    default:
-      break;
-    } 
-  }
-}
-
-/* Graphics State names */
-
-static int gl2psPDFgroupListWriteGStateResources(void)
-{
-  GL2PSpdfgroup *gro;
-  int offs = 0;
-  int i;
-
-  offs += fprintf(gl2ps->stream,
-                  "/ExtGState\n" 
-                  "<<\n"
-                  "/GSa 7 0 R\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
-    if(gro->gsno >= 0)
-      offs += fprintf(gl2ps->stream, "/GS%d %d 0 R\n", gro->gsno, gro->gsobjno);
-  }
-  offs += fprintf(gl2ps->stream, ">>\n"); 
-  return offs;
-}
-
-/* Main Shader names */
-
-static int gl2psPDFgroupListWriteShaderResources(void)
-{
-  GL2PSpdfgroup *gro;
-  int offs = 0;
-  int i;
-
-  offs += fprintf(gl2ps->stream,
-                  "/Shading\n"
-                  "<<\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
-    if(gro->shno >= 0)
-      offs += fprintf(gl2ps->stream, "/Sh%d %d 0 R\n", gro->shno, gro->shobjno);
-    if(gro->maskshno >= 0)
-      offs += fprintf(gl2ps->stream, "/TrSh%d %d 0 R\n", gro->maskshno, gro->maskshobjno);
-  }
-  offs += fprintf(gl2ps->stream,">>\n");  
-  return offs;
-}
-
-/* Images & Mask Shader XObject names */
-
-static int gl2psPDFgroupListWriteXObjectResources(void)
-{
-  int i;
-  GL2PSprimitive *p = NULL;
-  GL2PSpdfgroup *gro;
-  int offs = 0;
-
-  offs += fprintf(gl2ps->stream,
-                  "/XObject\n"
-                  "<<\n");
-
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
-    if(!gl2psListNbr(gro->ptrlist))
-      continue;
-    p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
-    switch(p->type){
-    case GL2PS_PIXMAP:
-      gro->imobjno = gl2ps->objects_stack++;
-      if(GL_RGBA == p->data.image->format)  /* reserve one object for image mask */
-        gl2ps->objects_stack++;
-      offs += fprintf(gl2ps->stream, "/Im%d %d 0 R\n", gro->imno, gro->imobjno);
-    case GL2PS_TRIANGLE:
-      if(gro->trgroupno >=0)
-        offs += fprintf(gl2ps->stream, "/TrG%d %d 0 R\n", gro->trgroupno, gro->trgroupobjno);
-      break;
-    default:
-      break;
-    }
-  }
-  offs += fprintf(gl2ps->stream,">>\n");
-  return offs;
-}
-
-/* Font names */
-
-static int gl2psPDFgroupListWriteFontResources(void)
-{
-  int i;
-  GL2PSpdfgroup *gro;
-  int offs = 0;
-
-  offs += fprintf(gl2ps->stream, "/Font\n<<\n");
-
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
-    if(gro->fontno < 0)
-      continue;
-    gro->fontobjno = gl2ps->objects_stack++;
-    offs += fprintf(gl2ps->stream, "/F%d %d 0 R\n", gro->fontno, gro->fontobjno);
-  }
-  offs += fprintf(gl2ps->stream, ">>\n");
-
-  return offs;
-}
-
-static void gl2psPDFgroupListDelete(void)
-{
-  int i;
-  GL2PSpdfgroup *gro = NULL;
-  
-  if(!gl2ps->pdfgrouplist)
-    return;
-
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){ 
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist,i);
-    gl2psListDelete(gro->ptrlist);
-  }
-
-  gl2psListDelete(gl2ps->pdfgrouplist);
-  gl2ps->pdfgrouplist = NULL;
-}
-
-/* Print 1st PDF object - file info */
-
-static int gl2psPrintPDFInfo(void)
-{
-  int offs;
-  time_t now;
-  struct tm *newtime;
-  
-  time(&now);
-  newtime = gmtime(&now);
-  
-  offs = fprintf(gl2ps->stream,
-                 "1 0 obj\n"
-                 "<<\n"
-                 "/Title (%s)\n"
-                 "/Creator (GL2PS %d.%d.%d%s, %s)\n"
-                 "/Producer (%s)\n",
-                 gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
-                 GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
-                 gl2ps->producer);
-  
-  if(!newtime){
-    offs += fprintf(gl2ps->stream, 
-                    ">>\n"
-                    "endobj\n");
-    return offs;
-  }
-  
-  offs += fprintf(gl2ps->stream, 
-                  "/CreationDate (D:%d%02d%02d%02d%02d%02d)\n"
-                  ">>\n"
-                  "endobj\n",
-                  newtime->tm_year+1900, 
-                  newtime->tm_mon+1, 
-                  newtime->tm_mday,
-                  newtime->tm_hour,
-                  newtime->tm_min,
-                  newtime->tm_sec);
-  return offs;
-}
-
-/* Create catalog and page structure - 2nd and 3th PDF object */
-
-static int gl2psPrintPDFCatalog(void)
-{
-  return fprintf(gl2ps->stream, 
-                 "2 0 obj\n"
-                 "<<\n"
-                 "/Type /Catalog\n"
-                 "/Pages 3 0 R\n"
-                 ">>\n"
-                 "endobj\n");
-}
-
-static int gl2psPrintPDFPages(void)
-{
-  return fprintf(gl2ps->stream, 
-                 "3 0 obj\n"
-                 "<<\n" 
-                 "/Type /Pages\n"
-                 "/Kids [6 0 R]\n"
-                 "/Count 1\n"
-                 ">>\n"
-                 "endobj\n");
-}
-
-/* Open stream for data - graphical objects, fonts etc. PDF object 4 */
-
-static int gl2psOpenPDFDataStream(void)
-{
-  int offs = 0;
-  
-  offs += fprintf(gl2ps->stream, 
-                  "4 0 obj\n"
-                  "<<\n" 
-                  "/Length 5 0 R\n" );
-  offs += gl2psPrintPDFCompressorType();
-  offs += fprintf(gl2ps->stream, 
-                  ">>\n"
-                  "stream\n");
-  return offs;
-}
-
-/* Stream setup - Graphics state, fill background if allowed */
-
-static int gl2psOpenPDFDataStreamWritePreface(void)
-{
-  int offs;
-
-  offs = gl2psPrintf("/GSa gs\n");
-  
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    offs += gl2psPrintPDFFillColor(gl2ps->bgcolor);
-    offs += gl2psPrintf("%d %d %d %d re\n",
-                        (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
-                        (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-    offs += gl2psPrintf("f\n");  
-  }
-  return offs;
-}
-
-/* Use the functions above to create the first part of the PDF*/
-
-static void gl2psPrintPDFHeader(void)
-{
-  int offs = 0;
-  gl2ps->pdfprimlist = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
-  gl2psPDFstacksInit();
-
-  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack); 
-
-#if defined(GL2PS_HAVE_ZLIB)
-  if(gl2ps->options & GL2PS_COMPRESS){
-    gl2psSetupCompress();
-  }
-#endif    
-  gl2ps->xreflist[0] = 0;
-  offs += fprintf(gl2ps->stream, "%%PDF-1.4\n");
-  gl2ps->xreflist[1] = offs;
-  
-  offs += gl2psPrintPDFInfo();
-  gl2ps->xreflist[2] = offs;
-  
-  offs += gl2psPrintPDFCatalog();
-  gl2ps->xreflist[3] = offs;
-  
-  offs += gl2psPrintPDFPages();
-  gl2ps->xreflist[4] = offs;
-  
-  offs += gl2psOpenPDFDataStream();
-  gl2ps->xreflist[5] = offs; /* finished in gl2psPrintPDFFooter */
-  gl2ps->streamlength = gl2psOpenPDFDataStreamWritePreface();
-}
-
-/* The central primitive drawing */
-
-static void gl2psPrintPDFPrimitive(void *data)
-{
-  GL2PSprimitive *prim = *(GL2PSprimitive**)data;
-
-  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) 
-    return;
-
-  prim = gl2psCopyPrimitive(prim); /* deep copy */
-  gl2psListAdd(gl2ps->pdfprimlist, &prim);
-}
-
-/* close stream and ... */
-
-static int gl2psClosePDFDataStream(void)
-{
-  int offs = 0;
- 
-#if defined(GL2PS_HAVE_ZLIB)
-  if(gl2ps->options & GL2PS_COMPRESS){
-    if(Z_OK != gl2psDeflate())
-      gl2psMsg(GL2PS_ERROR, "Zlib deflate error");
-    else
-      fwrite(gl2ps->compress->dest, gl2ps->compress->destLen, 1, gl2ps->stream);
-    gl2ps->streamlength += gl2ps->compress->destLen;
-    
-    offs += gl2ps->streamlength;
-    gl2psFreeCompress();
-  }
-#endif 
-  
-  offs += fprintf(gl2ps->stream, 
-                  "endstream\n"
-                  "endobj\n");
-  return offs;
-}
-
-/* ... write the now known length object */
-
-static int gl2psPrintPDFDataStreamLength(int val)
-{
-  return fprintf(gl2ps->stream,
-                 "5 0 obj\n"
-                 "%d\n"
-                 "endobj\n", val);
-}
-
-/* Put the info created before in PDF objects */
-
-static int gl2psPrintPDFOpenPage(void)
-{
-  int offs;
-  
-  /* Write fixed part */
-  
-  offs = fprintf(gl2ps->stream, 
-                 "6 0 obj\n"
-                 "<<\n" 
-                 "/Type /Page\n"
-                 "/Parent 3 0 R\n"
-                 "/MediaBox [%d %d %d %d]\n",
-                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
-                 (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-  
-  if(gl2ps->options & GL2PS_LANDSCAPE)
-    offs += fprintf(gl2ps->stream, "/Rotate -90\n");
-  
-  offs += fprintf(gl2ps->stream,
-                  "/Contents 4 0 R\n"
-                  "/Resources\n" 
-                  "<<\n" 
-                  "/ProcSet [/PDF /Text /ImageB /ImageC]  %%/ImageI\n");
-  
-  return offs;
-
-  /* End fixed part, proceeds in gl2psPDFgroupListWriteVariableResources() */
-}
-
-static int gl2psPDFgroupListWriteVariableResources(void)
-{
-  int offs = 0;
-  
-  /* a) Graphics States for shader alpha masks*/
-  offs += gl2psPDFgroupListWriteGStateResources();  
-  
-  /* b) Shader and shader masks */ 
-  offs += gl2psPDFgroupListWriteShaderResources();  
- 
-  /* c) XObjects (Images & Shader Masks) */
-  offs += gl2psPDFgroupListWriteXObjectResources();
-  
-  /* d) Fonts */
-  offs += gl2psPDFgroupListWriteFontResources();
-  
-  /* End resources and page */
-  offs += fprintf(gl2ps->stream,
-                  ">>\n"
-                  ">>\n"
-                  "endobj\n");
-  return offs;
-}
-
-/* Standard Graphics State */
-
-static int gl2psPrintPDFGSObject(void)
-{
-  return fprintf(gl2ps->stream,
-                 "7 0 obj\n"
-                 "<<\n"
-                 "/Type /ExtGState\n"
-                 "/SA false\n"
-                 "/SM 0.02\n"
-                 "/OP false\n"
-                 "/op false\n"
-                 "/OPM 0\n"
-                 "/BG2 /Default\n"
-                 "/UCR2 /Default\n"
-                 "/TR2 /Default\n"
-                 ">>\n"
-                 "endobj\n");
-}
-
-/* Put vertex' edge flag (8bit) and coordinates (32bit) in shader stream */
-
-static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex, 
-                                              size_t (*action)(unsigned long data, 
-                                                               size_t size), 
-                                              GLfloat dx, GLfloat dy, 
-                                              GLfloat xmin, GLfloat ymin)
-{
-  int offs = 0;
-  unsigned long imap;
-  GLfloat diff;
-  double dmax = ~1UL;
-  char edgeflag = 0;
-
-  /* FIXME: temp bux fix for 64 bit archs: */
-  if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
-
-  offs += (*action)(edgeflag, 1);
-
-  /* The Shader stream in PDF requires to be in a 'big-endian'
-     order */
-    
-  if(GL2PS_ZERO(dx * dy)){
-    offs += (*action)(0, 4);
-    offs += (*action)(0, 4);
-  }
-  else{
-    diff = (vertex->xyz[0] - xmin) / dx;
-    if(diff > 1)
-      diff = 1.0F;
-    else if(diff < 0)
-      diff = 0.0F;
-    imap = (unsigned long)(diff * dmax);
-    offs += (*action)(imap, 4);
-      
-    diff = (vertex->xyz[1] - ymin) / dy;
-    if(diff > 1)
-      diff = 1.0F;
-    else if(diff < 0)
-      diff = 0.0F;
-    imap = (unsigned long)(diff * dmax);
-    offs += (*action)(imap, 4);
-  }
-  
-  return offs;
-}
-
-/* Put vertex' rgb value (8bit for every component) in shader stream */
-
-static int gl2psPrintPDFShaderStreamDataRGB(GL2PSvertex *vertex,
-                                            size_t (*action)(unsigned long data, 
-                                                             size_t size))
-{
-  int offs = 0;
-  unsigned long imap;
-  double dmax = ~1UL;
-
-  /* FIXME: temp bux fix for 64 bit archs: */
-  if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
-
-  imap = (unsigned long)((vertex->rgba[0]) * dmax);
-  offs += (*action)(imap, 1);
-    
-  imap = (unsigned long)((vertex->rgba[1]) * dmax);
-  offs += (*action)(imap, 1);
-    
-  imap = (unsigned long)((vertex->rgba[2]) * dmax);
-  offs += (*action)(imap, 1);
-  
-  return offs;
-}
-
-/* Put vertex' alpha (8/16bit) in shader stream */
-
-static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex, 
-                                              size_t (*action)(unsigned long data, 
-                                                               size_t size),
-                                              int sigbyte)
-{
-  int offs = 0;
-  unsigned long imap;
-  double dmax = ~1UL;
-
-  /* FIXME: temp bux fix for 64 bit archs: */
-  if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
-
-  if(sigbyte != 8 && sigbyte != 16)
-    sigbyte = 8;
-        
-  sigbyte /= 8;
-  
-  imap = (unsigned long)((vertex->rgba[3]) * dmax);
-  
-  offs += (*action)(imap, sigbyte);
-  
-  return offs;
-}
-
-/* Put a triangles raw data in shader stream */
-
-static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle, 
-                                         GLfloat dx, GLfloat dy, 
-                                         GLfloat xmin, GLfloat ymin,
-                                         size_t (*action)(unsigned long data, 
-                                                          size_t size),
-                                         int gray)
-{
-  int i, offs = 0;
-  GL2PSvertex v;
-  
-  if(gray && gray != 8 && gray != 16)
-    gray = 8;
-  
-  for(i = 0; i < 3; ++i){
-    offs += gl2psPrintPDFShaderStreamDataCoord(&triangle->vertex[i], action,
-                                               dx, dy, xmin, ymin);
-    if(gray){ 
-      v = triangle->vertex[i];
-      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray); 
-    }
-    else{
-      offs += gl2psPrintPDFShaderStreamDataRGB(&triangle->vertex[i], action);
-    }
-  }
-  
-  return offs;
-}
-
-static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax, 
-                             GLfloat *ymin, GLfloat *ymax, 
-                             GL2PStriangle *triangles, int cnt)
-{
-  int i, j;
-
-  *xmin = triangles[0].vertex[0].xyz[0];
-  *xmax = triangles[0].vertex[0].xyz[0];
-  *ymin = triangles[0].vertex[0].xyz[1];
-  *ymax = triangles[0].vertex[0].xyz[1];
-  
-  for(i = 0; i < cnt; ++i){
-    for(j = 0; j < 3; ++j){
-      if(*xmin > triangles[i].vertex[j].xyz[0])
-        *xmin = triangles[i].vertex[j].xyz[0];
-      if(*xmax < triangles[i].vertex[j].xyz[0])
-        *xmax = triangles[i].vertex[j].xyz[0];
-      if(*ymin > triangles[i].vertex[j].xyz[1])
-        *ymin = triangles[i].vertex[j].xyz[1];
-      if(*ymax < triangles[i].vertex[j].xyz[1])
-        *ymax = triangles[i].vertex[j].xyz[1];
-    }
-  }
-}
-
-/* Writes shaded triangle 
-   gray == 0 means write RGB triangles
-   gray == 8             8bit-grayscale (for alpha masks)
-   gray == 16            16bit-grayscale (for alpha masks) */
-
-static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles, 
-                               int size, int gray)
-{
-  int i, offs = 0, vertexbytes, done = 0;
-  GLfloat xmin, xmax, ymin, ymax;
-        
-  switch(gray){
-  case 0:
-    vertexbytes = 1+4+4+1+1+1;
-    break;
-  case 8:
-    vertexbytes = 1+4+4+1;
-    break;
-  case 16:
-    vertexbytes = 1+4+4+2;
-    break;
-  default:
-    gray = 8;
-    vertexbytes = 1+4+4+1;
-    break;
-  }
-  
-  gl2psPDFRectHull(&xmin, &xmax, &ymin, &ymax, triangles, size);
-  
-  offs += fprintf(gl2ps->stream,
-                  "%d 0 obj\n"
-                  "<< "
-                  "/ShadingType 4 "
-                  "/ColorSpace %s "
-                  "/BitsPerCoordinate 32 "
-                  "/BitsPerComponent %d "
-                  "/BitsPerFlag 8 "
-                  "/Decode [%f %f %f %f 0 1 %s] ",
-                  obj,
-                  (gray) ? "/DeviceGray" : "/DeviceRGB", 
-                  (gray) ? gray : 8,
-                  xmin, xmax, ymin, ymax,
-                  (gray) ? "" : "0 1 0 1");
-  
-#if defined(GL2PS_HAVE_ZLIB)
-  if(gl2ps->options & GL2PS_COMPRESS){
-    gl2psAllocCompress(vertexbytes * size * 3);
-
-    for(i = 0; i < size; ++i)
-      gl2psPrintPDFShaderStreamData(&triangles[i],
-                                    xmax-xmin, ymax-ymin, xmin, ymin, 
-                                    gl2psWriteBigEndianCompress, gray);
-
-    if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
-      offs += gl2psPrintPDFCompressorType();
-      offs += fprintf(gl2ps->stream,
-                      "/Length %d "
-                      ">>\n"
-                      "stream\n",
-                      (int)gl2ps->compress->destLen);
-      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, 
-                                                gl2ps->compress->destLen, 
-                                                1, gl2ps->stream);
-      done = 1;
-    }
-    gl2psFreeCompress();
-  }
-#endif
-
-  if(!done){
-    /* no compression, or too long after compression, or compress error
-       -> write non-compressed entry */
-    offs += fprintf(gl2ps->stream,
-                    "/Length %d "
-                    ">>\n"
-                    "stream\n",
-                    vertexbytes * 3 * size);
-    for(i = 0; i < size; ++i)
-      offs += gl2psPrintPDFShaderStreamData(&triangles[i],
-                                            xmax-xmin, ymax-ymin, xmin, ymin,
-                                            gl2psWriteBigEndian, gray);
-  }
-  
-  offs += fprintf(gl2ps->stream,
-                  "\nendstream\n"
-                  "endobj\n");
-  
-  return offs;
-}
-
-/* Writes a XObject for a shaded triangle mask */
-
-static int gl2psPrintPDFShaderMask(int obj, int childobj)
-{
-  int offs = 0, len;
-  
-  offs += fprintf(gl2ps->stream,
-                  "%d 0 obj\n"
-                  "<<\n"
-                  "/Type /XObject\n"
-                  "/Subtype /Form\n"
-                  "/BBox [ %d %d %d %d ]\n"
-                  "/Group \n<<\n/S /Transparency /CS /DeviceRGB\n"
-                  ">>\n",
-                  obj,
-                  (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
-                  (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-  
-  len = (childobj>0) 
-    ? strlen("/TrSh sh\n") + (int)log10((double)childobj)+1
-    : strlen("/TrSh0 sh\n"); 
-  
-  offs += fprintf(gl2ps->stream,
-                  "/Length %d\n"
-                  ">>\n"
-                  "stream\n",
-                  len);
-  offs += fprintf(gl2ps->stream,
-                  "/TrSh%d sh\n",
-                  childobj);
-  offs += fprintf(gl2ps->stream,
-                  "endstream\n"
-                  "endobj\n");
-  
-  return offs;
-}
-
-/* Writes a Extended graphics state for a shaded triangle mask if
-   simplealpha ist true the childobj argument is ignored and a /ca
-   statement will be written instead */
-
-static int gl2psPrintPDFShaderExtGS(int obj, int childobj)
-{
-  int offs = 0;
-  
-  offs += fprintf(gl2ps->stream,
-                  "%d 0 obj\n"
-                  "<<\n",
-                  obj);
-  
-  offs += fprintf(gl2ps->stream,
-                  "/SMask << /S /Alpha /G %d 0 R >> ",
-                  childobj);
-  
-  offs += fprintf(gl2ps->stream,
-                  ">>\n"
-                  "endobj\n");
-  return offs;
-}
-
-/* a simple graphics state */
-
-static int gl2psPrintPDFShaderSimpleExtGS(int obj, GLfloat alpha)
-{
-  int offs = 0;
-  
-  offs += fprintf(gl2ps->stream,
-                  "%d 0 obj\n"
-                  "<<\n"
-                  "/ca %g"
-                  ">>\n"
-                  "endobj\n",
-                  obj, alpha);
-  return offs;
-}
-
-/* Similar groups of functions for pixmaps and text */
-
-static int gl2psPrintPDFPixmapStreamData(GL2PSimage *im,
-                                         size_t (*action)(unsigned long data, 
-                                                          size_t size), 
-                                         int gray)
-{
-  int x, y;
-  GLfloat r, g, b, a;
-
-  if(im->format != GL_RGBA && gray)
-    return 0;
-
-  if(gray && gray !=8 && gray != 16)
-    gray = 8;
-
-  gray /= 8;
-  
-  for(y = 0; y < im->height; ++y){
-    for(x = 0; x < im->width; ++x){
-      a = gl2psGetRGB(im, x, y, &r, &g, &b);
-      if(im->format == GL_RGBA && gray){
-        (*action)((unsigned long)(a*255) << 24, gray);
-      }
-      else{
-        (*action)((unsigned long)(r*255) << 24, 1);
-        (*action)((unsigned long)(g*255) << 24, 1);
-        (*action)((unsigned long)(b*255) << 24, 1);
-      }
-    }
-  }
-
-  switch(gray){
-  case 0: return 3 * im->width * im->height;
-  case 1: return im->width * im->height;
-  case 2: return 2 * im->width * im->height;
-  default: return 3 * im->width * im->height;
-  }
-}
-
-static int gl2psPrintPDFPixmap(int obj, int childobj, GL2PSimage *im, int gray)
-{
-  int offs = 0, done = 0, sigbytes = 3;
-
-  if(gray && gray !=8 && gray != 16)
-    gray = 8;
-  
-  if(gray)
-    sigbytes = gray / 8; 
-  
-  offs += fprintf(gl2ps->stream,
-                  "%d 0 obj\n"
-                  "<<\n"
-                  "/Type /XObject\n"
-                  "/Subtype /Image\n"
-                  "/Width %d\n"
-                  "/Height %d\n"
-                  "/ColorSpace %s \n"
-                  "/BitsPerComponent 8\n",
-                  obj,
-                  (int)im->width, (int)im->height,
-                  (gray) ? "/DeviceGray" : "/DeviceRGB" );
-  if(GL_RGBA == im->format && gray == 0){
-    offs += fprintf(gl2ps->stream,
-                    "/SMask %d 0 R\n",
-                    childobj);
-  }
-  
-#if defined(GL2PS_HAVE_ZLIB)
-  if(gl2ps->options & GL2PS_COMPRESS){
-    gl2psAllocCompress((int)(im->width * im->height * sigbytes));
-    
-    gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndianCompress, gray);
-    
-    if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
-      offs += gl2psPrintPDFCompressorType();
-      offs += fprintf(gl2ps->stream,
-                      "/Length %d "
-                      ">>\n"
-                      "stream\n",
-                      (int)gl2ps->compress->destLen);
-      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, gl2ps->compress->destLen,
-                                                1, gl2ps->stream);
-      done = 1;
-    }
-    gl2psFreeCompress();
-  }
-#endif
-  
-  if(!done){
-    /* no compression, or too long after compression, or compress error
-       -> write non-compressed entry */
-    offs += fprintf(gl2ps->stream,
-                    "/Length %d "
-                    ">>\n"
-                    "stream\n",
-                    (int)(im->width * im->height * sigbytes));
-    offs += gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndian, gray);
-  }
-  
-  offs += fprintf(gl2ps->stream,
-                  "\nendstream\n"
-                  "endobj\n");
-  
-  return offs;
-}
-
-static int gl2psPrintPDFText(int obj, GL2PSstring *s, int fontnumber)
-{
-  int offs = 0;
-  
-  offs += fprintf(gl2ps->stream,
-                  "%d 0 obj\n"
-                  "<<\n"
-                  "/Type /Font\n"
-                  "/Subtype /Type1\n"
-                  "/Name /F%d\n"
-                  "/BaseFont /%s\n"
-                  "/Encoding /MacRomanEncoding\n"
-                  ">>\n"
-                  "endobj\n",
-                  obj, fontnumber, s->fontname);
-  return offs;
-}
-
-/* Write the physical objects */
-
-static int gl2psPDFgroupListWriteObjects(int entryoffs)
-{
-  int i,j;
-  GL2PSprimitive *p = NULL;
-  GL2PSpdfgroup *gro;
-  int offs = entryoffs;
-  GL2PStriangle *triangles;
-  int size = 0;
-
-  if(!gl2ps->pdfgrouplist)
-    return offs;
-  
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
-    if(!gl2psListNbr(gro->ptrlist))
-      continue;
-    p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
-    switch(p->type){
-    case GL2PS_POINT:
-      break;
-    case GL2PS_LINE:
-      break;
-    case GL2PS_TRIANGLE:
-      size = gl2psListNbr(gro->ptrlist);
-      triangles = (GL2PStriangle*)gl2psMalloc(sizeof(GL2PStriangle) * size);
-      for(j = 0; j < size; ++j){  
-        p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        gl2psFillTriangleFromPrimitive(&triangles[j], p, GL_TRUE);
-      }
-      if(triangles[0].prop & T_VAR_COLOR){
-        gl2ps->xreflist[gro->shobjno] = offs;
-        offs += gl2psPrintPDFShader(gro->shobjno, triangles, size, 0);
-      }
-      if(triangles[0].prop & T_ALPHA_LESS_1){
-        gl2ps->xreflist[gro->gsobjno] = offs;
-        offs += gl2psPrintPDFShaderSimpleExtGS(gro->gsobjno, triangles[0].vertex[0].rgba[3]);
-      }
-      if(triangles[0].prop & T_VAR_ALPHA){
-        gl2ps->xreflist[gro->gsobjno] = offs;
-        offs += gl2psPrintPDFShaderExtGS(gro->gsobjno, gro->trgroupobjno);
-        gl2ps->xreflist[gro->trgroupobjno] = offs;
-        offs += gl2psPrintPDFShaderMask(gro->trgroupobjno, gro->maskshno);
-        gl2ps->xreflist[gro->maskshobjno] = offs;
-        offs += gl2psPrintPDFShader(gro->maskshobjno, triangles, size, 8);
-      }
-      gl2psFree(triangles);
-      break;
-    case GL2PS_PIXMAP:
-      gl2ps->xreflist[gro->imobjno] = offs;
-      offs += gl2psPrintPDFPixmap(gro->imobjno, gro->imobjno+1, p->data.image, 0);
-      if(p->data.image->format == GL_RGBA){
-        gl2ps->xreflist[gro->imobjno+1] = offs;
-        offs += gl2psPrintPDFPixmap(gro->imobjno+1, -1, p->data.image, 8);
-      }
-      break;
-    case GL2PS_TEXT:
-      gl2ps->xreflist[gro->fontobjno] = offs;
-      offs += gl2psPrintPDFText(gro->fontobjno,p->data.text,gro->fontno);
-      break;
-    case GL2PS_SPECIAL :
-      /* alignment contains the format for which the special output text
-         is intended */
-      if(p->data.text->alignment == GL2PS_PDF)
-        offs += fprintf(gl2ps->stream, "%s\n", p->data.text->str);
-      break;
-    default:
-      break;
-    } 
-  }
-  return offs;
-}
-
-/* All variable data has been written at this point and all required
-   functioninality has been gathered, so we can write now file footer
-   with cross reference table and trailer */
-
-static void gl2psPrintPDFFooter(void)
-{
-  int i, offs;  
-
-  gl2psPDFgroupListInit();
-  gl2psPDFgroupListWriteMainStream();
- 
-  offs = gl2ps->xreflist[5] + gl2ps->streamlength; 
-  offs += gl2psClosePDFDataStream();
-  gl2ps->xreflist[5] = offs;
-  
-  offs += gl2psPrintPDFDataStreamLength(gl2ps->streamlength);
-  gl2ps->xreflist[6] = offs;
-  gl2ps->streamlength = 0;
-  
-  offs += gl2psPrintPDFOpenPage();
-  offs += gl2psPDFgroupListWriteVariableResources();
-  gl2ps->xreflist = (int*)gl2psRealloc(gl2ps->xreflist,
-                                       sizeof(int) * (gl2ps->objects_stack + 1));
-  gl2ps->xreflist[7] = offs;
-  
-  offs += gl2psPrintPDFGSObject();
-  gl2ps->xreflist[8] = offs;
-  
-  gl2ps->xreflist[gl2ps->objects_stack] = 
-    gl2psPDFgroupListWriteObjects(gl2ps->xreflist[8]);
-
-  /* Start cross reference table. The file has to been opened in
-     binary mode to preserve the 20 digit string length! */
-  fprintf(gl2ps->stream,
-          "xref\n"
-          "0 %d\n"
-          "%010d 65535 f \n", gl2ps->objects_stack, 0);
-  
-  for(i = 1; i < gl2ps->objects_stack; ++i)
-    fprintf(gl2ps->stream, "%010d 00000 n \n", gl2ps->xreflist[i]);
-  
-  fprintf(gl2ps->stream,
-          "trailer\n"
-          "<<\n" 
-          "/Size %d\n"
-          "/Info 1 0 R\n"
-          "/Root 2 0 R\n"
-          ">>\n"
-          "startxref\n%d\n"
-          "%%%%EOF\n",
-          gl2ps->objects_stack, gl2ps->xreflist[gl2ps->objects_stack]);
-  
-  /* Free auxiliary lists and arrays */    
-  gl2psFree(gl2ps->xreflist);
-  gl2psListAction(gl2ps->pdfprimlist, gl2psFreePrimitive);
-  gl2psListDelete(gl2ps->pdfprimlist);
-  gl2psPDFgroupListDelete();
-  
-#if defined(GL2PS_HAVE_ZLIB)
-  if(gl2ps->options & GL2PS_COMPRESS){
-    gl2psFreeCompress();
-    gl2psFree(gl2ps->compress);
-    gl2ps->compress = NULL;
-  }
-#endif
-}
-
-/* PDF begin viewport */
-
-static void gl2psPrintPDFBeginViewport(GLint viewport[4])
-{
-  int offs = 0;
-  GLint index;
-  GLfloat rgba[4];
-  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
-  
-  glRenderMode(GL_FEEDBACK);
-  
-  if(gl2ps->header){
-    gl2psPrintPDFHeader();
-    gl2ps->header = GL_FALSE;
-  }
-
-  offs += gl2psPrintf("q\n");
-  
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
-      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
-    }
-    else{
-      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
-      rgba[0] = gl2ps->colormap[index][0];
-      rgba[1] = gl2ps->colormap[index][1];
-      rgba[2] = gl2ps->colormap[index][2];
-      rgba[3] = 1.0F;
-    }
-    offs += gl2psPrintPDFFillColor(rgba);
-    offs += gl2psPrintf("%d %d %d %d re\n"
-                        "W\n"
-                        "f\n",
-                        x, y, w, h);
-  }
-  else{
-    offs += gl2psPrintf("%d %d %d %d re\n"
-                        "W\n"   
-                        "n\n",
-                        x, y, w, h);            
-  }
-  
-  gl2ps->streamlength += offs;
-}
-
-static GLint gl2psPrintPDFEndViewport(void)
-{
-  GLint res;
-  
-  res = gl2psPrintPrimitives();
-  gl2ps->streamlength += gl2psPrintf("Q\n");
-  return res;
-}
-
-static void gl2psPrintPDFFinalPrimitive(void)
-{
-}
-
-/* definition of the PDF backend */
-
-static GL2PSbackend gl2psPDF = {
-  gl2psPrintPDFHeader,
-  gl2psPrintPDFFooter,
-  gl2psPrintPDFBeginViewport,
-  gl2psPrintPDFEndViewport,
-  gl2psPrintPDFPrimitive,
-  gl2psPrintPDFFinalPrimitive,
-  "pdf",
-  "Portable Document Format"
-};
-
-/********************************************************************* 
- *
- * SVG routines
- *
- *********************************************************************/
-
-static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts, 
-                                       GL2PSxyz *xyz, GL2PSrgba *rgba)
-{
-  int i, j;
-
-  for(i = 0; i < n; i++){
-    xyz[i][0] = verts[i].xyz[0];
-    xyz[i][1] = gl2ps->viewport[3] - verts[i].xyz[1];
-    xyz[i][2] = 0.0F;
-    for(j = 0; j < 4; j++)
-      rgba[i][j] = verts[i].rgba[j];
-  }
-}
-
-static void gl2psSVGGetColorString(GL2PSrgba rgba, char str[32])
-{
-  int r = (int)(255. * rgba[0]);
-  int g = (int)(255. * rgba[1]);
-  int b = (int)(255. * rgba[2]);
-  int rc = (r < 0) ? 0 : (r > 255) ? 255 : r;
-  int gc = (g < 0) ? 0 : (g > 255) ? 255 : g;
-  int bc = (b < 0) ? 0 : (b > 255) ? 255 : b;
-  sprintf(str, "#%2.2x%2.2x%2.2x", rc, gc, bc);
-}
-
-static void gl2psPrintSVGHeader(void)
-{
-  int x, y, width, height;
-  char col[32];
-  time_t now;
-  
-  time(&now);
-  
-  if (gl2ps->options & GL2PS_LANDSCAPE){
-    x = (int)gl2ps->viewport[1];
-    y = (int)gl2ps->viewport[0];
-    width = (int)gl2ps->viewport[3];
-    height = (int)gl2ps->viewport[2];
-  }
-  else{
-    x = (int)gl2ps->viewport[0];
-    y = (int)gl2ps->viewport[1];
-    width = (int)gl2ps->viewport[2];
-    height = (int)gl2ps->viewport[3];
-  }
-  
-  /* Compressed SVG files (.svgz) are simply gzipped SVG files */
-  gl2psPrintGzipHeader();
-  
-  gl2psPrintf("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");
-  gl2psPrintf("<svg xmlns=\"http://www.w3.org/2000/svg\"\n");
-  gl2psPrintf("     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n"
-              "     width=\"%dpx\" height=\"%dpx\" viewBox=\"%d %d %d %d\">\n",
-              width, height, x, y, width, height);
-  gl2psPrintf("<title>%s</title>\n", gl2ps->title);
-  gl2psPrintf("<desc>\n");
-  gl2psPrintf("Creator: GL2PS %d.%d.%d%s, %s\n"
-              "For: %s\n"
-              "CreationDate: %s",
-              GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION,
-              GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT, gl2ps->producer, ctime(&now));
-  gl2psPrintf("</desc>\n");
-  gl2psPrintf("<defs>\n");
-  gl2psPrintf("</defs>\n");
-
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    gl2psSVGGetColorString(gl2ps->bgcolor, col);
-    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], 
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1], 
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
-  }
-
-  /* group all the primitives and disable antialiasing */
-  gl2psPrintf("<g shape-rendering=\"crispEdges\">\n");
-}
-
-static void gl2psPrintSVGSmoothTriangle(GL2PSxyz xyz[3], GL2PSrgba rgba[3])
-{
-  int i;
-  GL2PSxyz xyz2[3];
-  GL2PSrgba rgba2[3];
-  char col[32];
-
-  /* Apparently there is no easy way to do Gouraud shading in SVG
-     without explicitly pre-defining gradients, so for now we just do
-     recursive subdivision */
-
-  if(gl2psSameColorThreshold(3, rgba, gl2ps->threshold)){
-    gl2psSVGGetColorString(rgba[0], col);
-    gl2psPrintf("<polygon fill=\"%s\" ", col);
-    if(rgba[0][3] < 1.0F) gl2psPrintf("fill-opacity=\"%g\" ", rgba[0][3]);
-    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1], 
-                xyz[1][0], xyz[1][1], xyz[2][0], xyz[2][1]);
-  }
-  else{
-    /* subdivide into 4 subtriangles */
-    for(i = 0; i < 3; i++){
-      xyz2[0][i] = xyz[0][i]; 
-      xyz2[1][i] = 0.5 * (xyz[0][i] + xyz[1][i]);
-      xyz2[2][i] = 0.5 * (xyz[0][i] + xyz[2][i]);
-    }
-    for(i = 0; i < 4; i++){
-      rgba2[0][i] = rgba[0][i]; 
-      rgba2[1][i] = 0.5 * (rgba[0][i] + rgba[1][i]);
-      rgba2[2][i] = 0.5 * (rgba[0][i] + rgba[2][i]);
-    }
-    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
-    for(i = 0; i < 3; i++){
-      xyz2[0][i] = 0.5 * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = xyz[1][i]; 
-      xyz2[2][i] = 0.5 * (xyz[1][i] + xyz[2][i]);
-    }
-    for(i = 0; i < 4; i++){
-      rgba2[0][i] = 0.5 * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = rgba[1][i]; 
-      rgba2[2][i] = 0.5 * (rgba[1][i] + rgba[2][i]);
-    }
-    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
-    for(i = 0; i < 3; i++){
-      xyz2[0][i] = 0.5 * (xyz[0][i] + xyz[2][i]);
-      xyz2[1][i] = xyz[2][i]; 
-      xyz2[2][i] = 0.5 * (xyz[1][i] + xyz[2][i]);
-    }
-    for(i = 0; i < 4; i++){
-      rgba2[0][i] = 0.5 * (rgba[0][i] + rgba[2][i]);
-      rgba2[1][i] = rgba[2][i]; 
-      rgba2[2][i] = 0.5 * (rgba[1][i] + rgba[2][i]);
-    }
-    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
-    for(i = 0; i < 3; i++){
-      xyz2[0][i] = 0.5 * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = 0.5 * (xyz[1][i] + xyz[2][i]); 
-      xyz2[2][i] = 0.5 * (xyz[0][i] + xyz[2][i]);
-    }
-    for(i = 0; i < 4; i++){
-      rgba2[0][i] = 0.5 * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = 0.5 * (rgba[1][i] + rgba[2][i]); 
-      rgba2[2][i] = 0.5 * (rgba[0][i] + rgba[2][i]);
-    }
-    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
-  }
-}
-
-static void gl2psPrintSVGDash(GLushort pattern, GLint factor)
-{
-  int i, n, array[10];
-
-  if(!pattern || !factor) return; /* solid line */
-
-  gl2psParseStipplePattern(pattern, factor, &n, array);
-  gl2psPrintf("stroke-dasharray=\"");
-  for(i = 0; i < n; i++){
-    if(i) gl2psPrintf(",");
-    gl2psPrintf("%d", array[i]);
-  }
-  gl2psPrintf("\" ");
-}
-
-static void gl2psEndSVGLine(void)
-{
-  int i;
-  if(gl2ps->lastvertex.rgba[0] >= 0.){
-    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0], 
-                gl2ps->viewport[3] - gl2ps->lastvertex.xyz[1]);
-    for(i = 0; i < 3; i++)
-      gl2ps->lastvertex.xyz[i] = -1.;
-    for(i = 0; i < 4; i++)
-      gl2ps->lastvertex.rgba[i] = -1.;
-  }
-}
-
-static void gl2psPrintSVGPixmap(GLfloat /*x*/, GLfloat /*y*/, GL2PSimage * /*pixmap*/)
-{
-#if defined(GL2PS_HAVE_LIBPNG)
-  GL2PSlist *png;
-  unsigned char c;
-  int i;
-
-  /* The only image types supported by the SVG standard are JPEG, PNG
-     and SVG. Here we choose PNG, and since we want to embed the image
-     directly in the SVG stream (and not link to an external image
-     file), we need to encode the pixmap into PNG in memory, then
-     encode it into base64. */
-
-  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000, 
-                        sizeof(unsigned char));
-  gl2psConvertPixmapToPNG(pixmap, png);
-  gl2psListEncodeBase64(png);
-  gl2psPrintf("<image x=\"%g\" y=\"%g\" width=\"%d\" height=\"%d\"\n",
-              x, y - pixmap->height, pixmap->width, pixmap->height);
-  gl2psPrintf("xlink:href=\"data:image/png;base64,");
-  for(i = 0; i < gl2psListNbr(png); i++){
-    gl2psListRead(png, i, &c);
-    gl2psPrintf("%c", c);
-  }
-  gl2psPrintf("\"/>\n");
-  gl2psListDelete(png);
-#else
-  gl2psMsg(GL2PS_WARNING, "GL2PS has to be compiled with PNG support in "
-           "order to embed images in SVG streams");
-#endif
-}
-
-static void gl2psPrintSVGPrimitive(void *data)
-{
-  GL2PSprimitive *prim;
-  GL2PSxyz xyz[4];
-  GL2PSrgba rgba[4];
-  char col[32];
-  int newline;
-
-  prim = *(GL2PSprimitive**)data;
-
-  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) return;
-
-  /* We try to draw connected lines as a single path to get nice line
-     joins and correct stippling. So if the primitive to print is not
-     a line we must first finish the current line (if any): */
-  if(prim->type != GL2PS_LINE) gl2psEndSVGLine();
-
-  gl2psSVGGetCoordsAndColors(prim->numverts, prim->verts, xyz, rgba);
-
-  switch(prim->type){
-  case GL2PS_POINT :
-    gl2psSVGGetColorString(rgba[0], col);
-    gl2psPrintf("<circle fill=\"%s\" ", col);
-    if(rgba[0][3] < 1.0F) gl2psPrintf("fill-opacity=\"%g\" ", rgba[0][3]);
-    gl2psPrintf("cx=\"%g\" cy=\"%g\" r=\"%g\"/>\n",
-                xyz[0][0], xyz[0][1], 0.5 * prim->width);
-    break;
-  case GL2PS_LINE :
-    if(!gl2psSamePosition(gl2ps->lastvertex.xyz, prim->verts[0].xyz) ||
-       !gl2psSameColor(gl2ps->lastrgba, prim->verts[0].rgba) ||
-       gl2ps->lastlinewidth != prim->width ||
-       gl2ps->lastpattern != prim->pattern ||
-       gl2ps->lastfactor != prim->factor){
-      /* End the current line if the new segment does not start where
-         the last one ended, or if the color, the width or the
-         stippling have changed (we will need to use multi-point
-         gradients for smooth-shaded lines) */
-      gl2psEndSVGLine();
-      newline = 1;
-    }
-    else{
-      newline = 0;
-    }
-    gl2ps->lastvertex = prim->verts[1];
-    gl2psSetLastColor(prim->verts[0].rgba);
-    gl2ps->lastlinewidth = prim->width;
-    gl2ps->lastpattern = prim->pattern;
-    gl2ps->lastfactor = prim->factor;
-    if(newline){
-      gl2psSVGGetColorString(rgba[0], col);
-      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ", 
-                  col, prim->width);
-      if(rgba[0][3] < 1.0F) gl2psPrintf("stroke-opacity=\"%g\" ", rgba[0][3]);
-      gl2psPrintSVGDash(prim->pattern, prim->factor);
-      gl2psPrintf("points=\"%g,%g ", xyz[0][0], xyz[0][1]);
-    }
-    else{
-      gl2psPrintf("%g,%g ", xyz[0][0], xyz[0][1]);
-    }
-    break;
-  case GL2PS_TRIANGLE :
-    gl2psPrintSVGSmoothTriangle(xyz, rgba);
-    break;
-  case GL2PS_QUADRANGLE :
-    gl2psMsg(GL2PS_WARNING, "There should not be any quad left to print");
-    break;
-  case GL2PS_PIXMAP :
-    gl2psPrintSVGPixmap(xyz[0][0], xyz[0][1], prim->data.image);
-    break;
-  case GL2PS_TEXT :
-    gl2psSVGGetColorString(prim->verts[0].rgba, col);
-    gl2psPrintf("<text fill=\"%s\" x=\"%g\" y=\"%g\" font-size=\"%d\" ",
-                col, xyz[0][0], xyz[0][1], prim->data.text->fontsize);
-    if(!strcmp(prim->data.text->fontname, "Times-Roman"))
-      gl2psPrintf("font-family=\"Times\">");
-    else if(!strcmp(prim->data.text->fontname, "Times-Bold"))
-      gl2psPrintf("font-family=\"Times\" font-weight=\"bold\">");
-    else if(!strcmp(prim->data.text->fontname, "Times-Italic"))
-      gl2psPrintf("font-family=\"Times\" font-style=\"italic\">");
-    else if(!strcmp(prim->data.text->fontname, "Times-BoldItalic"))
-      gl2psPrintf("font-family=\"Times\" font-style=\"italic\" font-weight=\"bold\">");
-    else if(!strcmp(prim->data.text->fontname, "Helvetica-Bold"))
-      gl2psPrintf("font-family=\"Helvetica\" font-weight=\"bold\">");
-    else if(!strcmp(prim->data.text->fontname, "Helvetica-Oblique"))
-      gl2psPrintf("font-family=\"Helvetica\" font-style=\"oblique\">");
-    else if(!strcmp(prim->data.text->fontname, "Helvetica-BoldOblique"))
-      gl2psPrintf("font-family=\"Helvetica\" font-style=\"oblique\" font-weight=\"bold\">");
-    else if(!strcmp(prim->data.text->fontname, "Courier-Bold"))
-      gl2psPrintf("font-family=\"Courier\" font-weight=\"bold\">");
-    else if(!strcmp(prim->data.text->fontname, "Courier-Oblique"))
-      gl2psPrintf("font-family=\"Courier\" font-style=\"oblique\">");
-    else if(!strcmp(prim->data.text->fontname, "Courier-BoldOblique"))
-      gl2psPrintf("font-family=\"Courier\" font-style=\"oblique\" font-weight=\"bold\">");
-    else
-      gl2psPrintf("font-family=\"%s\">", prim->data.text->fontname);
-    gl2psPrintf("%s</text>\n", prim->data.text->str);
-    break;
-  case GL2PS_SPECIAL :
-    /* alignment contains the format for which the special output text
-       is intended */
-    if(prim->data.text->alignment == GL2PS_SVG)
-      gl2psPrintf("%s\n", prim->data.text->str);
-    break;
-  default :
-    break;
-  }
-}
-
-static void gl2psPrintSVGFooter(void)
-{
-  gl2psPrintf("</g>\n");
-  gl2psPrintf("</svg>\n");  
-  
-  gl2psPrintGzipFooter();
-}
-
-static void gl2psPrintSVGBeginViewport(GLint viewport[4])
-{
-  GLint index;
-  char col[32];
-  GLfloat rgba[4];
-  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
-
-  glRenderMode(GL_FEEDBACK);
-  
-  if(gl2ps->header){
-    gl2psPrintSVGHeader();
-    gl2ps->header = GL_FALSE;
-  }
-
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
-      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
-    }
-    else{
-      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
-      rgba[0] = gl2ps->colormap[index][0];
-      rgba[1] = gl2ps->colormap[index][1];
-      rgba[2] = gl2ps->colormap[index][2];
-      rgba[3] = 1.0F;
-    }
-    gl2psSVGGetColorString(rgba, col);
-    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col, 
-                x, gl2ps->viewport[3] - y, 
-                x + w, gl2ps->viewport[3] - y, 
-                x + w, gl2ps->viewport[3] - (y + h), 
-                x, gl2ps->viewport[3] - (y + h));
-  }
-
-  gl2psPrintf("<clipPath id=\"cp%d%d%d%d\">\n", x, y, w, h);
-  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", 
-              x, gl2ps->viewport[3] - y, 
-              x + w, gl2ps->viewport[3] - y, 
-              x + w, gl2ps->viewport[3] - (y + h), 
-              x, gl2ps->viewport[3] - (y + h));
-  gl2psPrintf("</clipPath>\n");
-  gl2psPrintf("<g clip-path=\"url(#cp%d%d%d%d)\">\n", x, y, w, h);
-}
-
-static GLint gl2psPrintSVGEndViewport(void)
-{
-  GLint res;
-
-  res = gl2psPrintPrimitives();
-  gl2psPrintf("</g>\n");
-  return res;
-}
-
-static void gl2psPrintSVGFinalPrimitive(void)
-{
-  /* End any remaining line, if any */
-  gl2psEndSVGLine();
-}
-
-/* definition of the SVG backend */
-
-static GL2PSbackend gl2psSVG = {
-  gl2psPrintSVGHeader,
-  gl2psPrintSVGFooter,
-  gl2psPrintSVGBeginViewport,
-  gl2psPrintSVGEndViewport,
-  gl2psPrintSVGPrimitive,
-  gl2psPrintSVGFinalPrimitive,
-  "svg",
-  "Scalable Vector Graphics"
-};
-
-/*********************************************************************
- *
- * PGF routines
- *
- *********************************************************************/
-
-static void gl2psPrintPGFColor(GL2PSrgba rgba)
-{
-  if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
-    gl2psSetLastColor(rgba);
-    fprintf(gl2ps->stream, "\\color[rgb]{%f,%f,%f}\n", rgba[0], rgba[1], rgba[2]);
-  }
-}
-
-static void gl2psPrintPGFHeader(void)
-{
-  time_t now;
-
-  time(&now);
-
-  fprintf(gl2ps->stream, 
-          "%% Title: %s\n"
-          "%% Creator: GL2PS %d.%d.%d%s, %s\n"
-          "%% For: %s\n"
-          "%% CreationDate: %s",
-          gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
-          GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
-          gl2ps->producer, ctime(&now));
-
-  fprintf(gl2ps->stream, "\\begin{pgfpicture}\n");
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    gl2psPrintPGFColor(gl2ps->bgcolor);
-    fprintf(gl2ps->stream,
-            "\\pgfpathrectanglecorners{"
-            "\\pgfpoint{%dpt}{%dpt}}{\\pgfpoint{%dpt}{%dpt}}\n"
-            "\\pgfusepath{fill}\n",
-            (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
-            (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-  }
-}
-
-static void gl2psPrintPGFDash(GLushort pattern, GLint factor)
-{
-  int i, n, array[10];
-
-  if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
-    return;
-
-  gl2ps->lastpattern = pattern;
-  gl2ps->lastfactor = factor;
-
-  if(!pattern || !factor){
-    /* solid line */
-    fprintf(gl2ps->stream, "\\pgfsetdash{}{0pt}\n");
-  }
-  else{
-    gl2psParseStipplePattern(pattern, factor, &n, array);
-    fprintf(gl2ps->stream, "\\pgfsetdash{");
-    for(i = 0; i < n; i++) fprintf(gl2ps->stream, "{%dpt}", array[i]);
-    fprintf(gl2ps->stream, "}{0pt}\n");
-  }
-}
-
-static const char *gl2psPGFTextAlignment(int align)
-{
-  switch(align){
-  case GL2PS_TEXT_C  : return "center";
-  case GL2PS_TEXT_CL : return "west";
-  case GL2PS_TEXT_CR : return "east";
-  case GL2PS_TEXT_B  : return "south";
-  case GL2PS_TEXT_BR : return "south east";
-  case GL2PS_TEXT_T  : return "north";
-  case GL2PS_TEXT_TL : return "north west";
-  case GL2PS_TEXT_TR : return "north east";
-  case GL2PS_TEXT_BL : 
-  default            : return "south west";
-  }
-}
-
-static void gl2psPrintPGFPrimitive(void *data)
-{
-  GL2PSprimitive *prim;
-
-  prim = *(GL2PSprimitive**)data;
-
-  switch(prim->type){
-  case GL2PS_POINT :
-    /* Points in openGL are rectangular */
-    gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream, 
-            "\\pgfpathrectangle{\\pgfpoint{%fpt}{%fpt}}"
-            "{\\pgfpoint{%fpt}{%fpt}}\n\\pgfusepath{fill}\n",
-            prim->verts[0].xyz[0]-0.5*prim->width,
-            prim->verts[0].xyz[1]-0.5*prim->width,
-            prim->width,prim->width);
-    break;
-  case GL2PS_LINE :
-    gl2psPrintPGFColor(prim->verts[0].rgba);
-    if(gl2ps->lastlinewidth != prim->width){
-      gl2ps->lastlinewidth = prim->width;
-      fprintf(gl2ps->stream, "\\pgfsetlinewidth{%fpt}\n", gl2ps->lastlinewidth);
-    }
-    gl2psPrintPGFDash(prim->pattern, prim->factor);
-    fprintf(gl2ps->stream, 
-            "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
-            "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
-            "\\pgfusepath{stroke}\n",
-            prim->verts[1].xyz[0], prim->verts[1].xyz[1],
-            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-    break;
-  case GL2PS_TRIANGLE :
-    if(gl2ps->lastlinewidth != 0){
-      gl2ps->lastlinewidth = 0;
-      fprintf(gl2ps->stream, "\\pgfsetlinewidth{0.01pt}\n");
-    }
-    gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream, 
-            "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
-            "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
-            "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
-            "\\pgfpathclose\n"
-            "\\pgfusepath{fill,stroke}\n",
-            prim->verts[2].xyz[0], prim->verts[2].xyz[1],
-            prim->verts[1].xyz[0], prim->verts[1].xyz[1],
-            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-    break;
-  case GL2PS_TEXT :
-    fprintf(gl2ps->stream, "{\n\\pgftransformshift{\\pgfpoint{%fpt}{%fpt}}\n",
-            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-
-    if(prim->data.text->angle)
-      fprintf(gl2ps->stream, "\\pgftransformrotate{%f}{", prim->data.text->angle);
-
-    fprintf(gl2ps->stream, "\\pgfnode{rectangle}{%s}{\\fontsize{%d}{0}\\selectfont",
-            gl2psPGFTextAlignment(prim->data.text->alignment),
-            prim->data.text->fontsize);
-
-    fprintf(gl2ps->stream, "\\textcolor[rgb]{%g,%g,%g}{{%s}}",
-            prim->verts[0].rgba[0], prim->verts[0].rgba[1],
-            prim->verts[0].rgba[2], prim->data.text->str);
-
-    fprintf(gl2ps->stream, "}{}{\\pgfusepath{discard}}}\n");
-    break;
-  case GL2PS_SPECIAL :
-    /* alignment contains the format for which the special output text
-       is intended */
-    if (prim->data.text->alignment == GL2PS_PGF)
-      fprintf(gl2ps->stream, "%s\n", prim->data.text->str);
-    break;
-  default :
-    break;
-  }
-}
-
-static void gl2psPrintPGFFooter(void)
-{
-  fprintf(gl2ps->stream, "\\end{pgfpicture}\n");
-}
-
-static void gl2psPrintPGFBeginViewport(GLint viewport[4])
-{
-  GLint index;
-  GLfloat rgba[4];
-  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
-
-  glRenderMode(GL_FEEDBACK);
-
-  if(gl2ps->header){
-    gl2psPrintPGFHeader();
-    gl2ps->header = GL_FALSE;
-  }
-
-  fprintf(gl2ps->stream, "\\begin{pgfscope}\n");
-  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
-    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
-      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
-    }
-    else{
-      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
-      rgba[0] = gl2ps->colormap[index][0];
-      rgba[1] = gl2ps->colormap[index][1];
-      rgba[2] = gl2ps->colormap[index][2];
-      rgba[3] = 1.0F;
-    }
-    gl2psPrintPGFColor(rgba);
-    fprintf(gl2ps->stream, 
-            "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
-            "{\\pgfpoint{%dpt}{%dpt}}\n"
-            "\\pgfusepath{fill}\n",
-            x, y, w, h);
-  }
-  
-  fprintf(gl2ps->stream, 
-          "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
-          "{\\pgfpoint{%dpt}{%dpt}}\n"
-          "\\pgfusepath{clip}\n",
-          x, y, w, h);
-}
-
-static GLint gl2psPrintPGFEndViewport(void)
-{
-  GLint res;
-  res = gl2psPrintPrimitives();
-  fprintf(gl2ps->stream, "\\end{pgfscope}\n");
-  return res;
-}
-
-static void gl2psPrintPGFFinalPrimitive(void)
-{
-}
-
-/* definition of the PGF backend */
-
-static GL2PSbackend gl2psPGF = {
-  gl2psPrintPGFHeader,
-  gl2psPrintPGFFooter,
-  gl2psPrintPGFBeginViewport,
-  gl2psPrintPGFEndViewport,
-  gl2psPrintPGFPrimitive,
-  gl2psPrintPGFFinalPrimitive,
-  "tex",
-  "PGF Latex Graphics"
-};
-
-/********************************************************************* 
- *
- * General primitive printing routine
- *
- *********************************************************************/
-
-/* Warning: the ordering of the backends must match the format
-   #defines in gl2ps.h */
-
-static GL2PSbackend *gl2psbackends[] = {
-  &gl2psPS,  /* 0 */
-  &gl2psEPS, /* 1 */
-  &gl2psTEX, /* 2 */
-  &gl2psPDF, /* 3 */
-  &gl2psSVG, /* 4 */
-  &gl2psPGF  /* 5 */
-};
-
-static void gl2psComputeTightBoundingBox(void *data)
-{
-  GL2PSprimitive *prim;
-  int i;
-
-  prim = *(GL2PSprimitive**)data;
-
-  for(i = 0; i < prim->numverts; i++){
-    if(prim->verts[i].xyz[0] < gl2ps->viewport[0])
-      gl2ps->viewport[0] = (GLint)prim->verts[i].xyz[0];
-    if(prim->verts[i].xyz[0] > gl2ps->viewport[2])
-      gl2ps->viewport[2] = (GLint)(prim->verts[i].xyz[0] + 0.5F);
-    if(prim->verts[i].xyz[1] < gl2ps->viewport[1])
-      gl2ps->viewport[1] = (GLint)prim->verts[i].xyz[1];
-    if(prim->verts[i].xyz[1] > gl2ps->viewport[3])
-      gl2ps->viewport[3] = (GLint)(prim->verts[i].xyz[1] + 0.5F);
-  }
-}  
-
-static GLint gl2psPrintPrimitives(void)
-{
-  GL2PSbsptree *root;
-  GL2PSxyz eye = {0.0F, 0.0F, 100.0F * GL2PS_ZSCALE};
-  GLint used;
-
-  used = glRenderMode(GL_RENDER);
-
-  if(used < 0){
-    gl2psMsg(GL2PS_INFO, "OpenGL feedback buffer overflow");
-    return GL2PS_OVERFLOW;
-  }
-
-  if(used > 0)
-    gl2psParseFeedbackBuffer(used);
-
-  gl2psRescaleAndOffset();
-
-  if(gl2ps->header){
-    if(gl2psListNbr(gl2ps->primitives) && 
-       (gl2ps->options & GL2PS_TIGHT_BOUNDING_BOX)){
-      gl2ps->viewport[0] = gl2ps->viewport[1] = 100000;
-      gl2ps->viewport[2] = gl2ps->viewport[3] = -100000;
-      gl2psListAction(gl2ps->primitives, gl2psComputeTightBoundingBox);
-    }
-    (gl2psbackends[gl2ps->format]->printHeader)();
-    gl2ps->header = GL_FALSE;
-  }
-
-  if(!gl2psListNbr(gl2ps->primitives)){
-    /* empty feedback buffer and/or nothing else to print */
-    return GL2PS_NO_FEEDBACK;
-  }
-
-  switch(gl2ps->sort){
-  case GL2PS_NO_SORT :
-    gl2psListAction(gl2ps->primitives, gl2psbackends[gl2ps->format]->printPrimitive);
-    gl2psListAction(gl2ps->primitives, gl2psFreePrimitive);
-    /* reset the primitive list, waiting for the next viewport */
-    gl2psListReset(gl2ps->primitives);
-    break;
-  case GL2PS_SIMPLE_SORT :
-    gl2psListSort(gl2ps->primitives, gl2psCompareDepth);
-    if(gl2ps->options & GL2PS_OCCLUSION_CULL){
-      gl2psListActionInverse(gl2ps->primitives, gl2psAddInImageTree);
-      gl2psFreeBspImageTree(&gl2ps->imagetree);
-    }
-    gl2psListAction(gl2ps->primitives, gl2psbackends[gl2ps->format]->printPrimitive);
-    gl2psListAction(gl2ps->primitives, gl2psFreePrimitive);
-    /* reset the primitive list, waiting for the next viewport */
-    gl2psListReset(gl2ps->primitives);
-    break;
-  case GL2PS_BSP_SORT :
-    root = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
-    gl2psBuildBspTree(root, gl2ps->primitives);
-    if(GL_TRUE == gl2ps->boundary) gl2psBuildPolygonBoundary(root);
-    if(gl2ps->options & GL2PS_OCCLUSION_CULL){
-      gl2psTraverseBspTree(root, eye, -GL2PS_EPSILON, gl2psLess,
-                           gl2psAddInImageTree, 1);
-      gl2psFreeBspImageTree(&gl2ps->imagetree);
-    }
-    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater, 
-                         gl2psbackends[gl2ps->format]->printPrimitive, 0);
-    gl2psFreeBspTree(&root);
-    /* reallocate the primitive list (it's been deleted by
-       gl2psBuildBspTree) in case there is another viewport */
-    gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
-    break;
-  }
-  gl2psbackends[gl2ps->format]->printFinalPrimitive();
-
-  return GL2PS_SUCCESS;
-}
-
-/********************************************************************* 
- *
- * Public routines
- *
- *********************************************************************/
-
-GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
-                                  GLint viewport[4], GLint format, GLint sort,
-                                  GLint options, GLint colormode,
-                                  GLint colorsize, GL2PSrgba *colormap,
-                                  GLint nr, GLint ng, GLint nb, GLint buffersize,
-                                  FILE *stream, const char *filename)
-{
-  GLint index;
-  int i;
-
-  if(gl2ps){
-    gl2psMsg(GL2PS_ERROR, "gl2psBeginPage called in wrong program state");
-    return GL2PS_ERROR;
-  }
-
-  gl2ps = (GL2PScontext*)gl2psMalloc(sizeof(GL2PScontext));
-
-  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends) / sizeof(gl2psbackends[0]))){
-    gl2ps->format = format;
-  }
-  else {
-    gl2psMsg(GL2PS_ERROR, "Unknown output format: %d", format);
-    gl2psFree(gl2ps);
-    gl2ps = NULL;
-    return GL2PS_ERROR;
-  }
-
-  switch(sort){
-  case GL2PS_NO_SORT :
-  case GL2PS_SIMPLE_SORT :
-  case GL2PS_BSP_SORT :
-    gl2ps->sort = sort;
-    break;
-  default :
-    gl2psMsg(GL2PS_ERROR, "Unknown sorting algorithm: %d", sort);
-    gl2psFree(gl2ps);
-    gl2ps = NULL;
-    return GL2PS_ERROR;
-  }
-
-  if(stream){
-    gl2ps->stream = stream;
-  }
-  else{
-    gl2psMsg(GL2PS_ERROR, "Bad file pointer");
-    gl2psFree(gl2ps);
-    gl2ps = NULL;
-    return GL2PS_ERROR;
-  }
-
-  gl2ps->header = GL_TRUE;
-  gl2ps->maxbestroot = 10;
-  gl2ps->options = options;
-  gl2ps->compress = NULL;
-  gl2ps->imagemap_head = NULL;
-  gl2ps->imagemap_tail = NULL;
-
-  if(gl2ps->options & GL2PS_USE_CURRENT_VIEWPORT){
-    glGetIntegerv(GL_VIEWPORT, gl2ps->viewport);
-  }
-  else{
-    for(i = 0; i < 4; i++){
-      gl2ps->viewport[i] = viewport[i];
-    }
-  }
-
-  if(!gl2ps->viewport[2] || !gl2ps->viewport[3]){
-    gl2psMsg(GL2PS_ERROR, "Incorrect viewport (x=%d, y=%d, width=%d, height=%d)",
-             gl2ps->viewport[0], gl2ps->viewport[1], 
-             gl2ps->viewport[2], gl2ps->viewport[3]);
-    gl2psFree(gl2ps);
-    gl2ps = NULL;
-    return GL2PS_ERROR;
-  }
-
-  gl2ps->threshold[0] = nr ? 1.0F / (GLfloat)nr : 0.064F;
-  gl2ps->threshold[1] = ng ? 1.0F / (GLfloat)ng : 0.034F;
-  gl2ps->threshold[2] = nb ? 1.0F / (GLfloat)nb : 0.100F;
-  gl2ps->colormode = colormode;
-  gl2ps->buffersize = buffersize > 0 ? buffersize : 2048 * 2048;
-  for(i = 0; i < 3; i++){
-    gl2ps->lastvertex.xyz[i] = -1.0F;
-  }
-  for(i = 0; i < 4; i++){
-    gl2ps->lastvertex.rgba[i] = -1.0F;
-    gl2ps->lastrgba[i] = -1.0F;
-  }
-  gl2ps->lastlinewidth = -1.0F;
-  gl2ps->lastpattern = 0;
-  gl2ps->lastfactor = 0;
-  gl2ps->imagetree = NULL;
-  gl2ps->primitivetoadd = NULL;
-  gl2ps->zerosurfacearea = GL_FALSE;  
-  gl2ps->pdfprimlist = NULL;
-  gl2ps->pdfgrouplist = NULL;
-  gl2ps->xreflist = NULL;
-  
-  /* get default blending mode from current OpenGL state (enabled by
-     default for SVG) */
-  gl2ps->blending = (gl2ps->format == GL2PS_SVG) ? GL_TRUE : glIsEnabled(GL_BLEND);
-  glGetIntegerv(GL_BLEND_SRC, &gl2ps->blendfunc[0]);
-  glGetIntegerv(GL_BLEND_DST, &gl2ps->blendfunc[1]);
-
-  if(gl2ps->colormode == GL_RGBA){
-    gl2ps->colorsize = 0;
-    gl2ps->colormap = NULL;
-    glGetFloatv(GL_COLOR_CLEAR_VALUE, gl2ps->bgcolor);
-  }
-  else if(gl2ps->colormode == GL_COLOR_INDEX){
-    if(!colorsize || !colormap){
-      gl2psMsg(GL2PS_ERROR, "Missing colormap for GL_COLOR_INDEX rendering");
-      gl2psFree(gl2ps);
-      gl2ps = NULL;
-      return GL2PS_ERROR;
-    }
-    gl2ps->colorsize = colorsize;
-    gl2ps->colormap = (GL2PSrgba*)gl2psMalloc(gl2ps->colorsize * sizeof(GL2PSrgba));
-    memcpy(gl2ps->colormap, colormap, gl2ps->colorsize * sizeof(GL2PSrgba));
-    glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
-    gl2ps->bgcolor[0] = gl2ps->colormap[index][0];
-    gl2ps->bgcolor[1] = gl2ps->colormap[index][1];
-    gl2ps->bgcolor[2] = gl2ps->colormap[index][2];
-    gl2ps->bgcolor[3] = 1.0F;
-  }
-  else{
-    gl2psMsg(GL2PS_ERROR, "Unknown color mode in gl2psBeginPage");
-    gl2psFree(gl2ps);
-    gl2ps = NULL;
-    return GL2PS_ERROR;
-  }
-
-  if(!title){
-    gl2ps->title = (char*)gl2psMalloc(sizeof(char));
-    gl2ps->title[0] = '\0';
-  }
-  else{
-    gl2ps->title = (char*)gl2psMalloc((strlen(title)+1)*sizeof(char));
-    strcpy(gl2ps->title, title);
-  }
-    
-  if(!producer){
-    gl2ps->producer = (char*)gl2psMalloc(sizeof(char));
-    gl2ps->producer[0] = '\0';
-  }
-  else{
-    gl2ps->producer = (char*)gl2psMalloc((strlen(producer)+1)*sizeof(char));
-    strcpy(gl2ps->producer, producer);
-  }
-  
-  if(!filename){
-    gl2ps->filename = (char*)gl2psMalloc(sizeof(char));
-    gl2ps->filename[0] = '\0';
-  }
-  else{
-    gl2ps->filename = (char*)gl2psMalloc((strlen(filename)+1)*sizeof(char));
-    strcpy(gl2ps->filename, filename);
-  }
-
-  gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
-  gl2ps->auxprimitives = gl2psListCreate(100, 100, sizeof(GL2PSprimitive*));
-  gl2ps->feedback = (GLfloat*)gl2psMalloc(gl2ps->buffersize * sizeof(GLfloat));
-  glFeedbackBuffer(gl2ps->buffersize, GL_3D_COLOR, gl2ps->feedback);
-  glRenderMode(GL_FEEDBACK);  
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psEndPage(void)
-{
-  GLint res;
-
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  res = gl2psPrintPrimitives();
-
-  if(res != GL2PS_OVERFLOW)
-    (gl2psbackends[gl2ps->format]->printFooter)();
-  
-  fflush(gl2ps->stream);
-
-  gl2psListDelete(gl2ps->primitives);
-  gl2psListDelete(gl2ps->auxprimitives);
-  gl2psFreeImagemap(gl2ps->imagemap_head);
-  gl2psFree(gl2ps->colormap);
-  gl2psFree(gl2ps->title);
-  gl2psFree(gl2ps->producer);
-  gl2psFree(gl2ps->filename);
-  gl2psFree(gl2ps->feedback);
-  gl2psFree(gl2ps);
-  gl2ps = NULL;
-
-  return res;
-}
-
-GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4])
-{
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  (gl2psbackends[gl2ps->format]->beginViewport)(viewport);
-  
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psEndViewport(void)
-{
-  GLint res;
-
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  res = (gl2psbackends[gl2ps->format]->endViewport)();
-
-  /* reset last used colors, line widths */
-  gl2ps->lastlinewidth = -1.0F;
-
-  return res;
-}
-
-GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
-                                GLshort fontsize, GLint alignment, GLfloat angle)
-{
-  return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, alignment, angle);
-}
-
-GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, GLshort fontsize)
-{
-  return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, GL2PS_TEXT_BL, 0.0F);
-}
-
-GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str)
-{
-  return gl2psAddText(GL2PS_SPECIAL, str, "", 0, format, 0.0F);
-}
-
-GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
-                                   GLint xorig, GLint yorig,
-                                   GLenum format, GLenum type, 
-                                   const void *pixels)
-{
-  int size, i;
-  GLfloat pos[4], *piv;
-  GL2PSprimitive *prim;
-  GLboolean valid;
-
-  if(!gl2ps || !pixels) return GL2PS_UNINITIALIZED;
-
-  if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
-
-  if(gl2ps->options & GL2PS_NO_PIXMAP) return GL2PS_SUCCESS;
-
-  if((format != GL_RGB && format != GL_RGBA) || type != GL_FLOAT){
-    gl2psMsg(GL2PS_ERROR, "gl2psDrawPixels only implemented for "
-             "GL_RGB/GL_RGBA, GL_FLOAT pixels");
-    return GL2PS_ERROR;
-  }
-
-  glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
-  if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */
-
-  glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
-
-  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-  prim->type = GL2PS_PIXMAP;
-  prim->boundary = 0;
-  prim->numverts = 1;
-  prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
-  prim->verts[0].xyz[0] = pos[0] + xorig;
-  prim->verts[0].xyz[1] = pos[1] + yorig;
-  prim->verts[0].xyz[2] = pos[2];
-  prim->culled = 0;
-  prim->offset = 0;
-  prim->pattern = 0;
-  prim->factor = 0;
-  prim->width = 1;
-  glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
-  prim->data.image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
-  prim->data.image->width = width;
-  prim->data.image->height = height;
-  prim->data.image->format = format;
-  prim->data.image->type = type;
-
-  switch(format){
-  case GL_RGBA:
-    if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
-      /* special case: blending turned off */
-      prim->data.image->format = GL_RGB;
-      size = height * width * 3;
-      prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
-      piv = (GLfloat*)pixels;
-      for(i = 0; i < size; ++i, ++piv){
-        prim->data.image->pixels[i] = *piv;
-        if(!((i+1)%3))
-          ++piv;
-      }   
-    }
-    else{
-      size = height * width * 4;
-      prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
-      memcpy(prim->data.image->pixels, pixels, size * sizeof(GLfloat));
-    }
-    break;
-  case GL_RGB:
-  default:
-    size = height * width * 3;
-    prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
-    memcpy(prim->data.image->pixels, pixels, size * sizeof(GLfloat));
-    break;
-  }
-
-  gl2psListAdd(gl2ps->auxprimitives, &prim);
-  glPassThrough(GL2PS_DRAW_PIXELS_TOKEN);
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psDrawImageMap(GLsizei width, GLsizei height,
-                                     const GLfloat position[3],
-                                     const unsigned char *imagemap){
-  int size, i;
-  int sizeoffloat = sizeof(GLfloat);
-  
-  if(!gl2ps || !imagemap) return GL2PS_UNINITIALIZED;
-
-  if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
-  
-  size = height + height * ((width - 1) / 8);
-  glPassThrough(GL2PS_IMAGEMAP_TOKEN);
-  glBegin(GL_POINTS);
-  glVertex3f(position[0], position[1],position[2]);
-  glEnd();
-  glPassThrough((GLfloat)width);
-  glPassThrough((GLfloat)height);
-  for(i = 0; i < size; i += sizeoffloat){
-    float *value = (float*)imagemap;
-    glPassThrough(*value);
-    imagemap += sizeoffloat;
-  }
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psEnable(GLint mode)
-{
-  GLint tmp;
-
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  switch(mode){
-  case GL2PS_POLYGON_OFFSET_FILL :
-    glPassThrough(GL2PS_BEGIN_OFFSET_TOKEN);
-    glGetFloatv(GL_POLYGON_OFFSET_FACTOR, &gl2ps->offset[0]);
-    glGetFloatv(GL_POLYGON_OFFSET_UNITS, &gl2ps->offset[1]);
-    break;
-  case GL2PS_POLYGON_BOUNDARY :
-    glPassThrough(GL2PS_BEGIN_BOUNDARY_TOKEN);
-    break;
-  case GL2PS_LINE_STIPPLE :
-    glPassThrough(GL2PS_BEGIN_STIPPLE_TOKEN);
-    glGetIntegerv(GL_LINE_STIPPLE_PATTERN, &tmp);
-    glPassThrough((GLfloat)tmp);
-    glGetIntegerv(GL_LINE_STIPPLE_REPEAT, &tmp);
-    glPassThrough((GLfloat)tmp);
-    break;
-  case GL2PS_BLEND :
-    glPassThrough(GL2PS_BEGIN_BLEND_TOKEN);
-    break;
-  default :
-    gl2psMsg(GL2PS_WARNING, "Unknown mode in gl2psEnable: %d", mode);
-    return GL2PS_WARNING;
-  }
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psDisable(GLint mode)
-{
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  switch(mode){
-  case GL2PS_POLYGON_OFFSET_FILL :
-    glPassThrough(GL2PS_END_OFFSET_TOKEN);
-    break;
-  case GL2PS_POLYGON_BOUNDARY :
-    glPassThrough(GL2PS_END_BOUNDARY_TOKEN);
-    break;
-  case GL2PS_LINE_STIPPLE :
-    glPassThrough(GL2PS_END_STIPPLE_TOKEN);
-    break;
-  case GL2PS_BLEND :
-    glPassThrough(GL2PS_END_BLEND_TOKEN);
-    break;
-  default :
-    gl2psMsg(GL2PS_WARNING, "Unknown mode in gl2psDisable: %d", mode);
-    return GL2PS_WARNING;
-  }
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psPointSize(GLfloat value)
-{
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  glPassThrough(GL2PS_POINT_SIZE_TOKEN);
-  glPassThrough(value);
-  
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psLineWidth(GLfloat value)
-{
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  glPassThrough(GL2PS_LINE_WIDTH_TOKEN);
-  glPassThrough(value);
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psBlendFunc(GLenum sfactor, GLenum dfactor)
-{
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  if(GL_FALSE == gl2psSupportedBlendMode(sfactor, dfactor))
-    return GL2PS_WARNING;
-
-  glPassThrough(GL2PS_SRC_BLEND_TOKEN);
-  glPassThrough((GLfloat)sfactor);
-  glPassThrough(GL2PS_DST_BLEND_TOKEN);
-  glPassThrough((GLfloat)dfactor);
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psSetOptions(GLint options)
-{
-  if(!gl2ps) return GL2PS_UNINITIALIZED;
-
-  gl2ps->options = options;
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API GLint gl2psGetOptions(GLint *options)
-{
-  if(!gl2ps) {
-    *options = 0;
-    return GL2PS_UNINITIALIZED;
-  }
-
-  *options = gl2ps->options;
-
-  return GL2PS_SUCCESS;
-}
-
-GL2PSDLL_API const char *gl2psGetFileExtension(GLint format)
-{
-  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends) / sizeof(gl2psbackends[0])))
-    return gl2psbackends[format]->file_extension;
-  else
-    return "Unknown format";
-}
-
-GL2PSDLL_API const char *gl2psGetFormatDescription(GLint format)
-{
-  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends) / sizeof(gl2psbackends[0])))
-    return gl2psbackends[format]->description;
-  else
-    return "Unknown format";
-}
diff --git a/graf3d/gl/src/gl2ps.cxx b/graf3d/gl/src/gl2ps.cxx
new file mode 100644
index 0000000..e599963
--- /dev/null
+++ b/graf3d/gl/src/gl2ps.cxx
@@ -0,0 +1,6032 @@
+/* $Id: gl2ps.c,v 1.1.1.1 2007/04/04 16:01:45 mtadel Exp $ */
+/*
+ * GL2PS, an OpenGL to PostScript Printing Library
+ * Copyright (C) 1999-2005 Christophe Geuzaine <geuz@geuz.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of either:
+ *
+ * a) the GNU Library General Public License as published by the Free
+ * Software Foundation, either version 2 of the License, or (at your
+ * option) any later version; or
+ *
+ * b) the GL2PS License as published by Christophe Geuzaine, either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See either
+ * the GNU Library General Public License or the GL2PS License for
+ * more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library in the file named "COPYING.LGPL";
+ * if not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+ * Cambridge, MA 02139, USA.
+ *
+ * You should have received a copy of the GL2PS License with this
+ * library in the file named "COPYING.GL2PS"; if not, I will be glad
+ * to provide one.
+ *
+ * Contributors:
+ *   Michael Sweet <mike@easysw.com>
+ *   Marc Ume <marc.ume@digitalgraphics.be>
+ *   Jean-Francois Remacle <remacle@gce.ucl.ac.be>
+ *   Bart Kaptein <B.L.Kaptein@lumc.nl>
+ *   Quy Nguyen-Dai <quy@nguyendai.org>
+ *   Sam Buss <sbuss@ucsd.edu>
+ *   Shane Hill <Shane.Hill@dsto.defence.gov.au>
+ *   Romain Boman <r_boman@yahoo.fr>
+ *   Rouben Rostamian <rostamian@umbc.edu>
+ *   Diego Santa Cruz <Diego.SantaCruz@epfl.ch>
+ *   Shahzad Muzaffar <Shahzad.Muzaffar@cern.ch>
+ *   Lassi Tuura <lassi.tuura@cern.ch>
+ *   Guy Barrand <barrand@lal.in2p3.fr>
+ *   Prabhu Ramachandran <prabhu@aero.iitm.ernet.in>
+ *   Micha Bieber <bieber@traits.de>
+ *   Olivier Couet <couet@mail.cern.ch>
+ *   Shai Ayal <shaiay@gmail.com>
+ *   Fabian Wenzel <wenzel@tu-harburg.de>
+ *   Ian D. Gay <gay@sfu.ca>
+ *   Cosmin Truta <cosmin@cs.toronto.edu>
+ *   Baiju Devani <b.devani@gmail.com>
+ *   Alexander Danilov <danilov@lanl.gov>
+ *
+ * For the latest info about gl2ps, see http://www.geuz.org/gl2ps/.
+ * Please report all bugs and problems to <gl2ps@geuz.org>.
+ */
+
+#include "gl2ps.h"
+
+#include <math.h>
+#include <string.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#include <time.h>
+#include <float.h>
+
+#if defined(GL2PS_HAVE_ZLIB)
+#include <zlib.h>
+#endif
+
+#if defined(GL2PS_HAVE_LIBPNG)
+#include <png.h>
+#endif
+
+/********************************************************************* 
+ *
+ * Private definitions, data structures and prototypes
+ *
+ *********************************************************************/
+
+/* Magic numbers (assuming that the order of magnitude of window
+   coordinates is 10^3) */
+
+#define GL2PS_EPSILON       5.0e-3F
+#define GL2PS_ZSCALE        1000.0F
+#define GL2PS_ZOFFSET       5.0e-2F
+#define GL2PS_ZOFFSET_LARGE 20.0F
+#define GL2PS_ZERO(arg)     (fabs(arg) < 1.e-20)
+
+/* Primitive types */
+
+#define GL2PS_NO_TYPE          -1
+#define GL2PS_TEXT             1
+#define GL2PS_POINT            2
+#define GL2PS_LINE             3
+#define GL2PS_QUADRANGLE       4
+#define GL2PS_TRIANGLE         5
+#define GL2PS_PIXMAP           6
+#define GL2PS_IMAGEMAP         7
+#define GL2PS_IMAGEMAP_WRITTEN 8
+#define GL2PS_IMAGEMAP_VISIBLE 9
+#define GL2PS_SPECIAL          10
+
+/* BSP tree primitive comparison */
+
+#define GL2PS_COINCIDENT  1
+#define GL2PS_IN_FRONT_OF 2
+#define GL2PS_IN_BACK_OF  3
+#define GL2PS_SPANNING    4
+
+/* 2D BSP tree primitive comparison */
+
+#define GL2PS_POINT_COINCIDENT 0
+#define GL2PS_POINT_INFRONT    1
+#define GL2PS_POINT_BACK       2
+
+/* Internal feedback buffer pass-through tokens */
+
+#define GL2PS_BEGIN_OFFSET_TOKEN   1
+#define GL2PS_END_OFFSET_TOKEN     2
+#define GL2PS_BEGIN_BOUNDARY_TOKEN 3
+#define GL2PS_END_BOUNDARY_TOKEN   4
+#define GL2PS_BEGIN_STIPPLE_TOKEN  5
+#define GL2PS_END_STIPPLE_TOKEN    6
+#define GL2PS_POINT_SIZE_TOKEN     7
+#define GL2PS_LINE_WIDTH_TOKEN     8
+#define GL2PS_BEGIN_BLEND_TOKEN    9
+#define GL2PS_END_BLEND_TOKEN      10
+#define GL2PS_SRC_BLEND_TOKEN      11
+#define GL2PS_DST_BLEND_TOKEN      12
+#define GL2PS_IMAGEMAP_TOKEN       13
+#define GL2PS_DRAW_PIXELS_TOKEN    14
+#define GL2PS_TEXT_TOKEN           15
+
+typedef enum {
+  T_UNDEFINED    = -1,
+  T_CONST_COLOR  = 1,
+  T_VAR_COLOR    = 1<<1,
+  T_ALPHA_1      = 1<<2,
+  T_ALPHA_LESS_1 = 1<<3,
+  T_VAR_ALPHA    = 1<<4
+} GL2PS_TRIANGLE_PROPERTY;
+
+typedef GLfloat GL2PSxyz[3];
+typedef GLfloat GL2PSplane[4];
+
+typedef struct _GL2PSbsptree2d GL2PSbsptree2d;
+
+struct _GL2PSbsptree2d {
+  GL2PSplane plane;
+  GL2PSbsptree2d *front, *back;
+};
+
+typedef struct {
+  GLint nmax, size, incr, n;
+  char *array;
+} GL2PSlist;
+
+typedef struct _GL2PSbsptree GL2PSbsptree;
+
+struct _GL2PSbsptree {
+  GL2PSplane plane;
+  GL2PSlist *primitives;
+  GL2PSbsptree *front, *back;
+};
+
+typedef struct {
+  GL2PSxyz xyz;
+  GL2PSrgba rgba;
+} GL2PSvertex;
+
+typedef struct {
+  GL2PSvertex vertex[3];
+  int prop;
+} GL2PStriangle;
+
+typedef struct {
+  GLshort fontsize;
+  char *str, *fontname;
+  /* Note: for a 'special' string, 'alignment' holds the format
+     (PostScript, PDF, etc.) of the special string */
+  GLint alignment;
+  GLfloat angle;
+} GL2PSstring;
+
+typedef struct {
+  GLsizei width, height;
+  /* Note: for an imagemap, 'type' indicates if it has already been
+     written to the file or not, and 'format' indicates if it is
+     visible or not */
+  GLenum format, type;
+  GLfloat *pixels;
+} GL2PSimage;
+
+typedef struct _GL2PSimagemap GL2PSimagemap;
+
+struct _GL2PSimagemap {
+  GL2PSimage *image;
+  GL2PSimagemap *next;
+};
+
+typedef struct {
+  GLshort type, numverts;
+  GLushort pattern;
+  char boundary, offset, culled;
+  GLint factor;
+  GLfloat width;
+  GL2PSvertex *verts;
+  union {
+    GL2PSstring *text;
+    GL2PSimage *image;
+  } data;
+} GL2PSprimitive;
+
+typedef struct {
+#if defined(GL2PS_HAVE_ZLIB)
+  Bytef *dest, *src, *start;
+  uLongf destLen, srcLen;
+#else
+  int dummy;
+#endif
+} GL2PScompress;
+
+typedef struct{
+  GL2PSlist* ptrlist;
+  int gsno, fontno, imno, shno, maskshno, trgroupno;
+  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;
+} GL2PSpdfgroup;
+
+typedef struct {
+  /* General */
+  GLint format, sort, options, colorsize, colormode, buffersize;
+  char *title, *producer, *filename;
+  GLboolean boundary, blending;
+  GLfloat *feedback, offset[2], lastlinewidth;
+  GLint viewport[4], blendfunc[2], lastfactor;
+  GL2PSrgba *colormap, lastrgba, threshold, bgcolor;
+  GLushort lastpattern;
+  GL2PSvertex lastvertex;
+  GL2PSlist *primitives, *auxprimitives;
+  FILE *stream;
+  GL2PScompress *compress;
+  GLboolean header;
+
+  /* BSP-specific */
+  GLint maxbestroot;
+
+  /* Occlusion culling-specific */
+  GLboolean zerosurfacearea;
+  GL2PSbsptree2d *imagetree;
+  GL2PSprimitive *primitivetoadd;
+  
+  /* PDF-specific */
+  int streamlength;
+  GL2PSlist *pdfprimlist, *pdfgrouplist;
+  int *xreflist;
+  int objects_stack; /* available objects */
+  int extgs_stack; /* graphics state object number */
+  int font_stack; /* font object number */
+  int im_stack; /* image object number */
+  int trgroupobjects_stack; /* xobject numbers */
+  int shader_stack; /* shader object numbers */
+  int mshader_stack; /* mask shader object numbers */
+
+  /* for image map list */
+  GL2PSimagemap *imagemap_head;
+  GL2PSimagemap *imagemap_tail;
+} GL2PScontext;
+
+typedef struct {
+  void  (*printHeader)(void);
+  void  (*printFooter)(void);
+  void  (*beginViewport)(GLint viewport[4]);
+  GLint (*endViewport)(void);
+  void  (*printPrimitive)(void *data);
+  void  (*printFinalPrimitive)(void);
+  const char *file_extension;
+  const char *description;
+} GL2PSbackend;
+
+/* The gl2ps context. gl2ps is not thread safe (we should create a
+   local GL2PScontext during gl2psBeginPage) */
+
+static GL2PScontext *gl2ps = NULL;
+
+/* Need to forward-declare this one */
+
+static GLint gl2psPrintPrimitives(void);
+
+/********************************************************************* 
+ *
+ * Utility routines
+ *
+ *********************************************************************/
+
+static void gl2psMsg(GLint level, const char *fmt, ...)
+{
+  va_list args;
+
+  if(!(gl2ps->options & GL2PS_SILENT)){
+    switch(level){
+    case GL2PS_INFO : fprintf(stderr, "GL2PS info: "); break;
+    case GL2PS_WARNING : fprintf(stderr, "GL2PS warning: "); break;
+    case GL2PS_ERROR : fprintf(stderr, "GL2PS error: "); break;
+    }
+    va_start(args, fmt);
+    vfprintf(stderr, fmt, args); 
+    va_end(args);
+    fprintf(stderr, "\n");
+  }
+  /* if(level == GL2PS_ERROR) exit(1); */
+}
+
+static void *gl2psMalloc(size_t size)
+{
+  void *ptr;
+
+  if(!size) return(NULL);
+  ptr = malloc(size);
+  if(!ptr){
+    gl2psMsg(GL2PS_ERROR, "Couldn't allocate requested memory");
+    exit(1);
+  }
+  return(ptr);
+}
+
+static void *gl2psRealloc(void *ptr, size_t size)
+{
+  if(!size) return(NULL);
+  ptr = realloc(ptr, size);
+  if(!ptr){
+    gl2psMsg(GL2PS_ERROR, "Couldn't reallocate requested memory");
+    exit(1);
+  }
+  return(ptr);
+}
+
+static void gl2psFree(void *ptr)
+{
+  if(!ptr) return;
+  free(ptr);
+}
+
+static size_t gl2psWriteBigEndian(unsigned long data, size_t bytes)
+{
+  size_t i;
+  size_t size = sizeof(unsigned long);
+  for(i = 1; i <= bytes; ++i){
+    fputc(0xff & (data >> (size-i) * 8), gl2ps->stream);
+  }
+  return bytes;
+}
+
+/* zlib compression helper routines */
+
+#if defined(GL2PS_HAVE_ZLIB)
+
+static void gl2psSetupCompress(void)
+{
+  gl2ps->compress = (GL2PScompress*)gl2psMalloc(sizeof(GL2PScompress));
+  gl2ps->compress->src = NULL;
+  gl2ps->compress->start = NULL;
+  gl2ps->compress->dest = NULL;
+  gl2ps->compress->srcLen = 0;
+  gl2ps->compress->destLen = 0;
+}
+
+static void gl2psFreeCompress(void)
+{
+  if(!gl2ps->compress)
+    return;
+  gl2psFree(gl2ps->compress->start);
+  gl2psFree(gl2ps->compress->dest);
+  gl2ps->compress->src = NULL;
+  gl2ps->compress->start = NULL;
+  gl2ps->compress->dest = NULL;
+  gl2ps->compress->srcLen = 0;
+  gl2ps->compress->destLen = 0;
+}
+
+static int gl2psAllocCompress(unsigned int srcsize)
+{
+  gl2psFreeCompress();
+  
+  if(!gl2ps->compress || !srcsize)
+    return GL2PS_ERROR;
+  
+  gl2ps->compress->srcLen = srcsize;
+  gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
+  gl2ps->compress->src = (Bytef*)gl2psMalloc(gl2ps->compress->srcLen);
+  gl2ps->compress->start = gl2ps->compress->src;
+  gl2ps->compress->dest = (Bytef*)gl2psMalloc(gl2ps->compress->destLen);
+  
+  return GL2PS_SUCCESS;
+}
+
+static void *gl2psReallocCompress(unsigned int srcsize)
+{
+  if(!gl2ps->compress || !srcsize)
+    return NULL;
+  
+  if(srcsize < gl2ps->compress->srcLen)
+    return gl2ps->compress->start;
+  
+  gl2ps->compress->srcLen = srcsize;
+  gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
+  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src, 
+                                              gl2ps->compress->srcLen);
+  gl2ps->compress->start = gl2ps->compress->src;
+  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest, 
+                                               gl2ps->compress->destLen);
+  
+  return gl2ps->compress->start;
+}
+
+static size_t gl2psWriteBigEndianCompress(unsigned long data, size_t bytes)
+{
+  size_t i;
+  size_t size = sizeof(unsigned long);
+  for(i = 1; i <= bytes; ++i){
+    *gl2ps->compress->src = (Bytef)(0xff & (data >> (size-i) * 8));
+    ++gl2ps->compress->src;
+  }
+  return bytes;
+}
+
+static int gl2psDeflate(void)
+{
+  /* For compatibility with older zlib versions, we use compress(...)
+     instead of compress2(..., Z_BEST_COMPRESSION) */
+  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen, 
+                  gl2ps->compress->start, gl2ps->compress->srcLen);  
+}
+
+#endif
+
+static int gl2psPrintf(const char* fmt, ...)
+{
+  int ret;
+  va_list args;
+
+#if defined(GL2PS_HAVE_ZLIB)
+  unsigned int oldsize = 0;
+  static char buf[1000];
+  if(gl2ps->options & GL2PS_COMPRESS){
+    va_start(args, fmt);
+    ret = vsprintf(buf, fmt, args);
+    va_end(args);
+    oldsize = gl2ps->compress->srcLen;
+    gl2ps->compress->start = (Bytef*)gl2psReallocCompress(oldsize + ret);
+    memcpy(gl2ps->compress->start+oldsize, buf, ret);
+    ret = 0;
+  }
+  else{
+#endif
+    va_start(args, fmt);
+    ret = vfprintf(gl2ps->stream, fmt, args);
+    va_end(args);
+#if defined(GL2PS_HAVE_ZLIB)
+  }
+#endif
+  return ret;
+}
+
+static void gl2psPrintGzipHeader()
+{
+#if defined(GL2PS_HAVE_ZLIB)
+  char tmp[10] = {'\x1f', '\x8b', /* magic numbers: 0x1f, 0x8b */
+                  8, /* compression method: Z_DEFLATED */
+                  0, /* flags */
+                  0, 0, 0, 0, /* time */
+                  2, /* extra flags: max compression */
+                  '\x03'}; /* OS code: 0x03 (Unix) */
+
+  if(gl2ps->options & GL2PS_COMPRESS){
+    gl2psSetupCompress();
+    /* add the gzip file header */
+    fwrite(tmp, 10, 1, gl2ps->stream);
+  }
+#endif  
+}
+
+static void gl2psPrintGzipFooter()
+{
+#if defined(GL2PS_HAVE_ZLIB)
+  int n;
+  uLong crc, len;
+  char tmp[8];
+
+  if(gl2ps->options & GL2PS_COMPRESS){
+    if(Z_OK != gl2psDeflate()){
+      gl2psMsg(GL2PS_ERROR, "Zlib deflate error");
+    }
+    else{
+      /* determine the length of the header in the zlib stream */
+      n = 2; /* CMF+FLG */
+      if(gl2ps->compress->dest[1] & (1<<5)){
+        n += 4; /* DICTID */
+      }
+      /* write the data, without the zlib header and footer */
+      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4), 
+             1, gl2ps->stream);
+      /* add the gzip file footer */
+      crc = crc32(0L, gl2ps->compress->start, gl2ps->compress->srcLen);
+      for(n = 0; n < 4; ++n){
+        tmp[n] = (char)(crc & 0xff);
+        crc >>= 8;
+      }
+      len = gl2ps->compress->srcLen;
+      for(n = 4; n < 8; ++n){
+        tmp[n] = (char)(len & 0xff);
+        len >>= 8;
+      }
+      fwrite(tmp, 8, 1, gl2ps->stream);
+    }
+    gl2psFreeCompress();
+    gl2psFree(gl2ps->compress);
+    gl2ps->compress = NULL;
+  }
+#endif 
+}
+
+/* The list handling routines */
+
+static void gl2psListRealloc(GL2PSlist *list, GLint n)
+{
+  if(!list){
+    gl2psMsg(GL2PS_ERROR, "Cannot reallocate NULL list");
+    return;
+  }
+  if(n <= 0) return;
+  if(!list->array){
+    list->nmax = n;
+    list->array = (char*)gl2psMalloc(list->nmax * list->size);
+  }
+  else{
+    if(n > list->nmax){
+      list->nmax = ((n - 1) / list->incr + 1) * list->incr;
+      list->array = (char*)gl2psRealloc(list->array,
+                                        list->nmax * list->size);
+    }
+  }
+}
+
+static GL2PSlist *gl2psListCreate(GLint n, GLint incr, GLint size)
+{
+  GL2PSlist *list;
+
+  if(n < 0) n = 0;
+  if(incr <= 0) incr = 1;
+  list = (GL2PSlist*)gl2psMalloc(sizeof(GL2PSlist));
+  list->nmax = 0;
+  list->incr = incr;
+  list->size = size;
+  list->n = 0;
+  list->array = NULL;
+  gl2psListRealloc(list, n);
+  return(list);
+}
+
+static void gl2psListReset(GL2PSlist *list)
+{
+  if(!list) return;
+  list->n = 0;
+}
+
+static void gl2psListDelete(GL2PSlist *list)
+{
+  if(!list) return;  
+  gl2psFree(list->array);
+  gl2psFree(list);
+}
+
+static void gl2psListAdd(GL2PSlist *list, void *data)
+{
+  if(!list){
+    gl2psMsg(GL2PS_ERROR, "Cannot add into unallocated list");
+    return;
+  }
+  list->n++;
+  gl2psListRealloc(list, list->n);
+  memcpy(&list->array[(list->n - 1) * list->size], data, list->size);
+}
+
+static int gl2psListNbr(GL2PSlist *list)
+{
+  if(!list)
+    return 0;
+  return(list->n);
+}
+
+static void *gl2psListPointer(GL2PSlist *list, GLint index)
+{
+  if(!list){
+    gl2psMsg(GL2PS_ERROR, "Cannot point into unallocated list");
+    return NULL;
+  }
+  if((index < 0) || (index >= list->n)){
+    gl2psMsg(GL2PS_ERROR, "Wrong list index in gl2psListPointer");
+    return NULL;
+  }
+  return(&list->array[index * list->size]);
+}
+
+static void gl2psListSort(GL2PSlist *list,
+                          int (*fcmp)(const void *a, const void *b))
+{
+  if(!list)
+    return;
+  qsort(list->array, list->n, list->size, fcmp);
+}
+
+static void gl2psListAction(GL2PSlist *list, void (*action)(void *data))
+{
+  GLint i;
+
+  for(i = 0; i < gl2psListNbr(list); i++){
+    (*action)(gl2psListPointer(list, i));
+  }
+}
+
+static void gl2psListActionInverse(GL2PSlist *list, void (*action)(void *data))
+{
+  GLint i;
+
+  for(i = gl2psListNbr(list); i > 0; i--){
+    (*action)(gl2psListPointer(list, i-1));
+  }
+}
+
+#if defined(GL2PS_HAVE_LIBPNG)
+
+static void gl2psListRead(GL2PSlist *list, int index, void *data)
+{
+  if((index < 0) || (index >= list->n))
+    gl2psMsg(GL2PS_ERROR, "Wrong list index in gl2psListRead");
+  memcpy(data, &list->array[index * list->size], list->size);
+}
+
+static void gl2psEncodeBase64Block(unsigned char in[3], unsigned char out[4], int len)
+{
+  static const char cb64[] = 
+    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+  out[0] = cb64[ in[0] >> 2 ];
+  out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
+  out[2] = (len > 1) ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=';
+  out[3] = (len > 2) ? cb64[ in[2] & 0x3f ] : '=';
+}
+
+static void gl2psListEncodeBase64(GL2PSlist *list)
+{
+  unsigned char *buffer, in[3], out[4];
+  int i, n, index, len;
+
+  n = list->n * list->size;
+  buffer = (unsigned char*)gl2psMalloc(n * sizeof(unsigned char));
+  memcpy(buffer, list->array, n * sizeof(unsigned char));
+  gl2psListReset(list);
+
+  index = 0;
+  while(index < n) {
+    len = 0;
+    for(i = 0; i < 3; i++) {
+      if(index < n){
+        in[i] = buffer[index];
+        len++;
+      }
+      else{
+        in[i] = 0;
+      }
+      index++;
+    }
+    if(len) {
+      gl2psEncodeBase64Block(in, out, len);
+      for(i = 0; i < 4; i++)
+        gl2psListAdd(list, &out[i]);
+    }
+  }
+  gl2psFree(buffer);
+}
+
+#endif
+
+/* Helpers for rgba colors */
+
+static GLboolean gl2psSameColor(GL2PSrgba rgba1, GL2PSrgba rgba2)
+{
+  if(!GL2PS_ZERO(rgba1[0] - rgba2[0]) ||
+     !GL2PS_ZERO(rgba1[1] - rgba2[1]) ||
+     !GL2PS_ZERO(rgba1[2] - rgba2[2]))
+    return GL_FALSE;
+  return GL_TRUE;
+}
+  
+static GLboolean gl2psVertsSameColor(const GL2PSprimitive *prim)
+{
+  int i;
+
+  for(i = 1; i < prim->numverts; i++){
+    if(!gl2psSameColor(prim->verts[0].rgba, prim->verts[i].rgba)){
+      return GL_FALSE;
+    }
+  }
+  return GL_TRUE;
+}
+
+static GLboolean gl2psSameColorThreshold(int n, GL2PSrgba rgba[],
+                                         GL2PSrgba threshold)
+{
+  int i;
+
+  if(n < 2) return GL_TRUE;
+  
+  for(i = 1; i < n; i++){
+    if(fabs(rgba[0][0] - rgba[i][0]) > threshold[0] ||
+       fabs(rgba[0][1] - rgba[i][1]) > threshold[1] ||
+       fabs(rgba[0][2] - rgba[i][2]) > threshold[2])
+      return GL_FALSE;
+  }
+  
+  return GL_TRUE;
+}
+
+static void gl2psSetLastColor(GL2PSrgba rgba)
+{
+  int i;        
+  for(i = 0; i < 3; ++i){
+    gl2ps->lastrgba[i] = rgba[i];
+  }
+}
+
+static GLfloat gl2psGetRGB(GL2PSimage *im, GLuint x, GLuint y,
+                           GLfloat *red, GLfloat *green, GLfloat *blue)
+{
+  
+  GLsizei width = im->width;
+  GLsizei height = im->height;
+  GLfloat *pixels = im->pixels;
+  GLfloat *pimag;
+
+  /* OpenGL image is from down to up, PS image is up to down */  
+  switch(im->format){
+  case GL_RGBA:
+    pimag = pixels + 4 * (width * (height - 1 - y) + x);
+    break;
+  case GL_RGB:
+  default:
+    pimag = pixels + 3 * (width * (height - 1 - y) + x);
+    break;
+  }
+  *red = *pimag; pimag++;
+  *green = *pimag; pimag++;
+  *blue = *pimag; pimag++;
+
+  return (im->format == GL_RGBA) ? *pimag : 1.0F;
+}
+
+/* Helper routines for pixmaps */
+
+static GL2PSimage *gl2psCopyPixmap(GL2PSimage *im)
+{
+  int size;
+  GL2PSimage *image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
+  
+  image->width = im->width;
+  image->height = im->height;
+  image->format = im->format;
+  image->type = im->type;
+
+  switch(image->format){
+  case GL_RGBA:
+    size = image->height * image->width * 4 * sizeof(GLfloat);
+    break;
+  case GL_RGB:
+  default:
+    size = image->height * image->width * 3 * sizeof(GLfloat);
+    break;
+  }
+
+  image->pixels = (GLfloat*)gl2psMalloc(size);
+  memcpy(image->pixels, im->pixels, size);
+  
+  return image;
+}
+
+static void gl2psFreePixmap(GL2PSimage *im)
+{
+  if(!im)
+    return;
+  gl2psFree(im->pixels);
+  gl2psFree(im);
+}
+
+#if defined(GL2PS_HAVE_LIBPNG)
+
+#if !defined(png_jmpbuf)
+#  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
+#endif
+
+static void gl2psUserWritePNG(png_structp png_ptr, png_bytep data, png_size_t length)
+{
+  unsigned int i;
+  GL2PSlist *png = (GL2PSlist*)png_get_io_ptr(png_ptr);
+  for(i = 0; i < length; i++) 
+    gl2psListAdd(png, &data[i]);
+}
+
+static void gl2psUserFlushPNG(png_structp png_ptr)
+{
+}
+
+static void gl2psConvertPixmapToPNG(GL2PSimage *pixmap, GL2PSlist *png)
+{
+  png_structp png_ptr;
+  png_infop info_ptr;
+  unsigned char *row_data;
+  GLfloat dr, dg, db;
+  int row, col;
+
+  if(!(png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL)))
+    return;
+  
+  if(!(info_ptr = png_create_info_struct(png_ptr))){
+    png_destroy_write_struct(&png_ptr, NULL);
+    return;
+  }
+  
+  if(setjmp(png_jmpbuf(png_ptr))) {
+    png_destroy_write_struct(&png_ptr, &info_ptr);
+    return;
+  }
+  
+  png_set_write_fn(png_ptr, (void *)png, gl2psUserWritePNG, gl2psUserFlushPNG);
+  png_set_compression_level(png_ptr, Z_DEFAULT_COMPRESSION);
+  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8, 
+               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, 
+               PNG_FILTER_TYPE_BASE);
+  png_write_info(png_ptr, info_ptr);
+
+  row_data = (unsigned char*)gl2psMalloc(3 * pixmap->width * sizeof(unsigned char));
+  for(row = 0; row < pixmap->height; row++){
+    for(col = 0; col < pixmap->width; col++){
+      gl2psGetRGB(pixmap, col, row, &dr, &dg, &db);
+      row_data[3*col] = (unsigned char)(255. * dr);
+      row_data[3*col+1] = (unsigned char)(255. * dg);
+      row_data[3*col+2] = (unsigned char)(255. * db);
+    }
+    png_write_row(png_ptr, (png_bytep)row_data);
+  }
+  gl2psFree(row_data);
+
+  png_write_end(png_ptr, info_ptr);
+  png_destroy_write_struct(&png_ptr, &info_ptr);
+}
+
+#endif
+
+/* Helper routines for text strings */
+
+static GLint gl2psAddText(GLint type, const char *str, const char *fontname, 
+                          GLshort fontsize, GLint alignment, GLfloat angle)
+{
+  GLfloat pos[4];
+  GL2PSprimitive *prim;
+  GLboolean valid;
+
+  if(!gl2ps || !str || !fontname) return GL2PS_UNINITIALIZED;
+
+  if(gl2ps->options & GL2PS_NO_TEXT) return GL2PS_SUCCESS;
+
+  glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
+  if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */
+
+  glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
+
+  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+  prim->type = type;
+  prim->boundary = 0;
+  prim->numverts = 1;
+  prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
+  prim->verts[0].xyz[0] = pos[0];
+  prim->verts[0].xyz[1] = pos[1];
+  prim->verts[0].xyz[2] = pos[2];
+  prim->culled = 0;
+  prim->offset = 0;
+  prim->pattern = 0;
+  prim->factor = 0;
+  prim->width = 1;
+  glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
+  prim->data.text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
+  prim->data.text->str = (char*)gl2psMalloc((strlen(str)+1)*sizeof(char));
+  strcpy(prim->data.text->str, str); 
+  prim->data.text->fontname = (char*)gl2psMalloc((strlen(fontname)+1)*sizeof(char));
+  strcpy(prim->data.text->fontname, fontname);
+  prim->data.text->fontsize = fontsize;
+  prim->data.text->alignment = alignment;
+  prim->data.text->angle = angle;
+
+  gl2psListAdd(gl2ps->auxprimitives, &prim);
+  glPassThrough(GL2PS_TEXT_TOKEN);
+    
+  return GL2PS_SUCCESS;
+}
+
+static GL2PSstring *gl2psCopyText(GL2PSstring *t)
+{
+  GL2PSstring *text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
+  text->str = (char*)gl2psMalloc((strlen(t->str)+1)*sizeof(char));
+  strcpy(text->str, t->str); 
+  text->fontname = (char*)gl2psMalloc((strlen(t->fontname)+1)*sizeof(char));
+  strcpy(text->fontname, t->fontname);
+  text->fontsize = t->fontsize;
+  text->alignment = t->alignment;
+  text->angle = t->angle;
+  
+  return text;
+}
+
+static void gl2psFreeText(GL2PSstring *text)
+{
+  if(!text)
+    return;
+  gl2psFree(text->str);
+  gl2psFree(text->fontname);
+  gl2psFree(text);
+}
+
+/* Helpers for blending modes */
+
+static GLboolean gl2psSupportedBlendMode(GLenum sfactor, GLenum dfactor)
+{
+  /* returns TRUE if gl2ps supports the argument combination: only two
+     blending modes have been implemented so far */
+
+  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) || 
+      (sfactor == GL_ONE && dfactor == GL_ZERO) )
+    return GL_TRUE;
+  return GL_FALSE;
+}
+
+static void gl2psAdaptVertexForBlending(GL2PSvertex *v)
+{
+  /* Transforms vertex depending on the actual blending function -
+     currently the vertex v is considered as source vertex and his
+     alpha value is changed to 1.0 if source blending GL_ONE is
+     active. This might be extended in the future */
+
+  if(!v || !gl2ps)
+    return;
+
+  if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
+    v->rgba[3] = 1.0F;
+    return;
+  }
+  
+  switch(gl2ps->blendfunc[0]){
+  case GL_ONE:
+    v->rgba[3] = 1.0F;
+    break;
+  default:
+    break;
+  }
+}
+
+static void gl2psAssignTriangleProperties(GL2PStriangle *t)
+{
+  /* int i; */
+
+  t->prop = T_VAR_COLOR;
+
+  /* Uncommenting the following lines activates an even more fine
+     grained distinction between triangle types - please don't delete,
+     a remarkable amount of PDF handling code inside this file depends
+     on it if activated */
+  /*
+  t->prop = T_CONST_COLOR;    
+  for(i = 0; i < 3; ++i){
+    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) || 
+       !GL2PS_ZERO(t->vertex[1].rgba[i] - t->vertex[2].rgba[i])){
+      t->prop = T_VAR_COLOR;
+      break;
+    }
+  }
+  */
+
+  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) || 
+     !GL2PS_ZERO(t->vertex[1].rgba[3] - t->vertex[2].rgba[3])){
+    t->prop |= T_VAR_ALPHA;
+  }
+  else{
+    if(t->vertex[0].rgba[3] < 1)
+      t->prop |= T_ALPHA_LESS_1;
+    else
+      t->prop |= T_ALPHA_1;
+  }
+}
+
+static void gl2psFillTriangleFromPrimitive(GL2PStriangle *t, GL2PSprimitive *p,
+                                           GLboolean assignprops)
+{
+  t->vertex[0] = p->verts[0];
+  t->vertex[1] = p->verts[1];
+  t->vertex[2] = p->verts[2];
+  if(GL_TRUE == assignprops)
+    gl2psAssignTriangleProperties(t);
+}
+
+static void gl2psInitTriangle(GL2PStriangle *t)
+{
+  int i;
+  GL2PSvertex vertex = { {-1.0F, -1.0F, -1.0F}, {-1.0F, -1.0F, -1.0F, -1.0F} };
+  for(i = 0; i < 3; i++)
+    t->vertex[i] = vertex;
+  t->prop = T_UNDEFINED;
+}
+
+/* Miscellaneous helper routines */
+
+static GL2PSprimitive *gl2psCopyPrimitive(GL2PSprimitive *p)
+{
+  GL2PSprimitive *prim;
+
+  if(!p){
+    gl2psMsg(GL2PS_ERROR, "Trying to copy an empty primitive");
+    return NULL;
+  }
+
+  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+  
+  prim->type = p->type;
+  prim->numverts = p->numverts;
+  prim->boundary = p->boundary;
+  prim->offset = p->offset;
+  prim->pattern = p->pattern;
+  prim->factor = p->factor;
+  prim->culled = p->culled;
+  prim->width = p->width;
+  prim->verts = (GL2PSvertex*)gl2psMalloc(p->numverts*sizeof(GL2PSvertex));
+  memcpy(prim->verts, p->verts, p->numverts * sizeof(GL2PSvertex));
+
+  switch(prim->type){
+  case GL2PS_PIXMAP :
+    prim->data.image = gl2psCopyPixmap(p->data.image);
+    break;
+  case GL2PS_TEXT :
+  case GL2PS_SPECIAL :
+    prim->data.text = gl2psCopyText(p->data.text);
+    break;
+  default:
+    break;
+  }
+
+  return prim;
+}
+
+static GLboolean gl2psSamePosition(GL2PSxyz p1, GL2PSxyz p2)
+{
+  if(!GL2PS_ZERO(p1[0] - p2[0]) ||
+     !GL2PS_ZERO(p1[1] - p2[1]) ||
+     !GL2PS_ZERO(p1[2] - p2[2]))
+    return GL_FALSE;
+  return GL_TRUE;
+}
+
+/********************************************************************* 
+ *
+ * 3D sorting routines 
+ *
+ *********************************************************************/
+
+static GLfloat gl2psComparePointPlane(GL2PSxyz point, GL2PSplane plane)
+{
+  return(plane[0] * point[0] + 
+         plane[1] * point[1] + 
+         plane[2] * point[2] + 
+         plane[3]);
+}
+
+static GLfloat gl2psPsca(GLfloat *a, GLfloat *b)
+{
+  return(a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
+}
+
+static void gl2psPvec(GLfloat *a, GLfloat *b, GLfloat *c)
+{
+  c[0] = a[1]*b[2] - a[2]*b[1];
+  c[1] = a[2]*b[0] - a[0]*b[2];
+  c[2] = a[0]*b[1] - a[1]*b[0];
+}
+
+static GLfloat gl2psNorm(GLfloat *a)
+{
+  return (GLfloat)sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
+}
+
+static void gl2psGetNormal(GLfloat *a, GLfloat *b, GLfloat *c)
+{
+  GLfloat norm;
+
+  gl2psPvec(a, b, c);
+  if(!GL2PS_ZERO(norm = gl2psNorm(c))){
+    c[0] = c[0] / norm;
+    c[1] = c[1] / norm;
+    c[2] = c[2] / norm;
+  }
+  else{
+    /* The plane is still wrong despite our tests in gl2psGetPlane.
+       Let's return a dummy value for now (this is a hack: we should
+       do more intelligent tests in GetPlane) */
+    c[0] = c[1] = 0.0F;
+    c[2] = 1.0F;
+  }
+}
+
+static void gl2psGetPlane(GL2PSprimitive *prim, GL2PSplane plane)
+{
+  GL2PSxyz v = {0.0F, 0.0F, 0.0F}, w = {0.0F, 0.0F, 0.0F};
+
+  switch(prim->type){
+  case GL2PS_TRIANGLE :
+  case GL2PS_QUADRANGLE :
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
+    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0]; 
+    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1]; 
+    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2]; 
+    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) || 
+       (GL2PS_ZERO(w[0]) && GL2PS_ZERO(w[1]) && GL2PS_ZERO(w[2]))){
+      plane[0] = plane[1] = 0.0F;
+      plane[2] = 1.0F;
+      plane[3] = -prim->verts[0].xyz[2];
+    }
+    else{
+      gl2psGetNormal(v, w, plane);
+      plane[3] = 
+        - plane[0] * prim->verts[0].xyz[0] 
+        - plane[1] * prim->verts[0].xyz[1] 
+        - plane[2] * prim->verts[0].xyz[2];
+    }
+    break;
+  case GL2PS_LINE :
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
+    if(GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])){
+      plane[0] = plane[1] = 0.0F;
+      plane[2] = 1.0F;
+      plane[3] = -prim->verts[0].xyz[2];
+    }
+    else{
+      if(GL2PS_ZERO(v[0]))      w[0] = 1.0F;
+      else if(GL2PS_ZERO(v[1])) w[1] = 1.0F;
+      else                      w[2] = 1.0F;
+      gl2psGetNormal(v, w, plane);
+      plane[3] = 
+        - plane[0] * prim->verts[0].xyz[0] 
+        - plane[1] * prim->verts[0].xyz[1] 
+        - plane[2] * prim->verts[0].xyz[2];
+    }
+    break;
+  case GL2PS_POINT :
+  case GL2PS_PIXMAP :
+  case GL2PS_TEXT :
+  case GL2PS_SPECIAL :
+  case GL2PS_IMAGEMAP:
+    plane[0] = plane[1] = 0.0F;
+    plane[2] = 1.0F;
+    plane[3] = -prim->verts[0].xyz[2];
+    break;
+  default :
+    gl2psMsg(GL2PS_ERROR, "Unknown primitive type in BSP tree");
+    plane[0] = plane[1] = plane[3] = 0.0F;
+    plane[2] = 1.0F;
+    break;
+  }
+}
+
+static void gl2psCutEdge(GL2PSvertex *a, GL2PSvertex *b, GL2PSplane plane,
+                         GL2PSvertex *c)
+{
+  GL2PSxyz v;
+  GLfloat sect, psca;
+
+  v[0] = b->xyz[0] - a->xyz[0];
+  v[1] = b->xyz[1] - a->xyz[1];
+  v[2] = b->xyz[2] - a->xyz[2];
+
+  if(!GL2PS_ZERO(psca = gl2psPsca(plane, v)))
+    sect = -gl2psComparePointPlane(a->xyz, plane) / psca;
+  else
+    sect = 0.0F;
+  
+  c->xyz[0] = a->xyz[0] + v[0] * sect;
+  c->xyz[1] = a->xyz[1] + v[1] * sect;
+  c->xyz[2] = a->xyz[2] + v[2] * sect;
+  
+  c->rgba[0] = (1 - sect) * a->rgba[0] + sect * b->rgba[0];
+  c->rgba[1] = (1 - sect) * a->rgba[1] + sect * b->rgba[1];
+  c->rgba[2] = (1 - sect) * a->rgba[2] + sect * b->rgba[2];
+  c->rgba[3] = (1 - sect) * a->rgba[3] + sect * b->rgba[3];
+}
+
+static void gl2psCreateSplitPrimitive(GL2PSprimitive *parent, GL2PSplane plane,
+                                      GL2PSprimitive *child, GLshort numverts,
+                                      GLshort *index0, GLshort *index1)
+{
+  GLshort i;
+
+  if(parent->type == GL2PS_IMAGEMAP){
+    child->type = GL2PS_IMAGEMAP;
+    child->data.image = parent->data.image;
+  }
+  else{
+    if(numverts > 4){
+      gl2psMsg(GL2PS_WARNING, "%d vertices in polygon", numverts);
+      numverts = 4;
+    }
+    switch(numverts){
+    case 1 : child->type = GL2PS_POINT; break; 
+    case 2 : child->type = GL2PS_LINE; break; 
+    case 3 : child->type = GL2PS_TRIANGLE; break; 
+    case 4 : child->type = GL2PS_QUADRANGLE; break;    
+    default: child->type = GL2PS_NO_TYPE; break;
+    }
+  }
+
+  child->boundary = 0; /* FIXME: not done! */
+  child->culled = parent->culled;
+  child->offset = parent->offset;
+  child->pattern = parent->pattern;
+  child->factor = parent->factor;
+  child->width = parent->width;
+  child->numverts = numverts;
+  child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
+
+  for(i = 0; i < numverts; i++){
+    if(index1[i] < 0){
+      child->verts[i] = parent->verts[index0[i]];
+    }
+    else{
+      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]], 
+                   plane, &child->verts[i]);
+    }
+  }
+}
+
+static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb, 
+                          GLshort i, GLshort j)
+{
+  GLint k;
+
+  for(k = 0; k < *nb; k++){
+    if((index0[k] == i && index1[k] == j) ||
+       (index1[k] == i && index0[k] == j)) return;
+  }
+  index0[*nb] = i;
+  index1[*nb] = j;
+  (*nb)++;
+}
+
+static GLshort gl2psGetIndex(GLshort i, GLshort num)
+{
+  return (i < num - 1) ? i + 1 : 0;
+}
+
+static GLint gl2psTestSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane)
+{
+  GLint type = GL2PS_COINCIDENT;
+  GLshort i, j;
+  GLfloat d[5]; 
+
+  for(i = 0; i < prim->numverts; i++){  
+    d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
+  }
+
+  if(prim->numverts < 2){
+    return 0;
+  }
+  else{
+    for(i = 0; i < prim->numverts; i++){
+      j = gl2psGetIndex(i, prim->numverts);
+      if(d[j] > GL2PS_EPSILON){
+        if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
+        else if(type != GL2PS_IN_BACK_OF) return 1; 
+        if(d[i] < -GL2PS_EPSILON)         return 1;
+      }
+      else if(d[j] < -GL2PS_EPSILON){
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
+        else if(type != GL2PS_IN_FRONT_OF) return 1;
+        if(d[i] > GL2PS_EPSILON)           return 1;
+      }
+    }
+  }
+  return 0;
+}
+
+static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane, 
+                                 GL2PSprimitive **front, GL2PSprimitive **back)
+{
+  GLshort i, j, in = 0, out = 0, in0[5], in1[5], out0[5], out1[5];
+  GLint type;
+  GLfloat d[5]; 
+
+  type = GL2PS_COINCIDENT;
+
+  for(i = 0; i < prim->numverts; i++){  
+    d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
+  }
+
+  switch(prim->type){
+  case GL2PS_POINT :
+    if(d[0] > GL2PS_EPSILON)       type = GL2PS_IN_BACK_OF;
+    else if(d[0] < -GL2PS_EPSILON) type = GL2PS_IN_FRONT_OF;
+    else                           type = GL2PS_COINCIDENT;
+    break;
+  default :
+    for(i = 0; i < prim->numverts; i++){
+      j = gl2psGetIndex(i, prim->numverts);
+      if(d[j] > GL2PS_EPSILON){
+        if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
+        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING; 
+        if(d[i] < -GL2PS_EPSILON){
+          gl2psAddIndex(in0, in1, &in, i, j);
+          gl2psAddIndex(out0, out1, &out, i, j);
+          type = GL2PS_SPANNING;
+        }
+        gl2psAddIndex(out0, out1, &out, j, -1);
+      }
+      else if(d[j] < -GL2PS_EPSILON){
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
+        else if(type != GL2PS_IN_FRONT_OF) type = GL2PS_SPANNING;
+        if(d[i] > GL2PS_EPSILON){
+          gl2psAddIndex(in0, in1, &in, i, j);
+          gl2psAddIndex(out0, out1, &out, i, j);
+          type = GL2PS_SPANNING;
+        }
+        gl2psAddIndex(in0, in1, &in, j, -1);
+      }
+      else{
+        gl2psAddIndex(in0, in1, &in, j, -1);
+        gl2psAddIndex(out0, out1, &out, j, -1);
+      }
+    }
+    break;
+  }
+
+  if(type == GL2PS_SPANNING){
+    *back = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+    *front = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+    gl2psCreateSplitPrimitive(prim, plane, *back, out, out0, out1);
+    gl2psCreateSplitPrimitive(prim, plane, *front, in, in0, in1);
+  }
+
+  return type;
+}
+
+static void gl2psDivideQuad(GL2PSprimitive *quad, 
+                            GL2PSprimitive **t1, GL2PSprimitive **t2)
+{
+  *t1 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+  *t2 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+  (*t1)->type = (*t2)->type = GL2PS_TRIANGLE;
+  (*t1)->numverts = (*t2)->numverts = 3;
+  (*t1)->culled = (*t2)->culled = quad->culled;
+  (*t1)->offset = (*t2)->offset = quad->offset;
+  (*t1)->pattern = (*t2)->pattern = quad->pattern;
+  (*t1)->factor = (*t2)->factor = quad->factor;
+  (*t1)->width = (*t2)->width = quad->width;
+  (*t1)->verts = (GL2PSvertex*)gl2psMalloc(3 * sizeof(GL2PSvertex));
+  (*t2)->verts = (GL2PSvertex*)gl2psMalloc(3 * sizeof(GL2PSvertex));
+  (*t1)->verts[0] = quad->verts[0];
+  (*t1)->verts[1] = quad->verts[1];
+  (*t1)->verts[2] = quad->verts[2];
+  (*t1)->boundary = ((quad->boundary & 1) ? 1 : 0) | ((quad->boundary & 2) ? 2 : 0);
+  (*t2)->verts[0] = quad->verts[0];
+  (*t2)->verts[1] = quad->verts[2];
+  (*t2)->verts[2] = quad->verts[3];
+  (*t2)->boundary = ((quad->boundary & 4) ? 2 : 0) | ((quad->boundary & 4) ? 2 : 0);
+}
+
+static int gl2psCompareDepth(const void *a, const void *b)
+{
+  GL2PSprimitive *q, *w;
+  GLfloat dq = 0.0F, dw = 0.0F, diff;
+  int i;
+  
+  q = *(GL2PSprimitive**)a;
+  w = *(GL2PSprimitive**)b;
+
+  for(i = 0; i < q->numverts; i++){
+    dq += q->verts[i].xyz[2]; 
+  }
+  dq /= (GLfloat)q->numverts;
+
+  for(i = 0; i < w->numverts; i++){
+    dw += w->verts[i].xyz[2]; 
+  }
+  dw /= (GLfloat)w->numverts;
+
+  diff = dq - dw;
+  if(diff > 0.){
+    return -1;
+  }
+  else if(diff < 0.){
+    return 1;
+  }
+  else{
+    return 0;
+  }
+}
+
+static int gl2psTrianglesFirst(const void *a, const void *b)
+{
+  GL2PSprimitive *q, *w;
+
+  q = *(GL2PSprimitive**)a;
+  w = *(GL2PSprimitive**)b;
+  return(q->type < w->type ? 1 : -1);
+}
+
+static GLint gl2psFindRoot(GL2PSlist *primitives, GL2PSprimitive **root)
+{
+  GLint i, j, count, best = 1000000, index = 0;
+  GL2PSprimitive *prim1, *prim2;
+  GL2PSplane plane;
+  GLint maxp;
+
+  if(!gl2psListNbr(primitives)){
+    gl2psMsg(GL2PS_ERROR, "Cannot fint root in empty primitive list");
+    return 0;
+  }
+
+  *root = *(GL2PSprimitive**)gl2psListPointer(primitives, 0);
+
+  if(gl2ps->options & GL2PS_BEST_ROOT){
+    maxp = gl2psListNbr(primitives);
+    if(maxp > gl2ps->maxbestroot){
+      maxp = gl2ps->maxbestroot;
+    }
+    for(i = 0; i < maxp; i++){
+      prim1 = *(GL2PSprimitive**)gl2psListPointer(primitives, i);
+      gl2psGetPlane(prim1, plane);
+      count = 0;
+      for(j = 0; j < gl2psListNbr(primitives); j++){
+        if(j != i){
+          prim2 = *(GL2PSprimitive**)gl2psListPointer(primitives, j);
+          count += gl2psTestSplitPrimitive(prim2, plane); 
+        }
+        if(count > best) break;
+      }
+      if(count < best){
+        best = count;
+        index = i;
+        *root = prim1;
+        if(!count) return index;
+      }
+    }
+    /* if(index) gl2psMsg(GL2PS_INFO, "GL2PS_BEST_ROOT was worth it: %d", index); */
+    return index;
+  }
+  else{
+    return 0;
+  }
+}
+
+static void gl2psFreeImagemap(GL2PSimagemap *list){
+  GL2PSimagemap *next;
+  while(list != NULL){
+    next = list->next;
+    gl2psFree(list->image->pixels);
+    gl2psFree(list->image);
+    gl2psFree(list);
+    list = next;
+  }
+}
+
+static void gl2psFreePrimitive(void *data)
+{
+  GL2PSprimitive *q;
+  
+  q = *(GL2PSprimitive**)data;
+  gl2psFree(q->verts);
+  if(q->type == GL2PS_TEXT || q->type == GL2PS_SPECIAL){
+    gl2psFreeText(q->data.text);
+  }
+  else if(q->type == GL2PS_PIXMAP){
+    gl2psFreePixmap(q->data.image);
+  }
+  gl2psFree(q);
+}
+
+static void gl2psAddPrimitiveInList(GL2PSprimitive *prim, GL2PSlist *list)
+{
+  GL2PSprimitive *t1, *t2;
+
+  if(prim->type != GL2PS_QUADRANGLE){
+    gl2psListAdd(list, &prim);
+  }
+  else{
+    gl2psDivideQuad(prim, &t1, &t2);
+    gl2psListAdd(list, &t1);
+    gl2psListAdd(list, &t2);
+    gl2psFreePrimitive(&prim);
+  }
+  
+}
+
+static void gl2psFreeBspTree(GL2PSbsptree **tree)
+{
+  if(*tree){
+    if((*tree)->back) gl2psFreeBspTree(&(*tree)->back);
+    if((*tree)->primitives){
+      gl2psListAction((*tree)->primitives, gl2psFreePrimitive);
+      gl2psListDelete((*tree)->primitives);
+    }
+    if((*tree)->front) gl2psFreeBspTree(&(*tree)->front);
+    gl2psFree(*tree);
+    *tree = NULL;
+  }
+}
+
+static GLboolean gl2psGreater(GLfloat f1, GLfloat f2)
+{
+  if(f1 > f2) return GL_TRUE;
+  else return GL_FALSE;
+}
+
+static GLboolean gl2psLess(GLfloat f1, GLfloat f2)
+{
+  if(f1 < f2) return GL_TRUE;
+  else return GL_FALSE;
+}
+
+static void gl2psBuildBspTree(GL2PSbsptree *tree, GL2PSlist *primitives)
+{
+  GL2PSprimitive *prim, *frontprim = NULL, *backprim = NULL;
+  GL2PSlist *frontlist, *backlist;
+  GLint i, index;
+
+  tree->front = NULL;
+  tree->back = NULL;
+  tree->primitives = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
+  index = gl2psFindRoot(primitives, &prim);
+  gl2psGetPlane(prim, tree->plane);
+  gl2psAddPrimitiveInList(prim, tree->primitives);
+
+  frontlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
+  backlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
+
+  for(i = 0; i < gl2psListNbr(primitives); i++){
+    if(i != index){
+      prim = *(GL2PSprimitive**)gl2psListPointer(primitives,i);
+      switch(gl2psSplitPrimitive(prim, tree->plane, &frontprim, &backprim)){
+      case GL2PS_COINCIDENT:
+        gl2psAddPrimitiveInList(prim, tree->primitives);
+        break;
+      case GL2PS_IN_BACK_OF:
+        gl2psAddPrimitiveInList(prim, backlist);
+        break;
+      case GL2PS_IN_FRONT_OF:
+        gl2psAddPrimitiveInList(prim, frontlist);
+        break;
+      case GL2PS_SPANNING:
+        gl2psAddPrimitiveInList(backprim, backlist);
+        gl2psAddPrimitiveInList(frontprim, frontlist);
+        gl2psFreePrimitive(&prim);
+        break;
+      }
+    }
+  }
+
+  if(gl2psListNbr(tree->primitives)){
+    gl2psListSort(tree->primitives, gl2psTrianglesFirst);
+  }
+
+  if(gl2psListNbr(frontlist)){
+    gl2psListSort(frontlist, gl2psTrianglesFirst);
+    tree->front = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
+    gl2psBuildBspTree(tree->front, frontlist);
+  }
+  else{
+    gl2psListDelete(frontlist);
+  }
+
+  if(gl2psListNbr(backlist)){
+    gl2psListSort(backlist, gl2psTrianglesFirst);
+    tree->back = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
+    gl2psBuildBspTree(tree->back, backlist);
+  }
+  else{
+    gl2psListDelete(backlist);
+  }
+
+  gl2psListDelete(primitives);
+}
+
+static void gl2psTraverseBspTree(GL2PSbsptree *tree, GL2PSxyz eye, GLfloat epsilon,
+                                 GLboolean (*compare)(GLfloat f1, GLfloat f2),
+                                 void (*action)(void *data), int inverse)
+{
+  GLfloat result;
+
+  if(!tree) return;
+
+  result = gl2psComparePointPlane(eye, tree->plane);
+
+  if(GL_TRUE == compare(result, epsilon)){
+    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
+    if(inverse){
+      gl2psListActionInverse(tree->primitives, action);
+    }
+    else{
+      gl2psListAction(tree->primitives, action);
+    }
+    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
+  }
+  else if(GL_TRUE == compare(-epsilon, result)){ 
+    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
+    if(inverse){
+      gl2psListActionInverse(tree->primitives, action);
+    }
+    else{
+      gl2psListAction(tree->primitives, action);
+    }
+    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
+  }
+  else{
+    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
+    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
+  }
+}
+
+static void gl2psRescaleAndOffset()
+{
+  GL2PSprimitive *prim;
+  GLfloat minZ, maxZ, rangeZ, scaleZ;
+  GLfloat factor, units, area, dZ, dZdX, dZdY, maxdZ;
+  int i, j;
+
+  if(!gl2psListNbr(gl2ps->primitives))
+    return;
+
+  /* get z-buffer range */
+  prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, 0);
+  minZ = maxZ = prim->verts[0].xyz[2];
+  for(i = 1; i < prim->numverts; i++){
+    if(prim->verts[i].xyz[2] < minZ) minZ = prim->verts[i].xyz[2];
+    if(prim->verts[i].xyz[2] > maxZ) maxZ = prim->verts[i].xyz[2];
+  }
+  for(i = 1; i < gl2psListNbr(gl2ps->primitives); i++){
+    prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, i);
+    for(j = 0; j < prim->numverts; j++){
+      if(prim->verts[j].xyz[2] < minZ) minZ = prim->verts[j].xyz[2];
+      if(prim->verts[j].xyz[2] > maxZ) maxZ = prim->verts[j].xyz[2];
+    }
+  }
+  rangeZ = (maxZ - minZ);
+
+  /* rescale z-buffer coordinate in [0,GL2PS_ZSCALE], to make it of
+     the same order of magnitude as the x and y coordinates */
+  scaleZ = GL2PS_ZERO(rangeZ) ? GL2PS_ZSCALE : (GL2PS_ZSCALE / rangeZ);
+  /* avoid precision loss (we use floats!) */
+  if(scaleZ > 100000.F) scaleZ = 100000.F;
+
+  /* apply offsets */
+  for(i = 0; i < gl2psListNbr(gl2ps->primitives); i++){
+    prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, i);
+    for(j = 0; j < prim->numverts; j++){
+      prim->verts[j].xyz[2] = (prim->verts[j].xyz[2] - minZ) * scaleZ;
+    }
+    if((gl2ps->options & GL2PS_SIMPLE_LINE_OFFSET) &&
+       (prim->type == GL2PS_LINE)){
+      if(gl2ps->sort == GL2PS_SIMPLE_SORT){
+        prim->verts[0].xyz[2] -= GL2PS_ZOFFSET_LARGE;
+        prim->verts[1].xyz[2] -= GL2PS_ZOFFSET_LARGE;
+      }
+      else{
+        prim->verts[0].xyz[2] -= GL2PS_ZOFFSET;
+        prim->verts[1].xyz[2] -= GL2PS_ZOFFSET;
+      }
+    }
+    else if(prim->offset && (prim->type == GL2PS_TRIANGLE)){
+      factor = gl2ps->offset[0];
+      units = gl2ps->offset[1];
+      area = 
+        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) * 
+        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) - 
+        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) * 
+        (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]);
+      if(!GL2PS_ZERO(area)){
+        dZdX = 
+          ((prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) *
+           (prim->verts[1].xyz[2] - prim->verts[0].xyz[2]) -
+           (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]) *
+           (prim->verts[2].xyz[2] - prim->verts[1].xyz[2])) / area;
+        dZdY = 
+          ((prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
+           (prim->verts[2].xyz[2] - prim->verts[1].xyz[2]) -
+           (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
+           (prim->verts[1].xyz[2] - prim->verts[0].xyz[2])) / area;
+        maxdZ = (GLfloat)sqrt(dZdX * dZdX + dZdY * dZdY);
+      }
+      else{
+        maxdZ = 0.0F;
+      }
+      dZ = factor * maxdZ + units;
+      prim->verts[0].xyz[2] += dZ;
+      prim->verts[1].xyz[2] += dZ;
+      prim->verts[2].xyz[2] += dZ;
+    }
+  }
+}
+
+/********************************************************************* 
+ *
+ * 2D sorting routines (for occlusion culling) 
+ *
+ *********************************************************************/
+
+static GLint gl2psGetPlaneFromPoints(GL2PSxyz a, GL2PSxyz b, GL2PSplane plane)
+{
+  GLfloat n; 
+
+  plane[0] = b[1] - a[1];
+  plane[1] = a[0] - b[0];
+  n = (GLfloat)sqrt(plane[0]*plane[0] + plane[1]*plane[1]);
+  plane[2] = 0.0F;
+  if(!GL2PS_ZERO(n)){
+    plane[0] /= n;
+    plane[1] /= n;
+    plane[3] = -plane[0]*a[0]-plane[1]*a[1]; 
+    return 1;
+  }
+  else{
+    plane[0] = -1.0F;
+    plane[1] = 0.0F;
+    plane[3] = a[0];
+    return 0;
+  }
+}
+
+static void gl2psFreeBspImageTree(GL2PSbsptree2d **tree)
+{
+  if(*tree){
+    if((*tree)->back)  gl2psFreeBspImageTree(&(*tree)->back);
+    if((*tree)->front) gl2psFreeBspImageTree(&(*tree)->front);
+    gl2psFree(*tree);
+    *tree = NULL;
+  }
+}
+
+static GLint gl2psCheckPoint(GL2PSxyz point, GL2PSplane plane)
+{
+  GLfloat pt_dis;
+
+  pt_dis = gl2psComparePointPlane(point, plane);
+  if(pt_dis > GL2PS_EPSILON)        return GL2PS_POINT_INFRONT;
+  else if(pt_dis < -GL2PS_EPSILON)  return GL2PS_POINT_BACK;
+  else                              return GL2PS_POINT_COINCIDENT;
+}
+
+static void gl2psAddPlanesInBspTreeImage(GL2PSprimitive *prim,
+                                         GL2PSbsptree2d **tree)
+{
+  GLint ret = 0;
+  GLint i;
+  GLint offset = 0;
+  GL2PSbsptree2d *head = NULL, *cur = NULL;
+
+  if((*tree == NULL) && (prim->numverts > 2)){
+    /* don't cull if transparent
+    for(i = 0; i < prim->numverts - 1; i++)
+      if(prim->verts[i].rgba[3] < 1.0F) return;
+    */
+    head = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
+    for(i = 0; i < prim->numverts-1; i++){
+      if(!gl2psGetPlaneFromPoints(prim->verts[i].xyz,
+                                  prim->verts[i+1].xyz,
+                                  head->plane)){
+        if(prim->numverts-i > 3){
+          offset++;
+        }
+        else{
+          gl2psFree(head);
+          return;
+        }
+      }
+      else{
+        break;
+      }
+    }
+    head->back = NULL;
+    head->front = NULL;
+    for(i = 2+offset; i < prim->numverts; i++){
+      ret = gl2psCheckPoint(prim->verts[i].xyz, head->plane);
+      if(ret != GL2PS_POINT_COINCIDENT) break;
+    }
+    switch(ret){
+    case GL2PS_POINT_INFRONT :
+      cur = head;
+      for(i = 1+offset; i < prim->numverts-1; i++){
+        if(cur->front == NULL){
+          cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
+        }
+        if(gl2psGetPlaneFromPoints(prim->verts[i].xyz,
+                                   prim->verts[i+1].xyz,
+                                   cur->front->plane)){
+          cur = cur->front;
+          cur->front = NULL;
+          cur->back = NULL;
+        }
+      }
+      if(cur->front == NULL){
+        cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
+      }
+      if(gl2psGetPlaneFromPoints(prim->verts[i].xyz,
+                                 prim->verts[offset].xyz,
+                                 cur->front->plane)){
+        cur->front->front = NULL;
+        cur->front->back = NULL;
+      }
+      else{
+        gl2psFree(cur->front);
+        cur->front = NULL;
+      }
+      break;
+    case GL2PS_POINT_BACK :
+      for(i = 0; i < 4; i++){
+        head->plane[i] = -head->plane[i];
+      }
+      cur = head;
+      for(i = 1+offset; i < prim->numverts-1; i++){
+        if(cur->front == NULL){
+          cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
+        }
+        if(gl2psGetPlaneFromPoints(prim->verts[i+1].xyz,
+                                   prim->verts[i].xyz,
+                                   cur->front->plane)){
+          cur = cur->front;
+          cur->front = NULL;
+          cur->back = NULL;
+        }
+      }
+      if(cur->front == NULL){
+        cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
+      }
+      if(gl2psGetPlaneFromPoints(prim->verts[offset].xyz,
+                                 prim->verts[i].xyz,
+                                 cur->front->plane)){
+        cur->front->front = NULL;
+        cur->front->back = NULL;
+      }
+      else{
+        gl2psFree(cur->front);
+        cur->front = NULL;
+      }
+      break;
+    default:
+      gl2psFree(head);
+      return;
+    }
+    (*tree) = head;
+  }
+}
+
+static GLint gl2psCheckPrimitive(GL2PSprimitive *prim, GL2PSplane plane)
+{
+  GLint i;
+  GLint pos;
+
+  pos = gl2psCheckPoint(prim->verts[0].xyz, plane);
+  for(i = 1; i < prim->numverts; i++){
+    pos |= gl2psCheckPoint(prim->verts[i].xyz, plane);
+    if(pos == (GL2PS_POINT_INFRONT | GL2PS_POINT_BACK)) return GL2PS_SPANNING;
+  }
+  if(pos & GL2PS_POINT_INFRONT)   return GL2PS_IN_FRONT_OF;
+  else if(pos & GL2PS_POINT_BACK) return GL2PS_IN_BACK_OF;
+  else                            return GL2PS_COINCIDENT;
+}
+
+static GL2PSprimitive *gl2psCreateSplitPrimitive2D(GL2PSprimitive *parent,
+                                                   GLshort numverts,
+                                                   GL2PSvertex *vertx)
+{
+  GLint i;
+  GL2PSprimitive *child = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+
+  if(parent->type == GL2PS_IMAGEMAP){
+    child->type = GL2PS_IMAGEMAP;
+    child->data.image = parent->data.image;
+  }
+  else {
+    switch(numverts){
+    case 1 : child->type = GL2PS_POINT; break;
+    case 2 : child->type = GL2PS_LINE; break;
+    case 3 : child->type = GL2PS_TRIANGLE; break;
+    case 4 : child->type = GL2PS_QUADRANGLE; break;
+    default: child->type = GL2PS_NO_TYPE; break; /* FIXME */
+    }
+  }
+  child->boundary = 0; /* FIXME: not done! */
+  child->culled = parent->culled;
+  child->offset = parent->offset;
+  child->pattern = parent->pattern;
+  child->factor = parent->factor;
+  child->width = parent->width;
+  child->numverts = numverts;
+  child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
+  for(i = 0; i < numverts; i++){
+    child->verts[i] = vertx[i];
+  }
+  return child;
+}
+
+static void gl2psSplitPrimitive2D(GL2PSprimitive *prim,
+                                  GL2PSplane plane, 
+                                  GL2PSprimitive **front, 
+                                  GL2PSprimitive **back)
+{
+  /* cur will hold the position of the current vertex
+     prev will hold the position of the previous vertex
+     prev0 will hold the position of the vertex number 0
+     v1 and v2 represent the current and previous vertices, respectively
+     flag is set if the current vertex should be checked against the plane */
+  GLint cur = -1, prev = -1, i, v1 = 0, v2 = 0, flag = 1, prev0 = -1;
+  
+  /* list of vertices that will go in front and back primitive */
+  GL2PSvertex *front_list = NULL, *back_list = NULL;
+  
+  /* number of vertices in front and back list */
+  GLshort front_count = 0, back_count = 0;
+
+  for(i = 0; i <= prim->numverts; i++){
+    v1 = i;
+    if(v1 == prim->numverts){
+      if(prim->numverts < 3) break;
+      v1 = 0;
+      v2 = prim->numverts - 1;
+      cur = prev0;
+    }
+    else if(flag){
+      cur = gl2psCheckPoint(prim->verts[v1].xyz, plane);
+      if(i == 0){
+        prev0 = cur;
+      }
+    } 
+    if(((prev == -1) || (prev == cur) || (prev == 0) || (cur == 0)) &&
+       (i < prim->numverts)){
+      if(cur == GL2PS_POINT_INFRONT){
+        front_count++;
+        front_list = (GL2PSvertex*)gl2psRealloc(front_list,
+                                                sizeof(GL2PSvertex)*front_count);
+        front_list[front_count-1] = prim->verts[v1];
+      }
+      else if(cur == GL2PS_POINT_BACK){
+        back_count++;
+        back_list = (GL2PSvertex*)gl2psRealloc(back_list,
+                                               sizeof(GL2PSvertex)*back_count);
+        back_list[back_count-1] = prim->verts[v1];
+      }
+      else{
+        front_count++;
+        front_list = (GL2PSvertex*)gl2psRealloc(front_list,
+                                                sizeof(GL2PSvertex)*front_count);
+        front_list[front_count-1] = prim->verts[v1];
+        back_count++;
+        back_list = (GL2PSvertex*)gl2psRealloc(back_list,
+                                               sizeof(GL2PSvertex)*back_count);
+        back_list[back_count-1] = prim->verts[v1];
+      }
+      flag = 1;
+    }
+    else if((prev != cur) && (cur != 0) && (prev != 0)){
+      if(v1 != 0){
+        v2 = v1-1;
+        i--;
+      }
+      front_count++;
+      front_list = (GL2PSvertex*)gl2psRealloc(front_list,
+                                              sizeof(GL2PSvertex)*front_count);
+      gl2psCutEdge(&prim->verts[v2], &prim->verts[v1],
+                   plane, &front_list[front_count-1]);
+      back_count++;
+      back_list = (GL2PSvertex*)gl2psRealloc(back_list,
+                                             sizeof(GL2PSvertex)*back_count);
+      back_list[back_count-1] = front_list[front_count-1];
+      flag = 0;
+    }
+    prev = cur;
+  }
+  *front = gl2psCreateSplitPrimitive2D(prim, front_count, front_list);
+  *back = gl2psCreateSplitPrimitive2D(prim, back_count, back_list);
+  gl2psFree(front_list);
+  gl2psFree(back_list);
+}
+
+static GLint gl2psAddInBspImageTree(GL2PSprimitive *prim, GL2PSbsptree2d **tree)
+{
+  GLint ret = 0;
+  GL2PSprimitive *frontprim = NULL, *backprim = NULL;
+  
+  /* FIXME: until we consider the actual extent of text strings and
+     pixmaps, never cull them. Otherwise the whole string/pixmap gets
+     culled as soon as the reference point is hidden */
+  if(prim->type == GL2PS_PIXMAP || 
+     prim->type == GL2PS_TEXT || 
+     prim->type == GL2PS_SPECIAL){
+    return 1;
+  }
+
+  if(*tree == NULL){
+    if((prim->type != GL2PS_IMAGEMAP) && (GL_FALSE == gl2ps->zerosurfacearea)){
+      gl2psAddPlanesInBspTreeImage(gl2ps->primitivetoadd, tree);
+    }
+    return 1;
+  }
+  else{
+    switch(gl2psCheckPrimitive(prim, (*tree)->plane)){
+    case GL2PS_IN_BACK_OF: return gl2psAddInBspImageTree(prim, &(*tree)->back);
+    case GL2PS_IN_FRONT_OF: 
+      if((*tree)->front != NULL) return gl2psAddInBspImageTree(prim, &(*tree)->front);
+      else                       return 0;
+    case GL2PS_SPANNING:
+      gl2psSplitPrimitive2D(prim, (*tree)->plane, &frontprim, &backprim);
+      ret = gl2psAddInBspImageTree(backprim, &(*tree)->back);
+      if((*tree)->front != NULL){
+        if(gl2psAddInBspImageTree(frontprim, &(*tree)->front)){
+          ret = 1;
+        }
+      }
+      gl2psFree(frontprim->verts);
+      gl2psFree(frontprim);
+      gl2psFree(backprim->verts);
+      gl2psFree(backprim);
+      return ret;
+    case GL2PS_COINCIDENT:
+      if((*tree)->back != NULL){
+        gl2ps->zerosurfacearea = GL_TRUE;
+        ret = gl2psAddInBspImageTree(prim, &(*tree)->back);
+        gl2ps->zerosurfacearea = GL_FALSE;
+        if(ret) return ret;
+      }
+      if((*tree)->front != NULL){
+        gl2ps->zerosurfacearea = GL_TRUE;
+        ret = gl2psAddInBspImageTree(prim, &(*tree)->front);
+        gl2ps->zerosurfacearea = GL_FALSE;
+        if(ret) return ret;
+      }
+      if(prim->type == GL2PS_LINE) return 1;
+      else                         return 0;
+    }
+  }
+  return 0;
+}
+
+static void gl2psAddInImageTree(void *data)
+{
+  GL2PSprimitive *prim = *(GL2PSprimitive **)data;
+  gl2ps->primitivetoadd = prim;
+  if(prim->type == GL2PS_IMAGEMAP && prim->data.image->format == GL2PS_IMAGEMAP_VISIBLE){
+    prim->culled = 1;
+  }
+  else if(!gl2psAddInBspImageTree(prim, &gl2ps->imagetree)){
+    prim->culled = 1;
+  }
+  else if(prim->type == GL2PS_IMAGEMAP){
+    prim->data.image->format = GL2PS_IMAGEMAP_VISIBLE;
+  }
+}
+
+/* Boundary construction */
+
+static void gl2psAddBoundaryInList(GL2PSprimitive *prim, GL2PSlist *list)
+{
+  GL2PSprimitive *b;
+  GLshort i;
+  GL2PSxyz c;
+
+  c[0] = c[1] = c[2] = 0.0F;
+  for(i = 0; i < prim->numverts; i++){
+    c[0] += prim->verts[i].xyz[0];
+    c[1] += prim->verts[i].xyz[1];
+  }
+  c[0] /= prim->numverts;
+  c[1] /= prim->numverts;
+
+  for(i = 0; i < prim->numverts; i++){
+    if(prim->boundary & (GLint)pow(2., i)){
+      b = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+      b->type = GL2PS_LINE;
+      b->offset = prim->offset;
+      b->pattern = prim->pattern;
+      b->factor = prim->factor;
+      b->culled = prim->culled;
+      b->width = prim->width;
+      b->boundary = 0;
+      b->numverts = 2;
+      b->verts = (GL2PSvertex*)gl2psMalloc(2 * sizeof(GL2PSvertex));
+
+#if 0 /* FIXME: need to work on boundary offset... */
+      v[0] = c[0] - prim->verts[i].xyz[0];
+      v[1] = c[1] - prim->verts[i].xyz[1];
+      v[2] = 0.0F;
+      norm = gl2psNorm(v);
+      v[0] /= norm;
+      v[1] /= norm;
+      b->verts[0].xyz[0] = prim->verts[i].xyz[0] +0.1*v[0];
+      b->verts[0].xyz[1] = prim->verts[i].xyz[1] +0.1*v[1];
+      b->verts[0].xyz[2] = prim->verts[i].xyz[2];
+      v[0] = c[0] - prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[0];
+      v[1] = c[1] - prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[1];
+      norm = gl2psNorm(v);
+      v[0] /= norm;
+      v[1] /= norm;
+      b->verts[1].xyz[0] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[0] +0.1*v[0];
+      b->verts[1].xyz[1] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[1] +0.1*v[1];
+      b->verts[1].xyz[2] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[2];
+#else
+      b->verts[0].xyz[0] = prim->verts[i].xyz[0];
+      b->verts[0].xyz[1] = prim->verts[i].xyz[1];
+      b->verts[0].xyz[2] = prim->verts[i].xyz[2];
+      b->verts[1].xyz[0] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[0];
+      b->verts[1].xyz[1] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[1];
+      b->verts[1].xyz[2] = prim->verts[gl2psGetIndex(i, prim->numverts)].xyz[2];
+#endif
+
+      b->verts[0].rgba[0] = 0.0F;
+      b->verts[0].rgba[1] = 0.0F;
+      b->verts[0].rgba[2] = 0.0F;
+      b->verts[0].rgba[3] = 0.0F;
+      b->verts[1].rgba[0] = 0.0F;
+      b->verts[1].rgba[1] = 0.0F;
+      b->verts[1].rgba[2] = 0.0F;
+      b->verts[1].rgba[3] = 0.0F;
+      gl2psListAdd(list, &b);
+    }
+  }
+
+}
+
+static void gl2psBuildPolygonBoundary(GL2PSbsptree *tree)
+{
+  GLint i;
+  GL2PSprimitive *prim;
+
+  if(!tree) return;
+  gl2psBuildPolygonBoundary(tree->back);
+  for(i = 0; i < gl2psListNbr(tree->primitives); i++){
+    prim = *(GL2PSprimitive**)gl2psListPointer(tree->primitives, i);
+    if(prim->boundary) gl2psAddBoundaryInList(prim, tree->primitives);
+  }
+  gl2psBuildPolygonBoundary(tree->front);
+}
+
+/********************************************************************* 
+ *
+ * Feedback buffer parser
+ *
+ *********************************************************************/
+
+static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts, 
+                                  GL2PSvertex *verts, GLint offset, 
+                                  GLushort pattern, GLint factor,
+                                  GLfloat width, char boundary)
+{
+  GL2PSprimitive *prim;
+
+  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+  prim->type = type;
+  prim->numverts = numverts;
+  prim->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
+  memcpy(prim->verts, verts, numverts * sizeof(GL2PSvertex));
+  prim->boundary = boundary;
+  prim->offset = offset;
+  prim->pattern = pattern;
+  prim->factor = factor;
+  prim->width = width;
+  prim->culled = 0;
+
+  /* FIXME: here we should have an option to split stretched
+     tris/quads to enhance SIMPLE_SORT */
+
+  gl2psListAdd(gl2ps->primitives, &prim);
+}
+
+static GLint gl2psGetVertex(GL2PSvertex *v, GLfloat *p)
+{
+  GLint i;
+
+  v->xyz[0] = p[0];
+  v->xyz[1] = p[1];
+  v->xyz[2] = p[2];
+
+  if(gl2ps->colormode == GL_COLOR_INDEX && gl2ps->colorsize > 0){
+    i = (GLint)(p[3] + 0.5);
+    v->rgba[0] = gl2ps->colormap[i][0];
+    v->rgba[1] = gl2ps->colormap[i][1];
+    v->rgba[2] = gl2ps->colormap[i][2];
+    v->rgba[3] = gl2ps->colormap[i][3];
+    return 4;
+  }
+  else{
+    v->rgba[0] = p[3];
+    v->rgba[1] = p[4];
+    v->rgba[2] = p[5];
+    v->rgba[3] = p[6];
+    return 7;
+  }
+}
+
+static void gl2psParseFeedbackBuffer(GLint used)
+{
+  char flag;
+  GLushort pattern = 0;
+  GLboolean boundary;
+  GLint i, sizeoffloat, count, v, vtot, offset = 0, factor = 0, auxindex = 0;
+  GLfloat lwidth = 1.0F, psize = 1.0F;
+  GLfloat *current;
+  GL2PSvertex vertices[3];
+  GL2PSprimitive *prim;
+  GL2PSimagemap *node;
+
+  current = gl2ps->feedback;
+  boundary = gl2ps->boundary = GL_FALSE;
+
+  while(used > 0){
+
+    if(GL_TRUE == boundary) gl2ps->boundary = GL_TRUE;
+    
+    switch((GLint)*current){
+    case GL_POINT_TOKEN :
+      current ++;
+      used --;
+      i = gl2psGetVertex(&vertices[0], current);
+      current += i;
+      used    -= i;
+      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0, 
+                            pattern, factor, psize, 0);
+      break;
+    case GL_LINE_TOKEN :
+    case GL_LINE_RESET_TOKEN :
+      current ++;
+      used --;
+      i = gl2psGetVertex(&vertices[0], current);
+      current += i;
+      used    -= i;
+      i = gl2psGetVertex(&vertices[1], current);
+      current += i;
+      used    -= i;
+      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0, 
+                            pattern, factor, lwidth, 0);
+      break;
+    case GL_POLYGON_TOKEN :
+      count = (GLint)current[1];
+      current += 2;
+      used -= 2;
+      v = vtot = 0;
+      while(count > 0 && used > 0){
+        i = gl2psGetVertex(&vertices[v], current);
+        gl2psAdaptVertexForBlending(&vertices[v]);
+        current += i;
+        used    -= i;
+        count --;
+        vtot++;
+        if(v == 2){
+          if(GL_TRUE == boundary){
+            if(!count && vtot == 2) flag = 1|2|4;
+            else if(!count) flag = 2|4;
+            else if(vtot == 2) flag = 1|2;
+            else flag = 2;
+          }
+          else
+            flag = 0;
+          gl2psAddPolyPrimitive(GL2PS_TRIANGLE, 3, vertices, offset,
+                                pattern, factor, 1, flag);
+          vertices[1] = vertices[2];
+        }
+        else
+          v ++;
+      }
+      break;      
+    case GL_BITMAP_TOKEN :
+    case GL_DRAW_PIXEL_TOKEN :
+    case GL_COPY_PIXEL_TOKEN :
+      current ++;
+      used --;
+      i = gl2psGetVertex(&vertices[0], current);
+      current += i;
+      used    -= i;
+      break;      
+    case GL_PASS_THROUGH_TOKEN :
+      switch((GLint)current[1]){
+      case GL2PS_BEGIN_OFFSET_TOKEN : offset = 1; break;
+      case GL2PS_END_OFFSET_TOKEN : offset = 0; break;
+      case GL2PS_BEGIN_BOUNDARY_TOKEN : boundary = GL_TRUE; break;
+      case GL2PS_END_BOUNDARY_TOKEN : boundary = GL_FALSE; break;
+      case GL2PS_END_STIPPLE_TOKEN : pattern = factor = 0; break;
+      case GL2PS_BEGIN_BLEND_TOKEN : gl2ps->blending = GL_TRUE; break;
+      case GL2PS_END_BLEND_TOKEN : gl2ps->blending = GL_FALSE; break;
+      case GL2PS_BEGIN_STIPPLE_TOKEN : 
+        current += 2;
+        used -= 2; 
+        pattern = (GLushort)current[1]; 
+        current += 2;
+        used -= 2; 
+        factor = (GLint)current[1]; 
+        break;
+      case GL2PS_SRC_BLEND_TOKEN : 
+        current += 2; 
+        used -= 2; 
+        gl2ps->blendfunc[0] = (GLint)current[1];
+        break;
+      case GL2PS_DST_BLEND_TOKEN : 
+        current += 2; 
+        used -= 2; 
+        gl2ps->blendfunc[1] = (GLint)current[1];
+        break;
+      case GL2PS_POINT_SIZE_TOKEN : 
+        current += 2; 
+        used -= 2; 
+        psize = current[1];
+        break;
+      case GL2PS_LINE_WIDTH_TOKEN : 
+        current += 2; 
+        used -= 2; 
+        lwidth = current[1];
+        break;
+      case GL2PS_IMAGEMAP_TOKEN :
+        prim = (GL2PSprimitive *)gl2psMalloc(sizeof(GL2PSprimitive));
+        prim->type = GL2PS_IMAGEMAP;
+        prim->boundary = 0;
+        prim->numverts = 4;
+        prim->verts = (GL2PSvertex *)gl2psMalloc(4 * sizeof(GL2PSvertex));
+        prim->culled = 0;
+        prim->offset = 0;
+        prim->pattern = 0;
+        prim->factor = 0;
+        prim->width = 1;
+        
+        node = (GL2PSimagemap*)gl2psMalloc(sizeof(GL2PSimagemap));
+        node->image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
+        node->image->type = 0;
+        node->image->format = 0;
+        node->next = NULL;
+        
+        if(gl2ps->imagemap_head == NULL)
+          gl2ps->imagemap_head = node;
+        else
+          gl2ps->imagemap_tail->next = node;
+        gl2ps->imagemap_tail = node;
+        prim->data.image = node->image;
+        
+        current += 2; used -= 2;
+        i = gl2psGetVertex(&prim->verts[0], &current[1]);
+        current += i; used -= i;
+        
+        node->image->width = (GLint)current[2];
+        current += 2; used -= 2;
+        node->image->height = (GLint)current[2];
+        prim->verts[0].xyz[0] = prim->verts[0].xyz[0] - (int)(node->image->width / 2) + 0.5;
+        prim->verts[0].xyz[1] = prim->verts[0].xyz[1] - (int)(node->image->height / 2) + 0.5;
+        for(i = 1; i < 4; i++){
+          for(v = 0; v < 3; v++){
+            prim->verts[i].xyz[v] = prim->verts[0].xyz[v];
+            prim->verts[i].rgba[v] = prim->verts[0].rgba[v];
+          }
+          prim->verts[i].rgba[v] = prim->verts[0].rgba[v];
+        }
+        prim->verts[1].xyz[0] = prim->verts[1].xyz[0] + node->image->width;
+        prim->verts[2].xyz[0] = prim->verts[1].xyz[0];
+        prim->verts[2].xyz[1] = prim->verts[2].xyz[1] + node->image->height;
+        prim->verts[3].xyz[1] = prim->verts[2].xyz[1];
+
+        sizeoffloat = sizeof(GLfloat);
+        v = 2 * sizeoffloat;
+        vtot = node->image->height + node->image->height * 
+          ((node->image->width - 1) / 8);
+        node->image->pixels = (GLfloat*)gl2psMalloc(v + vtot);
+        node->image->pixels[0] = prim->verts[0].xyz[0];
+        node->image->pixels[1] = prim->verts[0].xyz[1];
+        
+        for(i = 0; i < vtot; i += sizeoffloat){
+          current += 2; used -= 2;
+          if((vtot - i) >= 4)
+            memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), sizeoffloat);
+          else
+            memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), vtot - i);
+        }
+        current++; used--;
+        gl2psListAdd(gl2ps->primitives, &prim);
+        break;
+      case GL2PS_DRAW_PIXELS_TOKEN :
+      case GL2PS_TEXT_TOKEN :
+        if(auxindex < gl2psListNbr(gl2ps->auxprimitives))
+          gl2psListAdd(gl2ps->primitives, 
+                       gl2psListPointer(gl2ps->auxprimitives, auxindex++));
+        else
+          gl2psMsg(GL2PS_ERROR, "Wrong number of auxiliary tokens in buffer");
+        break;
+      }
+      current += 2; 
+      used -= 2; 
+      break;      
+    default :
+      gl2psMsg(GL2PS_WARNING, "Unknown token in buffer");
+      current ++;
+      used --;
+      break;
+    }
+  }
+
+  gl2psListReset(gl2ps->auxprimitives);
+}
+
+/********************************************************************* 
+ *
+ * PostScript routines
+ *
+ *********************************************************************/
+
+static void gl2psWriteByte(unsigned char byte)
+{
+  unsigned char h = byte / 16;
+  unsigned char l = byte % 16;
+  gl2psPrintf("%x%x", h, l);
+}
+
+static void gl2psPrintPostScriptPixmap(GLfloat x, GLfloat y, GL2PSimage *im)
+{
+  GLuint nbhex, nbyte, nrgb, nbits;
+  GLuint row, col, ibyte, icase;
+  GLfloat dr, dg, db, fgrey;
+  unsigned char red = 0, green = 0, blue = 0, b, grey;
+  GLuint width = (GLuint)im->width;
+  GLuint height = (GLuint)im->height;
+
+  /* FIXME: should we define an option for these? Or just keep the
+     8-bit per component case? */
+  int greyscale = 0; /* set to 1 to output greyscale image */
+  int nbit = 8; /* number of bits per color compoment (2, 4 or 8) */
+
+  if((width <= 0) || (height <= 0)) return;
+
+  gl2psPrintf("gsave\n");
+  gl2psPrintf("%.2f %.2f translate\n", x, y); 
+  gl2psPrintf("%d %d scale\n", width, height); 
+
+  if(greyscale){ /* greyscale */
+    gl2psPrintf("/picstr %d string def\n", width); 
+    gl2psPrintf("%d %d %d\n", width, height, 8); 
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
+    gl2psPrintf("{ currentfile picstr readhexstring pop }\n");
+    gl2psPrintf("image\n");
+    for(row = 0; row < height; row++){
+      for(col = 0; col < width; col++){ 
+        gl2psGetRGB(im, col, row, &dr, &dg, &db);
+        fgrey = (0.30 * dr + 0.59 * dg + 0.11 * db);
+        grey = (unsigned char)(255. * fgrey);
+        gl2psWriteByte(grey);
+      }
+      gl2psPrintf("\n");
+    }
+    nbhex = width * height * 2; 
+    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex); 
+  }
+  else if(nbit == 2){ /* color, 2 bits for r and g and b; rgbs following each other */
+    nrgb = width  * 3;
+    nbits = nrgb * nbit;
+    nbyte = nbits / 8;
+    if((nbyte * 8) != nbits) nbyte++;
+    gl2psPrintf("/rgbstr %d string def\n", nbyte);
+    gl2psPrintf("%d %d %d\n", width, height, nbit);
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
+    gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
+    gl2psPrintf("false 3\n");
+    gl2psPrintf("colorimage\n");
+    for(row = 0; row < height; row++){
+      icase = 1;
+      col = 0;
+      b = 0;
+      for(ibyte = 0; ibyte < nbyte; ibyte++){
+        if(icase == 1) {
+          if(col < width) {
+            gl2psGetRGB(im, col, row, &dr, &dg, &db);
+          } 
+          else {
+            dr = dg = db = 0;
+          }
+          col++;
+          red = (unsigned char)(3. * dr);
+          green = (unsigned char)(3. * dg);
+          blue = (unsigned char)(3. * db);
+          b = red;
+          b = (b<<2) + green;
+          b = (b<<2) + blue;
+          if(col < width) {
+            gl2psGetRGB(im, col, row, &dr, &dg, &db);
+          } 
+          else {
+            dr = dg = db = 0;
+          }
+          col++;
+          red = (unsigned char)(3. * dr);
+          green = (unsigned char)(3. * dg);
+          blue = (unsigned char)(3. * db);
+          b = (b<<2) + red;
+          gl2psWriteByte(b);
+          b = 0;
+          icase++;
+        } 
+        else if(icase == 2) {
+          b = green;
+          b = (b<<2) + blue;
+          if(col < width) {
+            gl2psGetRGB(im, col, row, &dr, &dg, &db);
+          }
+          else {
+            dr = dg = db = 0;
+          }
+          col++;
+          red = (unsigned char)(3. * dr);
+          green = (unsigned char)(3. * dg);
+          blue = (unsigned char)(3. * db);
+          b = (b<<2) + red;
+          b = (b<<2) + green;
+          gl2psWriteByte(b);
+          b = 0;
+          icase++;
+        } 
+        else if(icase == 3) {
+          b = blue;
+          if(col < width) {
+            gl2psGetRGB(im, col, row, &dr, &dg, &db);
+          }
+          else {
+            dr = dg = db = 0;
+          }
+          col++;
+          red = (unsigned char)(3. * dr);
+          green = (unsigned char)(3. * dg);
+          blue = (unsigned char)(3. * db);
+          b = (b<<2) + red;
+          b = (b<<2) + green;
+          b = (b<<2) + blue;
+          gl2psWriteByte(b);
+          b = 0;
+          icase = 1;
+        }
+      }
+      gl2psPrintf("\n");
+    }
+  }
+  else if(nbit == 4){ /* color, 4 bits for r and g and b; rgbs following each other */
+    nrgb = width  * 3;
+    nbits = nrgb * nbit;
+    nbyte = nbits / 8;
+    if((nbyte * 8) != nbits) nbyte++; 
+    gl2psPrintf("/rgbstr %d string def\n", nbyte);
+    gl2psPrintf("%d %d %d\n", width, height, nbit);
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
+    gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
+    gl2psPrintf("false 3\n");
+    gl2psPrintf("colorimage\n");
+    for(row = 0; row < height; row++){
+      col = 0;
+      icase = 1;
+      for(ibyte = 0; ibyte < nbyte; ibyte++){
+        if(icase == 1) {
+          if(col < width) {
+            gl2psGetRGB(im, col, row, &dr, &dg, &db);
+          } 
+          else {
+            dr = dg = db = 0;
+          }
+          col++;
+          red = (unsigned char)(15. * dr);
+          green = (unsigned char)(15. * dg);
+          gl2psPrintf("%x%x", red, green);
+          icase++;
+        } 
+        else if(icase == 2) {
+          blue = (unsigned char)(15. * db);
+          if(col < width) {
+            gl2psGetRGB(im, col, row, &dr, &dg, &db);
+          } 
+          else {
+            dr = dg = db = 0;
+          }
+          col++;
+          red = (unsigned char)(15. * dr);
+          gl2psPrintf("%x%x", blue, red);
+          icase++;
+        }
+        else if(icase == 3) {
+          green = (unsigned char)(15. * dg);
+          blue = (unsigned char)(15. * db);
+          gl2psPrintf("%x%x", green, blue);
+          icase = 1;
+        }
+      }
+      gl2psPrintf("\n");
+    }
+  }
+  else{ /* 8 bit for r and g and b */
+    nbyte = width * 3;
+    gl2psPrintf("/rgbstr %d string def\n", nbyte);
+    gl2psPrintf("%d %d %d\n", width, height, 8);
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
+    gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
+    gl2psPrintf("false 3\n");
+    gl2psPrintf("colorimage\n");
+    for(row = 0; row < height; row++){
+      for(col = 0; col < width; col++){
+        gl2psGetRGB(im, col, row, &dr, &dg, &db);
+        red = (unsigned char)(255. * dr);
+        gl2psWriteByte(red);
+        green = (unsigned char)(255. * dg);
+        gl2psWriteByte(green);
+        blue = (unsigned char)(255. * db);
+        gl2psWriteByte(blue);
+      }
+      gl2psPrintf("\n");
+    }
+  }
+  
+  gl2psPrintf("grestore\n");
+}
+
+static void gl2psPrintPostScriptImagemap(GLfloat x, GLfloat y,
+                                         GLsizei width, GLsizei height,
+                                         const unsigned char *imagemap){
+  int i, size;
+  
+  if((width <= 0) || (height <= 0)) return;
+  
+  size = height + height * (width - 1) / 8;
+  
+  gl2psPrintf("gsave\n");
+  gl2psPrintf("%.2f %.2f translate\n", x, y);
+  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height); 
+  gl2psPrintf("[ %d 0 0 -%d 0 %d ] {<", width, height);
+  for(i = 0; i < size; i++){
+    gl2psWriteByte(*imagemap);
+    imagemap++;
+  }
+  gl2psPrintf(">} imagemask\ngrestore\n");
+}
+
+static void gl2psPrintPostScriptHeader(void)
+{
+  time_t now;
+
+  /* Since compression is not part of the PostScript standard,
+     compressed PostScript files are just gzipped PostScript files
+     ("ps.gz" or "eps.gz") */
+  gl2psPrintGzipHeader();
+
+  time(&now);
+
+  if(gl2ps->format == GL2PS_PS){
+    gl2psPrintf("%%!PS-Adobe-3.0\n");
+  }
+  else{
+    gl2psPrintf("%%!PS-Adobe-3.0 EPSF-3.0\n");
+  }
+
+  gl2psPrintf("%%%%Title: %s\n"
+              "%%%%Creator: GL2PS %d.%d.%d%s, %s\n"
+              "%%%%For: %s\n"
+              "%%%%CreationDate: %s"
+              "%%%%LanguageLevel: 3\n"
+              "%%%%DocumentData: Clean7Bit\n"
+              "%%%%Pages: 1\n",
+              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, 
+              GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
+              gl2ps->producer, ctime(&now));
+
+  if(gl2ps->format == GL2PS_PS){
+    gl2psPrintf("%%%%Orientation: %s\n"
+                "%%%%DocumentMedia: Default %d %d 0 () ()\n",
+                (gl2ps->options & GL2PS_LANDSCAPE) ? "Landscape" : "Portrait",
+                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
+                (int)gl2ps->viewport[2], 
+                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] : 
+                (int)gl2ps->viewport[3]);
+  }
+
+  gl2psPrintf("%%%%BoundingBox: %d %d %d %d\n"
+              "%%%%EndComments\n",
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] : 
+              (int)gl2ps->viewport[0],
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[0] :
+              (int)gl2ps->viewport[1],
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] : 
+              (int)gl2ps->viewport[2],
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
+              (int)gl2ps->viewport[3]);
+
+  /* RGB color: r g b C (replace C by G in output to change from rgb to gray)
+     Grayscale: r g b G
+     Font choose: size fontname FC
+     Text string: (string) x y size fontname S??
+     Rotated text string: (string) angle x y size fontname S??R
+     Point primitive: x y size P
+     Line width: width W
+     Line start: x y LS
+     Line joining last point: x y L
+     Line end: x y LE
+     Flat-shaded triangle: x3 y3 x2 y2 x1 y1 T
+     Smooth-shaded triangle: x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 ST */
+
+  gl2psPrintf("%%%%BeginProlog\n"
+              "/gl2psdict 64 dict def gl2psdict begin\n"
+              "0 setlinecap 0 setlinejoin\n"
+              "/tryPS3shading %s def %% set to false to force subdivision\n"
+              "/rThreshold %g def %% red component subdivision threshold\n"
+              "/gThreshold %g def %% green component subdivision threshold\n"
+              "/bThreshold %g def %% blue component subdivision threshold\n",
+              (gl2ps->options & GL2PS_NO_PS3_SHADING) ? "false" : "true",
+              gl2ps->threshold[0], gl2ps->threshold[1], gl2ps->threshold[2]);
+
+  gl2psPrintf("/BD { bind def } bind def\n"
+              "/C  { setrgbcolor } BD\n"
+              "/G  { 0.082 mul exch 0.6094 mul add exch 0.3086 mul add neg 1.0 add setgray } BD\n"
+              "/W  { setlinewidth } BD\n");
+
+  gl2psPrintf("/FC { findfont exch /SH exch def SH scalefont setfont } BD\n"
+              "/SW { dup stringwidth pop } BD\n"
+              "/S  { FC moveto show } BD\n"
+              "/SBC{ FC moveto SW -2 div 0 rmoveto show } BD\n"
+              "/SBR{ FC moveto SW neg 0 rmoveto show } BD\n"
+              "/SCL{ FC moveto 0 SH -2 div rmoveto show } BD\n"
+              "/SCC{ FC moveto SW -2 div SH -2 div rmoveto show } BD\n"
+              "/SCR{ FC moveto SW neg SH -2 div rmoveto show } BD\n"
+              "/STL{ FC moveto 0 SH neg rmoveto show } BD\n"
+              "/STC{ FC moveto SW -2 div SH neg rmoveto show } BD\n"
+              "/STR{ FC moveto SW neg SH neg rmoveto show } BD\n");
+
+  /* rotated text routines: same nameanem with R appended */
+
+  gl2psPrintf("/FCT { FC translate 0 0 } BD\n"
+              "/SR  { gsave FCT moveto rotate show grestore } BD\n"  
+              "/SBCR{ gsave FCT moveto rotate SW -2 div 0 rmoveto show grestore } BD\n"
+              "/SBRR{ gsave FCT moveto rotate SW neg 0 rmoveto show grestore } BD\n"
+              "/SCLR{ gsave FCT moveto rotate 0 SH -2 div rmoveto show grestore} BD\n");
+  gl2psPrintf("/SCCR{ gsave FCT moveto rotate SW -2 div SH -2 div rmoveto show grestore} BD\n"
+              "/SCRR{ gsave FCT moveto rotate SW neg SH -2 div rmoveto show grestore} BD\n"
+              "/STLR{ gsave FCT moveto rotate 0 SH neg rmoveto show grestore } BD\n"
+              "/STCR{ gsave FCT moveto rotate SW -2 div SH neg rmoveto show grestore } BD\n"
+              "/STRR{ gsave FCT moveto rotate SW neg SH neg rmoveto show grestore } BD\n");
+
+  gl2psPrintf("/P  { newpath 0.0 360.0 arc closepath fill } BD\n"
+              "/LS { newpath moveto } BD\n"
+              "/L  { lineto } BD\n"
+              "/LE { lineto stroke } BD\n"
+              "/T  { newpath moveto lineto lineto closepath fill } BD\n");
+  
+  /* Smooth-shaded triangle with PostScript level 3 shfill operator:
+        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STshfill */
+
+  gl2psPrintf("/STshfill {\n"
+              "      /b1 exch def /g1 exch def /r1 exch def /y1 exch def /x1 exch def\n"
+              "      /b2 exch def /g2 exch def /r2 exch def /y2 exch def /x2 exch def\n"
+              "      /b3 exch def /g3 exch def /r3 exch def /y3 exch def /x3 exch def\n"
+              "      gsave << /ShadingType 4 /ColorSpace [/DeviceRGB]\n"
+              "      /DataSource [ 0 x1 y1 r1 g1 b1 0 x2 y2 r2 g2 b2 0 x3 y3 r3 g3 b3 ] >>\n"
+              "      shfill grestore } BD\n");
+
+  /* Flat-shaded triangle with middle color:
+        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 Tm */
+
+  gl2psPrintf(/* stack : x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 */
+              "/Tm { 3 -1 roll 8 -1 roll 13 -1 roll add add 3 div\n" /* r = (r1+r2+r3)/3 */
+              /* stack : x3 y3 g3 b3 x2 y2 g2 b2 x1 y1 g1 b1 r */
+              "      3 -1 roll 7 -1 roll 11 -1 roll add add 3 div\n" /* g = (g1+g2+g3)/3 */
+              /* stack : x3 y3 b3 x2 y2 b2 x1 y1 b1 r g b */
+              "      3 -1 roll 6 -1 roll 9 -1 roll add add 3 div" /* b = (b1+b2+b3)/3 */
+              /* stack : x3 y3 x2 y2 x1 y1 r g b */
+              " C T } BD\n");
+
+  /* Split triangle in four sub-triangles (at sides middle points) and call the
+     STnoshfill procedure on each, interpolating the colors in RGB space:
+        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STsplit
+     (in procedure comments key: (Vi) = xi yi ri gi bi) */
+
+  gl2psPrintf("/STsplit {\n"
+              "      4 index 15 index add 0.5 mul\n" /* x13 = (x1+x3)/2 */
+              "      4 index 15 index add 0.5 mul\n" /* y13 = (y1+y3)/2 */
+              "      4 index 15 index add 0.5 mul\n" /* r13 = (r1+r3)/2 */
+              "      4 index 15 index add 0.5 mul\n" /* g13 = (g1+g3)/2 */
+              "      4 index 15 index add 0.5 mul\n" /* b13 = (b1+b3)/2 */
+              "      5 copy 5 copy 25 15 roll\n");
+
+  /* at his point, stack = (V3) (V13) (V13) (V13) (V2) (V1) */
+
+  gl2psPrintf("      9 index 30 index add 0.5 mul\n" /* x23 = (x2+x3)/2 */
+              "      9 index 30 index add 0.5 mul\n" /* y23 = (y2+y3)/2 */
+              "      9 index 30 index add 0.5 mul\n" /* r23 = (r2+r3)/2 */
+              "      9 index 30 index add 0.5 mul\n" /* g23 = (g2+g3)/2 */
+              "      9 index 30 index add 0.5 mul\n" /* b23 = (b2+b3)/2 */
+              "      5 copy 5 copy 35 5 roll 25 5 roll 15 5 roll\n");
+
+  /* stack = (V3) (V13) (V23) (V13) (V23) (V13) (V23) (V2) (V1) */
+
+  gl2psPrintf("      4 index 10 index add 0.5 mul\n" /* x12 = (x1+x2)/2 */
+              "      4 index 10 index add 0.5 mul\n" /* y12 = (y1+y2)/2 */
+              "      4 index 10 index add 0.5 mul\n" /* r12 = (r1+r2)/2 */
+              "      4 index 10 index add 0.5 mul\n" /* g12 = (g1+g2)/2 */
+              "      4 index 10 index add 0.5 mul\n" /* b12 = (b1+b2)/2 */
+              "      5 copy 5 copy 40 5 roll 25 5 roll 15 5 roll 25 5 roll\n");
+  
+  /* stack = (V3) (V13) (V23) (V13) (V12) (V23) (V13) (V1) (V12) (V23) (V12) (V2) */
+
+  gl2psPrintf("      STnoshfill STnoshfill STnoshfill STnoshfill } BD\n");
+  
+  /* Gouraud shaded triangle using recursive subdivision until the difference
+     between corner colors does not exceed the thresholds:
+        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STnoshfill  */
+
+  gl2psPrintf("/STnoshfill {\n"
+              "      2 index 8 index sub abs rThreshold gt\n" /* |r1-r2|>rth */
+              "      { STsplit }\n"
+              "      { 1 index 7 index sub abs gThreshold gt\n" /* |g1-g2|>gth */
+              "        { STsplit }\n"
+              "        { dup 6 index sub abs bThreshold gt\n" /* |b1-b2|>bth */
+              "          { STsplit }\n"
+              "          { 2 index 13 index sub abs rThreshold gt\n" /* |r1-r3|>rht */
+              "            { STsplit }\n"
+              "            { 1 index 12 index sub abs gThreshold gt\n" /* |g1-g3|>gth */
+              "              { STsplit }\n"
+              "              { dup 11 index sub abs bThreshold gt\n" /* |b1-b3|>bth */
+              "                { STsplit }\n"
+              "                { 7 index 13 index sub abs rThreshold gt\n"); /* |r2-r3|>rht */
+  gl2psPrintf("                  { STsplit }\n"
+              "                  { 6 index 12 index sub abs gThreshold gt\n" /* |g2-g3|>gth */
+              "                    { STsplit }\n"
+              "                    { 5 index 11 index sub abs bThreshold gt\n" /* |b2-b3|>bth */
+              "                      { STsplit }\n"
+              "                      { Tm }\n" /* all colors sufficiently similar */
+              "                      ifelse }\n"
+              "                    ifelse }\n"
+              "                  ifelse }\n"
+              "                ifelse }\n"
+              "              ifelse }\n"
+              "            ifelse }\n"
+              "          ifelse }\n"
+              "        ifelse }\n"
+              "      ifelse } BD\n");
+  
+  gl2psPrintf("tryPS3shading\n"
+              "{ /shfill where\n"
+              "  { /ST { STshfill } BD }\n"
+              "  { /ST { STnoshfill } BD }\n"
+              "  ifelse }\n"
+              "{ /ST { STnoshfill } BD }\n"
+              "ifelse\n");
+
+  gl2psPrintf("end\n"
+              "%%%%EndProlog\n"
+              "%%%%BeginSetup\n"
+              "/DeviceRGB setcolorspace\n"
+              "gl2psdict begin\n"
+              "%%%%EndSetup\n"
+              "%%%%Page: 1 1\n"
+              "%%%%BeginPageSetup\n");
+  
+  if(gl2ps->options & GL2PS_LANDSCAPE){
+    gl2psPrintf("%d 0 translate 90 rotate\n",
+                (int)gl2ps->viewport[3]);
+  }
+
+  gl2psPrintf("%%%%EndPageSetup\n"
+              "mark\n"
+              "gsave\n"
+              "1.0 1.0 scale\n");
+          
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    gl2psPrintf("%g %g %g C\n"
+                "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
+                "closepath fill\n",
+                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2], 
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], 
+                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
+  }
+}
+
+static void gl2psPrintPostScriptColor(GL2PSrgba rgba)
+{
+  if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
+    gl2psSetLastColor(rgba);
+    gl2psPrintf("%g %g %g C\n", rgba[0], rgba[1], rgba[2]);
+  }
+}
+
+static void gl2psResetPostScriptColor(void)
+{
+  gl2ps->lastrgba[0] = gl2ps->lastrgba[1] = gl2ps->lastrgba[2] = -1.;
+}
+
+static void gl2psEndPostScriptLine(void)
+{
+  int i;
+  if(gl2ps->lastvertex.rgba[0] >= 0.){
+    gl2psPrintf("%g %g LE\n", gl2ps->lastvertex.xyz[0], gl2ps->lastvertex.xyz[1]);
+    for(i = 0; i < 3; i++)
+      gl2ps->lastvertex.xyz[i] = -1.;
+    for(i = 0; i < 4; i++)
+      gl2ps->lastvertex.rgba[i] = -1.;
+  }
+}
+
+static void gl2psParseStipplePattern(GLushort pattern, GLint factor, 
+                                     int *nb, int array[10])
+{
+  int i, n;
+  int on[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+  int off[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+  char tmp[16];
+
+  /* extract the 16 bits from the OpenGL stipple pattern */
+  for(n = 15; n >= 0; n--){
+    tmp[n] = (char)(pattern & 0x01);
+    pattern >>= 1;
+  }
+  /* compute the on/off pixel sequence */
+  n = 0;
+  for(i = 0; i < 8; i++){
+    while(n < 16 && !tmp[n]){ off[i]++; n++; }
+    while(n < 16 && tmp[n]){ on[i]++; n++; }
+    if(n >= 15){ i++; break; }
+  }
+
+  /* store the on/off array from right to left, starting with off
+     pixels. The PostScript specification allows for at most 11
+     elements in the on/off array, so we limit ourselves to 5 on/off
+     couples (our longest possible array is thus [on4 off4 on3 off3
+     on2 off2 on1 off1 on0 off0]) */
+  *nb = 0;
+  for(n = i - 1; n >= 0; n--){
+    array[(*nb)++] = factor * on[n];
+    array[(*nb)++] = factor * off[n];
+    if(*nb == 10) break;
+  }
+}
+
+static int gl2psPrintPostScriptDash(GLushort pattern, GLint factor, const char *str)
+{
+  int len = 0, i, n, array[10];
+
+  if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
+    return 0;
+  
+  gl2ps->lastpattern = pattern;
+  gl2ps->lastfactor = factor;
+  
+  if(!pattern || !factor){
+    /* solid line */
+    len += gl2psPrintf("[] 0 %s\n", str);
+  }
+  else{
+    gl2psParseStipplePattern(pattern, factor, &n, array);
+    len += gl2psPrintf("[");
+    for(i = 0; i < n; i++){
+      if(i) len += gl2psPrintf(" ");
+      len += gl2psPrintf("%d", array[i]);
+    }
+    len += gl2psPrintf("] 0 %s\n", str);
+  }
+  
+  return len;
+}
+
+static void gl2psPrintPostScriptPrimitive(void *data)
+{
+  int newline;
+  GL2PSprimitive *prim;
+
+  prim = *(GL2PSprimitive**)data;
+
+  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) return;
+
+  /* Every effort is made to draw lines as connected segments (i.e.,
+     using a single PostScript path): this is the only way to get nice
+     line joins and to not restart the stippling for every line
+     segment. So if the primitive to print is not a line we must first
+     finish the current line (if any): */
+  if(prim->type != GL2PS_LINE) gl2psEndPostScriptLine();
+
+  switch(prim->type){
+  case GL2PS_POINT :
+    gl2psPrintPostScriptColor(prim->verts[0].rgba);
+    gl2psPrintf("%g %g %g P\n", 
+                prim->verts[0].xyz[0], prim->verts[0].xyz[1], 0.5 * prim->width);
+    break;
+  case GL2PS_LINE :
+    if(!gl2psSamePosition(gl2ps->lastvertex.xyz, prim->verts[0].xyz) ||
+       !gl2psSameColor(gl2ps->lastrgba, prim->verts[0].rgba) ||
+       gl2ps->lastlinewidth != prim->width ||
+       gl2ps->lastpattern != prim->pattern ||
+       gl2ps->lastfactor != prim->factor){
+      /* End the current line if the new segment does not start where
+         the last one ended, or if the color, the width or the
+         stippling have changed (multi-stroking lines with changing
+         colors is necessary until we use /shfill for lines;
+         unfortunately this means that at the moment we can screw up
+         line stippling for smooth-shaded lines) */
+      gl2psEndPostScriptLine();
+      newline = 1;
+    }
+    else{
+      newline = 0;
+    }
+    if(gl2ps->lastlinewidth != prim->width){
+      gl2ps->lastlinewidth = prim->width;
+      gl2psPrintf("%g W\n", gl2ps->lastlinewidth);
+    }
+    gl2psPrintPostScriptDash(prim->pattern, prim->factor, "setdash");
+    gl2psPrintPostScriptColor(prim->verts[0].rgba);
+    gl2psPrintf("%g %g %s\n", prim->verts[0].xyz[0], prim->verts[0].xyz[1],
+                newline ? "LS" : "L");
+    gl2ps->lastvertex = prim->verts[1];
+    break;
+  case GL2PS_TRIANGLE :
+    if(!gl2psVertsSameColor(prim)){
+      gl2psResetPostScriptColor();
+      gl2psPrintf("%g %g %g %g %g %g %g %g %g %g %g %g %g %g %g ST\n",
+                  prim->verts[2].xyz[0], prim->verts[2].xyz[1],
+                  prim->verts[2].rgba[0], prim->verts[2].rgba[1],
+                  prim->verts[2].rgba[2], prim->verts[1].xyz[0],
+                  prim->verts[1].xyz[1], prim->verts[1].rgba[0],
+                  prim->verts[1].rgba[1], prim->verts[1].rgba[2],
+                  prim->verts[0].xyz[0], prim->verts[0].xyz[1],
+                  prim->verts[0].rgba[0], prim->verts[0].rgba[1],
+                  prim->verts[0].rgba[2]);
+    }
+    else{
+      gl2psPrintPostScriptColor(prim->verts[0].rgba);
+      gl2psPrintf("%g %g %g %g %g %g T\n",
+                  prim->verts[2].xyz[0], prim->verts[2].xyz[1],
+                  prim->verts[1].xyz[0], prim->verts[1].xyz[1],
+                  prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+    }
+    break;
+  case GL2PS_QUADRANGLE :
+    gl2psMsg(GL2PS_WARNING, "There should not be any quad left to print");
+    break;
+  case GL2PS_PIXMAP :
+    gl2psPrintPostScriptPixmap(prim->verts[0].xyz[0], prim->verts[0].xyz[1],
+                               prim->data.image);
+    break;
+  case GL2PS_IMAGEMAP :
+    if(prim->data.image->type != GL2PS_IMAGEMAP_WRITTEN){
+      gl2psPrintPostScriptColor(prim->verts[0].rgba);
+      gl2psPrintPostScriptImagemap(prim->data.image->pixels[0],
+                                   prim->data.image->pixels[1],
+                                   prim->data.image->width, prim->data.image->height,
+                                   (const unsigned char*)(&(prim->data.image->pixels[2])));
+      prim->data.image->type = GL2PS_IMAGEMAP_WRITTEN;
+    }
+    break;
+  case GL2PS_TEXT :
+    gl2psPrintPostScriptColor(prim->verts[0].rgba);
+    gl2psPrintf("(%s) ", prim->data.text->str);
+    if(prim->data.text->angle)
+      gl2psPrintf("%g ", prim->data.text->angle);
+    gl2psPrintf("%g %g %d /%s ",
+                prim->verts[0].xyz[0], prim->verts[0].xyz[1],
+                prim->data.text->fontsize, prim->data.text->fontname);
+    switch(prim->data.text->alignment){
+    case GL2PS_TEXT_C:
+      gl2psPrintf(prim->data.text->angle ? "SCCR\n" : "SCC\n");
+      break;
+    case GL2PS_TEXT_CL:
+      gl2psPrintf(prim->data.text->angle ? "SCLR\n" : "SCL\n");
+      break;
+    case GL2PS_TEXT_CR:
+      gl2psPrintf(prim->data.text->angle ? "SCRR\n" : "SCR\n");
+      break;
+    case GL2PS_TEXT_B:
+      gl2psPrintf(prim->data.text->angle ? "SBCR\n" : "SBC\n");
+      break;
+    case GL2PS_TEXT_BR:
+      gl2psPrintf(prim->data.text->angle ? "SBRR\n" : "SBR\n");
+      break;
+    case GL2PS_TEXT_T:
+      gl2psPrintf(prim->data.text->angle ? "STCR\n" : "STC\n");
+      break;
+    case GL2PS_TEXT_TL:
+      gl2psPrintf(prim->data.text->angle ? "STLR\n" : "STL\n");
+      break;
+    case GL2PS_TEXT_TR:
+      gl2psPrintf(prim->data.text->angle ? "STRR\n" : "STR\n");
+      break;
+    case GL2PS_TEXT_BL:
+    default:
+      gl2psPrintf(prim->data.text->angle ? "SR\n" : "S\n");
+      break;
+    }
+    break;
+  case GL2PS_SPECIAL :
+    /* alignment contains the format for which the special output text
+       is intended */
+    if(prim->data.text->alignment == GL2PS_PS ||
+       prim->data.text->alignment == GL2PS_EPS)
+      gl2psPrintf("%s\n", prim->data.text->str);
+    break;
+  default :
+    break;
+  }
+}
+
+static void gl2psPrintPostScriptFooter(void)
+{
+  gl2psPrintf("grestore\n"
+              "showpage\n"
+              "cleartomark\n"
+              "%%%%PageTrailer\n"
+              "%%%%Trailer\n"
+              "end\n"
+              "%%%%EOF\n");
+
+  gl2psPrintGzipFooter();
+}
+
+static void gl2psPrintPostScriptBeginViewport(GLint viewport[4])
+{
+  GLint index;
+  GLfloat rgba[4];
+  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
+
+  glRenderMode(GL_FEEDBACK);
+
+  if(gl2ps->header){
+    gl2psPrintPostScriptHeader();
+    gl2ps->header = GL_FALSE;
+  }
+
+  gl2psPrintf("gsave\n"
+              "1.0 1.0 scale\n");
+
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
+      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
+    }
+    else{
+      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
+      rgba[0] = gl2ps->colormap[index][0];
+      rgba[1] = gl2ps->colormap[index][1];
+      rgba[2] = gl2ps->colormap[index][2];
+      rgba[3] = 1.0F;
+    }
+    gl2psPrintf("%g %g %g C\n"
+                "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
+                "closepath fill\n",
+                rgba[0], rgba[1], rgba[2], 
+                x, y, x+w, y, x+w, y+h, x, y+h);
+  }
+    
+  gl2psPrintf("newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
+              "closepath clip\n",
+              x, y, x+w, y, x+w, y+h, x, y+h);
+  
+}
+
+static GLint gl2psPrintPostScriptEndViewport(void)
+{
+  GLint res;
+
+  res = gl2psPrintPrimitives();
+  gl2psPrintf("grestore\n");
+  return res;
+}
+
+static void gl2psPrintPostScriptFinalPrimitive(void)
+{
+  /* End any remaining line, if any */
+  gl2psEndPostScriptLine();
+}
+
+/* definition of the PostScript and Encapsulated PostScript backends */
+
+static GL2PSbackend gl2psPS = {
+  gl2psPrintPostScriptHeader,
+  gl2psPrintPostScriptFooter,
+  gl2psPrintPostScriptBeginViewport,
+  gl2psPrintPostScriptEndViewport,
+  gl2psPrintPostScriptPrimitive,
+  gl2psPrintPostScriptFinalPrimitive,
+  "ps",
+  "Postscript"
+};
+
+static GL2PSbackend gl2psEPS = {
+  gl2psPrintPostScriptHeader,
+  gl2psPrintPostScriptFooter,
+  gl2psPrintPostScriptBeginViewport,
+  gl2psPrintPostScriptEndViewport,
+  gl2psPrintPostScriptPrimitive,
+  gl2psPrintPostScriptFinalPrimitive,
+  "eps",
+  "Encapsulated Postscript"
+};
+
+/********************************************************************* 
+ *
+ * LaTeX routines
+ *
+ *********************************************************************/
+
+static void gl2psPrintTeXHeader(void)
+{
+  char name[256];
+  time_t now;
+  int i;
+
+  if(gl2ps->filename && strlen(gl2ps->filename) < 256){
+    for(i = strlen(gl2ps->filename)-1; i >= 0; i--){
+      if(gl2ps->filename[i] == '.'){
+        strncpy(name, gl2ps->filename, i);
+        name[i] = '\0';
+        break;
+      }
+    }
+    if(i <= 0) strcpy(name, gl2ps->filename);
+  }
+  else{
+    strcpy(name, "untitled");
+  }
+
+  time(&now);
+
+  fprintf(gl2ps->stream, 
+          "%% Title: %s\n"
+          "%% Creator: GL2PS %d.%d.%d%s, %s\n"
+          "%% For: %s\n"
+          "%% CreationDate: %s",
+          gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
+          GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
+          gl2ps->producer, ctime(&now));
+
+  fprintf(gl2ps->stream, 
+          "\\setlength{\\unitlength}{1pt}\n"
+          "\\begin{picture}(0,0)\n"
+          "\\includegraphics{%s}\n"
+          "\\end{picture}%%\n"
+          "%s\\begin{picture}(%d,%d)(0,0)\n",
+          name, (gl2ps->options & GL2PS_LANDSCAPE) ? "\\rotatebox{90}{" : "",
+          (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
+}
+
+static void gl2psPrintTeXPrimitive(void *data)
+{
+  GL2PSprimitive *prim;
+
+  prim = *(GL2PSprimitive**)data;
+
+  switch(prim->type){
+  case GL2PS_TEXT :
+    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont", 
+            prim->data.text->fontsize);
+    fprintf(gl2ps->stream, "\\put(%g,%g){\\makebox(0,0)",
+            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+    switch(prim->data.text->alignment){
+    case GL2PS_TEXT_C:
+      fprintf(gl2ps->stream, "{");
+      break;
+    case GL2PS_TEXT_CL:
+      fprintf(gl2ps->stream, "[l]{");
+      break;
+    case GL2PS_TEXT_CR:
+      fprintf(gl2ps->stream, "[r]{");
+      break;
+    case GL2PS_TEXT_B:
+      fprintf(gl2ps->stream, "[b]{");
+      break;
+    case GL2PS_TEXT_BR:
+      fprintf(gl2ps->stream, "[br]{");
+      break;
+    case GL2PS_TEXT_T:
+      fprintf(gl2ps->stream, "[t]{");
+      break;
+    case GL2PS_TEXT_TL:
+      fprintf(gl2ps->stream, "[tl]{");
+      break;
+    case GL2PS_TEXT_TR:
+      fprintf(gl2ps->stream, "[tr]{");
+      break;
+    case GL2PS_TEXT_BL:
+    default:
+      fprintf(gl2ps->stream, "[bl]{");
+      break;
+    }
+    if(prim->data.text->angle)
+      fprintf(gl2ps->stream, "\\rotatebox{%g}{", prim->data.text->angle);
+    fprintf(gl2ps->stream, "\\textcolor[rgb]{%g,%g,%g}{{%s}}",
+            prim->verts[0].rgba[0], prim->verts[0].rgba[1], prim->verts[0].rgba[2],
+            prim->data.text->str);
+    if(prim->data.text->angle)
+      fprintf(gl2ps->stream, "}");
+    fprintf(gl2ps->stream, "}}\n");
+    break;
+  case GL2PS_SPECIAL :
+    /* alignment contains the format for which the special output text
+       is intended */
+    if (prim->data.text->alignment == GL2PS_TEX)
+      fprintf(gl2ps->stream, "%s\n", prim->data.text->str);
+    break;
+  default :
+    break;
+  }
+}
+
+static void gl2psPrintTeXFooter(void)
+{
+  fprintf(gl2ps->stream, "\\end{picture}%s\n",
+          (gl2ps->options & GL2PS_LANDSCAPE) ? "}" : "");
+}
+
+static void gl2psPrintTeXBeginViewport(GLint /*viewport*/[4])
+{
+  glRenderMode(GL_FEEDBACK);
+  
+  if(gl2ps->header){
+    gl2psPrintTeXHeader();
+    gl2ps->header = GL_FALSE;
+  }
+}
+
+static GLint gl2psPrintTeXEndViewport(void)
+{
+  return gl2psPrintPrimitives();
+}
+
+static void gl2psPrintTeXFinalPrimitive(void)
+{
+}
+
+/* definition of the LaTeX backend */
+
+static GL2PSbackend gl2psTEX = {
+  gl2psPrintTeXHeader,
+  gl2psPrintTeXFooter,
+  gl2psPrintTeXBeginViewport,
+  gl2psPrintTeXEndViewport,
+  gl2psPrintTeXPrimitive,
+  gl2psPrintTeXFinalPrimitive,
+  "tex",
+  "LaTeX text"
+};
+
+/********************************************************************* 
+ *
+ * PDF routines
+ *
+ *********************************************************************/
+
+static int gl2psPrintPDFCompressorType(void)
+{
+#if defined(GL2PS_HAVE_ZLIB)
+  if(gl2ps->options & GL2PS_COMPRESS){
+    return fprintf(gl2ps->stream, "/Filter [/FlateDecode]\n");
+  }
+#endif
+  return 0;
+}
+
+static int gl2psPrintPDFStrokeColor(GL2PSrgba rgba)
+{
+  int i, offs = 0;
+
+  gl2psSetLastColor(rgba);
+  for(i = 0; i < 3; ++i){
+    if(GL2PS_ZERO(rgba[i]))
+      offs += gl2psPrintf("%.0f ", 0.);
+    else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
+      offs += gl2psPrintf("%f ", rgba[i]);
+    else
+      offs += gl2psPrintf("%g ", rgba[i]);
+  }
+  offs += gl2psPrintf("RG\n");
+  return offs;
+}
+
+static int gl2psPrintPDFFillColor(GL2PSrgba rgba)
+{
+  int i, offs = 0;
+  
+  for(i = 0; i < 3; ++i){
+    if(GL2PS_ZERO(rgba[i]))
+      offs += gl2psPrintf("%.0f ", 0.);
+    else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
+      offs += gl2psPrintf("%f ", rgba[i]);
+    else
+      offs += gl2psPrintf("%g ", rgba[i]);
+  }
+  offs += gl2psPrintf("rg\n");
+  return offs;
+}
+
+static int gl2psPrintPDFLineWidth(GLfloat lw)
+{
+  if(GL2PS_ZERO(lw))
+    return gl2psPrintf("%.0f w\n", 0.);
+  else if(lw < 1e-4 || lw > 1e6) /* avoid %e formatting */
+    return gl2psPrintf("%f w\n", lw);
+  else
+    return gl2psPrintf("%g w\n", lw);
+}
+
+static void gl2psPutPDFText(GL2PSstring *text, int cnt, GLfloat x, GLfloat y)
+{
+  gl2ps->streamlength += 
+    gl2psPrintf("BT\n"
+                "/F%d %d Tf\n"
+                "%f %f Td\n"
+                "(%s) Tj\n"
+                "ET\n", 
+                cnt, text->fontsize, x, y, text->str);  
+}
+
+static void gl2psPutPDFImage(GL2PSimage *image, int cnt, GLfloat x, GLfloat y)
+{
+  gl2ps->streamlength += 
+    gl2psPrintf("q\n"
+                "%d 0 0 %d %f %f cm\n"
+                "/Im%d Do\n"
+                "Q\n",
+                (int)image->width, (int)image->height, x, y, cnt);
+}
+
+static void gl2psPDFstacksInit(void)
+{
+  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1; 
+  gl2ps->extgs_stack = 0;   
+  gl2ps->font_stack = 0;    
+  gl2ps->im_stack = 0;      
+  gl2ps->trgroupobjects_stack = 0;    
+  gl2ps->shader_stack = 0;  
+  gl2ps->mshader_stack = 0; 
+}
+
+static void gl2psPDFgroupObjectInit(GL2PSpdfgroup *gro)
+{
+  if(!gro)
+    return;
+  
+  gro->ptrlist = NULL;
+  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno 
+    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno 
+    = gro->maskshobjno = gro->gsobjno = gro->trgroupobjno = -1;
+}
+
+/* Build up group objects and assign name and object numbers */
+
+static void gl2psPDFgroupListInit(void)
+{
+  int i;
+  GL2PSprimitive *p = NULL;
+  GL2PSpdfgroup gro;
+  int lasttype = GL2PS_NO_TYPE;
+  GL2PSrgba lastrgba = {-1.0F, -1.0F, -1.0F, -1.0F};
+  GLushort lastpattern = 0;
+  GLint lastfactor = 0;
+  GLfloat lastwidth = 1;
+  GL2PStriangle lastt, tmpt;
+  int lastTriangleWasNotSimpleWithSameColor = 0;
+
+  if(!gl2ps->pdfprimlist)
+    return;
+
+  gl2ps->pdfgrouplist = gl2psListCreate(500, 500, sizeof(GL2PSpdfgroup));
+  gl2psInitTriangle(&lastt);
+
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){  
+    p = *(GL2PSprimitive**)gl2psListPointer(gl2ps->pdfprimlist, i);
+    switch(p->type){
+    case GL2PS_PIXMAP:
+      gl2psPDFgroupObjectInit(&gro);
+      gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
+      gro.imno = gl2ps->im_stack++;
+      gl2psListAdd(gro.ptrlist, &p);
+      gl2psListAdd(gl2ps->pdfgrouplist, &gro);
+      break;
+    case GL2PS_TEXT:
+      gl2psPDFgroupObjectInit(&gro);
+      gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
+      gro.fontno = gl2ps->font_stack++;
+      gl2psListAdd(gro.ptrlist, &p);
+      gl2psListAdd(gl2ps->pdfgrouplist, &gro);
+      break;
+    case GL2PS_LINE:
+      if(lasttype != p->type || lastwidth != p->width || 
+         lastpattern != p->pattern || lastfactor != p->factor ||
+         !gl2psSameColor(p->verts[0].rgba, lastrgba)){
+        gl2psPDFgroupObjectInit(&gro);
+        gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
+        gl2psListAdd(gro.ptrlist, &p);
+        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
+      }
+      else{
+        gl2psListAdd(gro.ptrlist, &p);
+      }
+      lastpattern = p->pattern;
+      lastfactor = p->factor;
+      lastwidth = p->width;
+      lastrgba[0] = p->verts[0].rgba[0];
+      lastrgba[1] = p->verts[0].rgba[1];
+      lastrgba[2] = p->verts[0].rgba[2];
+      break;
+    case GL2PS_POINT:
+      if(lasttype != p->type || lastwidth != p->width || 
+         !gl2psSameColor(p->verts[0].rgba, lastrgba)){
+        gl2psPDFgroupObjectInit(&gro);
+        gro.ptrlist = gl2psListCreate(1,2,sizeof(GL2PSprimitive*));
+        gl2psListAdd(gro.ptrlist, &p);
+        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
+      }
+      else{
+        gl2psListAdd(gro.ptrlist, &p);
+      }
+      lastwidth = p->width;
+      lastrgba[0] = p->verts[0].rgba[0];
+      lastrgba[1] = p->verts[0].rgba[1];
+      lastrgba[2] = p->verts[0].rgba[2];
+      break;
+    case GL2PS_TRIANGLE:
+      gl2psFillTriangleFromPrimitive(&tmpt, p, GL_TRUE);
+      lastTriangleWasNotSimpleWithSameColor = 
+        !(tmpt.prop & T_CONST_COLOR && tmpt.prop & T_ALPHA_1) ||
+        !gl2psSameColor(tmpt.vertex[0].rgba, lastt.vertex[0].rgba);
+      if(lasttype == p->type && tmpt.prop == lastt.prop && 
+         lastTriangleWasNotSimpleWithSameColor){
+        /* TODO Check here for last alpha */
+        gl2psListAdd(gro.ptrlist, &p);
+      }
+      else{
+        gl2psPDFgroupObjectInit(&gro);
+        gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
+        gl2psListAdd(gro.ptrlist, &p);
+        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
+      }
+      lastt = tmpt;
+      break;
+    default:
+      break;
+    } 
+    lasttype = p->type;
+  }
+}
+
+static void gl2psSortOutTrianglePDFgroup(GL2PSpdfgroup *gro)
+{
+  GL2PStriangle t;
+  GL2PSprimitive *prim = NULL;
+  
+  if(!gro)
+    return;
+
+  if(!gl2psListNbr(gro->ptrlist))
+    return;
+
+  prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
+
+  if(prim->type != GL2PS_TRIANGLE)
+    return;
+
+  gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
+  
+  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){        
+    gro->gsno = gl2ps->extgs_stack++; 
+    gro->gsobjno = gl2ps->objects_stack ++;
+  }
+  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){              
+    gro->gsno = gl2ps->extgs_stack++;
+    gro->gsobjno = gl2ps->objects_stack++;
+    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
+    gro->trgroupobjno = gl2ps->objects_stack++;
+    gro->maskshno = gl2ps->mshader_stack++;
+    gro->maskshobjno = gl2ps->objects_stack++;
+  }
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){          
+    gro->shno = gl2ps->shader_stack++;
+    gro->shobjno = gl2ps->objects_stack++;
+  }
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){             
+    gro->gsno = gl2ps->extgs_stack++;
+    gro->gsobjno = gl2ps->objects_stack++;
+    gro->shno = gl2ps->shader_stack++; 
+    gro->shobjno = gl2ps->objects_stack++;
+  }
+  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){                
+    gro->gsno = gl2ps->extgs_stack++;
+    gro->gsobjno = gl2ps->objects_stack++;
+    gro->shno = gl2ps->shader_stack++; 
+    gro->shobjno = gl2ps->objects_stack++;
+    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
+    gro->trgroupobjno = gl2ps->objects_stack++;
+    gro->maskshno = gl2ps->mshader_stack++;
+    gro->maskshobjno = gl2ps->objects_stack++;
+  }
+}
+
+/* Main stream data */
+
+static void gl2psPDFgroupListWriteMainStream(void)
+{
+  int i, j, lastel;
+  GL2PSprimitive *prim = NULL, *prev = NULL;
+  GL2PSpdfgroup *gro;
+  GL2PStriangle t;
+
+  if(!gl2ps->pdfgrouplist)
+    return;
+
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+
+    lastel = gl2psListNbr(gro->ptrlist) - 1;
+    if(lastel < 0)
+      continue;
+
+    prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
+
+    switch(prim->type){
+    case GL2PS_POINT:
+      gl2ps->streamlength += gl2psPrintf("1 J\n");
+      gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
+      gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
+      for(j = 0; j <= lastel; ++j){  
+        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+        gl2ps->streamlength +=
+          gl2psPrintf("%f %f m %f %f l\n",
+                      prim->verts[0].xyz[0], prim->verts[0].xyz[1],
+                      prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+      }
+      gl2ps->streamlength += gl2psPrintf("S\n"); 
+      gl2ps->streamlength += gl2psPrintf("0 J\n");
+      break;
+    case GL2PS_LINE:
+      /* We try to use as few paths as possible to draw lines, in
+         order to get nice stippling even when the individual segments
+         are smaller than the stipple */
+      gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
+      gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
+      gl2ps->streamlength += gl2psPrintPostScriptDash(prim->pattern, prim->factor, "d");
+      /* start new path */
+      gl2ps->streamlength += 
+        gl2psPrintf("%f %f m\n", 
+                    prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+      
+      for(j = 1; j <= lastel; ++j){
+        prev = prim;
+        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+        if(!gl2psSamePosition(prim->verts[0].xyz, prev->verts[1].xyz)){
+          /* the starting point of the new segment does not match the
+             end point of the previous line, so we end the current
+             path and start a new one */
+          gl2ps->streamlength += 
+            gl2psPrintf("%f %f l\n", 
+                        prev->verts[1].xyz[0], prev->verts[1].xyz[1]);
+          gl2ps->streamlength += 
+            gl2psPrintf("%f %f m\n", 
+                        prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+        }
+        else{
+          /* the two segements are connected, so we just append to the
+             current path */
+          gl2ps->streamlength += 
+            gl2psPrintf("%f %f l\n",
+                        prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+        }
+      }
+      /* end last path */
+      gl2ps->streamlength += 
+        gl2psPrintf("%f %f l\n", 
+                    prim->verts[1].xyz[0], prim->verts[1].xyz[1]);
+      gl2ps->streamlength += gl2psPrintf("S\n");
+      break;
+    case GL2PS_TRIANGLE:
+      gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
+      gl2psSortOutTrianglePDFgroup(gro);
+      
+      /* No alpha and const color: Simple PDF draw orders  */
+      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){         
+        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);        
+        for(j = 0; j <= lastel; ++j){  
+          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
+          gl2ps->streamlength 
+            += gl2psPrintf("%f %f m\n"
+                           "%f %f l\n"
+                           "%f %f l\n"
+                           "h f\n",
+                           t.vertex[0].xyz[0], t.vertex[0].xyz[1],
+                           t.vertex[1].xyz[0], t.vertex[1].xyz[1],
+                           t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
+        }
+      }
+      /* Const alpha < 1 and const color: Simple PDF draw orders 
+         and an extra extended Graphics State for the alpha const */
+      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){               
+        gl2ps->streamlength += gl2psPrintf("q\n"
+                                           "/GS%d gs\n",
+                                           gro->gsno);
+        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
+        for(j = 0; j <= lastel; ++j){  
+          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
+          gl2ps->streamlength 
+            += gl2psPrintf("%f %f m\n"
+                           "%f %f l\n"
+                           "%f %f l\n"
+                           "h f\n",
+                           t.vertex[0].xyz[0], t.vertex[0].xyz[1],
+                           t.vertex[1].xyz[0], t.vertex[1].xyz[1],
+                           t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
+        }
+        gl2ps->streamlength += gl2psPrintf("Q\n");
+      }
+      /* Variable alpha and const color: Simple PDF draw orders 
+         and an extra extended Graphics State + Xobject + Shader 
+         object for the alpha mask */
+      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){          
+        gl2ps->streamlength += gl2psPrintf("q\n"
+                                           "/GS%d gs\n"
+                                           "/TrG%d Do\n",
+                                           gro->gsno, gro->trgroupno);
+        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
+        for(j = 0; j <= lastel; ++j){  
+          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
+          gl2ps->streamlength 
+            += gl2psPrintf("%f %f m\n"
+                           "%f %f l\n"
+                           "%f %f l\n"
+                           "h f\n",
+                           t.vertex[0].xyz[0], t.vertex[0].xyz[1],
+                           t.vertex[1].xyz[0], t.vertex[1].xyz[1],
+                           t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
+        }
+        gl2ps->streamlength += gl2psPrintf("Q\n");
+      }
+      /* Variable color and no alpha: Shader Object for the colored
+         triangle(s) */
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){              
+        gl2ps->streamlength += gl2psPrintf("/Sh%d sh\n", gro->shno);
+      }
+      /* Variable color and const alpha < 1: Shader Object for the 
+         colored triangle(s) and an extra extended Graphics State 
+         for the alpha const */
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){         
+        gl2ps->streamlength += gl2psPrintf("q\n"
+                                           "/GS%d gs\n"
+                                           "/Sh%d sh\n"
+                                           "Q\n",
+                                           gro->gsno, gro->shno);
+      }
+      /* Variable alpha and color: Shader Object for the colored 
+         triangle(s) and an extra extended Graphics State 
+         + Xobject + Shader object for the alpha mask */
+      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){            
+        gl2ps->streamlength += gl2psPrintf("q\n"
+                                           "/GS%d gs\n"
+                                           "/TrG%d Do\n"
+                                           "/Sh%d sh\n"
+                                           "Q\n",
+                                           gro->gsno, gro->trgroupno, gro->shno);
+      }
+      break;
+    case GL2PS_PIXMAP:
+      for(j = 0; j <= lastel; ++j){
+        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0], 
+                         prim->verts[0].xyz[1]);
+      }
+      break;
+    case GL2PS_TEXT:
+      for(j = 0; j <= lastel; ++j){  
+        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
+        gl2psPutPDFText(prim->data.text, gro->fontno, prim->verts[0].xyz[0],
+                        prim->verts[0].xyz[1]);
+      }
+      break;
+    default:
+      break;
+    } 
+  }
+}
+
+/* Graphics State names */
+
+static int gl2psPDFgroupListWriteGStateResources(void)
+{
+  GL2PSpdfgroup *gro;
+  int offs = 0;
+  int i;
+
+  offs += fprintf(gl2ps->stream,
+                  "/ExtGState\n" 
+                  "<<\n"
+                  "/GSa 7 0 R\n");
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+    if(gro->gsno >= 0)
+      offs += fprintf(gl2ps->stream, "/GS%d %d 0 R\n", gro->gsno, gro->gsobjno);
+  }
+  offs += fprintf(gl2ps->stream, ">>\n"); 
+  return offs;
+}
+
+/* Main Shader names */
+
+static int gl2psPDFgroupListWriteShaderResources(void)
+{
+  GL2PSpdfgroup *gro;
+  int offs = 0;
+  int i;
+
+  offs += fprintf(gl2ps->stream,
+                  "/Shading\n"
+                  "<<\n");
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+    if(gro->shno >= 0)
+      offs += fprintf(gl2ps->stream, "/Sh%d %d 0 R\n", gro->shno, gro->shobjno);
+    if(gro->maskshno >= 0)
+      offs += fprintf(gl2ps->stream, "/TrSh%d %d 0 R\n", gro->maskshno, gro->maskshobjno);
+  }
+  offs += fprintf(gl2ps->stream,">>\n");  
+  return offs;
+}
+
+/* Images & Mask Shader XObject names */
+
+static int gl2psPDFgroupListWriteXObjectResources(void)
+{
+  int i;
+  GL2PSprimitive *p = NULL;
+  GL2PSpdfgroup *gro;
+  int offs = 0;
+
+  offs += fprintf(gl2ps->stream,
+                  "/XObject\n"
+                  "<<\n");
+
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+    if(!gl2psListNbr(gro->ptrlist))
+      continue;
+    p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
+    switch(p->type){
+    case GL2PS_PIXMAP:
+      gro->imobjno = gl2ps->objects_stack++;
+      if(GL_RGBA == p->data.image->format)  /* reserve one object for image mask */
+        gl2ps->objects_stack++;
+      offs += fprintf(gl2ps->stream, "/Im%d %d 0 R\n", gro->imno, gro->imobjno);
+    case GL2PS_TRIANGLE:
+      if(gro->trgroupno >=0)
+        offs += fprintf(gl2ps->stream, "/TrG%d %d 0 R\n", gro->trgroupno, gro->trgroupobjno);
+      break;
+    default:
+      break;
+    }
+  }
+  offs += fprintf(gl2ps->stream,">>\n");
+  return offs;
+}
+
+/* Font names */
+
+static int gl2psPDFgroupListWriteFontResources(void)
+{
+  int i;
+  GL2PSpdfgroup *gro;
+  int offs = 0;
+
+  offs += fprintf(gl2ps->stream, "/Font\n<<\n");
+
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+    if(gro->fontno < 0)
+      continue;
+    gro->fontobjno = gl2ps->objects_stack++;
+    offs += fprintf(gl2ps->stream, "/F%d %d 0 R\n", gro->fontno, gro->fontobjno);
+  }
+  offs += fprintf(gl2ps->stream, ">>\n");
+
+  return offs;
+}
+
+static void gl2psPDFgroupListDelete(void)
+{
+  int i;
+  GL2PSpdfgroup *gro = NULL;
+  
+  if(!gl2ps->pdfgrouplist)
+    return;
+
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){ 
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist,i);
+    gl2psListDelete(gro->ptrlist);
+  }
+
+  gl2psListDelete(gl2ps->pdfgrouplist);
+  gl2ps->pdfgrouplist = NULL;
+}
+
+/* Print 1st PDF object - file info */
+
+static int gl2psPrintPDFInfo(void)
+{
+  int offs;
+  time_t now;
+  struct tm *newtime;
+  
+  time(&now);
+  newtime = gmtime(&now);
+  
+  offs = fprintf(gl2ps->stream,
+                 "1 0 obj\n"
+                 "<<\n"
+                 "/Title (%s)\n"
+                 "/Creator (GL2PS %d.%d.%d%s, %s)\n"
+                 "/Producer (%s)\n",
+                 gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
+                 GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
+                 gl2ps->producer);
+  
+  if(!newtime){
+    offs += fprintf(gl2ps->stream, 
+                    ">>\n"
+                    "endobj\n");
+    return offs;
+  }
+  
+  offs += fprintf(gl2ps->stream, 
+                  "/CreationDate (D:%d%02d%02d%02d%02d%02d)\n"
+                  ">>\n"
+                  "endobj\n",
+                  newtime->tm_year+1900, 
+                  newtime->tm_mon+1, 
+                  newtime->tm_mday,
+                  newtime->tm_hour,
+                  newtime->tm_min,
+                  newtime->tm_sec);
+  return offs;
+}
+
+/* Create catalog and page structure - 2nd and 3th PDF object */
+
+static int gl2psPrintPDFCatalog(void)
+{
+  return fprintf(gl2ps->stream, 
+                 "2 0 obj\n"
+                 "<<\n"
+                 "/Type /Catalog\n"
+                 "/Pages 3 0 R\n"
+                 ">>\n"
+                 "endobj\n");
+}
+
+static int gl2psPrintPDFPages(void)
+{
+  return fprintf(gl2ps->stream, 
+                 "3 0 obj\n"
+                 "<<\n" 
+                 "/Type /Pages\n"
+                 "/Kids [6 0 R]\n"
+                 "/Count 1\n"
+                 ">>\n"
+                 "endobj\n");
+}
+
+/* Open stream for data - graphical objects, fonts etc. PDF object 4 */
+
+static int gl2psOpenPDFDataStream(void)
+{
+  int offs = 0;
+  
+  offs += fprintf(gl2ps->stream, 
+                  "4 0 obj\n"
+                  "<<\n" 
+                  "/Length 5 0 R\n" );
+  offs += gl2psPrintPDFCompressorType();
+  offs += fprintf(gl2ps->stream, 
+                  ">>\n"
+                  "stream\n");
+  return offs;
+}
+
+/* Stream setup - Graphics state, fill background if allowed */
+
+static int gl2psOpenPDFDataStreamWritePreface(void)
+{
+  int offs;
+
+  offs = gl2psPrintf("/GSa gs\n");
+  
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    offs += gl2psPrintPDFFillColor(gl2ps->bgcolor);
+    offs += gl2psPrintf("%d %d %d %d re\n",
+                        (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
+                        (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
+    offs += gl2psPrintf("f\n");  
+  }
+  return offs;
+}
+
+/* Use the functions above to create the first part of the PDF*/
+
+static void gl2psPrintPDFHeader(void)
+{
+  int offs = 0;
+  gl2ps->pdfprimlist = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
+  gl2psPDFstacksInit();
+
+  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack); 
+
+#if defined(GL2PS_HAVE_ZLIB)
+  if(gl2ps->options & GL2PS_COMPRESS){
+    gl2psSetupCompress();
+  }
+#endif    
+  gl2ps->xreflist[0] = 0;
+  offs += fprintf(gl2ps->stream, "%%PDF-1.4\n");
+  gl2ps->xreflist[1] = offs;
+  
+  offs += gl2psPrintPDFInfo();
+  gl2ps->xreflist[2] = offs;
+  
+  offs += gl2psPrintPDFCatalog();
+  gl2ps->xreflist[3] = offs;
+  
+  offs += gl2psPrintPDFPages();
+  gl2ps->xreflist[4] = offs;
+  
+  offs += gl2psOpenPDFDataStream();
+  gl2ps->xreflist[5] = offs; /* finished in gl2psPrintPDFFooter */
+  gl2ps->streamlength = gl2psOpenPDFDataStreamWritePreface();
+}
+
+/* The central primitive drawing */
+
+static void gl2psPrintPDFPrimitive(void *data)
+{
+  GL2PSprimitive *prim = *(GL2PSprimitive**)data;
+
+  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) 
+    return;
+
+  prim = gl2psCopyPrimitive(prim); /* deep copy */
+  gl2psListAdd(gl2ps->pdfprimlist, &prim);
+}
+
+/* close stream and ... */
+
+static int gl2psClosePDFDataStream(void)
+{
+  int offs = 0;
+ 
+#if defined(GL2PS_HAVE_ZLIB)
+  if(gl2ps->options & GL2PS_COMPRESS){
+    if(Z_OK != gl2psDeflate())
+      gl2psMsg(GL2PS_ERROR, "Zlib deflate error");
+    else
+      fwrite(gl2ps->compress->dest, gl2ps->compress->destLen, 1, gl2ps->stream);
+    gl2ps->streamlength += gl2ps->compress->destLen;
+    
+    offs += gl2ps->streamlength;
+    gl2psFreeCompress();
+  }
+#endif 
+  
+  offs += fprintf(gl2ps->stream, 
+                  "endstream\n"
+                  "endobj\n");
+  return offs;
+}
+
+/* ... write the now known length object */
+
+static int gl2psPrintPDFDataStreamLength(int val)
+{
+  return fprintf(gl2ps->stream,
+                 "5 0 obj\n"
+                 "%d\n"
+                 "endobj\n", val);
+}
+
+/* Put the info created before in PDF objects */
+
+static int gl2psPrintPDFOpenPage(void)
+{
+  int offs;
+  
+  /* Write fixed part */
+  
+  offs = fprintf(gl2ps->stream, 
+                 "6 0 obj\n"
+                 "<<\n" 
+                 "/Type /Page\n"
+                 "/Parent 3 0 R\n"
+                 "/MediaBox [%d %d %d %d]\n",
+                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
+                 (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
+  
+  if(gl2ps->options & GL2PS_LANDSCAPE)
+    offs += fprintf(gl2ps->stream, "/Rotate -90\n");
+  
+  offs += fprintf(gl2ps->stream,
+                  "/Contents 4 0 R\n"
+                  "/Resources\n" 
+                  "<<\n" 
+                  "/ProcSet [/PDF /Text /ImageB /ImageC]  %%/ImageI\n");
+  
+  return offs;
+
+  /* End fixed part, proceeds in gl2psPDFgroupListWriteVariableResources() */
+}
+
+static int gl2psPDFgroupListWriteVariableResources(void)
+{
+  int offs = 0;
+  
+  /* a) Graphics States for shader alpha masks*/
+  offs += gl2psPDFgroupListWriteGStateResources();  
+  
+  /* b) Shader and shader masks */ 
+  offs += gl2psPDFgroupListWriteShaderResources();  
+ 
+  /* c) XObjects (Images & Shader Masks) */
+  offs += gl2psPDFgroupListWriteXObjectResources();
+  
+  /* d) Fonts */
+  offs += gl2psPDFgroupListWriteFontResources();
+  
+  /* End resources and page */
+  offs += fprintf(gl2ps->stream,
+                  ">>\n"
+                  ">>\n"
+                  "endobj\n");
+  return offs;
+}
+
+/* Standard Graphics State */
+
+static int gl2psPrintPDFGSObject(void)
+{
+  return fprintf(gl2ps->stream,
+                 "7 0 obj\n"
+                 "<<\n"
+                 "/Type /ExtGState\n"
+                 "/SA false\n"
+                 "/SM 0.02\n"
+                 "/OP false\n"
+                 "/op false\n"
+                 "/OPM 0\n"
+                 "/BG2 /Default\n"
+                 "/UCR2 /Default\n"
+                 "/TR2 /Default\n"
+                 ">>\n"
+                 "endobj\n");
+}
+
+/* Put vertex' edge flag (8bit) and coordinates (32bit) in shader stream */
+
+static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex, 
+                                              size_t (*action)(unsigned long data, 
+                                                               size_t size), 
+                                              GLfloat dx, GLfloat dy, 
+                                              GLfloat xmin, GLfloat ymin)
+{
+  int offs = 0;
+  unsigned long imap;
+  GLfloat diff;
+  double dmax = ~1UL;
+  char edgeflag = 0;
+
+  /* FIXME: temp bux fix for 64 bit archs: */
+  if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
+
+  offs += (*action)(edgeflag, 1);
+
+  /* The Shader stream in PDF requires to be in a 'big-endian'
+     order */
+    
+  if(GL2PS_ZERO(dx * dy)){
+    offs += (*action)(0, 4);
+    offs += (*action)(0, 4);
+  }
+  else{
+    diff = (vertex->xyz[0] - xmin) / dx;
+    if(diff > 1)
+      diff = 1.0F;
+    else if(diff < 0)
+      diff = 0.0F;
+    imap = (unsigned long)(diff * dmax);
+    offs += (*action)(imap, 4);
+      
+    diff = (vertex->xyz[1] - ymin) / dy;
+    if(diff > 1)
+      diff = 1.0F;
+    else if(diff < 0)
+      diff = 0.0F;
+    imap = (unsigned long)(diff * dmax);
+    offs += (*action)(imap, 4);
+  }
+  
+  return offs;
+}
+
+/* Put vertex' rgb value (8bit for every component) in shader stream */
+
+static int gl2psPrintPDFShaderStreamDataRGB(GL2PSvertex *vertex,
+                                            size_t (*action)(unsigned long data, 
+                                                             size_t size))
+{
+  int offs = 0;
+  unsigned long imap;
+  double dmax = ~1UL;
+
+  /* FIXME: temp bux fix for 64 bit archs: */
+  if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
+
+  imap = (unsigned long)((vertex->rgba[0]) * dmax);
+  offs += (*action)(imap, 1);
+    
+  imap = (unsigned long)((vertex->rgba[1]) * dmax);
+  offs += (*action)(imap, 1);
+    
+  imap = (unsigned long)((vertex->rgba[2]) * dmax);
+  offs += (*action)(imap, 1);
+  
+  return offs;
+}
+
+/* Put vertex' alpha (8/16bit) in shader stream */
+
+static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex, 
+                                              size_t (*action)(unsigned long data, 
+                                                               size_t size),
+                                              int sigbyte)
+{
+  int offs = 0;
+  unsigned long imap;
+  double dmax = ~1UL;
+
+  /* FIXME: temp bux fix for 64 bit archs: */
+  if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
+
+  if(sigbyte != 8 && sigbyte != 16)
+    sigbyte = 8;
+        
+  sigbyte /= 8;
+  
+  imap = (unsigned long)((vertex->rgba[3]) * dmax);
+  
+  offs += (*action)(imap, sigbyte);
+  
+  return offs;
+}
+
+/* Put a triangles raw data in shader stream */
+
+static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle, 
+                                         GLfloat dx, GLfloat dy, 
+                                         GLfloat xmin, GLfloat ymin,
+                                         size_t (*action)(unsigned long data, 
+                                                          size_t size),
+                                         int gray)
+{
+  int i, offs = 0;
+  GL2PSvertex v;
+  
+  if(gray && gray != 8 && gray != 16)
+    gray = 8;
+  
+  for(i = 0; i < 3; ++i){
+    offs += gl2psPrintPDFShaderStreamDataCoord(&triangle->vertex[i], action,
+                                               dx, dy, xmin, ymin);
+    if(gray){ 
+      v = triangle->vertex[i];
+      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray); 
+    }
+    else{
+      offs += gl2psPrintPDFShaderStreamDataRGB(&triangle->vertex[i], action);
+    }
+  }
+  
+  return offs;
+}
+
+static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax, 
+                             GLfloat *ymin, GLfloat *ymax, 
+                             GL2PStriangle *triangles, int cnt)
+{
+  int i, j;
+
+  *xmin = triangles[0].vertex[0].xyz[0];
+  *xmax = triangles[0].vertex[0].xyz[0];
+  *ymin = triangles[0].vertex[0].xyz[1];
+  *ymax = triangles[0].vertex[0].xyz[1];
+  
+  for(i = 0; i < cnt; ++i){
+    for(j = 0; j < 3; ++j){
+      if(*xmin > triangles[i].vertex[j].xyz[0])
+        *xmin = triangles[i].vertex[j].xyz[0];
+      if(*xmax < triangles[i].vertex[j].xyz[0])
+        *xmax = triangles[i].vertex[j].xyz[0];
+      if(*ymin > triangles[i].vertex[j].xyz[1])
+        *ymin = triangles[i].vertex[j].xyz[1];
+      if(*ymax < triangles[i].vertex[j].xyz[1])
+        *ymax = triangles[i].vertex[j].xyz[1];
+    }
+  }
+}
+
+/* Writes shaded triangle 
+   gray == 0 means write RGB triangles
+   gray == 8             8bit-grayscale (for alpha masks)
+   gray == 16            16bit-grayscale (for alpha masks) */
+
+static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles, 
+                               int size, int gray)
+{
+  int i, offs = 0, vertexbytes, done = 0;
+  GLfloat xmin, xmax, ymin, ymax;
+        
+  switch(gray){
+  case 0:
+    vertexbytes = 1+4+4+1+1+1;
+    break;
+  case 8:
+    vertexbytes = 1+4+4+1;
+    break;
+  case 16:
+    vertexbytes = 1+4+4+2;
+    break;
+  default:
+    gray = 8;
+    vertexbytes = 1+4+4+1;
+    break;
+  }
+  
+  gl2psPDFRectHull(&xmin, &xmax, &ymin, &ymax, triangles, size);
+  
+  offs += fprintf(gl2ps->stream,
+                  "%d 0 obj\n"
+                  "<< "
+                  "/ShadingType 4 "
+                  "/ColorSpace %s "
+                  "/BitsPerCoordinate 32 "
+                  "/BitsPerComponent %d "
+                  "/BitsPerFlag 8 "
+                  "/Decode [%f %f %f %f 0 1 %s] ",
+                  obj,
+                  (gray) ? "/DeviceGray" : "/DeviceRGB", 
+                  (gray) ? gray : 8,
+                  xmin, xmax, ymin, ymax,
+                  (gray) ? "" : "0 1 0 1");
+  
+#if defined(GL2PS_HAVE_ZLIB)
+  if(gl2ps->options & GL2PS_COMPRESS){
+    gl2psAllocCompress(vertexbytes * size * 3);
+
+    for(i = 0; i < size; ++i)
+      gl2psPrintPDFShaderStreamData(&triangles[i],
+                                    xmax-xmin, ymax-ymin, xmin, ymin, 
+                                    gl2psWriteBigEndianCompress, gray);
+
+    if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
+      offs += gl2psPrintPDFCompressorType();
+      offs += fprintf(gl2ps->stream,
+                      "/Length %d "
+                      ">>\n"
+                      "stream\n",
+                      (int)gl2ps->compress->destLen);
+      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, 
+                                                gl2ps->compress->destLen, 
+                                                1, gl2ps->stream);
+      done = 1;
+    }
+    gl2psFreeCompress();
+  }
+#endif
+
+  if(!done){
+    /* no compression, or too long after compression, or compress error
+       -> write non-compressed entry */
+    offs += fprintf(gl2ps->stream,
+                    "/Length %d "
+                    ">>\n"
+                    "stream\n",
+                    vertexbytes * 3 * size);
+    for(i = 0; i < size; ++i)
+      offs += gl2psPrintPDFShaderStreamData(&triangles[i],
+                                            xmax-xmin, ymax-ymin, xmin, ymin,
+                                            gl2psWriteBigEndian, gray);
+  }
+  
+  offs += fprintf(gl2ps->stream,
+                  "\nendstream\n"
+                  "endobj\n");
+  
+  return offs;
+}
+
+/* Writes a XObject for a shaded triangle mask */
+
+static int gl2psPrintPDFShaderMask(int obj, int childobj)
+{
+  int offs = 0, len;
+  
+  offs += fprintf(gl2ps->stream,
+                  "%d 0 obj\n"
+                  "<<\n"
+                  "/Type /XObject\n"
+                  "/Subtype /Form\n"
+                  "/BBox [ %d %d %d %d ]\n"
+                  "/Group \n<<\n/S /Transparency /CS /DeviceRGB\n"
+                  ">>\n",
+                  obj,
+                  (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
+                  (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
+  
+  len = (childobj>0) 
+    ? strlen("/TrSh sh\n") + (int)log10((double)childobj)+1
+    : strlen("/TrSh0 sh\n"); 
+  
+  offs += fprintf(gl2ps->stream,
+                  "/Length %d\n"
+                  ">>\n"
+                  "stream\n",
+                  len);
+  offs += fprintf(gl2ps->stream,
+                  "/TrSh%d sh\n",
+                  childobj);
+  offs += fprintf(gl2ps->stream,
+                  "endstream\n"
+                  "endobj\n");
+  
+  return offs;
+}
+
+/* Writes a Extended graphics state for a shaded triangle mask if
+   simplealpha ist true the childobj argument is ignored and a /ca
+   statement will be written instead */
+
+static int gl2psPrintPDFShaderExtGS(int obj, int childobj)
+{
+  int offs = 0;
+  
+  offs += fprintf(gl2ps->stream,
+                  "%d 0 obj\n"
+                  "<<\n",
+                  obj);
+  
+  offs += fprintf(gl2ps->stream,
+                  "/SMask << /S /Alpha /G %d 0 R >> ",
+                  childobj);
+  
+  offs += fprintf(gl2ps->stream,
+                  ">>\n"
+                  "endobj\n");
+  return offs;
+}
+
+/* a simple graphics state */
+
+static int gl2psPrintPDFShaderSimpleExtGS(int obj, GLfloat alpha)
+{
+  int offs = 0;
+  
+  offs += fprintf(gl2ps->stream,
+                  "%d 0 obj\n"
+                  "<<\n"
+                  "/ca %g"
+                  ">>\n"
+                  "endobj\n",
+                  obj, alpha);
+  return offs;
+}
+
+/* Similar groups of functions for pixmaps and text */
+
+static int gl2psPrintPDFPixmapStreamData(GL2PSimage *im,
+                                         size_t (*action)(unsigned long data, 
+                                                          size_t size), 
+                                         int gray)
+{
+  int x, y;
+  GLfloat r, g, b, a;
+
+  if(im->format != GL_RGBA && gray)
+    return 0;
+
+  if(gray && gray !=8 && gray != 16)
+    gray = 8;
+
+  gray /= 8;
+  
+  for(y = 0; y < im->height; ++y){
+    for(x = 0; x < im->width; ++x){
+      a = gl2psGetRGB(im, x, y, &r, &g, &b);
+      if(im->format == GL_RGBA && gray){
+        (*action)((unsigned long)(a*255) << 24, gray);
+      }
+      else{
+        (*action)((unsigned long)(r*255) << 24, 1);
+        (*action)((unsigned long)(g*255) << 24, 1);
+        (*action)((unsigned long)(b*255) << 24, 1);
+      }
+    }
+  }
+
+  switch(gray){
+  case 0: return 3 * im->width * im->height;
+  case 1: return im->width * im->height;
+  case 2: return 2 * im->width * im->height;
+  default: return 3 * im->width * im->height;
+  }
+}
+
+static int gl2psPrintPDFPixmap(int obj, int childobj, GL2PSimage *im, int gray)
+{
+  int offs = 0, done = 0, sigbytes = 3;
+
+  if(gray && gray !=8 && gray != 16)
+    gray = 8;
+  
+  if(gray)
+    sigbytes = gray / 8; 
+  
+  offs += fprintf(gl2ps->stream,
+                  "%d 0 obj\n"
+                  "<<\n"
+                  "/Type /XObject\n"
+                  "/Subtype /Image\n"
+                  "/Width %d\n"
+                  "/Height %d\n"
+                  "/ColorSpace %s \n"
+                  "/BitsPerComponent 8\n",
+                  obj,
+                  (int)im->width, (int)im->height,
+                  (gray) ? "/DeviceGray" : "/DeviceRGB" );
+  if(GL_RGBA == im->format && gray == 0){
+    offs += fprintf(gl2ps->stream,
+                    "/SMask %d 0 R\n",
+                    childobj);
+  }
+  
+#if defined(GL2PS_HAVE_ZLIB)
+  if(gl2ps->options & GL2PS_COMPRESS){
+    gl2psAllocCompress((int)(im->width * im->height * sigbytes));
+    
+    gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndianCompress, gray);
+    
+    if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
+      offs += gl2psPrintPDFCompressorType();
+      offs += fprintf(gl2ps->stream,
+                      "/Length %d "
+                      ">>\n"
+                      "stream\n",
+                      (int)gl2ps->compress->destLen);
+      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, gl2ps->compress->destLen,
+                                                1, gl2ps->stream);
+      done = 1;
+    }
+    gl2psFreeCompress();
+  }
+#endif
+  
+  if(!done){
+    /* no compression, or too long after compression, or compress error
+       -> write non-compressed entry */
+    offs += fprintf(gl2ps->stream,
+                    "/Length %d "
+                    ">>\n"
+                    "stream\n",
+                    (int)(im->width * im->height * sigbytes));
+    offs += gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndian, gray);
+  }
+  
+  offs += fprintf(gl2ps->stream,
+                  "\nendstream\n"
+                  "endobj\n");
+  
+  return offs;
+}
+
+static int gl2psPrintPDFText(int obj, GL2PSstring *s, int fontnumber)
+{
+  int offs = 0;
+  
+  offs += fprintf(gl2ps->stream,
+                  "%d 0 obj\n"
+                  "<<\n"
+                  "/Type /Font\n"
+                  "/Subtype /Type1\n"
+                  "/Name /F%d\n"
+                  "/BaseFont /%s\n"
+                  "/Encoding /MacRomanEncoding\n"
+                  ">>\n"
+                  "endobj\n",
+                  obj, fontnumber, s->fontname);
+  return offs;
+}
+
+/* Write the physical objects */
+
+static int gl2psPDFgroupListWriteObjects(int entryoffs)
+{
+  int i,j;
+  GL2PSprimitive *p = NULL;
+  GL2PSpdfgroup *gro;
+  int offs = entryoffs;
+  GL2PStriangle *triangles;
+  int size = 0;
+
+  if(!gl2ps->pdfgrouplist)
+    return offs;
+  
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+    if(!gl2psListNbr(gro->ptrlist))
+      continue;
+    p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
+    switch(p->type){
+    case GL2PS_POINT:
+      break;
+    case GL2PS_LINE:
+      break;
+    case GL2PS_TRIANGLE:
+      size = gl2psListNbr(gro->ptrlist);
+      triangles = (GL2PStriangle*)gl2psMalloc(sizeof(GL2PStriangle) * size);
+      for(j = 0; j < size; ++j){  
+        p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
+        gl2psFillTriangleFromPrimitive(&triangles[j], p, GL_TRUE);
+      }
+      if(triangles[0].prop & T_VAR_COLOR){
+        gl2ps->xreflist[gro->shobjno] = offs;
+        offs += gl2psPrintPDFShader(gro->shobjno, triangles, size, 0);
+      }
+      if(triangles[0].prop & T_ALPHA_LESS_1){
+        gl2ps->xreflist[gro->gsobjno] = offs;
+        offs += gl2psPrintPDFShaderSimpleExtGS(gro->gsobjno, triangles[0].vertex[0].rgba[3]);
+      }
+      if(triangles[0].prop & T_VAR_ALPHA){
+        gl2ps->xreflist[gro->gsobjno] = offs;
+        offs += gl2psPrintPDFShaderExtGS(gro->gsobjno, gro->trgroupobjno);
+        gl2ps->xreflist[gro->trgroupobjno] = offs;
+        offs += gl2psPrintPDFShaderMask(gro->trgroupobjno, gro->maskshno);
+        gl2ps->xreflist[gro->maskshobjno] = offs;
+        offs += gl2psPrintPDFShader(gro->maskshobjno, triangles, size, 8);
+      }
+      gl2psFree(triangles);
+      break;
+    case GL2PS_PIXMAP:
+      gl2ps->xreflist[gro->imobjno] = offs;
+      offs += gl2psPrintPDFPixmap(gro->imobjno, gro->imobjno+1, p->data.image, 0);
+      if(p->data.image->format == GL_RGBA){
+        gl2ps->xreflist[gro->imobjno+1] = offs;
+        offs += gl2psPrintPDFPixmap(gro->imobjno+1, -1, p->data.image, 8);
+      }
+      break;
+    case GL2PS_TEXT:
+      gl2ps->xreflist[gro->fontobjno] = offs;
+      offs += gl2psPrintPDFText(gro->fontobjno,p->data.text,gro->fontno);
+      break;
+    case GL2PS_SPECIAL :
+      /* alignment contains the format for which the special output text
+         is intended */
+      if(p->data.text->alignment == GL2PS_PDF)
+        offs += fprintf(gl2ps->stream, "%s\n", p->data.text->str);
+      break;
+    default:
+      break;
+    } 
+  }
+  return offs;
+}
+
+/* All variable data has been written at this point and all required
+   functioninality has been gathered, so we can write now file footer
+   with cross reference table and trailer */
+
+static void gl2psPrintPDFFooter(void)
+{
+  int i, offs;  
+
+  gl2psPDFgroupListInit();
+  gl2psPDFgroupListWriteMainStream();
+ 
+  offs = gl2ps->xreflist[5] + gl2ps->streamlength; 
+  offs += gl2psClosePDFDataStream();
+  gl2ps->xreflist[5] = offs;
+  
+  offs += gl2psPrintPDFDataStreamLength(gl2ps->streamlength);
+  gl2ps->xreflist[6] = offs;
+  gl2ps->streamlength = 0;
+  
+  offs += gl2psPrintPDFOpenPage();
+  offs += gl2psPDFgroupListWriteVariableResources();
+  gl2ps->xreflist = (int*)gl2psRealloc(gl2ps->xreflist,
+                                       sizeof(int) * (gl2ps->objects_stack + 1));
+  gl2ps->xreflist[7] = offs;
+  
+  offs += gl2psPrintPDFGSObject();
+  gl2ps->xreflist[8] = offs;
+  
+  gl2ps->xreflist[gl2ps->objects_stack] = 
+    gl2psPDFgroupListWriteObjects(gl2ps->xreflist[8]);
+
+  /* Start cross reference table. The file has to been opened in
+     binary mode to preserve the 20 digit string length! */
+  fprintf(gl2ps->stream,
+          "xref\n"
+          "0 %d\n"
+          "%010d 65535 f \n", gl2ps->objects_stack, 0);
+  
+  for(i = 1; i < gl2ps->objects_stack; ++i)
+    fprintf(gl2ps->stream, "%010d 00000 n \n", gl2ps->xreflist[i]);
+  
+  fprintf(gl2ps->stream,
+          "trailer\n"
+          "<<\n" 
+          "/Size %d\n"
+          "/Info 1 0 R\n"
+          "/Root 2 0 R\n"
+          ">>\n"
+          "startxref\n%d\n"
+          "%%%%EOF\n",
+          gl2ps->objects_stack, gl2ps->xreflist[gl2ps->objects_stack]);
+  
+  /* Free auxiliary lists and arrays */    
+  gl2psFree(gl2ps->xreflist);
+  gl2psListAction(gl2ps->pdfprimlist, gl2psFreePrimitive);
+  gl2psListDelete(gl2ps->pdfprimlist);
+  gl2psPDFgroupListDelete();
+  
+#if defined(GL2PS_HAVE_ZLIB)
+  if(gl2ps->options & GL2PS_COMPRESS){
+    gl2psFreeCompress();
+    gl2psFree(gl2ps->compress);
+    gl2ps->compress = NULL;
+  }
+#endif
+}
+
+/* PDF begin viewport */
+
+static void gl2psPrintPDFBeginViewport(GLint viewport[4])
+{
+  int offs = 0;
+  GLint index;
+  GLfloat rgba[4];
+  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
+  
+  glRenderMode(GL_FEEDBACK);
+  
+  if(gl2ps->header){
+    gl2psPrintPDFHeader();
+    gl2ps->header = GL_FALSE;
+  }
+
+  offs += gl2psPrintf("q\n");
+  
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
+      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
+    }
+    else{
+      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
+      rgba[0] = gl2ps->colormap[index][0];
+      rgba[1] = gl2ps->colormap[index][1];
+      rgba[2] = gl2ps->colormap[index][2];
+      rgba[3] = 1.0F;
+    }
+    offs += gl2psPrintPDFFillColor(rgba);
+    offs += gl2psPrintf("%d %d %d %d re\n"
+                        "W\n"
+                        "f\n",
+                        x, y, w, h);
+  }
+  else{
+    offs += gl2psPrintf("%d %d %d %d re\n"
+                        "W\n"   
+                        "n\n",
+                        x, y, w, h);            
+  }
+  
+  gl2ps->streamlength += offs;
+}
+
+static GLint gl2psPrintPDFEndViewport(void)
+{
+  GLint res;
+  
+  res = gl2psPrintPrimitives();
+  gl2ps->streamlength += gl2psPrintf("Q\n");
+  return res;
+}
+
+static void gl2psPrintPDFFinalPrimitive(void)
+{
+}
+
+/* definition of the PDF backend */
+
+static GL2PSbackend gl2psPDF = {
+  gl2psPrintPDFHeader,
+  gl2psPrintPDFFooter,
+  gl2psPrintPDFBeginViewport,
+  gl2psPrintPDFEndViewport,
+  gl2psPrintPDFPrimitive,
+  gl2psPrintPDFFinalPrimitive,
+  "pdf",
+  "Portable Document Format"
+};
+
+/********************************************************************* 
+ *
+ * SVG routines
+ *
+ *********************************************************************/
+
+static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts, 
+                                       GL2PSxyz *xyz, GL2PSrgba *rgba)
+{
+  int i, j;
+
+  for(i = 0; i < n; i++){
+    xyz[i][0] = verts[i].xyz[0];
+    xyz[i][1] = gl2ps->viewport[3] - verts[i].xyz[1];
+    xyz[i][2] = 0.0F;
+    for(j = 0; j < 4; j++)
+      rgba[i][j] = verts[i].rgba[j];
+  }
+}
+
+static void gl2psSVGGetColorString(GL2PSrgba rgba, char str[32])
+{
+  int r = (int)(255. * rgba[0]);
+  int g = (int)(255. * rgba[1]);
+  int b = (int)(255. * rgba[2]);
+  int rc = (r < 0) ? 0 : (r > 255) ? 255 : r;
+  int gc = (g < 0) ? 0 : (g > 255) ? 255 : g;
+  int bc = (b < 0) ? 0 : (b > 255) ? 255 : b;
+  sprintf(str, "#%2.2x%2.2x%2.2x", rc, gc, bc);
+}
+
+static void gl2psPrintSVGHeader(void)
+{
+  int x, y, width, height;
+  char col[32];
+  time_t now;
+  
+  time(&now);
+  
+  if (gl2ps->options & GL2PS_LANDSCAPE){
+    x = (int)gl2ps->viewport[1];
+    y = (int)gl2ps->viewport[0];
+    width = (int)gl2ps->viewport[3];
+    height = (int)gl2ps->viewport[2];
+  }
+  else{
+    x = (int)gl2ps->viewport[0];
+    y = (int)gl2ps->viewport[1];
+    width = (int)gl2ps->viewport[2];
+    height = (int)gl2ps->viewport[3];
+  }
+  
+  /* Compressed SVG files (.svgz) are simply gzipped SVG files */
+  gl2psPrintGzipHeader();
+  
+  gl2psPrintf("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");
+  gl2psPrintf("<svg xmlns=\"http://www.w3.org/2000/svg\"\n");
+  gl2psPrintf("     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n"
+              "     width=\"%dpx\" height=\"%dpx\" viewBox=\"%d %d %d %d\">\n",
+              width, height, x, y, width, height);
+  gl2psPrintf("<title>%s</title>\n", gl2ps->title);
+  gl2psPrintf("<desc>\n");
+  gl2psPrintf("Creator: GL2PS %d.%d.%d%s, %s\n"
+              "For: %s\n"
+              "CreationDate: %s",
+              GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION,
+              GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT, gl2ps->producer, ctime(&now));
+  gl2psPrintf("</desc>\n");
+  gl2psPrintf("<defs>\n");
+  gl2psPrintf("</defs>\n");
+
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    gl2psSVGGetColorString(gl2ps->bgcolor, col);
+    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], 
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1], 
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
+  }
+
+  /* group all the primitives and disable antialiasing */
+  gl2psPrintf("<g shape-rendering=\"crispEdges\">\n");
+}
+
+static void gl2psPrintSVGSmoothTriangle(GL2PSxyz xyz[3], GL2PSrgba rgba[3])
+{
+  int i;
+  GL2PSxyz xyz2[3];
+  GL2PSrgba rgba2[3];
+  char col[32];
+
+  /* Apparently there is no easy way to do Gouraud shading in SVG
+     without explicitly pre-defining gradients, so for now we just do
+     recursive subdivision */
+
+  if(gl2psSameColorThreshold(3, rgba, gl2ps->threshold)){
+    gl2psSVGGetColorString(rgba[0], col);
+    gl2psPrintf("<polygon fill=\"%s\" ", col);
+    if(rgba[0][3] < 1.0F) gl2psPrintf("fill-opacity=\"%g\" ", rgba[0][3]);
+    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1], 
+                xyz[1][0], xyz[1][1], xyz[2][0], xyz[2][1]);
+  }
+  else{
+    /* subdivide into 4 subtriangles */
+    for(i = 0; i < 3; i++){
+      xyz2[0][i] = xyz[0][i]; 
+      xyz2[1][i] = 0.5 * (xyz[0][i] + xyz[1][i]);
+      xyz2[2][i] = 0.5 * (xyz[0][i] + xyz[2][i]);
+    }
+    for(i = 0; i < 4; i++){
+      rgba2[0][i] = rgba[0][i]; 
+      rgba2[1][i] = 0.5 * (rgba[0][i] + rgba[1][i]);
+      rgba2[2][i] = 0.5 * (rgba[0][i] + rgba[2][i]);
+    }
+    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
+    for(i = 0; i < 3; i++){
+      xyz2[0][i] = 0.5 * (xyz[0][i] + xyz[1][i]);
+      xyz2[1][i] = xyz[1][i]; 
+      xyz2[2][i] = 0.5 * (xyz[1][i] + xyz[2][i]);
+    }
+    for(i = 0; i < 4; i++){
+      rgba2[0][i] = 0.5 * (rgba[0][i] + rgba[1][i]);
+      rgba2[1][i] = rgba[1][i]; 
+      rgba2[2][i] = 0.5 * (rgba[1][i] + rgba[2][i]);
+    }
+    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
+    for(i = 0; i < 3; i++){
+      xyz2[0][i] = 0.5 * (xyz[0][i] + xyz[2][i]);
+      xyz2[1][i] = xyz[2][i]; 
+      xyz2[2][i] = 0.5 * (xyz[1][i] + xyz[2][i]);
+    }
+    for(i = 0; i < 4; i++){
+      rgba2[0][i] = 0.5 * (rgba[0][i] + rgba[2][i]);
+      rgba2[1][i] = rgba[2][i]; 
+      rgba2[2][i] = 0.5 * (rgba[1][i] + rgba[2][i]);
+    }
+    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
+    for(i = 0; i < 3; i++){
+      xyz2[0][i] = 0.5 * (xyz[0][i] + xyz[1][i]);
+      xyz2[1][i] = 0.5 * (xyz[1][i] + xyz[2][i]); 
+      xyz2[2][i] = 0.5 * (xyz[0][i] + xyz[2][i]);
+    }
+    for(i = 0; i < 4; i++){
+      rgba2[0][i] = 0.5 * (rgba[0][i] + rgba[1][i]);
+      rgba2[1][i] = 0.5 * (rgba[1][i] + rgba[2][i]); 
+      rgba2[2][i] = 0.5 * (rgba[0][i] + rgba[2][i]);
+    }
+    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
+  }
+}
+
+static void gl2psPrintSVGDash(GLushort pattern, GLint factor)
+{
+  int i, n, array[10];
+
+  if(!pattern || !factor) return; /* solid line */
+
+  gl2psParseStipplePattern(pattern, factor, &n, array);
+  gl2psPrintf("stroke-dasharray=\"");
+  for(i = 0; i < n; i++){
+    if(i) gl2psPrintf(",");
+    gl2psPrintf("%d", array[i]);
+  }
+  gl2psPrintf("\" ");
+}
+
+static void gl2psEndSVGLine(void)
+{
+  int i;
+  if(gl2ps->lastvertex.rgba[0] >= 0.){
+    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0], 
+                gl2ps->viewport[3] - gl2ps->lastvertex.xyz[1]);
+    for(i = 0; i < 3; i++)
+      gl2ps->lastvertex.xyz[i] = -1.;
+    for(i = 0; i < 4; i++)
+      gl2ps->lastvertex.rgba[i] = -1.;
+  }
+}
+
+static void gl2psPrintSVGPixmap(GLfloat /*x*/, GLfloat /*y*/, GL2PSimage * /*pixmap*/)
+{
+#if defined(GL2PS_HAVE_LIBPNG)
+  GL2PSlist *png;
+  unsigned char c;
+  int i;
+
+  /* The only image types supported by the SVG standard are JPEG, PNG
+     and SVG. Here we choose PNG, and since we want to embed the image
+     directly in the SVG stream (and not link to an external image
+     file), we need to encode the pixmap into PNG in memory, then
+     encode it into base64. */
+
+  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000, 
+                        sizeof(unsigned char));
+  gl2psConvertPixmapToPNG(pixmap, png);
+  gl2psListEncodeBase64(png);
+  gl2psPrintf("<image x=\"%g\" y=\"%g\" width=\"%d\" height=\"%d\"\n",
+              x, y - pixmap->height, pixmap->width, pixmap->height);
+  gl2psPrintf("xlink:href=\"data:image/png;base64,");
+  for(i = 0; i < gl2psListNbr(png); i++){
+    gl2psListRead(png, i, &c);
+    gl2psPrintf("%c", c);
+  }
+  gl2psPrintf("\"/>\n");
+  gl2psListDelete(png);
+#else
+  gl2psMsg(GL2PS_WARNING, "GL2PS has to be compiled with PNG support in "
+           "order to embed images in SVG streams");
+#endif
+}
+
+static void gl2psPrintSVGPrimitive(void *data)
+{
+  GL2PSprimitive *prim;
+  GL2PSxyz xyz[4];
+  GL2PSrgba rgba[4];
+  char col[32];
+  int newline;
+
+  prim = *(GL2PSprimitive**)data;
+
+  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) return;
+
+  /* We try to draw connected lines as a single path to get nice line
+     joins and correct stippling. So if the primitive to print is not
+     a line we must first finish the current line (if any): */
+  if(prim->type != GL2PS_LINE) gl2psEndSVGLine();
+
+  gl2psSVGGetCoordsAndColors(prim->numverts, prim->verts, xyz, rgba);
+
+  switch(prim->type){
+  case GL2PS_POINT :
+    gl2psSVGGetColorString(rgba[0], col);
+    gl2psPrintf("<circle fill=\"%s\" ", col);
+    if(rgba[0][3] < 1.0F) gl2psPrintf("fill-opacity=\"%g\" ", rgba[0][3]);
+    gl2psPrintf("cx=\"%g\" cy=\"%g\" r=\"%g\"/>\n",
+                xyz[0][0], xyz[0][1], 0.5 * prim->width);
+    break;
+  case GL2PS_LINE :
+    if(!gl2psSamePosition(gl2ps->lastvertex.xyz, prim->verts[0].xyz) ||
+       !gl2psSameColor(gl2ps->lastrgba, prim->verts[0].rgba) ||
+       gl2ps->lastlinewidth != prim->width ||
+       gl2ps->lastpattern != prim->pattern ||
+       gl2ps->lastfactor != prim->factor){
+      /* End the current line if the new segment does not start where
+         the last one ended, or if the color, the width or the
+         stippling have changed (we will need to use multi-point
+         gradients for smooth-shaded lines) */
+      gl2psEndSVGLine();
+      newline = 1;
+    }
+    else{
+      newline = 0;
+    }
+    gl2ps->lastvertex = prim->verts[1];
+    gl2psSetLastColor(prim->verts[0].rgba);
+    gl2ps->lastlinewidth = prim->width;
+    gl2ps->lastpattern = prim->pattern;
+    gl2ps->lastfactor = prim->factor;
+    if(newline){
+      gl2psSVGGetColorString(rgba[0], col);
+      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ", 
+                  col, prim->width);
+      if(rgba[0][3] < 1.0F) gl2psPrintf("stroke-opacity=\"%g\" ", rgba[0][3]);
+      gl2psPrintSVGDash(prim->pattern, prim->factor);
+      gl2psPrintf("points=\"%g,%g ", xyz[0][0], xyz[0][1]);
+    }
+    else{
+      gl2psPrintf("%g,%g ", xyz[0][0], xyz[0][1]);
+    }
+    break;
+  case GL2PS_TRIANGLE :
+    gl2psPrintSVGSmoothTriangle(xyz, rgba);
+    break;
+  case GL2PS_QUADRANGLE :
+    gl2psMsg(GL2PS_WARNING, "There should not be any quad left to print");
+    break;
+  case GL2PS_PIXMAP :
+    gl2psPrintSVGPixmap(xyz[0][0], xyz[0][1], prim->data.image);
+    break;
+  case GL2PS_TEXT :
+    gl2psSVGGetColorString(prim->verts[0].rgba, col);
+    gl2psPrintf("<text fill=\"%s\" x=\"%g\" y=\"%g\" font-size=\"%d\" ",
+                col, xyz[0][0], xyz[0][1], prim->data.text->fontsize);
+    if(!strcmp(prim->data.text->fontname, "Times-Roman"))
+      gl2psPrintf("font-family=\"Times\">");
+    else if(!strcmp(prim->data.text->fontname, "Times-Bold"))
+      gl2psPrintf("font-family=\"Times\" font-weight=\"bold\">");
+    else if(!strcmp(prim->data.text->fontname, "Times-Italic"))
+      gl2psPrintf("font-family=\"Times\" font-style=\"italic\">");
+    else if(!strcmp(prim->data.text->fontname, "Times-BoldItalic"))
+      gl2psPrintf("font-family=\"Times\" font-style=\"italic\" font-weight=\"bold\">");
+    else if(!strcmp(prim->data.text->fontname, "Helvetica-Bold"))
+      gl2psPrintf("font-family=\"Helvetica\" font-weight=\"bold\">");
+    else if(!strcmp(prim->data.text->fontname, "Helvetica-Oblique"))
+      gl2psPrintf("font-family=\"Helvetica\" font-style=\"oblique\">");
+    else if(!strcmp(prim->data.text->fontname, "Helvetica-BoldOblique"))
+      gl2psPrintf("font-family=\"Helvetica\" font-style=\"oblique\" font-weight=\"bold\">");
+    else if(!strcmp(prim->data.text->fontname, "Courier-Bold"))
+      gl2psPrintf("font-family=\"Courier\" font-weight=\"bold\">");
+    else if(!strcmp(prim->data.text->fontname, "Courier-Oblique"))
+      gl2psPrintf("font-family=\"Courier\" font-style=\"oblique\">");
+    else if(!strcmp(prim->data.text->fontname, "Courier-BoldOblique"))
+      gl2psPrintf("font-family=\"Courier\" font-style=\"oblique\" font-weight=\"bold\">");
+    else
+      gl2psPrintf("font-family=\"%s\">", prim->data.text->fontname);
+    gl2psPrintf("%s</text>\n", prim->data.text->str);
+    break;
+  case GL2PS_SPECIAL :
+    /* alignment contains the format for which the special output text
+       is intended */
+    if(prim->data.text->alignment == GL2PS_SVG)
+      gl2psPrintf("%s\n", prim->data.text->str);
+    break;
+  default :
+    break;
+  }
+}
+
+static void gl2psPrintSVGFooter(void)
+{
+  gl2psPrintf("</g>\n");
+  gl2psPrintf("</svg>\n");  
+  
+  gl2psPrintGzipFooter();
+}
+
+static void gl2psPrintSVGBeginViewport(GLint viewport[4])
+{
+  GLint index;
+  char col[32];
+  GLfloat rgba[4];
+  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
+
+  glRenderMode(GL_FEEDBACK);
+  
+  if(gl2ps->header){
+    gl2psPrintSVGHeader();
+    gl2ps->header = GL_FALSE;
+  }
+
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
+      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
+    }
+    else{
+      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
+      rgba[0] = gl2ps->colormap[index][0];
+      rgba[1] = gl2ps->colormap[index][1];
+      rgba[2] = gl2ps->colormap[index][2];
+      rgba[3] = 1.0F;
+    }
+    gl2psSVGGetColorString(rgba, col);
+    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col, 
+                x, gl2ps->viewport[3] - y, 
+                x + w, gl2ps->viewport[3] - y, 
+                x + w, gl2ps->viewport[3] - (y + h), 
+                x, gl2ps->viewport[3] - (y + h));
+  }
+
+  gl2psPrintf("<clipPath id=\"cp%d%d%d%d\">\n", x, y, w, h);
+  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", 
+              x, gl2ps->viewport[3] - y, 
+              x + w, gl2ps->viewport[3] - y, 
+              x + w, gl2ps->viewport[3] - (y + h), 
+              x, gl2ps->viewport[3] - (y + h));
+  gl2psPrintf("</clipPath>\n");
+  gl2psPrintf("<g clip-path=\"url(#cp%d%d%d%d)\">\n", x, y, w, h);
+}
+
+static GLint gl2psPrintSVGEndViewport(void)
+{
+  GLint res;
+
+  res = gl2psPrintPrimitives();
+  gl2psPrintf("</g>\n");
+  return res;
+}
+
+static void gl2psPrintSVGFinalPrimitive(void)
+{
+  /* End any remaining line, if any */
+  gl2psEndSVGLine();
+}
+
+/* definition of the SVG backend */
+
+static GL2PSbackend gl2psSVG = {
+  gl2psPrintSVGHeader,
+  gl2psPrintSVGFooter,
+  gl2psPrintSVGBeginViewport,
+  gl2psPrintSVGEndViewport,
+  gl2psPrintSVGPrimitive,
+  gl2psPrintSVGFinalPrimitive,
+  "svg",
+  "Scalable Vector Graphics"
+};
+
+/*********************************************************************
+ *
+ * PGF routines
+ *
+ *********************************************************************/
+
+static void gl2psPrintPGFColor(GL2PSrgba rgba)
+{
+  if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
+    gl2psSetLastColor(rgba);
+    fprintf(gl2ps->stream, "\\color[rgb]{%f,%f,%f}\n", rgba[0], rgba[1], rgba[2]);
+  }
+}
+
+static void gl2psPrintPGFHeader(void)
+{
+  time_t now;
+
+  time(&now);
+
+  fprintf(gl2ps->stream, 
+          "%% Title: %s\n"
+          "%% Creator: GL2PS %d.%d.%d%s, %s\n"
+          "%% For: %s\n"
+          "%% CreationDate: %s",
+          gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
+          GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
+          gl2ps->producer, ctime(&now));
+
+  fprintf(gl2ps->stream, "\\begin{pgfpicture}\n");
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    gl2psPrintPGFColor(gl2ps->bgcolor);
+    fprintf(gl2ps->stream,
+            "\\pgfpathrectanglecorners{"
+            "\\pgfpoint{%dpt}{%dpt}}{\\pgfpoint{%dpt}{%dpt}}\n"
+            "\\pgfusepath{fill}\n",
+            (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
+            (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
+  }
+}
+
+static void gl2psPrintPGFDash(GLushort pattern, GLint factor)
+{
+  int i, n, array[10];
+
+  if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
+    return;
+
+  gl2ps->lastpattern = pattern;
+  gl2ps->lastfactor = factor;
+
+  if(!pattern || !factor){
+    /* solid line */
+    fprintf(gl2ps->stream, "\\pgfsetdash{}{0pt}\n");
+  }
+  else{
+    gl2psParseStipplePattern(pattern, factor, &n, array);
+    fprintf(gl2ps->stream, "\\pgfsetdash{");
+    for(i = 0; i < n; i++) fprintf(gl2ps->stream, "{%dpt}", array[i]);
+    fprintf(gl2ps->stream, "}{0pt}\n");
+  }
+}
+
+static const char *gl2psPGFTextAlignment(int align)
+{
+  switch(align){
+  case GL2PS_TEXT_C  : return "center";
+  case GL2PS_TEXT_CL : return "west";
+  case GL2PS_TEXT_CR : return "east";
+  case GL2PS_TEXT_B  : return "south";
+  case GL2PS_TEXT_BR : return "south east";
+  case GL2PS_TEXT_T  : return "north";
+  case GL2PS_TEXT_TL : return "north west";
+  case GL2PS_TEXT_TR : return "north east";
+  case GL2PS_TEXT_BL : 
+  default            : return "south west";
+  }
+}
+
+static void gl2psPrintPGFPrimitive(void *data)
+{
+  GL2PSprimitive *prim;
+
+  prim = *(GL2PSprimitive**)data;
+
+  switch(prim->type){
+  case GL2PS_POINT :
+    /* Points in openGL are rectangular */
+    gl2psPrintPGFColor(prim->verts[0].rgba);
+    fprintf(gl2ps->stream, 
+            "\\pgfpathrectangle{\\pgfpoint{%fpt}{%fpt}}"
+            "{\\pgfpoint{%fpt}{%fpt}}\n\\pgfusepath{fill}\n",
+            prim->verts[0].xyz[0]-0.5*prim->width,
+            prim->verts[0].xyz[1]-0.5*prim->width,
+            prim->width,prim->width);
+    break;
+  case GL2PS_LINE :
+    gl2psPrintPGFColor(prim->verts[0].rgba);
+    if(gl2ps->lastlinewidth != prim->width){
+      gl2ps->lastlinewidth = prim->width;
+      fprintf(gl2ps->stream, "\\pgfsetlinewidth{%fpt}\n", gl2ps->lastlinewidth);
+    }
+    gl2psPrintPGFDash(prim->pattern, prim->factor);
+    fprintf(gl2ps->stream, 
+            "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
+            "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
+            "\\pgfusepath{stroke}\n",
+            prim->verts[1].xyz[0], prim->verts[1].xyz[1],
+            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+    break;
+  case GL2PS_TRIANGLE :
+    if(gl2ps->lastlinewidth != 0){
+      gl2ps->lastlinewidth = 0;
+      fprintf(gl2ps->stream, "\\pgfsetlinewidth{0.01pt}\n");
+    }
+    gl2psPrintPGFColor(prim->verts[0].rgba);
+    fprintf(gl2ps->stream, 
+            "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
+            "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
+            "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
+            "\\pgfpathclose\n"
+            "\\pgfusepath{fill,stroke}\n",
+            prim->verts[2].xyz[0], prim->verts[2].xyz[1],
+            prim->verts[1].xyz[0], prim->verts[1].xyz[1],
+            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+    break;
+  case GL2PS_TEXT :
+    fprintf(gl2ps->stream, "{\n\\pgftransformshift{\\pgfpoint{%fpt}{%fpt}}\n",
+            prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
+
+    if(prim->data.text->angle)
+      fprintf(gl2ps->stream, "\\pgftransformrotate{%f}{", prim->data.text->angle);
+
+    fprintf(gl2ps->stream, "\\pgfnode{rectangle}{%s}{\\fontsize{%d}{0}\\selectfont",
+            gl2psPGFTextAlignment(prim->data.text->alignment),
+            prim->data.text->fontsize);
+
+    fprintf(gl2ps->stream, "\\textcolor[rgb]{%g,%g,%g}{{%s}}",
+            prim->verts[0].rgba[0], prim->verts[0].rgba[1],
+            prim->verts[0].rgba[2], prim->data.text->str);
+
+    fprintf(gl2ps->stream, "}{}{\\pgfusepath{discard}}}\n");
+    break;
+  case GL2PS_SPECIAL :
+    /* alignment contains the format for which the special output text
+       is intended */
+    if (prim->data.text->alignment == GL2PS_PGF)
+      fprintf(gl2ps->stream, "%s\n", prim->data.text->str);
+    break;
+  default :
+    break;
+  }
+}
+
+static void gl2psPrintPGFFooter(void)
+{
+  fprintf(gl2ps->stream, "\\end{pgfpicture}\n");
+}
+
+static void gl2psPrintPGFBeginViewport(GLint viewport[4])
+{
+  GLint index;
+  GLfloat rgba[4];
+  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
+
+  glRenderMode(GL_FEEDBACK);
+
+  if(gl2ps->header){
+    gl2psPrintPGFHeader();
+    gl2ps->header = GL_FALSE;
+  }
+
+  fprintf(gl2ps->stream, "\\begin{pgfscope}\n");
+  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
+    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
+      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
+    }
+    else{
+      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
+      rgba[0] = gl2ps->colormap[index][0];
+      rgba[1] = gl2ps->colormap[index][1];
+      rgba[2] = gl2ps->colormap[index][2];
+      rgba[3] = 1.0F;
+    }
+    gl2psPrintPGFColor(rgba);
+    fprintf(gl2ps->stream, 
+            "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
+            "{\\pgfpoint{%dpt}{%dpt}}\n"
+            "\\pgfusepath{fill}\n",
+            x, y, w, h);
+  }
+  
+  fprintf(gl2ps->stream, 
+          "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
+          "{\\pgfpoint{%dpt}{%dpt}}\n"
+          "\\pgfusepath{clip}\n",
+          x, y, w, h);
+}
+
+static GLint gl2psPrintPGFEndViewport(void)
+{
+  GLint res;
+  res = gl2psPrintPrimitives();
+  fprintf(gl2ps->stream, "\\end{pgfscope}\n");
+  return res;
+}
+
+static void gl2psPrintPGFFinalPrimitive(void)
+{
+}
+
+/* definition of the PGF backend */
+
+static GL2PSbackend gl2psPGF = {
+  gl2psPrintPGFHeader,
+  gl2psPrintPGFFooter,
+  gl2psPrintPGFBeginViewport,
+  gl2psPrintPGFEndViewport,
+  gl2psPrintPGFPrimitive,
+  gl2psPrintPGFFinalPrimitive,
+  "tex",
+  "PGF Latex Graphics"
+};
+
+/********************************************************************* 
+ *
+ * General primitive printing routine
+ *
+ *********************************************************************/
+
+/* Warning: the ordering of the backends must match the format
+   #defines in gl2ps.h */
+
+static GL2PSbackend *gl2psbackends[] = {
+  &gl2psPS,  /* 0 */
+  &gl2psEPS, /* 1 */
+  &gl2psTEX, /* 2 */
+  &gl2psPDF, /* 3 */
+  &gl2psSVG, /* 4 */
+  &gl2psPGF  /* 5 */
+};
+
+static void gl2psComputeTightBoundingBox(void *data)
+{
+  GL2PSprimitive *prim;
+  int i;
+
+  prim = *(GL2PSprimitive**)data;
+
+  for(i = 0; i < prim->numverts; i++){
+    if(prim->verts[i].xyz[0] < gl2ps->viewport[0])
+      gl2ps->viewport[0] = (GLint)prim->verts[i].xyz[0];
+    if(prim->verts[i].xyz[0] > gl2ps->viewport[2])
+      gl2ps->viewport[2] = (GLint)(prim->verts[i].xyz[0] + 0.5F);
+    if(prim->verts[i].xyz[1] < gl2ps->viewport[1])
+      gl2ps->viewport[1] = (GLint)prim->verts[i].xyz[1];
+    if(prim->verts[i].xyz[1] > gl2ps->viewport[3])
+      gl2ps->viewport[3] = (GLint)(prim->verts[i].xyz[1] + 0.5F);
+  }
+}  
+
+static GLint gl2psPrintPrimitives(void)
+{
+  GL2PSbsptree *root;
+  GL2PSxyz eye = {0.0F, 0.0F, 100.0F * GL2PS_ZSCALE};
+  GLint used;
+
+  used = glRenderMode(GL_RENDER);
+
+  if(used < 0){
+    gl2psMsg(GL2PS_INFO, "OpenGL feedback buffer overflow");
+    return GL2PS_OVERFLOW;
+  }
+
+  if(used > 0)
+    gl2psParseFeedbackBuffer(used);
+
+  gl2psRescaleAndOffset();
+
+  if(gl2ps->header){
+    if(gl2psListNbr(gl2ps->primitives) && 
+       (gl2ps->options & GL2PS_TIGHT_BOUNDING_BOX)){
+      gl2ps->viewport[0] = gl2ps->viewport[1] = 100000;
+      gl2ps->viewport[2] = gl2ps->viewport[3] = -100000;
+      gl2psListAction(gl2ps->primitives, gl2psComputeTightBoundingBox);
+    }
+    (gl2psbackends[gl2ps->format]->printHeader)();
+    gl2ps->header = GL_FALSE;
+  }
+
+  if(!gl2psListNbr(gl2ps->primitives)){
+    /* empty feedback buffer and/or nothing else to print */
+    return GL2PS_NO_FEEDBACK;
+  }
+
+  switch(gl2ps->sort){
+  case GL2PS_NO_SORT :
+    gl2psListAction(gl2ps->primitives, gl2psbackends[gl2ps->format]->printPrimitive);
+    gl2psListAction(gl2ps->primitives, gl2psFreePrimitive);
+    /* reset the primitive list, waiting for the next viewport */
+    gl2psListReset(gl2ps->primitives);
+    break;
+  case GL2PS_SIMPLE_SORT :
+    gl2psListSort(gl2ps->primitives, gl2psCompareDepth);
+    if(gl2ps->options & GL2PS_OCCLUSION_CULL){
+      gl2psListActionInverse(gl2ps->primitives, gl2psAddInImageTree);
+      gl2psFreeBspImageTree(&gl2ps->imagetree);
+    }
+    gl2psListAction(gl2ps->primitives, gl2psbackends[gl2ps->format]->printPrimitive);
+    gl2psListAction(gl2ps->primitives, gl2psFreePrimitive);
+    /* reset the primitive list, waiting for the next viewport */
+    gl2psListReset(gl2ps->primitives);
+    break;
+  case GL2PS_BSP_SORT :
+    root = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
+    gl2psBuildBspTree(root, gl2ps->primitives);
+    if(GL_TRUE == gl2ps->boundary) gl2psBuildPolygonBoundary(root);
+    if(gl2ps->options & GL2PS_OCCLUSION_CULL){
+      gl2psTraverseBspTree(root, eye, -GL2PS_EPSILON, gl2psLess,
+                           gl2psAddInImageTree, 1);
+      gl2psFreeBspImageTree(&gl2ps->imagetree);
+    }
+    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater, 
+                         gl2psbackends[gl2ps->format]->printPrimitive, 0);
+    gl2psFreeBspTree(&root);
+    /* reallocate the primitive list (it's been deleted by
+       gl2psBuildBspTree) in case there is another viewport */
+    gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
+    break;
+  }
+  gl2psbackends[gl2ps->format]->printFinalPrimitive();
+
+  return GL2PS_SUCCESS;
+}
+
+/********************************************************************* 
+ *
+ * Public routines
+ *
+ *********************************************************************/
+
+GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
+                                  GLint viewport[4], GLint format, GLint sort,
+                                  GLint options, GLint colormode,
+                                  GLint colorsize, GL2PSrgba *colormap,
+                                  GLint nr, GLint ng, GLint nb, GLint buffersize,
+                                  FILE *stream, const char *filename)
+{
+  GLint index;
+  int i;
+
+  if(gl2ps){
+    gl2psMsg(GL2PS_ERROR, "gl2psBeginPage called in wrong program state");
+    return GL2PS_ERROR;
+  }
+
+  gl2ps = (GL2PScontext*)gl2psMalloc(sizeof(GL2PScontext));
+
+  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends) / sizeof(gl2psbackends[0]))){
+    gl2ps->format = format;
+  }
+  else {
+    gl2psMsg(GL2PS_ERROR, "Unknown output format: %d", format);
+    gl2psFree(gl2ps);
+    gl2ps = NULL;
+    return GL2PS_ERROR;
+  }
+
+  switch(sort){
+  case GL2PS_NO_SORT :
+  case GL2PS_SIMPLE_SORT :
+  case GL2PS_BSP_SORT :
+    gl2ps->sort = sort;
+    break;
+  default :
+    gl2psMsg(GL2PS_ERROR, "Unknown sorting algorithm: %d", sort);
+    gl2psFree(gl2ps);
+    gl2ps = NULL;
+    return GL2PS_ERROR;
+  }
+
+  if(stream){
+    gl2ps->stream = stream;
+  }
+  else{
+    gl2psMsg(GL2PS_ERROR, "Bad file pointer");
+    gl2psFree(gl2ps);
+    gl2ps = NULL;
+    return GL2PS_ERROR;
+  }
+
+  gl2ps->header = GL_TRUE;
+  gl2ps->maxbestroot = 10;
+  gl2ps->options = options;
+  gl2ps->compress = NULL;
+  gl2ps->imagemap_head = NULL;
+  gl2ps->imagemap_tail = NULL;
+
+  if(gl2ps->options & GL2PS_USE_CURRENT_VIEWPORT){
+    glGetIntegerv(GL_VIEWPORT, gl2ps->viewport);
+  }
+  else{
+    for(i = 0; i < 4; i++){
+      gl2ps->viewport[i] = viewport[i];
+    }
+  }
+
+  if(!gl2ps->viewport[2] || !gl2ps->viewport[3]){
+    gl2psMsg(GL2PS_ERROR, "Incorrect viewport (x=%d, y=%d, width=%d, height=%d)",
+             gl2ps->viewport[0], gl2ps->viewport[1], 
+             gl2ps->viewport[2], gl2ps->viewport[3]);
+    gl2psFree(gl2ps);
+    gl2ps = NULL;
+    return GL2PS_ERROR;
+  }
+
+  gl2ps->threshold[0] = nr ? 1.0F / (GLfloat)nr : 0.064F;
+  gl2ps->threshold[1] = ng ? 1.0F / (GLfloat)ng : 0.034F;
+  gl2ps->threshold[2] = nb ? 1.0F / (GLfloat)nb : 0.100F;
+  gl2ps->colormode = colormode;
+  gl2ps->buffersize = buffersize > 0 ? buffersize : 2048 * 2048;
+  for(i = 0; i < 3; i++){
+    gl2ps->lastvertex.xyz[i] = -1.0F;
+  }
+  for(i = 0; i < 4; i++){
+    gl2ps->lastvertex.rgba[i] = -1.0F;
+    gl2ps->lastrgba[i] = -1.0F;
+  }
+  gl2ps->lastlinewidth = -1.0F;
+  gl2ps->lastpattern = 0;
+  gl2ps->lastfactor = 0;
+  gl2ps->imagetree = NULL;
+  gl2ps->primitivetoadd = NULL;
+  gl2ps->zerosurfacearea = GL_FALSE;  
+  gl2ps->pdfprimlist = NULL;
+  gl2ps->pdfgrouplist = NULL;
+  gl2ps->xreflist = NULL;
+  
+  /* get default blending mode from current OpenGL state (enabled by
+     default for SVG) */
+  gl2ps->blending = (gl2ps->format == GL2PS_SVG) ? GL_TRUE : glIsEnabled(GL_BLEND);
+  glGetIntegerv(GL_BLEND_SRC, &gl2ps->blendfunc[0]);
+  glGetIntegerv(GL_BLEND_DST, &gl2ps->blendfunc[1]);
+
+  if(gl2ps->colormode == GL_RGBA){
+    gl2ps->colorsize = 0;
+    gl2ps->colormap = NULL;
+    glGetFloatv(GL_COLOR_CLEAR_VALUE, gl2ps->bgcolor);
+  }
+  else if(gl2ps->colormode == GL_COLOR_INDEX){
+    if(!colorsize || !colormap){
+      gl2psMsg(GL2PS_ERROR, "Missing colormap for GL_COLOR_INDEX rendering");
+      gl2psFree(gl2ps);
+      gl2ps = NULL;
+      return GL2PS_ERROR;
+    }
+    gl2ps->colorsize = colorsize;
+    gl2ps->colormap = (GL2PSrgba*)gl2psMalloc(gl2ps->colorsize * sizeof(GL2PSrgba));
+    memcpy(gl2ps->colormap, colormap, gl2ps->colorsize * sizeof(GL2PSrgba));
+    glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
+    gl2ps->bgcolor[0] = gl2ps->colormap[index][0];
+    gl2ps->bgcolor[1] = gl2ps->colormap[index][1];
+    gl2ps->bgcolor[2] = gl2ps->colormap[index][2];
+    gl2ps->bgcolor[3] = 1.0F;
+  }
+  else{
+    gl2psMsg(GL2PS_ERROR, "Unknown color mode in gl2psBeginPage");
+    gl2psFree(gl2ps);
+    gl2ps = NULL;
+    return GL2PS_ERROR;
+  }
+
+  if(!title){
+    gl2ps->title = (char*)gl2psMalloc(sizeof(char));
+    gl2ps->title[0] = '\0';
+  }
+  else{
+    gl2ps->title = (char*)gl2psMalloc((strlen(title)+1)*sizeof(char));
+    strcpy(gl2ps->title, title);
+  }
+    
+  if(!producer){
+    gl2ps->producer = (char*)gl2psMalloc(sizeof(char));
+    gl2ps->producer[0] = '\0';
+  }
+  else{
+    gl2ps->producer = (char*)gl2psMalloc((strlen(producer)+1)*sizeof(char));
+    strcpy(gl2ps->producer, producer);
+  }
+  
+  if(!filename){
+    gl2ps->filename = (char*)gl2psMalloc(sizeof(char));
+    gl2ps->filename[0] = '\0';
+  }
+  else{
+    gl2ps->filename = (char*)gl2psMalloc((strlen(filename)+1)*sizeof(char));
+    strcpy(gl2ps->filename, filename);
+  }
+
+  gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
+  gl2ps->auxprimitives = gl2psListCreate(100, 100, sizeof(GL2PSprimitive*));
+  gl2ps->feedback = (GLfloat*)gl2psMalloc(gl2ps->buffersize * sizeof(GLfloat));
+  glFeedbackBuffer(gl2ps->buffersize, GL_3D_COLOR, gl2ps->feedback);
+  glRenderMode(GL_FEEDBACK);  
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psEndPage(void)
+{
+  GLint res;
+
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  res = gl2psPrintPrimitives();
+
+  if(res != GL2PS_OVERFLOW)
+    (gl2psbackends[gl2ps->format]->printFooter)();
+  
+  fflush(gl2ps->stream);
+
+  gl2psListDelete(gl2ps->primitives);
+  gl2psListDelete(gl2ps->auxprimitives);
+  gl2psFreeImagemap(gl2ps->imagemap_head);
+  gl2psFree(gl2ps->colormap);
+  gl2psFree(gl2ps->title);
+  gl2psFree(gl2ps->producer);
+  gl2psFree(gl2ps->filename);
+  gl2psFree(gl2ps->feedback);
+  gl2psFree(gl2ps);
+  gl2ps = NULL;
+
+  return res;
+}
+
+GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4])
+{
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  (gl2psbackends[gl2ps->format]->beginViewport)(viewport);
+  
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psEndViewport(void)
+{
+  GLint res;
+
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  res = (gl2psbackends[gl2ps->format]->endViewport)();
+
+  /* reset last used colors, line widths */
+  gl2ps->lastlinewidth = -1.0F;
+
+  return res;
+}
+
+GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
+                                GLshort fontsize, GLint alignment, GLfloat angle)
+{
+  return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, alignment, angle);
+}
+
+GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, GLshort fontsize)
+{
+  return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, GL2PS_TEXT_BL, 0.0F);
+}
+
+GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str)
+{
+  return gl2psAddText(GL2PS_SPECIAL, str, "", 0, format, 0.0F);
+}
+
+GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
+                                   GLint xorig, GLint yorig,
+                                   GLenum format, GLenum type, 
+                                   const void *pixels)
+{
+  int size, i;
+  GLfloat pos[4], *piv;
+  GL2PSprimitive *prim;
+  GLboolean valid;
+
+  if(!gl2ps || !pixels) return GL2PS_UNINITIALIZED;
+
+  if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
+
+  if(gl2ps->options & GL2PS_NO_PIXMAP) return GL2PS_SUCCESS;
+
+  if((format != GL_RGB && format != GL_RGBA) || type != GL_FLOAT){
+    gl2psMsg(GL2PS_ERROR, "gl2psDrawPixels only implemented for "
+             "GL_RGB/GL_RGBA, GL_FLOAT pixels");
+    return GL2PS_ERROR;
+  }
+
+  glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
+  if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */
+
+  glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
+
+  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
+  prim->type = GL2PS_PIXMAP;
+  prim->boundary = 0;
+  prim->numverts = 1;
+  prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
+  prim->verts[0].xyz[0] = pos[0] + xorig;
+  prim->verts[0].xyz[1] = pos[1] + yorig;
+  prim->verts[0].xyz[2] = pos[2];
+  prim->culled = 0;
+  prim->offset = 0;
+  prim->pattern = 0;
+  prim->factor = 0;
+  prim->width = 1;
+  glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
+  prim->data.image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
+  prim->data.image->width = width;
+  prim->data.image->height = height;
+  prim->data.image->format = format;
+  prim->data.image->type = type;
+
+  switch(format){
+  case GL_RGBA:
+    if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
+      /* special case: blending turned off */
+      prim->data.image->format = GL_RGB;
+      size = height * width * 3;
+      prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
+      piv = (GLfloat*)pixels;
+      for(i = 0; i < size; ++i, ++piv){
+        prim->data.image->pixels[i] = *piv;
+        if(!((i+1)%3))
+          ++piv;
+      }   
+    }
+    else{
+      size = height * width * 4;
+      prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
+      memcpy(prim->data.image->pixels, pixels, size * sizeof(GLfloat));
+    }
+    break;
+  case GL_RGB:
+  default:
+    size = height * width * 3;
+    prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
+    memcpy(prim->data.image->pixels, pixels, size * sizeof(GLfloat));
+    break;
+  }
+
+  gl2psListAdd(gl2ps->auxprimitives, &prim);
+  glPassThrough(GL2PS_DRAW_PIXELS_TOKEN);
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psDrawImageMap(GLsizei width, GLsizei height,
+                                     const GLfloat position[3],
+                                     const unsigned char *imagemap){
+  int size, i;
+  int sizeoffloat = sizeof(GLfloat);
+  
+  if(!gl2ps || !imagemap) return GL2PS_UNINITIALIZED;
+
+  if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
+  
+  size = height + height * ((width - 1) / 8);
+  glPassThrough(GL2PS_IMAGEMAP_TOKEN);
+  glBegin(GL_POINTS);
+  glVertex3f(position[0], position[1],position[2]);
+  glEnd();
+  glPassThrough((GLfloat)width);
+  glPassThrough((GLfloat)height);
+  for(i = 0; i < size; i += sizeoffloat){
+    float *value = (float*)imagemap;
+    glPassThrough(*value);
+    imagemap += sizeoffloat;
+  }
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psEnable(GLint mode)
+{
+  GLint tmp;
+
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  switch(mode){
+  case GL2PS_POLYGON_OFFSET_FILL :
+    glPassThrough(GL2PS_BEGIN_OFFSET_TOKEN);
+    glGetFloatv(GL_POLYGON_OFFSET_FACTOR, &gl2ps->offset[0]);
+    glGetFloatv(GL_POLYGON_OFFSET_UNITS, &gl2ps->offset[1]);
+    break;
+  case GL2PS_POLYGON_BOUNDARY :
+    glPassThrough(GL2PS_BEGIN_BOUNDARY_TOKEN);
+    break;
+  case GL2PS_LINE_STIPPLE :
+    glPassThrough(GL2PS_BEGIN_STIPPLE_TOKEN);
+    glGetIntegerv(GL_LINE_STIPPLE_PATTERN, &tmp);
+    glPassThrough((GLfloat)tmp);
+    glGetIntegerv(GL_LINE_STIPPLE_REPEAT, &tmp);
+    glPassThrough((GLfloat)tmp);
+    break;
+  case GL2PS_BLEND :
+    glPassThrough(GL2PS_BEGIN_BLEND_TOKEN);
+    break;
+  default :
+    gl2psMsg(GL2PS_WARNING, "Unknown mode in gl2psEnable: %d", mode);
+    return GL2PS_WARNING;
+  }
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psDisable(GLint mode)
+{
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  switch(mode){
+  case GL2PS_POLYGON_OFFSET_FILL :
+    glPassThrough(GL2PS_END_OFFSET_TOKEN);
+    break;
+  case GL2PS_POLYGON_BOUNDARY :
+    glPassThrough(GL2PS_END_BOUNDARY_TOKEN);
+    break;
+  case GL2PS_LINE_STIPPLE :
+    glPassThrough(GL2PS_END_STIPPLE_TOKEN);
+    break;
+  case GL2PS_BLEND :
+    glPassThrough(GL2PS_END_BLEND_TOKEN);
+    break;
+  default :
+    gl2psMsg(GL2PS_WARNING, "Unknown mode in gl2psDisable: %d", mode);
+    return GL2PS_WARNING;
+  }
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psPointSize(GLfloat value)
+{
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  glPassThrough(GL2PS_POINT_SIZE_TOKEN);
+  glPassThrough(value);
+  
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psLineWidth(GLfloat value)
+{
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  glPassThrough(GL2PS_LINE_WIDTH_TOKEN);
+  glPassThrough(value);
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psBlendFunc(GLenum sfactor, GLenum dfactor)
+{
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  if(GL_FALSE == gl2psSupportedBlendMode(sfactor, dfactor))
+    return GL2PS_WARNING;
+
+  glPassThrough(GL2PS_SRC_BLEND_TOKEN);
+  glPassThrough((GLfloat)sfactor);
+  glPassThrough(GL2PS_DST_BLEND_TOKEN);
+  glPassThrough((GLfloat)dfactor);
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psSetOptions(GLint options)
+{
+  if(!gl2ps) return GL2PS_UNINITIALIZED;
+
+  gl2ps->options = options;
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API GLint gl2psGetOptions(GLint *options)
+{
+  if(!gl2ps) {
+    *options = 0;
+    return GL2PS_UNINITIALIZED;
+  }
+
+  *options = gl2ps->options;
+
+  return GL2PS_SUCCESS;
+}
+
+GL2PSDLL_API const char *gl2psGetFileExtension(GLint format)
+{
+  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends) / sizeof(gl2psbackends[0])))
+    return gl2psbackends[format]->file_extension;
+  else
+    return "Unknown format";
+}
+
+GL2PSDLL_API const char *gl2psGetFormatDescription(GLint format)
+{
+  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends) / sizeof(gl2psbackends[0])))
+    return gl2psbackends[format]->description;
+  else
+    return "Unknown format";
+}
diff --git a/gui/ged/inc/TGedFrame.h b/gui/ged/inc/TGedFrame.h
index 1976637..7e522da 100644
--- a/gui/ged/inc/TGedFrame.h
+++ b/gui/ged/inc/TGedFrame.h
@@ -55,7 +55,6 @@ protected:
    Bool_t          fInit;        // init flag for setting signals/slots
    TGedEditor     *fGedEditor;   // manager of this frame
    TClass         *fModelClass;  // class corresponding to instantiated GedFrame
-   TGLayoutHints  *fLayoutHints; // defines how this frame is added to fGedEditor
    Bool_t          fAvoidSignal; // flag for executing slots
 
    TList          *fExtraTabs;   // addtional tabs in ged editor
@@ -74,8 +73,6 @@ public:
 
    virtual Option_t *GetDrawOption() const;
 
-   virtual TGLayoutHints* GetLayoutHints();
-
    TClass*           GetModelClass()              { return fModelClass;  }
    Int_t             GetPriority()                { return fPriority;    }
    TList*            GetExtraTabs()               { return fExtraTabs;   }
diff --git a/gui/ged/src/TGedEditor.cxx b/gui/ged/src/TGedEditor.cxx
index 9486d73..3b2a2a5 100644
--- a/gui/ged/src/TGedEditor.cxx
+++ b/gui/ged/src/TGedEditor.cxx
@@ -217,7 +217,7 @@ TGedTabInfo* TGedEditor::GetEditorTabInfo(const char* name)
    TGedFrame* nf = CreateNameFrame(tc, name);
    nf->SetGedEditor(this);
    nf->SetModelClass(0);
-   tc->AddFrame(nf, nf->GetLayoutHints());
+   tc->AddFrame(nf, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 2, 2, 2, 2));
 
    // add to list of created tabs
    TGedTabInfo* ti = new TGedTabInfo(te, tc);
@@ -377,7 +377,7 @@ void TGedEditor::SetModel(TVirtualPad* pad, TObject* obj, Int_t event)
          TGedFrame* gfr;
          TIter ngf(&fGedFrames);
          while ((gfr = (TGedFrame*) ngf()))
-            fTabContainer->AddFrame(gfr, gfr->GetLayoutHints());
+            fTabContainer->AddFrame(gfr, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 2, 2, 2, 2));
 
          fExclMap.Clear();
          fGedFrames.Clear();
diff --git a/gui/ged/src/TGedFrame.cxx b/gui/ged/src/TGedFrame.cxx
index 4f23c88..3fa25fc 100644
--- a/gui/ged/src/TGedFrame.cxx
+++ b/gui/ged/src/TGedFrame.cxx
@@ -38,7 +38,6 @@ TGedFrame::TGedFrame(const TGWindow *p, Int_t width,
         fInit(kTRUE),
         fGedEditor(0),
         fModelClass(0),
-        fLayoutHints(0),
         fAvoidSignal(kFALSE),
         fExtraTabs(0),
         fPriority(50)
@@ -65,7 +64,6 @@ TGedFrame::~TGedFrame()
       }
       delete fExtraTabs;
    }
-   delete fLayoutHints;
 
    // Destructor of TGCompositeFrame will do the rest.
 }
@@ -94,18 +92,6 @@ Option_t *TGedFrame::GetDrawOption() const
 }
 
 //______________________________________________________________________________
-TGLayoutHints* TGedFrame::GetLayoutHints()
-{
-   // Get layout hints with which is added to TGedEditor frame.
-
-   if (fLayoutHints == 0){
-      fLayoutHints = new TGLayoutHints(kLHintsTop | kLHintsExpandX, 2, 2, 2, 2);
-      fLayoutHints->AddReference();
-   }
-   return fLayoutHints;
-}
-
-//______________________________________________________________________________
 void TGedFrame::MakeTitle(const char *title)
 {
    // Create attribute frame title.
@@ -227,7 +213,6 @@ TGedNameFrame::~TGedNameFrame()
 {
    // Destructor.
 
-   fLayoutHints = 0; // will be deleted via deep-cleanup of tab-containers
    delete fTip;
 }
 
diff --git a/gui/gui/inc/TGFSContainer.h b/gui/gui/inc/TGFSContainer.h
index 5f515b7..7380e1f 100644
--- a/gui/gui/inc/TGFSContainer.h
+++ b/gui/gui/inc/TGFSContainer.h
@@ -143,6 +143,7 @@ protected:
    TViewUpdateTimer *fRefresh;        // refresh timer
    ULong_t           fMtime;          // directory modification time
    TString           fDirectory;      // current directory
+   TList            *fCleanups;       // list of pictures to cleanup
    const TGPicture  *fFolder_t;       // small folder icon
    const TGPicture  *fFolder_s;       // big folder icon
    const TGPicture  *fApp_t;          // small application icon
diff --git a/gui/gui/inc/TGSlider.h b/gui/gui/inc/TGSlider.h
index 82e5334..3cf33cb 100644
--- a/gui/gui/inc/TGSlider.h
+++ b/gui/gui/inc/TGSlider.h
@@ -78,8 +78,10 @@ protected:
    Int_t            fScale;         // tick mark scale
    Bool_t           fDragging;      // true if in dragging mode
    const TGPicture *fSliderPic;     // picture to draw slider
+   const TGPicture *fDisabledPic;   // picture to draw disabled slider
 
    TString GetTypeString() const;   // used in SavePrimitive
+   virtual void CreateDisabledPicture();
 
 private:
    TGSlider(const TGSlider&);             // not implemented
@@ -97,6 +99,8 @@ public:
    virtual Bool_t HandleConfigureNotify(Event_t* event) = 0;
    virtual Bool_t HandleMotion(Event_t *event) = 0;
 
+   virtual void  SetEnabled(Bool_t flag = kTRUE) { SetState( flag ); }              //*TOGGLE* *GETTER=IsEnabled
+   virtual void  SetState(Bool_t state);
    virtual void  SetScale(Int_t scale) { fScale = scale; }                          //*MENU*
    virtual void  SetRange(Int_t min, Int_t max) { fVmin = min; fVmax = max; }       //*MENU*
    virtual void  SetPosition(Int_t pos) { fPos = pos; fClient->NeedRedraw(this); }  //*MENU*
diff --git a/gui/gui/src/TGFSContainer.cxx b/gui/gui/src/TGFSContainer.cxx
index 950c62a..086bc95 100644
--- a/gui/gui/src/TGFSContainer.cxx
+++ b/gui/gui/src/TGFSContainer.cxx
@@ -39,6 +39,8 @@
 #include "TBufferFile.h"
 #include "Riostream.h"
 #include "TRemoteObject.h"
+#include "TImage.h"
+#include "snprintf.h"
 #include <time.h>
 
 ClassImp(TGFileItem)
@@ -410,6 +412,7 @@ TGFileContainer::TGFileContainer(const TGWindow *p, UInt_t w, UInt_t h,
    gSystem->AddTimer(fRefresh);
    fCachePictures = kTRUE;
    fDisplayStat   = kTRUE;
+   fCleanups  = new TList;
 
    fFolder_s = fClient->GetPicture("folder_s.xpm");
    fFolder_t = fClient->GetPicture("folder_t.xpm");
@@ -443,6 +446,7 @@ TGFileContainer::TGFileContainer(TGCanvas *p, UInt_t options, ULong_t back) :
    gSystem->AddTimer(fRefresh);
    fCachePictures = kTRUE;
    fDisplayStat   = kTRUE;
+   fCleanups  = new TList;
 
    fFolder_s = fClient->GetPicture("folder_s.xpm");
    fFolder_t = fClient->GetPicture("folder_t.xpm");
@@ -477,6 +481,15 @@ TGFileContainer::~TGFileContainer()
    fClient->FreePicture(fDoc_t);
    fClient->FreePicture(fSlink_s);
    fClient->FreePicture(fSlink_t);
+   if (fCleanups) {
+      TGPicture *pic;
+      TIter nextp(fCleanups);
+      while ((pic = (TGPicture *)nextp())) {
+         fClient->GetPicturePool()->FreePicture(pic);
+      }
+      fCleanups->Clear();
+      delete fCleanups;
+   }
 }
 
 //______________________________________________________________________________
@@ -547,7 +560,7 @@ void TGFileContainer::GetFilePictures(const TGPicture **pic,
    if (fCachePictures && ext && cached_spic && cached_lpic && (cached_ext == ext)) {
       *pic = cached_spic;
       *lpic = cached_lpic;
-      return;
+      if (!is_link) return;
    }
 
    if (R_ISREG(file_type)) {
@@ -560,7 +573,7 @@ void TGFileContainer::GetFilePictures(const TGPicture **pic,
             cached_ext = ext;
             cached_spic = *pic;
             cached_lpic = *lpic;
-            return;
+            if (!is_link) return;
          }
       }
    } else {
@@ -581,8 +594,35 @@ void TGFileContainer::GetFilePictures(const TGPicture **pic,
       }
    }
    if (is_link) {
-      *pic = fSlink_t;
-      *lpic = fSlink_s;
+      TImage *img1, *img2;
+      if (*pic && *lpic) {
+         img1 = TImage::Create();
+         img1->SetImage(((const TGPicture *)*pic)->GetPicture(),
+                        ((const TGPicture *)*pic)->GetMask());
+         img2 = TImage::Open("slink_t.xpm");
+         if (img2) img1->Merge(img2);
+         TString lnk_name = ((const TGPicture *)*pic)->GetName();
+         lnk_name.Prepend("lnk_");
+         *pic = fClient->GetPicturePool()->GetPicture(lnk_name.Data(), 
+                              img1->GetPixmap(), img1->GetMask());
+         fCleanups->Add(((TObject *)*pic));
+         if (img2) delete img2; delete img1;
+         img1 = TImage::Create();
+         img1->SetImage(((const TGPicture *)*lpic)->GetPicture(),
+                        ((const TGPicture *)*lpic)->GetMask());
+         img2 = TImage::Open("slink_s.xpm");
+         if (img2) img1->Merge(img2);
+         lnk_name = ((const TGPicture *)*lpic)->GetName();
+         lnk_name.Prepend("lnk_");
+         *lpic = fClient->GetPicturePool()->GetPicture(lnk_name.Data(), 
+                              img1->GetPixmap(), img1->GetMask());
+         fCleanups->Add(((TObject *)*lpic));
+         if (img2) delete img2; delete img1;
+      }
+      else {
+         *pic = fSlink_t;
+         *lpic = fSlink_s;
+      }
    }
 
    cached_lpic = 0;
diff --git a/gui/gui/src/TGFileDialog.cxx b/gui/gui/src/TGFileDialog.cxx
index b015cae..2172ff0 100644
--- a/gui/gui/src/TGFileDialog.cxx
+++ b/gui/gui/src/TGFileDialog.cxx
@@ -219,7 +219,7 @@ TGFileDialog::TGFileDialog(const TGWindow *p, const TGWindow *main,
 
    fList->SetState(kButtonEngaged);
 
-   AddFrame(fFv, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 4, 4, 3, 1));
+   AddFrame(fFv, new TGLayoutHints(kLHintsTop | kLHintsExpandX | kLHintsExpandY, 4, 4, 3, 1));
 
    if (dlg_type == kFDOpen) {
       fCheckB->Connect("Toggled(Bool_t)","TGFileContainer",fFc,"SetMultipleSelection(Bool_t)");
@@ -310,7 +310,7 @@ TGFileDialog::TGFileDialog(const TGWindow *p, const TGWindow *main,
    //---- make the message box non-resizable
 
    SetWMSize(size.fWidth, size.fHeight);
-   SetWMSizeHints(size.fWidth, size.fHeight, size.fWidth, size.fHeight, 0, 0);
+   SetWMSizeHints(size.fWidth, size.fHeight, 10000, 10000, 1, 1);
 
    const char *wname = (dlg_type == kFDSave) ? "Save As..." : "Open";
    SetWindowName(wname);
diff --git a/gui/gui/src/TGSlider.cxx b/gui/gui/src/TGSlider.cxx
index 996c05c..488f83a 100644
--- a/gui/gui/src/TGSlider.cxx
+++ b/gui/gui/src/TGSlider.cxx
@@ -48,6 +48,8 @@
 
 #include "TGSlider.h"
 #include "TGPicture.h"
+#include "TImage.h"
+#include "TEnv.h"
 #include "Riostream.h"
 
 ClassImp(TGSlider)
@@ -62,8 +64,9 @@ TGSlider::TGSlider(const TGWindow *p, UInt_t w, UInt_t h, UInt_t type, Int_t id,
 {
    // Slider constructor.
 
+   fDisabledPic = 0;
    fWidgetId    = id;
-   fWidgetFlags = kWidgetWantFocus;
+   fWidgetFlags = kWidgetWantFocus | kWidgetIsEnabled;
    fMsgWindow   = p;
 
    fType     = type;
@@ -72,6 +75,44 @@ TGSlider::TGSlider(const TGWindow *p, UInt_t w, UInt_t h, UInt_t type, Int_t id,
 }
 
 //______________________________________________________________________________
+void TGSlider::CreateDisabledPicture()
+{
+   // Creates disabled picture.
+
+   if (!fSliderPic) return;
+
+   TImage *img = TImage::Create();
+   TImage *img2 = TImage::Create();
+
+   TString back = gEnv->GetValue("Gui.BackgroundColor", "#c0c0c0");
+   img2->FillRectangle(back.Data(), 0, 0, fSliderPic->GetWidth(), 
+                       fSliderPic->GetHeight());
+   img->SetImage(fSliderPic->GetPicture(), fSliderPic->GetMask());
+   Pixmap_t mask = img->GetMask();
+   img2->Merge(img, "overlay");
+
+   TString name = "disbl_";
+   name += fSliderPic->GetName();
+   fDisabledPic = fClient->GetPicturePool()->GetPicture(name.Data(),
+                                             img2->GetPixmap(), mask);
+   delete img;
+   delete img2;
+}
+
+//______________________________________________________________________________
+void TGSlider::SetState(Bool_t state)
+{
+   // Set state of widget. If kTRUE=enabled, kFALSE=disabled.
+
+   if (state) {
+      SetFlags(kWidgetIsEnabled);
+   } else {
+      ClearFlags(kWidgetIsEnabled);
+   }
+   fClient->NeedRedraw(this);
+}
+
+//______________________________________________________________________________
 TGVSlider::TGVSlider(const TGWindow *p, UInt_t h, UInt_t type, Int_t id,
                      UInt_t options, ULong_t back) :
    TGSlider(p, kSliderWidth, h, type, id, options, back)
@@ -86,6 +127,8 @@ TGVSlider::TGVSlider(const TGWindow *p, UInt_t h, UInt_t type, Int_t id,
    if (!fSliderPic)
       Error("TGVSlider", "slider?h.xpm not found");
 
+   CreateDisabledPicture();
+
    gVirtualX->GrabButton(fId, kAnyButton, kAnyModifier,
                          kButtonPressMask | kButtonReleaseMask |
                          kPointerMotionMask, kNone, kNone);
@@ -106,6 +149,7 @@ TGVSlider::~TGVSlider()
    // Delete vertical slider widget.
 
    if (fSliderPic) fClient->FreePicture(fSliderPic);
+   if (fDisabledPic) fClient->FreePicture(fDisabledPic);
 }
 
 //______________________________________________________________________________
@@ -116,11 +160,13 @@ void TGVSlider::DoRedraw()
    // cleanup the drawable
    gVirtualX->ClearWindow(fId);
 
+   GContext_t drawGC = IsEnabled() ? GetBlackGC()() : GetShadowGC()();
+   
    gVirtualX->DrawLine(fId, GetShadowGC()(), fWidth/2, 8, fWidth/2-1, 8);
    gVirtualX->DrawLine(fId, GetShadowGC()(), fWidth/2-1, 8, fWidth/2-1, fHeight-9);
    gVirtualX->DrawLine(fId, GetHilightGC()(), fWidth/2+1, 8, fWidth/2+1, fHeight-8);
    gVirtualX->DrawLine(fId, GetHilightGC()(), fWidth/2+1, fHeight-8, fWidth/2, fHeight-8);
-   gVirtualX->DrawLine(fId, GetBlackGC()(), fWidth/2, 9, fWidth/2, fHeight-9);
+   gVirtualX->DrawLine(fId, drawGC, fWidth/2, 9, fWidth/2, fHeight-9);
 
    // check scale
    if (fScale == 1) fScale++;
@@ -131,9 +177,9 @@ void TGVSlider::DoRedraw()
       if (lines < 1) lines = 1;
       for (int i = 0; i <= lines; i++) {
          int y = i * fScale + (i * remain) / lines;
-         gVirtualX->DrawLine(fId, GetBlackGC()(), fWidth/2+8, y+7, fWidth/2+10, y+7);
+         gVirtualX->DrawLine(fId, drawGC, fWidth/2+8, y+7, fWidth/2+10, y+7);
          if ((fType & kSlider2) && (fType & kScaleBoth))
-            gVirtualX->DrawLine(fId, GetBlackGC()(), fWidth/2-9, y+7, fWidth/2-11, y+7);
+            gVirtualX->DrawLine(fId, drawGC, fWidth/2-9, y+7, fWidth/2-11, y+7);
       }
    }
    if (fPos < fVmin) fPos = fVmin;
@@ -141,7 +187,12 @@ void TGVSlider::DoRedraw()
 
    // calc slider-picture position
    fRelPos = (((int)fHeight-16) * (fPos - fVmin)) / (fVmax - fVmin) + 8;
-   if (fSliderPic) fSliderPic->Draw(fId, GetBckgndGC()(), fWidth/2-7, fRelPos-6);
+   const TGPicture *pic = fSliderPic;
+   if (!IsEnabled()) {
+      if (!fDisabledPic) CreateDisabledPicture();
+      pic = fDisabledPic ? fDisabledPic : fSliderPic;
+   }
+   if (pic) pic->Draw(fId, GetBckgndGC()(), fWidth/2-7, fRelPos-6);
 }
 
 //______________________________________________________________________________
@@ -149,6 +200,7 @@ Bool_t TGVSlider::HandleButton(Event_t *event)
 {
    // Handle mouse button event in vertical slider.
 
+   if (!IsEnabled()) return kTRUE;
    if (event->fType == kButtonPress) {
       // constrain to the slider width
       if (event->fX < (Int_t)fWidth/2-7 || event->fX > (Int_t)fWidth/2+7) {
@@ -251,6 +303,8 @@ TGHSlider::TGHSlider(const TGWindow *p, UInt_t w, UInt_t type, Int_t id,
    if (!fSliderPic)
       Error("TGHSlider", "slider?v.xpm not found");
 
+   CreateDisabledPicture();
+
    gVirtualX->GrabButton(fId, kAnyButton, kAnyModifier,
                          kButtonPressMask | kButtonReleaseMask |
                          kPointerMotionMask, kNone, kNone);
@@ -271,6 +325,7 @@ TGHSlider::~TGHSlider()
    // Delete a horizontal slider widget.
 
    if (fSliderPic) fClient->FreePicture(fSliderPic);
+   if (fDisabledPic) fClient->FreePicture(fDisabledPic);
 }
 
 //______________________________________________________________________________
@@ -281,11 +336,13 @@ void TGHSlider::DoRedraw()
    // cleanup drawable
    gVirtualX->ClearWindow(fId);
 
+   GContext_t drawGC = IsEnabled() ? GetBlackGC()() : GetShadowGC()();
+   
    gVirtualX->DrawLine(fId, GetShadowGC()(), 8, fHeight/2, 8, fHeight/2-1);
    gVirtualX->DrawLine(fId, GetShadowGC()(), 8, fHeight/2-1, fWidth-9, fHeight/2-1);
    gVirtualX->DrawLine(fId, GetHilightGC()(), 8, fHeight/2+1, fWidth-8, fHeight/2+1);
    gVirtualX->DrawLine(fId, GetHilightGC()(), fWidth-8, fHeight/2+1, fWidth-8, fHeight/2);
-   gVirtualX->DrawLine(fId, GetBlackGC()(), 9, fHeight/2, fWidth-9, fHeight/2);
+   gVirtualX->DrawLine(fId, drawGC, 9, fHeight/2, fWidth-9, fHeight/2);
 
    if (fScale == 1) fScale++;
    if (fScale * 2 > (int)fWidth) fScale = 0;
@@ -295,9 +352,9 @@ void TGHSlider::DoRedraw()
       if (lines < 1) lines = 1;
       for (int i = 0; i <= lines; i++) {
          int x = i * fScale + (i * remain) / lines;
-         gVirtualX->DrawLine(fId, GetBlackGC()(), x+7, fHeight/2+8, x+7, fHeight/2+10);
+         gVirtualX->DrawLine(fId, drawGC, x+7, fHeight/2+8, x+7, fHeight/2+10);
          if ((fType & kSlider2) && (fType & kScaleBoth))
-            gVirtualX->DrawLine(fId, GetBlackGC()(), x+7, fHeight/2-9, x+7, fHeight/2-11);
+            gVirtualX->DrawLine(fId, drawGC, x+7, fHeight/2-9, x+7, fHeight/2-11);
       }
    }
    if (fPos < fVmin) fPos = fVmin;
@@ -305,7 +362,12 @@ void TGHSlider::DoRedraw()
 
    // calc slider-picture position
    fRelPos = (((int)fWidth-16) * (fPos - fVmin)) / (fVmax - fVmin) + 8;
-   if (fSliderPic) fSliderPic->Draw(fId, GetBckgndGC()(), fRelPos-6, fHeight/2-7);
+   const TGPicture *pic = fSliderPic;
+   if (!IsEnabled()) {
+      if (!fDisabledPic) CreateDisabledPicture();
+      pic = fDisabledPic ? fDisabledPic : fSliderPic;
+   }
+   if (pic) pic->Draw(fId, GetBckgndGC()(), fRelPos-6, fHeight/2-7);
 }
 
 //______________________________________________________________________________
@@ -313,6 +375,7 @@ Bool_t TGHSlider::HandleButton(Event_t *event)
 {
    // Handle mouse button event in horizontal slider widget.
 
+   if (!IsEnabled()) return kTRUE;
    if (event->fType == kButtonPress) {
       // constrain to the slider height
       if (event->fY < (Int_t)fHeight/2-7 || event->fY > (Int_t)fHeight/2+7) {
@@ -396,7 +459,6 @@ Bool_t TGHSlider::HandleConfigureNotify(Event_t* event)
    return kTRUE;
 }
 
-
 //______________________________________________________________________________
 TString TGSlider::GetTypeString() const
 {
@@ -459,6 +521,9 @@ void TGHSlider::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 
    if (fScale != 10)
       out << "   " << GetName() <<"->SetScale(" << fScale << ");" << endl;
+
+   if (!IsEnabled())
+      out << "   " << GetName() <<"->SetState(kFALSE);" << endl;
 }
 
 //______________________________________________________________________________
@@ -492,4 +557,7 @@ void TGVSlider::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 
    if (fScale != 10)
       out << "   " << GetName() <<"->SetScale(" << fScale << ");" << endl;
+
+   if (!IsEnabled())
+      out << "   " << GetName() <<"->SetState(kFALSE);" << endl;
 }
diff --git a/gui/gui/src/TGTableLayout.cxx b/gui/gui/src/TGTableLayout.cxx
index 10b689d..7263e15 100644
--- a/gui/gui/src/TGTableLayout.cxx
+++ b/gui/gui/src/TGTableLayout.cxx
@@ -154,6 +154,7 @@ void TGTableLayout::FindRowColSizesSinglyAttached()
    TGFrameElement *ptr;
 
    while ((ptr = (TGFrameElement *) next())) {
+      if (ptr->fState == 0) continue;
       TGTableLayoutHints *layout =
             dynamic_cast<TGTableLayoutHints*>(ptr->fLayout);
       if (!layout) {
@@ -208,6 +209,7 @@ void TGTableLayout::FindRowColSizesMultiplyAttached()
    TGFrameElement *ptr;
 
    while ((ptr = (TGFrameElement *) next())) {
+      if (ptr->fState == 0) continue;
       TGTableLayoutHints *layout =
             dynamic_cast<TGTableLayoutHints*>(ptr->fLayout);
       if (!layout) {
