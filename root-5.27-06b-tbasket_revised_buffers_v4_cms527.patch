--- root_cms_patched_pristine/tree/tree/src/TTree.cxx	2011-06-08 21:56:51.000000000 +0200
+++ root_cms_patched_v2/tree/tree/src/TTree.cxx	2011-06-08 21:44:30.000000000 +0200
@@ -515,6 +515,7 @@
 , fClones(0)
 , fBranchRef(0)
 , fFriendLockStatus(0)
+, fTransientBuffer(0)
 {
    // Default constructor and I/O constructor.
    //
@@ -577,6 +578,7 @@
 , fClones(0)
 , fBranchRef(0)
 , fFriendLockStatus(0)
+, fTransientBuffer(0)
 {
    // Normal tree constructor.
    //
@@ -715,6 +717,22 @@
    // Must be done after the destruction of friends.
    // Note: We do *not* own our directory.
    fDirectory = 0;
+
+   if (fTransientBuffer) {
+      delete fTransientBuffer;
+      fTransientBuffer = 0;
+   }
+}
+
+//______________________________________________________________________________
+TBuffer* TTree::GetTransientBuffer(Int_t size)
+{
+    // Returns the transient buffer currently used by this TTree for reading/writing baskets
+    if (fTransientBuffer) {
+        return fTransientBuffer;
+    }
+    fTransientBuffer = new TBufferFile(TBuffer::kRead, size);
+    return fTransientBuffer;
 }
 
 //______________________________________________________________________________
--- root_cms_patched_pristine/tree/tree/src/TBasket.cxx	2011-06-08 21:56:51.000000000 +0200
+++ root_cms_patched_v2/tree/tree/src/TBasket.cxx	2011-06-08 21:56:01.000000000 +0200
@@ -18,6 +18,20 @@
 #include "TTreeCache.h"
 #include "TTreeCacheUnzip.h"
 
+// TODO: Copied from TBranch.cxx
+#if (__GNUC__ >= 3) || defined(__INTEL_COMPILER)
+#if !defined(R__unlikely)
+  #define R__unlikely(expr) __builtin_expect(!!(expr), 0)
+#endif
+#if !defined(R__likely)
+  #define R__likely(expr) __builtin_expect(!!(expr), 1)
+#endif
+#else
+  #define R__unlikely(expr) expr
+  #define R__likely(expr) expr
+#endif
+
+
 extern "C" void R__zip (Int_t cxlevel, Int_t *nin, char *bufin, Int_t *lout, char *bufout, Int_t *nout);
 extern "C" void R__unzip(Int_t *nin, UChar_t *bufin, Int_t *lout, char *bufout, Int_t *nout);
 
@@ -34,7 +48,7 @@
 //
 
 //_______________________________________________________________________
-TBasket::TBasket() : fCompressedSize(0),fCompressedBuffer(0)
+TBasket::TBasket() : fCompressedBufferRef(0), fLastWriteBufferSize(0)
 {
    // Default contructor.
 
@@ -51,10 +65,9 @@
 }
 
 //_______________________________________________________________________
-TBasket::TBasket(TDirectory *motherDir) : TKey(motherDir),fCompressedSize(0),fCompressedBuffer(0)
+TBasket::TBasket(TDirectory *motherDir) : TKey(motherDir),fCompressedBufferRef(0), fLastWriteBufferSize(0)
 {
    // Constructor used during reading.
-
    fDisplacement  = 0;
    fEntryOffset   = 0;
    fBufferRef     = 0;
@@ -69,7 +82,7 @@
 
 //_______________________________________________________________________
 TBasket::TBasket(const char *name, const char *title, TBranch *branch) : 
-   TKey(branch->GetDirectory()),fCompressedSize(0),fCompressedBuffer(0)
+   TKey(branch->GetDirectory()), fLastWriteBufferSize(0)
 {
    // Basket normal constructor, used during writing.
 
@@ -90,7 +103,14 @@
    }
    fHeaderOnly  = kTRUE;
    fLast        = 0; // Must initialize before calling Streamer()
-   
+   if (branch && branch->GetTree()) {
+      fCompressedBufferRef = branch->GetTree()->GetTransientBuffer(fBufferSize);
+      fOwnsCompressedBuffer = kFALSE;
+      if (!fCompressedBufferRef) {
+         fCompressedBufferRef = new TBufferFile(TBuffer::kRead, fBufferSize);
+         fOwnsCompressedBuffer = kTRUE;
+      }
+   }
    Streamer(*fBufferRef);
    fKeylen      = fBufferRef->Length();
    fObjlen      = fBufferSize - fKeylen;
@@ -112,12 +132,16 @@
 
    if (fDisplacement) delete [] fDisplacement;
    if (fEntryOffset)  delete [] fEntryOffset;
-   if (fBuffer == fCompressedBuffer) fBuffer = 0;
-   if (fCompressedBuffer) delete [] fCompressedBuffer;
+   if (fBufferRef) delete fBufferRef;
+   fBufferRef = 0;
+   fBuffer = 0;
    fDisplacement= 0;
    fEntryOffset = 0;
-   fCompressedSize = 0;
-   fCompressedBuffer = 0;
+   // Note we only delete the compressed buffer if we own it
+   if (fCompressedBufferRef && fOwnsCompressedBuffer) {
+       delete fCompressedBufferRef;
+       fCompressedBufferRef = 0;
+   }
 }
 
 //_______________________________________________________________________
@@ -171,19 +195,17 @@
 Int_t TBasket::DropBuffers()
 {
    // Drop buffers of this basket if it is not the current basket.
-
    if (!fBuffer && !fBufferRef) return 0;
 
    if (fDisplacement) delete [] fDisplacement;
    if (fEntryOffset)  delete [] fEntryOffset;
    if (fBufferRef)    delete fBufferRef;
-   if (fCompressedBuffer) delete [] fCompressedBuffer;
+   if (fCompressedBufferRef && fOwnsCompressedBuffer) delete fCompressedBufferRef;
    fBufferRef   = 0;
+   fCompressedBufferRef = 0;
    fBuffer      = 0;
    fDisplacement= 0;
    fEntryOffset = 0;
-   fCompressedSize = 0;
-   fCompressedBuffer = 0;
    fBranch->GetTree()->IncrementTotalBuffers(-fBufferSize);
    return fBufferSize;
 }
@@ -277,6 +299,91 @@
    fNevBuf -= dentries;
 }
 
+#define OLD_CASE_EXPRESSION fObjlen==fNbytes-fKeylen && GetBranch()->GetCompressionLevel()!=0 && file->GetVersion()<=30401
+//_______________________________________________________________________
+Int_t TBasket::ReadBasketBuffersUncompressedCase()
+{
+   // By-passing buffer unzipping has been requested and is
+   // possible (only 1 entry in this basket). 
+   fBuffer = fBufferRef->Buffer();
+            
+   // Make sure that the buffer is set at the END of the data
+   fBufferRef->SetBufferOffset(fNbytes);
+            
+   // Indicate that this buffer is weird.
+   fBufferRef->SetBit(TBufferFile::kNotDecompressed);
+            
+   // Usage of this mode assume the existance of only ONE
+   // entry in this basket.
+   delete [] fEntryOffset; fEntryOffset = 0;
+   delete [] fDisplacement; fDisplacement = 0;
+            
+   fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
+   return 0;
+}
+
+//_______________________________________________________________________
+Int_t TBasket::ReadBasketBuffersUnzip(char* buffer, Int_t size, Bool_t mustFree, TFile* file)
+{
+   // We always create the TBuffer for the basket but it hold the buffer from the cache.
+   if (fBufferRef) {
+      fBufferRef->SetBuffer(buffer, size, mustFree);
+      fBufferRef->SetReadMode();
+      fBufferRef->Reset();
+   } else {
+      fBufferRef = new TBufferFile(TBuffer::kRead, size, buffer, mustFree);
+   }
+   fBufferRef->SetParent(file);
+
+   Streamer(*fBufferRef);
+   
+   if (IsZombie()) {
+      return -1; 
+   }        
+    
+
+   Bool_t oldCase = OLD_CASE_EXPRESSION;
+
+   if ((fObjlen > fNbytes-fKeylen || oldCase) && TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1)) {
+      return TBasket::ReadBasketBuffersUncompressedCase();
+   }
+
+   fBuffer = fBufferRef->Buffer();
+   return fObjlen+fKeylen;
+
+}
+
+// Initialize a buffer for reading if it is not already initialized
+static inline TBuffer* R__initializeReadBasketBuffer(TBuffer* bufferRef, Int_t len, TFile* file)
+{
+   TBuffer* result;
+   if (R__likely(bufferRef)) {
+      bufferRef->SetReadMode();
+      Int_t curBufferSize = bufferRef->BufferSize();
+      if (curBufferSize < len) {
+         // Experience shows that giving 5% "wiggle-room" decreases churn.
+         bufferRef->Expand(Int_t(len*1.05));
+      }
+      bufferRef->Reset();
+      result = bufferRef;
+   } else {
+      result = new TBufferFile(TBuffer::kRead, len);
+   }
+   result->SetParent(file);
+   return result;
+}
+
+//_______________________________________________________________________
+void TBasket::InitializeCompressedBuffer(Int_t len, TFile* file)
+{
+    // Initialize the compressed buffer; either from the TTree or create a local one.
+    Bool_t compressedBufferExists = fCompressedBufferRef != NULL;
+    fCompressedBufferRef = R__initializeReadBasketBuffer(fCompressedBufferRef, len, file);
+    if (!compressedBufferExists) {
+        fOwnsCompressedBuffer = kTRUE;
+    }
+}
+
 //_______________________________________________________________________
 Int_t TBasket::ReadBasketBuffers(Long64_t pos, Int_t len, TFile *file)
 {
@@ -294,165 +401,115 @@
    // There is a lot of code duplication but it was necesary to assure
    // the expected behavior when there is no cache.
 
-
    if(!fBranch->GetDirectory()) {
       return -1;
-   }
-   Int_t badread= 0;
-
-   TFileCacheRead *pf = file->GetCacheRead();
-   char *buffer = 0;
-   Bool_t free = kTRUE; // Must we free this buffer or does it make part of the cache? 
-   Int_t res = -1;
-
-   if (pf) res = pf->GetUnzipBuffer(&buffer, pos, len, &free);
-
-   if (res >= 0) {
-
-      // We always create the TBuffer for the basket but it will be a shell only,
-      // since we pass the pointer to the low level buffer
-      if (fBufferRef) {
-         fBufferRef->SetBuffer(buffer, res, free);
-         fBufferRef->SetReadMode();
-         fBufferRef->Reset();
-      } else {
-         fBufferRef = new TBufferFile(TBuffer::kRead, res, buffer, free);
-      }
-      fBufferRef->SetParent(file);
-
-      Streamer(*fBufferRef);
+   }  
    
-      if (IsZombie()) {
-         badread = 1;
-         return badread;         
-      }
-
-      Bool_t oldCase = fObjlen==fNbytes-fKeylen
-         && GetBranch()->GetCompressionLevel()!=0
-         && file->GetVersion()<=30401;
-      if (fObjlen > fNbytes-fKeylen || oldCase) {
-         if (TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1)) {
-            // By-passing buffer unzipping has been requested and is
-            // possible (only 1 entry in this basket).
-            fBuffer = fBufferRef->Buffer();
-
-            // Make sure that the buffer is set at the END of the data
-            fBufferRef->SetBufferOffset(fNbytes);
+   Bool_t oldCase;
+   char *rawUncompressedBuffer, *rawCompressedBuffer;
+   Int_t uncompressedBufferLen;
 
-            // Indicate that this buffer is weird.
-            fBufferRef->SetBit(TBufferFile::kNotDecompressed);
-
-            // Usage of this mode assume the existance of only ONE
-            // entry in this basket.
-            delete [] fEntryOffset; fEntryOffset = 0;
-            delete [] fDisplacement; fDisplacement = 0;
-
-            fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
-            return badread;
+   // See if the cache has already unzipped the buffer for us.
+   TFileCacheRead *pf = file->GetCacheRead();
+   if (pf) {
+      Int_t res = -1;
+      Bool_t free = kTRUE;
+      char *buffer;
+      res = pf->GetUnzipBuffer(&buffer, pos, len, &free);
+      if (R__unlikely(res >= 0)) {
+         len = ReadBasketBuffersUnzip(buffer, res, free, file);
+         // Note that in the kNotDecompressed case, the above function will return 0;
+         // In such a case, we should stop processing
+         if (len <= 0) return -len;
+         goto AfterBuffer;
+      }
+   }
+
+   // Initialize the buffer to hold the compressed data.
+   InitializeCompressedBuffer(len, file);
+   if (!fCompressedBufferRef) {
+       Error("ReadBasketBuffers", "Unable to allocate buffer.");
+       return 1;
+   }
+   rawCompressedBuffer = fCompressedBufferRef->Buffer();
+
+   // Read from the file and unstream the header information.
+   if (file->ReadBuffer(rawCompressedBuffer,pos,len)) {
+      return 1;
+   }
+   Streamer(*fCompressedBufferRef);
+   if (IsZombie()) {
+      return 1;
+   }
+
+   // Initialize buffer to hold the uncompressed data
+   // Note that in previous versions we didn't allocate buffers until we verified
+   // the zip headers; this is no longer beforehand as the buffer lifetime is scoped
+   // to the TBranch.
+   uncompressedBufferLen = len > fObjlen+fKeylen ? len : fObjlen+fKeylen;
+   fBufferRef = R__initializeReadBasketBuffer(fBufferRef, uncompressedBufferLen, file);
+   rawUncompressedBuffer = fBufferRef->Buffer();
+   fBuffer = rawUncompressedBuffer;
+
+   oldCase = OLD_CASE_EXPRESSION;
+   if (fObjlen > fNbytes-fKeylen || oldCase) {
+      if (R__unlikely(TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1))) {
+         return ReadBasketBuffersUncompressedCase();
+      }
+
+      // Optional monitor for zip time profiling.
+      //Double_t start;
+      //if (gPerfStats) {
+      //   start = TTimeStamp();
+      //}
+
+      memcpy(rawUncompressedBuffer, rawCompressedBuffer, fKeylen);
+      char *rawUncompressedObjectBuffer = rawUncompressedBuffer+fKeylen;
+      UChar_t *rawCompressedObjectBuffer = (UChar_t*)rawCompressedBuffer+fKeylen;
+      Int_t nin, nbuf;
+      Int_t nout = 0, noutot = 0, nintot = 0;
+
+      // Unzip all the compressed objects in the compressed object buffer.
+      while (1) {
+         nin  = 9 + ((Int_t)rawCompressedObjectBuffer[3] | ((Int_t)rawCompressedObjectBuffer[4] << 8) | ((Int_t)rawCompressedObjectBuffer[5] << 16));
+         nbuf = (Int_t)rawCompressedObjectBuffer[6] | ((Int_t)rawCompressedObjectBuffer[7] << 8) | ((Int_t)rawCompressedObjectBuffer[8] << 16);
+         // Check the header for errors.
+         //if (R__unlikely(R__unzip_header(&nin, rawCompressedObjectBuffer, &nbuf) != 0)) {
+         //   Error("ReadBasketBuffers", "Inconsistency found in header (nin=%d, nbuf=%d)", nin, nbuf);
+         //   break;
+         //}
+         if (R__unlikely(oldCase && (nin > fObjlen || nbuf > fObjlen))) {
+            memcpy(rawUncompressedBuffer+fKeylen, rawCompressedObjectBuffer+fKeylen, fObjlen);
+            goto AfterBuffer;
          }
-      }
 
-      fBuffer = fBufferRef->Buffer();
-      len = fObjlen+fKeylen;
-   }
-   else{
-      if (fBufferRef) {
-         fBufferRef->SetReadMode();
-         if (fBufferRef->BufferSize() < len) {
-            fBufferRef->Expand(len);
-         }
-         fBufferRef->Reset();
-      } else {
-         fBufferRef = new TBufferFile(TBuffer::kRead, len);
+         R__unzip(&nin, rawCompressedObjectBuffer, &nbuf, rawUncompressedObjectBuffer, &nout);
+         if (!nout) break;
+         noutot += nout;
+         nintot += nin;
+         if (noutot >= fObjlen) break;
+         rawCompressedObjectBuffer += nin;
+         rawUncompressedObjectBuffer += nout;
       }
-      fBufferRef->SetParent(file);
 
-      buffer = fBufferRef->Buffer();
-      if (file->ReadBuffer(buffer,pos,len)) {
-         badread = 1;
-         return badread;
-      }
-
-      Streamer(*fBufferRef);
-
-      if (IsZombie()) {
-         badread = 1;
-         return badread;         
-      }
-      
-      Bool_t oldCase = fObjlen==fNbytes-fKeylen
-         && GetBranch()->GetCompressionLevel()!=0
-         && file->GetVersion()<=30401;
-      if (fObjlen > fNbytes-fKeylen || oldCase) {
-         if (TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1)) {
-            // By-passing buffer unzipping has been requested and is
-            // possible (only 1 entry in this basket).
-            fBuffer = fBufferRef->Buffer();
-            
-            // Make sure that the buffer is set at the END of the data
-            fBufferRef->SetBufferOffset(fNbytes);
-            
-            // Indicate that this buffer is weird.
-            fBufferRef->SetBit(TBufferFile::kNotDecompressed);
-            
-            // Usage of this mode assume the existance of only ONE
-            // entry in this basket.
-            delete [] fEntryOffset; fEntryOffset = 0;
-            delete [] fDisplacement; fDisplacement = 0;
-            
-            fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
-            return badread;
-         }
-         if ((fObjlen+fKeylen) > fCompressedSize) {
-            if (fCompressedSize) delete [] fCompressedBuffer;
-            fCompressedSize = fObjlen+fKeylen;
-            fCompressedBuffer = new char[fCompressedSize];
-         }
-         fBuffer = fCompressedBuffer;
-         memcpy(fBuffer,buffer,fKeylen);
-         char *objbuf = fBuffer + fKeylen;
-         UChar_t *bufcur = (UChar_t *)&buffer[fKeylen];
-         Int_t nin, nout, nbuf;
-         Int_t noutot = 0;
-         while (1) {
-            nin  = 9 + ((Int_t)bufcur[3] | ((Int_t)bufcur[4] << 8) | ((Int_t)bufcur[5] << 16));
-            nbuf = (Int_t)bufcur[6] | ((Int_t)bufcur[7] << 8) | ((Int_t)bufcur[8] << 16);
-            if (oldCase && (nin > fObjlen || nbuf > fObjlen)) {
-               //buffer was very likely not compressed in an old version
-               delete [] fBuffer;
-               fBuffer = fBufferRef->Buffer();
-               goto AfterBuffer;
-            }
-            R__unzip(&nin, bufcur, &nbuf, objbuf, &nout);
-            if (!nout) break;
-            noutot += nout;
-            if (noutot >= fObjlen) break;
-            bufcur += nin;
-            objbuf += nout;
-         }
-         if (noutot != fObjlen) {
-            Error("ReadBasketBuffers", "fNbytes = %d, fKeylen = %d, fObjlen = %d, noutot = %d, nout=%d, nin=%d, nbuf=%d", fNbytes,fKeylen,fObjlen, noutot,nout,nin,nbuf);
-            badread = 1;
-         }
-         // Switch the 2 buffers
-         char *temp = fBufferRef->Buffer();
-         Int_t templen = fBufferRef->BufferSize();
-         fBufferRef->ResetBit(TBuffer::kIsOwner);
-         fBufferRef->SetBuffer(fBuffer, fCompressedSize, kTRUE); // Do adopt the buffer.
-         fCompressedBuffer = temp;
-         fCompressedSize = templen;
-         len = fObjlen+fKeylen;
-      } else {
-         fBuffer = fBufferRef->Buffer();
+      // Make sure the uncompressed numbers are consistent with header.
+      if (R__unlikely(noutot != fObjlen)) {
+         Error("ReadBasketBuffers", "fNbytes = %d, fKeylen = %d, fObjlen = %d, noutot = %d, nout=%d, nin=%d, nbuf=%d", fNbytes,fKeylen,fObjlen, noutot,nout,nin,nbuf);
+         fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
+         return 1;
       }
+      len = fObjlen+fKeylen;
+      //if (gPerfStats) {
+      //   gPerfStats->FileUnzipEvent(file,pos,start,nintot,fObjlen);
+      //}
+   } else {
+      memcpy(rawUncompressedBuffer, rawCompressedBuffer, len);
    }
- AfterBuffer:
 
-   fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
+AfterBuffer:
 
-   // read offsets table
-   if (badread || !fBranch->GetEntryOffsetLen()) {
-      return badread;
+   if (!fBranch->GetEntryOffsetLen()) {
+      return 0;
    }
    delete [] fEntryOffset;
    fEntryOffset = 0;
@@ -462,19 +519,20 @@
       fEntryOffset = new Int_t[fNevBuf+1];
       fEntryOffset[0] = fKeylen;
       Warning("ReadBasketBuffers","basket:%s has fNevBuf=%d but fEntryOffset=0, pos=%lld, len=%d, fNbytes=%d, fObjlen=%d, trying to repair",GetName(),fNevBuf,pos,len,fNbytes,fObjlen);
-      return badread;
-   }
+      return 0;
+   }        
    delete [] fDisplacement;
-   fDisplacement = 0;
+   fDisplacement = 0; 
    if (fBufferRef->Length() != len) {
       // There is more data in the buffer!  It is the displacement
       // array.  If len is less than TBuffer::kMinimalSize the actual
       // size of the buffer is too large, so we can not use the
       // fBufferRef->BufferSize()
       fBufferRef->ReadArray(fDisplacement);
-   }
+   }        
+            
+   return 0; 
 
-   return badread;
 }
 
 //_______________________________________________________________________
@@ -502,8 +560,43 @@
    // Name, Title, fClassName, fBranch 
    // stay the same.
    
-   TKey::Reset();
+   // Downsize the buffer if needed.
+   Int_t curSize = fBufferRef->BufferSize();
+   // fBufferLen at this point is already reset, so use indirect measurements
+   Int_t curLen = (GetObjlen() + GetKeylen());
+   Int_t newSize = 0;
+   if (curSize > 2*curLen)
+   {
+      Long_t curBsize = fBranch->GetBasketSize();      
+      if (curSize > 2*curBsize ) {
+         Long_t avgSize = (Long_t)(fBranch->GetTotBytes() / (1+fBranch->GetWriteBasket())); // Average number of bytes per basket so far
+         if (curSize > 2*avgSize) {
+            newSize = curBsize;
+            if (curLen > newSize) {
+               newSize = curLen;
+            }
+            if (avgSize > newSize) {
+               newSize = avgSize;
+            }
+            newSize = Int_t(1.05*Float_t(newSize));;
+         }
+      }
+   }
+/*
+   if (curSize > fLastWriteBufferSize) {
+      if (newSize == 0) {
+         newSize = Int_t(1.05*Float_t(fBufferRef->Length()));
+      }
+      fLastWriteBufferSize = newSize;
+   }
+*/
+   // By calling Expand(1) then the new size, we avoid a memmove
+   if (newSize) {
+      fBufferRef->Expand(1);
+      fBufferRef->Expand(newSize); // May shrink or grow
+   }
 
+   TKey::Reset();
    Int_t newNevBufSize = fBranch->GetEntryOffsetLen();
    if (newNevBufSize==0) {
       delete [] fEntryOffset;
@@ -727,8 +820,8 @@
       return -1;
    }
    fMotherDir = file; // fBranch->GetDirectory();
-   
-   if (fBufferRef->TestBit(TBufferFile::kNotDecompressed)) {
+  
+   if (R__unlikely(fBufferRef->TestBit(TBufferFile::kNotDecompressed))) {
       // Read the basket information that was saved inside the buffer.
       Bool_t writing = fBufferRef->IsWriting();
       fBufferRef->SetReadMode();
@@ -773,12 +866,13 @@
       //if (cxlevel == 2) cxlevel--; RB: I cannot remember why we had this!
       Int_t nbuffers = fObjlen/kMAXBUF;
       Int_t buflen = fKeylen + fObjlen + 28; //add 28 bytes in case object is placed in a deleted gap
-      if (buflen > fCompressedSize) {
-         if (fCompressedSize) delete [] fCompressedBuffer;
-         fCompressedSize = buflen;
-         fCompressedBuffer = new char[fCompressedSize];
+      InitializeCompressedBuffer(buflen, file);
+      if (!fCompressedBufferRef) {
+         Warning("WriteBuffer", "Unable to allocate the compressed buffer");
+         return -1;
       }
-      fBuffer = fCompressedBuffer;
+      fCompressedBufferRef->SetWriteMode();
+      fBuffer = fCompressedBufferRef->Buffer();
       char *objbuf = fBufferRef->Buffer() + fKeylen;
       char *bufcur = &fBuffer[fKeylen];
       noutot = 0;
@@ -794,9 +888,8 @@
          // buffer is larger than the input. In this case, we write the original uncompressed buffer
          if (nout == 0 || nout >= fObjlen) {
             nout = fObjlen;
-            // We use do delete fBuffer here, we no longer want to since
-            // the buffer (held by fCompressedBuffer) might be re-used later.
-            // delete [] fBuffer;
+            // We used to delete fBuffer here, we no longer want to since
+            // the buffer (held by fCompressedBufferRef) might be re-used later.
             fBuffer = fBufferRef->Buffer();
             Create(fObjlen,file);
             fBufferRef->SetBufferOffset(0);
--- root_cms_patched_pristine/tree/tree/inc/TBasket.h	2011-06-08 21:56:51.000000000 +0200
+++ root_cms_patched_v2/tree/tree/inc/TBasket.h	2011-06-08 21:44:30.000000000 +0200
@@ -40,7 +40,14 @@
 private:
    TBasket(const TBasket&);            // TBasket objects are not copiable.
    TBasket& operator=(const TBasket&); // TBasket objects are not copiable.
-      
+
+   // Internal corner cases for ReadBasketBuffers
+   Int_t ReadBasketBuffersUnzip(char*, Int_t, Bool_t, TFile*);
+   Int_t ReadBasketBuffersUncompressedCase();
+
+   // Helper for managing the compressed buffer.
+   void InitializeCompressedBuffer(Int_t len, TFile* file);
+ 
 protected:
    Int_t       fBufferSize;      //fBuffer length in bytes
    Int_t       fNevBufSize;      //Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!
@@ -50,9 +57,10 @@
    Int_t      *fDisplacement;    //![fNevBuf] Displacement of entries in fBuffer(TKey)
    Int_t      *fEntryOffset;     //[fNevBuf] Offset of entries in fBuffer(TKey)
    TBranch    *fBranch;          //Pointer to the basket support branch
-   Int_t       fCompressedSize;  //!Size of the allocated memroy in fCompressedBuffer
-   char       *fCompressedBuffer;//!Temporary place holder for the compressed buffer if needed.
-   
+   TBuffer    *fCompressedBufferRef; //! Compressed buffer.
+   Bool_t      fOwnsCompressedBuffer; //! Whether or not we own the compressed buffer.
+   Int_t       fLastWriteBufferSize; //! Size of the buffer last time we wrote it to disk
+
 public:
    
    TBasket();
--- root_cms_patched_pristine/tree/tree/inc/TTree.h	2011-06-08 21:56:51.000000000 +0200
+++ root_cms_patched_v2/tree/tree/inc/TTree.h	2011-06-08 21:47:04.000000000 +0200
@@ -134,6 +134,7 @@
    TList         *fClones;            //! List of cloned trees which share our addresses
    TBranchRef    *fBranchRef;         //  Branch supporting the TRefTable (if any)
    UInt_t         fFriendLockStatus;  //! Record which method is locking the friend recursion
+   TBuffer       *fTransientBuffer;   //! Pointer to the current transient buffer.
 
    static Int_t     fgBranchStyle;      //  Old/New branch style
    static Long64_t  fgMaxTreeSize;      //  Maximum size of a file containg a Tree
@@ -461,6 +462,7 @@
    void                    UseCurrentStyle();
    virtual Int_t           Write(const char *name=0, Int_t option=0, Int_t bufsize=0);
    virtual Int_t           Write(const char *name=0, Int_t option=0, Int_t bufsize=0) const;
+   TBuffer*                GetTransientBuffer(Int_t size);
 
    ClassDef(TTree,18)  //Tree descriptor (the main ROOT I/O class)
 };
