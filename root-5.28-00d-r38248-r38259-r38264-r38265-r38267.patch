diff -aur root.orig/cint/reflex/inc/Reflex/Builder/ClassBuilder.h root/cint/reflex/inc/Reflex/Builder/ClassBuilder.h
--- root.orig/cint/reflex/inc/Reflex/Builder/ClassBuilder.h	2011-05-25 10:02:20.000000000 +0200
+++ root/cint/reflex/inc/Reflex/Builder/ClassBuilder.h	2011-06-01 11:54:40.000000000 +0200
@@ -23,6 +23,34 @@
 namespace Cint { namespace Internal {} }
 
 namespace Reflex {
+
+/* Helper class to avoid compiler warning about casting function pointer
+** to void pointer.
+*/
+class BuilderFunc2Void {
+   typedef void (*funcptr_t)();
+
+   union funcptr_and_voidptr {
+      typedef void (*funcptr_t)();
+
+      funcptr_and_voidptr(void *val) : _read(val) {}
+
+      void *_read;
+      funcptr_t _write;
+   };
+
+   funcptr_and_voidptr _tmp;
+public:
+   template <typename T>
+   BuilderFunc2Void( T vfp ) : _tmp(0) {
+      _tmp._write = ( funcptr_t )vfp;
+   }
+
+   operator void*() const {
+      return _tmp._read;
+   }
+};
+
 // forward declarations
 class Class;
 class ClassBuilder;
diff -aur root.orig/cint/reflex/python/genreflex/gendict.py root/cint/reflex/python/genreflex/gendict.py
--- root.orig/cint/reflex/python/genreflex/gendict.py	2011-05-25 10:02:20.000000000 +0200
+++ root/cint/reflex/python/genreflex/gendict.py	2011-06-01 11:54:40.000000000 +0200
@@ -576,6 +576,11 @@
     #------------------------------------------------------------------------------
     classDefImpl = ClassDefImplementation(selclasses, self)
 
+    #------------------------------------------------------------------------------
+    # Process Class_Version implementation before writing: sets 'extra' properties
+    #------------------------------------------------------------------------------
+    Class_VersionImplementation(selclasses,self)
+
     f_buffer = ''
     # Need to specialize templated class's functions (e.g. A<T>::Class())
     # before first instantiation (stubs), so classDefImpl before stubs.
@@ -895,7 +900,7 @@
         sc += '  rule->fSource      = "%s";\n' % (attrs['source'],)
         
       if rule.has_key( 'funcname' ):
-        sc += '  rule->fFunctionPtr = (void *)%s;\n' % (rule['funcname'],)
+        sc += '  rule->fFunctionPtr = Reflex::BuilderFunc2Void(%s);\n' % (rule['funcname'],)
         sc += '  rule->fCode        = "%s";\n' % (rule['code'].replace( '\n', '\\n' ), )
 
       if attrs.has_key( 'version' ):
@@ -975,6 +980,7 @@
       # Initialize the structure - to  be changed later
       #---------------------------------------------------------------------------
       for member in source:
+        if member[0] == '': continue;
         sc += '  static Long_t offset_Onfile_' + mappedName
         sc += '_' + member[1] + ' = oldObj->GetClass()->GetDataMemberOffset("'
         sc += member[1] +'");\n';
@@ -1034,7 +1040,9 @@
         sc += 'void %s( char *target, TVirtualObject *oldObj )\n' % (funcname,)
         sc += '{\n'
         sc += self.processIOAutoVariables( cl, clt, sourceMembersSpl, targetMembers, memTypes )
-        sc += '  %s* newObj = (%s*)target;\n' % (cl, cl)
+        #to avoid compiler warnings about unused variables only declare newObj if user actually uses it
+        if -1 != rule['code'].find('newObj'):
+           sc += '  %s* newObj = (%s*)target;\n' % (cl, cl)
         sc += '  //--- User\'s code ---\n'
         sc += rule['code'].strip('\n')
         sc += '\n}\n\n'
@@ -2765,3 +2773,31 @@
   if haveClassDef == 1 :
     return "} // unnamed namespace\n\n" + returnValue + "\nnamespace {\n"
   return ""
+
+#--------------------------------------------------------------------------------------
+# If Class_Version is a member function of the class, use it to set ClassVersion
+def Class_VersionImplementation(selclasses, self):
+  for attrs in selclasses :
+    #if ClassVersion was already set, do not change
+    if attrs.has_key('extra') and 'ClassVersion' in attrs['extra']:
+        continue
+    
+    members = attrs.get('members','')
+    membersList = members.split()
+
+    hasClass_Version = False
+    for ml in membersList:
+      memAttrs = self.xref[ml]['attrs']
+      if ml[1].isdigit() and memAttrs.has_key('name') and memAttrs['name'] == "Class_Version":
+        if memAttrs.get('access') not in ('protected', 'private') and 'static' in memAttrs:         
+            hasClass_Version = True
+        else:
+            print "--->> genreflex: ERROR: class %s's method Class_Version() must be both 'static' and 'public'." % attrs['fullname']
+        break
+
+    if hasClass_Version:
+      clname = '::' + attrs['fullname']
+      if attrs.has_key('extra'):
+        attrs['extra']['ClassVersion'] = '!RAW!' + clname + '::Class_Version()'
+      else:
+        attrs['extra']={'ClassVersion' : '!RAW!' + clname + '::Class_Version()'}
