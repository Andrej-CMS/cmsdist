diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf2d/x11/src/GX11Gui.cxx root/graf2d/x11/src/GX11Gui.cxx
--- root-old/graf2d/x11/src/GX11Gui.cxx	2010-10-27 16:37:25.000000000 +0200
+++ root/graf2d/x11/src/GX11Gui.cxx	2011-04-04 16:56:04.000000000 +0200
@@ -1386,7 +1386,8 @@
 {
    // Free color cell with specified pixel value.
 
-   XFreeColors(fDisplay, (Colormap)cmap, &pixel, 1, 0);
+   if (fRedDiv == -1)
+      XFreeColors(fDisplay, (Colormap)cmap, &pixel, 1, 0);
 }
 
 //______________________________________________________________________________
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/inc/TGFrame.h root/gui/gui/inc/TGFrame.h
--- root-old/gui/gui/inc/TGFrame.h	2010-10-27 16:37:14.000000000 +0200
+++ root/gui/gui/inc/TGFrame.h	2011-04-04 17:02:16.000000000 +0200
@@ -536,6 +536,7 @@
    virtual Bool_t HandleSelectionRequest(Event_t *event);
    virtual Bool_t HandleButton(Event_t *event);
    virtual Bool_t HandleMotion(Event_t *event);
+   virtual Bool_t SaveFrameAsCodeOrImage();
    virtual void   SendCloseMessage();
    virtual void   CloseWindow();   //*SIGNAL*
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/gui/gui/src/TGFrame.cxx root/gui/gui/src/TGFrame.cxx
--- root-old/gui/gui/src/TGFrame.cxx	2010-10-27 16:37:14.000000000 +0200
+++ root/gui/gui/src/TGFrame.cxx	2011-04-04 17:10:07.000000000 +0200
@@ -1471,77 +1471,96 @@
 }
 
 //______________________________________________________________________________
+Bool_t TGMainFrame::SaveFrameAsCodeOrImage()
+{
+   // Opens dialog window allowing user to save the frame contents
+   // as a ROOT macro or as an image.
+   // Returns kTRUE if something was saved.
+   //
+   // This is bound to Ctrl-S by default.
+
+   static TString dir(".");
+   static Bool_t overwr = kFALSE;
+
+   Bool_t repeat_save;
+   do {
+      repeat_save = kFALSE;
+
+      TGFileInfo fi;
+      TGMainFrame *main = (TGMainFrame*)GetMainFrame();
+      fi.fFileTypes = gSaveMacroTypes;
+      fi.fIniDir    = StrDup(dir);
+      fi.fOverwrite = overwr;
+      new TGFileDialog(fClient->GetDefaultRoot(), this, kFDSave, &fi);
+      if (!fi.fFilename) return kFALSE;
+      dir = fi.fIniDir;
+      overwr = fi.fOverwrite;
+      TString fname = gSystem->UnixPathName(fi.fFilename);
+      if (fname.EndsWith(".C"))
+         main->SaveSource(fname.Data(), "");
+      else {
+         TImage::EImageFileTypes gtype = TImage::kUnknown;
+         if (fname.EndsWith("gif")) {
+            gtype = TImage::kGif;
+         } else if (fname.EndsWith(".png")) {
+            gtype = TImage::kPng;
+         } else if (fname.EndsWith(".jpg")) {
+            gtype = TImage::kJpeg;
+         } else if (fname.EndsWith(".tiff")) {
+            gtype = TImage::kTiff;
+         } else if (fname.EndsWith(".xpm")) {
+            gtype = TImage::kXpm;
+         }
+         if (gtype != TImage::kUnknown) {
+            Int_t saver = gErrorIgnoreLevel;
+            gErrorIgnoreLevel = kFatal;
+            TImage *img = TImage::Create();
+            RaiseWindow();
+            img->FromWindow(GetId());
+            img->WriteImage(fname, gtype);
+            gErrorIgnoreLevel = saver;
+            delete img;
+         }
+         else {
+            Int_t retval;
+            new TGMsgBox(fClient->GetDefaultRoot(), this, "Error...",
+                         TString::Format("file (%s) cannot be saved with this extension",
+                                         fname.Data()), kMBIconExclamation,
+                         kMBRetry | kMBCancel, &retval);
+            repeat_save = (retval == kMBRetry);
+         }
+      }
+   } while (repeat_save);
+
+   return kTRUE;
+}
+
+//______________________________________________________________________________
 Bool_t TGMainFrame::HandleKey(Event_t *event)
 {
    // Handle keyboard events.
 
-   if ((event->fType == kGKeyPress) && (event->fState & kKeyControlMask)) {
-      UInt_t keysym;
-      char str[2];
-      gVirtualX->LookupString(event, str, sizeof(str), keysym);
+   if (fBindList) {
 
-      if ((keysym & ~0x20) == kKey_S) { // case insensitive ctrl-s
-         static TString dir(".");
-         static Bool_t overwr = kFALSE;
-         TGFileInfo fi;
-         TGMainFrame *main = (TGMainFrame*)GetMainFrame();
-         fi.fFileTypes = gSaveMacroTypes;
-         fi.fIniDir    = StrDup(dir);
-         fi.fOverwrite = overwr;
-         new TGFileDialog(fClient->GetDefaultRoot(), this, kFDSave, &fi);
-         if (!fi.fFilename) return kTRUE;
-         dir = fi.fIniDir;
-         overwr = fi.fOverwrite;
-         TString fname = gSystem->UnixPathName(fi.fFilename);
-         if (fname.EndsWith(".C"))
-            main->SaveSource(fname.Data(), "");
-         else {
-            TImage::EImageFileTypes gtype = TImage::kUnknown;
-            if (fname.EndsWith("gif")) {
-               gtype = TImage::kGif;
-            } else if (fname.EndsWith(".png")) {
-               gtype = TImage::kPng;
-            } else if (fname.EndsWith(".jpg")) {
-               gtype = TImage::kJpeg;
-            } else if (fname.EndsWith(".tiff")) {
-               gtype = TImage::kTiff;
-            } else if (fname.EndsWith(".xpm")) {
-               gtype = TImage::kXpm;
-            }
-            if (gtype != TImage::kUnknown) {
-               Int_t saver = gErrorIgnoreLevel;
-               gErrorIgnoreLevel = kFatal;
-               TImage *img = TImage::Create();
-               RaiseWindow();
-               img->FromWindow(GetId());
-               img->WriteImage(fname, gtype);
-               gErrorIgnoreLevel = saver;
-               delete img;
-            }
-            else {
-               Int_t retval;
-               new TGMsgBox(fClient->GetDefaultRoot(), this, "Error...",
-                            TString::Format("file (%s) cannot be saved with this extension", 
-                            fname.Data()), kMBIconExclamation, 
-                            kMBRetry | kMBCancel, &retval);
-               if (retval == kMBRetry)
-                  HandleKey(event);
-            }
+      TIter next(fBindList);
+      TGMapKey *m;
+      TGFrame  *w = 0;
+
+      while ((m = (TGMapKey *) next())) {
+         if (m->fKeyCode == event->fCode) {
+            w = (TGFrame *) m->fWindow;
+            if (w->HandleKey(event)) return kTRUE;
          }
-         return kTRUE;
       }
    }
 
-   if (!fBindList) return kFALSE;
-
-   TIter next(fBindList);
-   TGMapKey *m;
-   TGFrame  *w = 0;
+   if ((event->fType == kGKeyPress) && (event->fState & kKeyControlMask)) {
+      UInt_t keysym;
+      char str[2];
+      gVirtualX->LookupString(event, str, sizeof(str), keysym);
 
-   while ((m = (TGMapKey *) next())) {
-      if (m->fKeyCode == event->fCode) {
-         w = (TGFrame *) m->fWindow;
-         if (w->HandleKey(event)) return kTRUE;
+      if ((keysym & ~0x20) == kKey_S) { // case insensitive ctrl-s
+         return SaveFrameAsCodeOrImage();
       }
    }
    return kFALSE;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/LinkDef1.h root/graf3d/eve/inc/LinkDef1.h
--- root-old/graf3d/eve/inc/LinkDef1.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/LinkDef1.h	2011-04-04 08:03:06.000000000 -0700
@@ -90,16 +90,23 @@
 #pragma link C++ class TEveManager::TExceptionHandler+;
 
 // TEveVSD
-#pragma link C++ class TEveVSD+;
 #pragma link C++ class TEveMCTrack+;
 #pragma link C++ class TEveHit+;
 #pragma link C++ class TEveCluster+;
-#pragma link C++ class TEveRecTrack+;
+
+#pragma link C++ class   TEveRecTrackT<Float_t>+;
+#pragma link C++ class   TEveRecTrackT<Double_t>+;
+#pragma link C++ typedef TEveRecTrack;
+#pragma link C++ typedef TEveRecTrackF;
+#pragma link C++ typedef TEveRecTrackD;
+
 #pragma link C++ class TEveRecKink+;
 #pragma link C++ class TEveRecV0+;
 #pragma link C++ class TEveRecCascade+;
 #pragma link C++ class TEveMCRecCrossRef+;
 
+#pragma link C++ class TEveVSD+;
+
 // TEveChunkManager
 #pragma link C++ class TEveChunkManager+;
 #pragma link C++ class TEveChunkManager::iterator-;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveCalo.h root/graf3d/eve/inc/TEveCalo.h
--- root-old/graf3d/eve/inc/TEveCalo.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/TEveCalo.h	2011-04-04 08:03:06.000000000 -0700
@@ -192,6 +192,7 @@
 {
    friend class TEveCalo2DGL;
 
+public:
    typedef std::vector<TEveCaloData::vCellId_t*>           vBinCells_t;
    typedef std::vector<TEveCaloData::vCellId_t*>::iterator vBinCells_i;
 
@@ -229,6 +230,8 @@
 
    virtual Float_t GetValToHeight() const;
 
+   const TEveCalo2D::vBinCells_t& GetBinLists() const { return fCellLists; }
+
    ClassDef(TEveCalo2D, 0); // Class for visualization of projected calorimeter event data.
 };
 /**************************************************************************/
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEvePathMark.h root/graf3d/eve/inc/TEvePathMark.h
--- root-old/graf3d/eve/inc/TEvePathMark.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/TEvePathMark.h	2011-04-04 08:03:06.000000000 -0700
@@ -42,6 +42,10 @@
    TEvePathMarkT(EType_e type, const TEveVectorT<TT>& v, const TEveVectorT<TT>& p, const TEveVectorT<TT>& e, TT time=0) :
       fType(type), fV(v), fP(p), fE(e), fTime(time) {}
 
+   template <typename OO>
+   TEvePathMarkT(const TEvePathMarkT<OO>& pm) :
+      fType((EType_e)pm.fType), fV(pm.fV), fP(pm.fP), fE(pm.fE), fTime(pm.fTime) {}
+
    const char* TypeName();
 
    ClassDefNV(TEvePathMarkT, 1); // Template for a special point on a track: position/momentum reference, daughter creation or decay.
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveProjections.h root/graf3d/eve/inc/TEveProjections.h
--- root-old/graf3d/eve/inc/TEveProjections.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/TEveProjections.h	2011-06-14 15:55:33.321752428 -0700
@@ -54,8 +54,9 @@
    EGeoMode_e          fGeoMode;       // strategy of polygon projection (what to try first)
    TString             fName;          // name
 
-   TEveVector          fCenter;        // center of distortion
-   TEveVector          fZeroPosVal;    // projected origin (0, 0, 0)
+   TEveVector          fCenter;        // center of distortionprivate:
+
+   bool                fDisplaceOrigin; // displace point before projection
 
    Bool_t              fUsePreScale;   // use pre-scaling
    vPreScale_t         fPreScales[3];  // scaling before the distortion
@@ -71,9 +72,6 @@
    Float_t             fPastFixZScale; // relative scaling beyond fFixZ
    Float_t             fMaxTrackStep;  // maximum distance between two points on a track
 
-   TEveVector          fLowLimit;      // convergence of point +infinity
-   TEveVector          fUpLimit;       // convergence of point -infinity
-
    void PreScaleVariable(Int_t dim, Float_t& v);
 
 public:
@@ -96,8 +94,11 @@
    const   Char_t*     GetName() const            { return fName.Data(); }
    void                SetName(const Char_t* txt) { fName = txt; }
 
-   virtual void        SetCenter(TEveVector& v)   { fCenter = v; UpdateLimit(); }
-   virtual Float_t*    GetProjectedCenter()       { return fCenter.Arr(); }
+   virtual void        SetCenter(TEveVector& v) { fCenter = v; }
+   virtual Float_t*    GetProjectedCenter();
+  
+   void                SetDisplaceOrigin(bool);
+   Bool_t              GetDisplaceOrigin() const { return fDisplaceOrigin; }
 
    void                SetType(EPType_e t)        { fType = t; }
    EPType_e            GetType() const            { return fType; }
@@ -105,8 +106,6 @@
    void                SetGeoMode(EGeoMode_e m)   { fGeoMode = m; }
    EGeoMode_e          GetGeoMode() const         { return fGeoMode; }
 
-   virtual void        UpdateLimit();
-
    Bool_t   GetUsePreScale() const   { return fUsePreScale; }
    void     SetUsePreScale(Bool_t x) { fUsePreScale = x; }
 
@@ -133,13 +132,17 @@
    virtual Bool_t      AcceptSegment(TEveVector&, TEveVector&, Float_t /*tolerance*/) const { return kTRUE; }
    virtual Int_t       SubSpaceId(const TEveVector&) const { return 0; }
    virtual Bool_t      IsOnSubSpaceBoundrary(const TEveVector&) const { return kFALSE; }
-   virtual void        BisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr=1e-10f);
+   virtual void        BisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr);
+   virtual void        BisectBreakPoint(TEveVector& vL, TEveVector& vR, Bool_t project_result=kFALSE, Float_t depth=0);
    virtual void        SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
 
    // utils to draw axis
+   TEveVector          GetOrthogonalCenter(int idx, TEveVector& out);
    virtual Float_t     GetValForScreenPos(Int_t ax, Float_t value);
    virtual Float_t     GetScreenVal(Int_t ax, Float_t value);
-   Float_t             GetLimit(Int_t i, Bool_t pos) { return pos ? fUpLimit[i] : fLowLimit[i]; }
+   Float_t             GetScreenVal(Int_t i, Float_t x, TEveVector& dirVec, TEveVector& oCenter);
+   Float_t             GetLimit(Int_t i, Bool_t pos);
+
 
    static   Float_t    fgEps;    // resolution of projected points
    static   Float_t    fgEpsSqr; // square of resolution of projected points
@@ -166,11 +169,9 @@
 
    virtual void        ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
 
-   virtual void        SetCenter(TEveVector& center);
+   virtual void        SetCenter(TEveVector& v); 
    virtual Float_t*    GetProjectedCenter() { return fProjectedCenter.Arr(); }
 
-   virtual void        UpdateLimit();
-
    virtual Bool_t      HasSeveralSubSpaces() const { return kTRUE; }
    virtual Bool_t      AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance) const;
    virtual Int_t       SubSpaceId(const TEveVector& v) const;
@@ -218,4 +219,7 @@
    ClassDef(TEve3DProjection, 0); // 3D scaling "projection"
 };
 
+// AMT: temporary workaround till root pactches are integrated in CMSSW 	 
+#define TEVEPROJECTIONS_DISPLACE_ORIGIN_MODE	 
+	 
 #endif
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrack.h root/graf3d/eve/inc/TEveTrack.h
--- root-old/graf3d/eve/inc/TEveTrack.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/TEveTrack.h	2011-04-04 08:03:06.000000000 -0700
@@ -16,6 +16,7 @@
 
 #include "TEveVector.h"
 #include "TEvePathMark.h"
+#include "TEveVSDStructs.h"
 #include "TEveElement.h"
 #include "TEveLine.h"
 
@@ -25,7 +26,6 @@
 class TEveTrackPropagator;
 class TEveTrackList;
 
-class TEveRecTrack;
 class TEveMCTrack;
 class TParticle;
 
@@ -39,7 +39,7 @@
    TEveTrack& operator=(const TEveTrack&); // Not implemented
 
 public:
-   typedef std::vector<TEvePathMark>    vPathMark_t;
+   typedef std::vector<TEvePathMarkD>   vPathMark_t;
    typedef vPathMark_t::iterator        vPathMark_i;
    typedef vPathMark_t::const_iterator  vPathMark_ci;
 
@@ -47,9 +47,9 @@
    enum EBreakProjectedTracks_e { kBPTDefault, kBPTAlways, kBPTNever };
 
 protected:
-   TEveVector         fV;          // Starting vertex
-   TEveVector         fP;          // Starting momentum
-   TEveVector         fPEnd;       // Momentum at the last point of extrapolation
+   TEveVectorD        fV;          // Starting vertex
+   TEveVectorD        fP;          // Starting momentum
+   TEveVectorD        fPEnd;       // Momentum at the last point of extrapolation
    Double_t           fBeta;       // Relativistic beta factor
    Int_t              fPdg;        // PDG code
    Int_t              fCharge;     // Charge in units of e0
@@ -67,6 +67,7 @@
    TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop=0);
    TEveTrack(TEveMCTrack*  t, TEveTrackPropagator* prop=0);
    TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop=0);
+   TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop=0);
    TEveTrack(const TEveTrack& t);
    virtual ~TEveTrack();
 
@@ -84,9 +85,9 @@
    void  SetPropagator(TEveTrackPropagator* prop);
    void  SetAttLineAttMarker(TEveTrackList* tl);
 
-   const TEveVector& GetVertex()      const { return fV;    }
-   const TEveVector& GetMomentum()    const { return fP;    }
-   const TEveVector& GetEndMomentum() const { return fPEnd; }
+   const TEveVectorD& GetVertex()      const { return fV;    }
+   const TEveVectorD& GetMomentum()    const { return fP;    }
+   const TEveVectorD& GetEndMomentum() const { return fPEnd; }
 
    Int_t GetPdg()    const    { return fPdg;    }
    void  SetPdg(Int_t pdg)    { fPdg = pdg;     }
@@ -99,7 +100,9 @@
    Int_t GetStatus()  const   { return fStatus; }
    void  SetStatus(Int_t idx) { fStatus = idx;  }
 
-   void  AddPathMark(const TEvePathMark& pm) { fPathMarks.push_back(pm); }
+   void  AddPathMark(const TEvePathMarkD& pm) { fPathMarks.push_back(pm); }
+   void  AddPathMark(const TEvePathMark& pm)  { fPathMarks.push_back(pm); }
+
    void  SortPathMarksByTime();
          vPathMark_t& RefPathMarks()       { return fPathMarks; }
    const vPathMark_t& RefPathMarks() const { return fPathMarks; }
@@ -128,7 +131,7 @@
    static Bool_t GetDefaultBreakProjectedTracks();
    static void   SetDefaultBreakProjectedTracks(Bool_t bt);
 
-   ClassDef(TEveTrack, 1); // Track with given vertex, momentum and optional referece-points (path-marks) along its path.
+   ClassDef(TEveTrack, 0); // Track with given vertex, momentum and optional referece-points (path-marks) along its path.
 };
 
 /******************************************************************************/
@@ -153,16 +156,16 @@
    Bool_t               fRnrLine;    // Render track as line.
    Bool_t               fRnrPoints;  // Render track as points.
 
-   Float_t              fMinPt;      // Minimum track pT for display selection.
-   Float_t              fMaxPt;      // Maximum track pT for display selection.
-   Float_t              fLimPt;      // Highest track pT in the container.
-   Float_t              fMinP;       // Minimum track p for display selection.
-   Float_t              fMaxP;       // Maximum track p for display selection.
-   Float_t              fLimP;       // Highest track p in the container.
-
-   void    FindMomentumLimits(TEveElement* el, Bool_t recurse=kTRUE);
-   Float_t RoundMomentumLimit(Float_t x);
-   void    SanitizeMinMaxCuts();
+   Double_t             fMinPt;      // Minimum track pTfor display selection.
+   Double_t             fMaxPt;      // Maximum track pTfor display selection.
+   Double_t             fLimPt;      // Highest track pT in the container.
+   Double_t             fMinP;       // Minimum track pfor display selection.
+   Double_t             fMaxP;       // Maximum track pfor display selection.
+   Double_t             fLimP;       // Highest track p in the container.
+
+   void     FindMomentumLimits(TEveElement* el, Bool_t recurse=kTRUE);
+   Double_t RoundMomentumLimit(Double_t x);
+   void     SanitizeMinMaxCuts();
 
 public:
    TEveTrackList(TEveTrackPropagator* prop=0);
@@ -203,17 +206,17 @@
    void   SetRnrPoints(Bool_t r, TEveElement* el);
    Bool_t GetRnrPoints() const { return fRnrPoints; }
 
-   void SelectByPt(Float_t min_pt, Float_t max_pt);
-   void SelectByPt(Float_t min_pt, Float_t max_pt, TEveElement* el);
-   void SelectByP (Float_t min_p,  Float_t max_p);
-   void SelectByP (Float_t min_p,  Float_t max_p,  TEveElement* el);
-
-   Float_t GetMinPt() const { return fMinPt; }
-   Float_t GetMaxPt() const { return fMaxPt; }
-   Float_t GetLimPt() const { return fLimPt; }
-   Float_t GetMinP()  const { return fMinP;  }
-   Float_t GetMaxP()  const { return fMaxP;  }
-   Float_t GetLimP()  const { return fLimP;  }
+   void SelectByPt(Double_t min_pt, Double_t max_pt);
+   void SelectByPt(Double_t min_pt, Double_t max_pt, TEveElement* el);
+   void SelectByP (Double_t min_p,  Double_t max_p);
+   void SelectByP (Double_t min_p,  Double_t max_p,  TEveElement* el);
+
+   Double_t GetMinPt() const { return fMinPt; }
+   Double_t GetMaxPt() const { return fMaxPt; }
+   Double_t GetLimPt() const { return fLimPt; }
+   Double_t GetMinP()  const { return fMinP;  }
+   Double_t GetMaxP()  const { return fMaxP;  }
+   Double_t GetLimP()  const { return fLimP;  }
 
    //-------------------------------------------------------------------
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackProjected.h root/graf3d/eve/inc/TEveTrackProjected.h
--- root-old/graf3d/eve/inc/TEveTrackProjected.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/TEveTrackProjected.h	2011-06-14 15:55:32.221752427 -0700
@@ -26,7 +26,6 @@
    TEveTrackProjected& operator=(const TEveTrackProjected&); // Not implemented
 
    Int_t GetBreakPointIdx(Int_t start);
-   void  GetBreakPoint(Int_t N, Bool_t back, Float_t& x, Float_t& y, Float_t& z);
 
    TEveVector*          fOrigPnts;     // original track points
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveTrackPropagator.h root/graf3d/eve/inc/TEveTrackPropagator.h
--- root-old/graf3d/eve/inc/TEveTrackPropagator.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/TEveTrackPropagator.h	2011-05-19 21:25:10.000000000 -0700
@@ -38,14 +38,21 @@
 
    virtual Bool_t IsConst() const {return fFieldConstant;};
 
-   virtual void  PrintField(Float_t x, Float_t y, Float_t z) const
+   virtual void  PrintField(Double_t x, Double_t y, Double_t z) const
    {
       TEveVector b = GetField(x, y, z);
       printf("v(%f, %f, %f) B(%f, %f, %f) \n", x, y, z, b.fX, b.fY, b.fZ);
    }
 
-   virtual TEveVector GetField(const TEveVector &v) const { return GetField(v.fX, v.fY, v.fZ);}
-   virtual TEveVector GetField(Float_t x, Float_t y, Float_t z) const = 0;
+   TEveVectorD GetFieldD(const TEveVectorD &v) const { return GetFieldD(v.fX, v.fY, v.fZ); }
+
+   // Track propgator uses only GetFieldD() and GetMaxFieldMagD(). Have to keep/reuse
+   // GetField() and GetMaxFieldMag() because of backward compatibility.
+
+   virtual TEveVectorD GetFieldD(Double_t x, Double_t y, Double_t z) const { return GetField(x, y, z); }
+   virtual Double_t GetMaxFieldMagD() const { return GetMaxFieldMag(); } // not abstract because of backward compatibility
+
+   virtual TEveVector GetField(Float_t, Float_t, Float_t) const { return TEveVector(); }
    virtual Float_t GetMaxFieldMag() const { return 4; } // not abstract because of backward compatibility
 
    ClassDef(TEveMagField, 0); // Abstract interface to magnetic field
@@ -59,16 +66,16 @@
 class TEveMagFieldConst : public TEveMagField
 {
 protected:
-   TEveVector fB;
+   TEveVectorD fB;
 
 public:
-   TEveMagFieldConst(Float_t x, Float_t y, Float_t z) : TEveMagField(), fB(x, y, z)
+   TEveMagFieldConst(Double_t x, Double_t y, Double_t z) : TEveMagField(), fB(x, y, z)
    { fFieldConstant = kTRUE; }
    virtual ~TEveMagFieldConst() {}
 
    using   TEveMagField::GetField;
-   virtual TEveVector GetField(Float_t /*x*/, Float_t /*y*/, Float_t /*z*/) const { return fB; }
-   virtual Float_t GetMaxFieldMag() const { return fB.Mag(); };
+   virtual TEveVectorD GetFieldD(Double_t /*x*/, Double_t /*y*/, Double_t /*z*/) const { return fB; }
+   virtual Double_t GetMaxFieldMagD() const { return fB.Mag(); };
 
    ClassDef(TEveMagFieldConst, 0); // Interface to constant magnetic field.
 };
@@ -81,12 +88,12 @@
 class TEveMagFieldDuo : public TEveMagField
 {
 protected:
-   TEveVector fBIn;
-   TEveVector fBOut;
-   Float_t    fR2;
+   TEveVectorD fBIn;
+   TEveVectorD fBOut;
+   Double_t    fR2;
 
 public:
-   TEveMagFieldDuo(Float_t r, Float_t bIn, Float_t bOut) : TEveMagField(),
+   TEveMagFieldDuo(Double_t r, Double_t bIn, Double_t bOut) : TEveMagField(),
      fBIn(0,0,bIn), fBOut(0,0,bOut), fR2(r*r)
    {
       fFieldConstant = kFALSE;
@@ -94,10 +101,11 @@
    virtual ~TEveMagFieldDuo() {}
 
    using   TEveMagField::GetField;
-   virtual TEveVector GetField(Float_t x, Float_t y, Float_t /*z*/) const
+   virtual TEveVectorD GetFieldD(Double_t x, Double_t y, Double_t /*z*/) const
    { return  ((x*x+y*y)<fR2) ? fBIn : fBOut; }
-   virtual Float_t GetMaxFieldMag() const
-   { Float_t b1 = fBIn.Mag(), b2 = fBOut.Mag(); return b1 > b2 ? b1 : b2; }
+
+   virtual Double_t GetMaxFieldMagD() const
+   { Double_t b1 = fBIn.Mag(), b2 = fBOut.Mag(); return b1 > b2 ? b1 : b2; }
 
    ClassDef(TEveMagFieldDuo, 0); // Interface to magnetic field with two different values depending of radius.
 };
@@ -113,52 +121,54 @@
    friend class TEveTrackPropagatorSubEditor;
 
 public:
+   enum EStepper_e    { kHelix, kRungeKutta };
+
+   enum EProjTrackBreaking_e { kPTB_Break, kPTB_UseFirstPointPos, kPTB_UseLastPointPos };
+
+protected:
    struct Helix_t
    {
-      Int_t   fCharge;   // Charge of tracked particle.
-      Float_t fMaxAng;   // Maximum step angle.
-      Float_t fMaxStep;  // Maximum allowed step size.
-      Float_t fDelta;    // Maximum error in the middle of the step.
+      Int_t    fCharge;   // Charge of tracked particle.
+      Double_t fMaxAng;   // Maximum step angle.
+      Double_t fMaxStep;  // Maximum allowed step size.
+      Double_t fDelta;    // Maximum error in the middle of the step.
 
-      Float_t fPhi;      // Accumulated angle to check fMaxOrbs by propagator.
-      Bool_t  fValid;    // Corner case pT~0 or B~0, possible in variable mag field.
+      Double_t fPhi;      // Accumulated angle to check fMaxOrbs by propagator.
+      Bool_t   fValid;    // Corner case pT~0 or B~0, possible in variable mag field.
 
       // ----------------------------------------------------------------
 
       // helix parameters
-      Float_t fLam;         // Momentum ratio pT/pZ.
-      Float_t fR;           // Helix radius in cm.
-      Float_t fPhiStep;     // Caluclated from fMinAng and fDelta.
-      Float_t fSin, fCos;   // Current sin/cos(phistep).
+      Double_t fLam;         // Momentum ratio pT/pZ.
+      Double_t fR;           // Helix radius in cm.
+      Double_t fPhiStep;     // Caluclated from fMinAng and fDelta.
+      Double_t fSin, fCos;   // Current sin/cos(phistep).
 
       // Runge-Kutta parameters
-      Float_t fRKStep;      // Step for Runge-Kutta.
+      Double_t fRKStep;      // Step for Runge-Kutta.
 
       // cached
-      TEveVector fB;        // Current magnetic field, cached.
-      TEveVector fE1, fE2, fE3; // Base vectors: E1 -> B dir, E2->pT dir, E3 = E1xE2.
-      TEveVector fPt, fPl;  // Transverse and longitudinal momentum.
-      Float_t fPtMag;       // Magnitude of pT.
-      Float_t fPlMag;       // Momentum parallel to mag field.
-      Float_t fLStep;       // Transverse step arc-length in cm.
+      TEveVectorD fB;        // Current magnetic field, cached.
+      TEveVectorD fE1, fE2, fE3; // Base vectors: E1 -> B dir, E2->pT dir, E3 = E1xE2.
+      TEveVectorD fPt, fPl;  // Transverse and longitudinal momentum.
+      Double_t fPtMag;       // Magnitude of pT.
+      Double_t fPlMag;       // Momentum parallel to mag field.
+      Double_t fLStep;       // Transverse step arc-length in cm.
 
       // ----------------------------------------------------------------
 
       Helix_t();
 
-      void UpdateCommon(const TEveVector & p, const TEveVector& b);
-      void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t full_update, Bool_t enforce_max_step);
-      void UpdateRK   (const TEveVector & p, const TEveVector& b);
+      void UpdateCommon(const TEveVectorD & p, const TEveVectorD& b);
+      void UpdateHelix (const TEveVectorD & p, const TEveVectorD& b, Bool_t full_update, Bool_t enforce_max_step);
+      void UpdateRK    (const TEveVectorD & p, const TEveVectorD& b);
 
-      void Step(const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut);
+      void Step(const TEveVector4D& v, const TEveVectorD& p, TEveVector4D& vOut, TEveVectorD& pOut);
 
-      Float_t GetStep()  { return fLStep * TMath::Sqrt(1 + fLam*fLam); }
-      Float_t GetStep2() { return fLStep * fLStep * (1 + fLam*fLam);   }
+      Double_t GetStep()  { return fLStep * TMath::Sqrt(1 + fLam*fLam); }
+      Double_t GetStep2() { return fLStep * fLStep * (1 + fLam*fLam);   }
    };
 
-   enum EStepper_e    { kHelix, kRungeKutta };
-
-   enum EProjTrackBreaking_e { kPTB_Break, kPTB_UseFirstPointPos, kPTB_UseLastPointPos };
 
 private:
    TEveTrackPropagator(const TEveTrackPropagator&);            // Not implemented
@@ -171,11 +181,11 @@
    Bool_t                   fOwnMagFiledObj;
 
    // Track extrapolation limits
-   Float_t                  fMaxR;          // Max radius for track extrapolation
-   Float_t                  fMaxZ;          // Max z-coordinate for track extrapolation.
-   Int_t                    fNMax;          // Max steps
+   Double_t                  fMaxR;          // Max radius for track extrapolation
+   Double_t                  fMaxZ;          // Max z-coordinate for track extrapolation.
+   Int_t                     fNMax;          // Max steps
    // Helix limits
-   Float_t                  fMaxOrbs;       // Maximal angular path of tracks' orbits (1 ~ 2Pi).
+   Double_t                  fMaxOrbs;       // Maximal angular path of tracks' orbits (1 ~ 2Pi).
 
    // Path-mark / first-vertex control
    Bool_t                   fEditPathMarks; // Show widgets for path-mark control in GUI editor.
@@ -199,28 +209,28 @@
    // ----------------------------------------------------------------
 
    // Propagation, state of current track
-   std::vector<TEveVector4> fPoints;        // Calculated point.
-   TEveVector               fV;             // Start vertex.
-   Helix_t                  fH;             // Helix.
+   std::vector<TEveVector4D> fPoints;        // Calculated point.
+   TEveVectorD               fV;             // Start vertex.
+   Helix_t                   fH;             // Helix.
 
    void    RebuildTracks();
-   void    Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update=kFALSE, Bool_t enforce_max_step=kFALSE);
-   void    Step(const TEveVector4 &v, const TEveVector &p, TEveVector4 &vOut, TEveVector &pOut);
+   void    Update(const TEveVector4D& v, const TEveVectorD& p, Bool_t full_update=kFALSE, Bool_t enforce_max_step=kFALSE);
+   void    Step(const TEveVector4D &v, const TEveVectorD &p, TEveVector4D &vOut, TEveVectorD &pOut);
 
-   Bool_t  LoopToVertex(TEveVector& v, TEveVector& p);
-   void    LoopToBounds(TEveVector& p);
+   Bool_t  LoopToVertex(TEveVectorD& v, TEveVectorD& p);
+   void    LoopToBounds(TEveVectorD& p);
 
-   Bool_t  LineToVertex (TEveVector& v);
-   void    LineToBounds (TEveVector& p);
+   Bool_t  LineToVertex (TEveVectorD& v);
+   void    LineToBounds (TEveVectorD& p);
 
    void    StepRungeKutta(Double_t step, Double_t* vect, Double_t* vout);
 
-   Bool_t  HelixIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal,
-                               TEveVector& itsect);
-   Bool_t  LineIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal,
-                              TEveVector& itsect);
+   Bool_t  HelixIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal,
+                               TEveVectorD&itsect);
+   Bool_t  LineIntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal,
+                              TEveVectorD& itsect);
 
-   Bool_t PointOverVertex(const TEveVector4& v0, const TEveVector4& v, Float_t* p=0);
+   Bool_t PointOverVertex(const TEveVector4D& v0, const TEveVector4D& v, Double_t* p=0);
 
 public:
    TEveTrackPropagator(const char* n="TEveTrackPropagator", const char* t="",
@@ -234,29 +244,34 @@
    virtual void ElementChanged(Bool_t update_scenes=kTRUE, Bool_t redraw=kFALSE);
 
    // propagation
-   void   InitTrack(TEveVector& v, Int_t charge);
+   void   InitTrack(const TEveVectorD& v, Int_t charge);
    void   ResetTrack();
-   void   GoToBounds(TEveVector& p);
-   Bool_t GoToVertex(TEveVector& v, TEveVector& p);
+   void   GoToBounds(TEveVectorD& p);
+   Bool_t GoToVertex(TEveVectorD& v, TEveVectorD& p);
+
+   // TEveVectorF wrappers
+   void   InitTrack(const TEveVectorF& v, Int_t charge);
+   void   GoToBounds(TEveVectorF& p);
+   Bool_t GoToVertex(TEveVectorF& v, TEveVectorF&p);
 
-   Bool_t IntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal,
-                         TEveVector& itsect);
+   Bool_t IntersectPlane(const TEveVectorD& p, const TEveVectorD& point, const TEveVectorD& normal,
+                         TEveVectorD& itsect);
 
    void   FillPointSet(TEvePointSet* ps) const;
 
    void   SetStepper(EStepper_e s) { fStepper = s; }
 
-   void   SetMagField(Float_t bX, Float_t bY, Float_t bZ);
-   void   SetMagField(Float_t b) { SetMagField(0.f, 0.f, b); }
+   void   SetMagField(Double_t bX, Double_t bY, Double_t bZ);
+   void   SetMagField(Double_t b) { SetMagField(0, 0, b); }
    void   SetMagFieldObj(TEveMagField* field, Bool_t own_field=kTRUE);
 
-   void   SetMaxR(Float_t x);
-   void   SetMaxZ(Float_t x);
-   void   SetMaxOrbs(Float_t x);
-   void   SetMinAng(Float_t x);
-   void   SetMaxAng(Float_t x);
-   void   SetMaxStep(Float_t x);
-   void   SetDelta(Float_t x);
+   void   SetMaxR(Double_t x);
+   void   SetMaxZ(Double_t x);
+   void   SetMaxOrbs(Double_t x);
+   void   SetMinAng(Double_t x);
+   void   SetMaxAng(Double_t x);
+   void   SetMaxStep(Double_t x);
+   void   SetDelta(Double_t x);
 
    void   SetEditPathMarks(Bool_t x) { fEditPathMarks = x; }
    void   SetRnrDaughters(Bool_t x);
@@ -271,18 +286,18 @@
    void   SetProjTrackBreaking(UChar_t x);
    void   SetRnrPTBMarkers(Bool_t x);
 
-   TEveVector GetMagField(Float_t x, Float_t y, Float_t z) { return fMagFieldObj->GetField(x, y, z); }
-   void PrintMagField(Float_t x, Float_t y, Float_t z) const;
+   TEveVectorD GetMagField(Double_t x, Double_t y, Double_t z) { return fMagFieldObj->GetField(x, y, z); }
+   void PrintMagField(Double_t x, Double_t y, Double_t z) const;
 
    EStepper_e   GetStepper()  const { return fStepper;}
 
-   Float_t GetMaxR()     const { return fMaxR;     }
-   Float_t GetMaxZ()     const { return fMaxZ;     }
-   Float_t GetMaxOrbs()  const { return fMaxOrbs;  }
-   Float_t GetMinAng()   const;
-   Float_t GetMaxAng()   const { return fH.fMaxAng;   }
-   Float_t GetMaxStep()  const { return fH.fMaxStep;  }
-   Float_t GetDelta()    const { return fH.fDelta;    }
+   Double_t GetMaxR()     const { return fMaxR;     }
+   Double_t GetMaxZ()     const { return fMaxZ;     }
+   Double_t GetMaxOrbs()  const { return fMaxOrbs;  }
+   Double_t GetMinAng()   const;
+   Double_t GetMaxAng()   const { return fH.fMaxAng;   }
+   Double_t GetMaxStep()  const { return fH.fMaxStep;  }
+   Double_t GetDelta()    const { return fH.fDelta;    }
 
    Bool_t  GetEditPathMarks() const { return fEditPathMarks; }
    Bool_t  GetRnrDaughters()  const { return fRnrDaughters;  }
@@ -302,22 +317,22 @@
    TMarker& RefPTBAtt() { return fPTBAtt; }
    
 
-   static Bool_t IsOutsideBounds(const TEveVector& point, Float_t maxRsqr, Float_t maxZ);
+   static Bool_t IsOutsideBounds(const TEveVectorD& point, Double_t maxRsqr, Double_t maxZ);
 
-   static Float_t             fgDefMagField; // Default value for constant solenoid magnetic field.
-   static const Float_t       fgkB2C;        // Constant for conversion of momentum to curvature.
-   static TEveTrackPropagator fgDefault;     // Default track propagator.
+   static Double_t             fgDefMagField; // Default value for constant solenoid magnetic field.
+   static const Double_t       fgkB2C;        // Constant for conversion of momentum to curvature.
+   static TEveTrackPropagator  fgDefault;     // Default track propagator.
 
-   static Float_t             fgEditorMaxR;  // Max R that can be set in GUI editor.
-   static Float_t             fgEditorMaxZ;  // Max Z that can be set in GUI editor.
+   static Double_t             fgEditorMaxR;  // Max R that can be set in GUI editor.
+   static Double_t             fgEditorMaxZ;  // Max Z that can be set in GUI editor.
 
    ClassDef(TEveTrackPropagator, 0); // Calculates path of a particle taking into account special path-marks and imposed boundaries.
 };
 
 //______________________________________________________________________________
-inline Bool_t TEveTrackPropagator::IsOutsideBounds(const TEveVector& point,
-                                                   Float_t           maxRsqr,
-                                                   Float_t           maxZ)
+inline Bool_t TEveTrackPropagator::IsOutsideBounds(const TEveVectorD& point,
+                                                   Double_t           maxRsqr,
+                                                   Double_t           maxZ)
 {
    // Return true if point% is outside of cylindrical bounds detrmined by
    // square radius and z.
@@ -327,15 +342,15 @@
 }
 
 //______________________________________________________________________________
-inline Bool_t TEveTrackPropagator::PointOverVertex(const TEveVector4 &v0,
-                                                   const TEveVector4 &v,
-                                                   Float_t           *p)
+inline Bool_t TEveTrackPropagator::PointOverVertex(const TEveVector4D &v0,
+                                                   const TEveVector4D &v,
+                                                   Double_t           *p)
 {
-   static const Float_t kMinPl = 1e-5;
+   static const Double_t kMinPl = 1e-5;
 
-   TEveVector dv; dv.Sub(v0, v);
+   TEveVectorD dv; dv.Sub(v0, v);
 
-   Float_t dotV;
+   Double_t dotV;
 
    if (TMath::Abs(fH.fPlMag) > kMinPl)
    {
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/inc/TEveVSDStructs.h root/graf3d/eve/inc/TEveVSDStructs.h
--- root-old/graf3d/eve/inc/TEveVSDStructs.h	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/eve/inc/TEveVSDStructs.h	2011-04-04 08:03:06.000000000 -0700
@@ -125,28 +125,31 @@
 /******************************************************************************/
 // TEveRecTrack
 /******************************************************************************/
-
-class TEveRecTrack : public TObject
+template <typename TT>
+class TEveRecTrackT : public TObject
 {
 public:
-   Int_t       fLabel;       // Label of the track.
-   Int_t       fIndex;       // Index of the track (in some source array).
-   Int_t       fStatus;      // Status as exported from reconstruction.
-   Int_t       fSign;        // Charge of the track.
-   TEveVector  fV;           // Start vertex from reconstruction.
-   TEveVector  fP;           // Reconstructed momentum at start vertex.
-   Float_t     fBeta;        // Relativistic beta factor.
+   Int_t           fLabel;       // Label of the track.
+   Int_t           fIndex;       // Index of the track (in some source array).
+   Int_t           fStatus;      // Status as exported from reconstruction.
+   Int_t           fSign;        // Charge of the track.
+   TEveVectorT<TT> fV;           // Start vertex from reconstruction.
+   TEveVectorT<TT> fP;           // Reconstructed momentum at start vertex.
+   TT              fBeta;        // Relativistic beta factor.
 
    // PID data missing
 
-   TEveRecTrack() : fLabel(-1), fIndex(-1), fStatus(0), fSign(0), fV(), fP(), fBeta(0) {}
-   virtual ~TEveRecTrack() {}
+   TEveRecTrackT() : fLabel(-1), fIndex(-1), fStatus(0), fSign(0), fV(), fP(), fBeta(0) {}
+   virtual ~TEveRecTrackT() {}
 
    Float_t Pt() { return fP.Perp(); }
 
-   ClassDef(TEveRecTrack, 1); // Reconstructed track (also used in VSD).
+   ClassDef(TEveRecTrackT, 1); // Template for reconstructed track (also used in VSD).
 };
 
+typedef TEveRecTrackT<Float_t>  TEveRecTrack;
+typedef TEveRecTrackT<Float_t>  TEveRecTrackF;
+typedef TEveRecTrackT<Double_t> TEveRecTrackD;
 
 /******************************************************************************/
 // TEveRecKink
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCaloLegoGL.cxx root/graf3d/eve/src/TEveCaloLegoGL.cxx
--- root-old/graf3d/eve/src/TEveCaloLegoGL.cxx	2010-12-15 08:34:00.000000000 -0800
+++ root/graf3d/eve/src/TEveCaloLegoGL.cxx	2011-05-19 21:25:27.000000000 -0700
@@ -419,34 +419,46 @@
 {
    // Draw z-axis and z-box at the appropriate grid corner-point including
    // tick-marks and labels.
-
+   
    // set font size first depending on size of projected axis
- 
+
    TGLMatrix mm;
    GLdouble pm[16];
-   GLint    vp[4];
    glGetDoublev(GL_MODELVIEW_MATRIX, mm.Arr());
    glGetDoublev(GL_PROJECTION_MATRIX, pm);
-   glGetIntegerv(GL_VIEWPORT, vp);
-
+   Int_t* vp = rnrCtx.RefCamera().RefViewport().CArr();
    GLdouble dn[3];
    GLdouble up[3];
-   gluProject(fZAxisTitlePos.fX, fZAxisTitlePos.fY, 0                , mm.Arr(), pm, vp, &dn[0], &dn[1], &dn[2]);
-   gluProject(fZAxisTitlePos.fX, fZAxisTitlePos.fY, fZAxisTitlePos.fZ, mm.Arr(), pm, vp, &up[0], &up[1], &up[2]);
-   Double_t len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0])
+   gluProject(fXAxisTitlePos.fX, fXAxisTitlePos.fY, fXAxisTitlePos.fZ, mm.Arr(), pm, vp, &up[0], &up[1], &up[2]);
+   gluProject(fYAxisTitlePos.fX, fYAxisTitlePos.fY, fYAxisTitlePos.fZ, mm.Arr(), pm, vp, &dn[0], &dn[1], &dn[2]);
+   Float_t len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0])
                               + (up[1] - dn[1]) * (up[1] - dn[1])
                               + (up[2] - dn[2]) * (up[2] - dn[2]));
+   len = TMath::Min(len, rnrCtx.RefCamera().RefViewport().Diagonal()*0.7f);
+   len /= TMath::Sqrt2();
 
    TGLVertex3 worldRef(fZAxisTitlePos.fX, fZAxisTitlePos.fY, fZAxisTitlePos.fZ);
-
    fAxisPainter.RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -len, 0,  &mm);
-   fAxisPainter.SetLabelPixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
-   fAxisPainter.SetTitlePixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
+   fAxisPainter.SetLabelPixelFontSize(TMath::Nint(TMath::Max(len*fM->GetData()->GetEtaBins()->GetLabelSize(), 0.02f)));
+   fAxisPainter.SetTitlePixelFontSize(TMath::Nint(TMath::Max(len*fM->GetData()->GetEtaBins()->GetLabelSize(), 0.02f)));
 
+   Float_t tickLength = TMath::Max(fM->GetData()->GetEtaBins()->GetTickLength(), 0.02f);
+   Float_t labelOffset = TMath::Max(fM->GetData()->GetEtaBins()->GetLabelOffset(), 0.02f);
+   
    // Z axis
    //
    if (fM->fData->Empty() == kFALSE)
    {
+      Int_t    ondiv;
+      Double_t omin=0, omax=0, bw1;
+      THLimitsFinder::Optimize(0, fMaxVal, fM->fNZSteps, omin, omax, ondiv, bw1);
+      worldRef.Set(fZAxisTitlePos.fX, fZAxisTitlePos.fY, fZAxisTitlePos.fZ);
+      TGLVector3 zto = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, 0, fAxisPainter.GetLabelPixelFontSize(),  &mm);                  
+      // check z axis title does not overalp with label
+      if ( fZAxisTitlePos.fZ - omax <   fAxisPainter.GetLabelPixelFontSize())
+         fZAxisTitlePos.fZ = omax + zto.Z();
+
+      
       fZAxis->SetAxisColor(fGridColor);
       fZAxis->SetLabelColor(fFontColor);
       fZAxis->SetTitleColor(fFontColor);
@@ -462,10 +474,9 @@
 
       // tickmark vector = 10 pixels left
       fAxisPainter.RefTitlePos().Set(fAxisPainter.RefTMOff(0).X()*0.05,  fAxisPainter.RefTMOff(0).Y()*0.05, fZAxisTitlePos.fZ);
-      fZAxis->SetLabelOffset(0.05);
-      fZAxis->SetTickLength(0.05);
+      fZAxis->SetLabelOffset(labelOffset);
+      fZAxis->SetTickLength(tickLength);
       fAxisPainter.PaintAxis(rnrCtx, fZAxis);
-      glTranslated( fAxisPainter.RefTMOff(0).X(),  fAxisPainter.RefTMOff(0).Y(),  fAxisPainter.RefTMOff(0).Z());
       glPopMatrix();
 
       // draw box frame
@@ -500,10 +511,6 @@
 
          // box horizontals stippled
          glEnable(GL_LINE_STIPPLE);
-         Int_t ondiv;
-         Double_t omin, omax, bw1;
-         THLimitsFinder::Optimize(0, fMaxVal, fM->fNZSteps, omin, omax, ondiv, bw1);
-
          glLineStipple(1, 0x5555);
          glBegin(GL_LINES);
          Float_t hz  = bw1;
@@ -533,8 +540,8 @@
    ax.SetLabelColor(fFontColor);
    ax.SetTitleColor(fFontColor);
    ax.SetTitleFont(fM->GetData()->GetEtaBins()->GetTitleFont());
-   ax.SetLabelOffset(0.02);
-   ax.SetTickLength(0.05);
+   ax.SetLabelOffset(labelOffset);
+   ax.SetTickLength(tickLength);
    fAxisPainter.SetTMNDim(2);
    fAxisPainter.RefTMOff(1).Set(0, 0, -fMaxVal);
    fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
@@ -544,7 +551,8 @@
    fAxisPainter.RefDir().Set(1, 0, 0);
    fAxisPainter.RefTMOff(0).Set(0, yOff, 0);
    glTranslatef(0, fXAxisTitlePos.fY, 0);
-   ax.SetNdivisions(710);
+   
+   ax.SetNdivisions(fM->GetData()->GetEtaBins()->GetNdivisions());
    ax.SetLimits(fM->GetEtaMin(), fM->GetEtaMax());
    ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(fXAxisTitlePos.fX, yOff*1.5*ax.GetTickLength(), -fMaxVal*ax.GetTickLength());
@@ -554,7 +562,7 @@
    // phi
    fAxisPainter.RefDir().Set(0, 1, 0);
    fAxisPainter.RefTMOff(0).Set(xOff, 0, 0);
-   ax.SetNdivisions(510);
+   ax.SetNdivisions(fM->GetData()->GetPhiBins()->GetNdivisions());
    ax.SetLimits(fM->GetPhiMin(), fM->GetPhiMax());
    ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());
    glPushMatrix();
@@ -601,8 +609,9 @@
    ax.SetLabelColor(fFontColor);
    ax.SetTitleColor(fFontColor);
    ax.SetTitleFont(fM->GetData()->GetEtaBins()->GetTitleFont());
-   ax.SetLabelOffset(0.01);
-   ax.SetTickLength(0.05);
+   ax.SetTitleSize(TMath::Max(fM->GetData()->GetEtaBins()->GetTitleSize(), 0.02f));
+   ax.SetLabelOffset(TMath::Max(fM->GetData()->GetEtaBins()->GetLabelOffset(), 0.02f));
+   ax.SetTickLength(TMath::Max(fM->GetData()->GetEtaBins()->GetTickLength(), 0.05f));
 
    // set fonts
    fAxisPainter.SetAttAxis(&ax);
@@ -630,7 +639,7 @@
    // eta
    fAxisPainter.SetLabelPixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
    fAxisPainter.SetTitlePixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
-   ax.SetNdivisions(710);
+   ax.SetNdivisions(fM->GetData()->GetEtaBins()->GetNdivisions());
    ax.SetLimits(fM->GetEtaMin(), fM->GetEtaMax());
    ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(fM->GetEtaMax(), -fM->GetPhiRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), 0 );
@@ -646,7 +655,7 @@
    glPopMatrix();
 
    // phi
-   ax.SetNdivisions(510);
+   ax.SetNdivisions(fM->GetData()->GetPhiBins()->GetNdivisions());
    ax.SetLimits(fM->GetPhiMin(), fM->GetPhiMax());
    ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(-fM->GetEtaRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), fM->GetPhiMax(), 0);
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveCaloLegoOverlay.cxx root/graf3d/eve/src/TEveCaloLegoOverlay.cxx
--- root-old/graf3d/eve/src/TEveCaloLegoOverlay.cxx	2010-10-27 07:37:10.000000000 -0700
+++ root/graf3d/eve/src/TEveCaloLegoOverlay.cxx	2011-05-19 21:25:27.000000000 -0700
@@ -530,9 +530,9 @@
 
    TGLRect& vp = rnrCtx.RefCamera().RefViewport();
    Double_t maxVal = fCalo->GetMaxVal();
-   Int_t    bn;
-   Double_t bw; // bin with first second order
-   Double_t bl, bh; // bin low, high first
+   Int_t    bn = 0;
+   Double_t bw = 0;         // bin with first second order
+   Double_t bl = 0, bh = 0; // bin low, high first
    THLimitsFinder::Optimize(0, maxVal, 10, bl, bh, bn, bw);
    bn = TMath::CeilNint(maxVal/bw) + 1;
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveManager.cxx root/graf3d/eve/src/TEveManager.cxx
--- root-old/graf3d/eve/src/TEveManager.cxx	2010-10-27 07:37:10.000000000 -0700
+++ root/graf3d/eve/src/TEveManager.cxx	2011-05-19 21:25:27.000000000 -0700
@@ -667,18 +667,20 @@
          model->SetRnrChildren(kFALSE);
 
          TEveElement* old_model = dynamic_cast<TEveElement*>(pair->Value());
-         while (old_model->HasChildren())
+         if (old_model)
          {
-            TEveElement *el = old_model->FirstChild();
-            el->SetVizModel(model);
-            if (update)
+            while (old_model->HasChildren())
             {
-               el->CopyVizParams(model);
-               el->PropagateVizParamsToProjecteds();
+               TEveElement *el = old_model->FirstChild();
+               el->SetVizModel(model);
+               if (update)
+               {
+                  el->CopyVizParams(model);
+                  el->PropagateVizParamsToProjecteds();
+               }
             }
+            old_model->DecDenyDestroy();
          }
-         old_model->DecDenyDestroy();
-
          pair->SetValue(dynamic_cast<TObject*>(model));
          return kTRUE;
       }
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveProjectionAxesGL.cxx root/graf3d/eve/src/TEveProjectionAxesGL.cxx
--- root-old/graf3d/eve/src/TEveProjectionAxesGL.cxx	2010-10-27 07:48:32.000000000 -0700
+++ root/graf3d/eve/src/TEveProjectionAxesGL.cxx	2011-05-19 21:25:27.000000000 -0700
@@ -65,7 +65,7 @@
    TGLAxisPainter::LabVec_t &orig = fAxisPainter.RefLabVec();
    if (orig.size() == 0) return;
 
-   Float_t center = fM->GetManager()->GetCenter()[idx];
+   Float_t center = fM->GetManager()->GetProjection()->GetProjectedCenter()[idx];
 
    // Get index of label closest to the distortion center.
    // Needed to keep simetry around center.
@@ -157,12 +157,6 @@
    {
       SplitIntervalByPos(p1, p2, ax);
    }
-
-
-   FilterOverlappingLabels(0, p2 -p1);
-
-   // Minimum/maximum are defined at the front/back element of list.
-   fAxisPainter.RefTMVec().push_back(TGLAxisPainter::TM_t(p2, -1));
 }
 
 //______________________________________________________________________________
@@ -174,8 +168,8 @@
    Int_t n1a = TMath::FloorNint(fM->GetNdivisions() / 100);
    Int_t n2a = fM->GetNdivisions() - n1a * 100;
    Int_t bn1, bn2;
-   Double_t bw1, bw2; // bin with first second order
-   Double_t bl1, bh1, bl2, bh2; // bin low, high first second order
+   Double_t bw1, bw2;                   // bin with first second order
+   Double_t bl1=0, bh1=0, bl2=0, bh2=0; // bin low, high first second order
    THLimitsFinder::Optimize(p1, p2, n1a, bl1, bh1, bn1, bw1);
    THLimitsFinder::Optimize(bl1, bl1+bw1, n2a, bl2, bh2, bn2, bw2);
 
@@ -218,8 +212,6 @@
 {
    // Add tick-marks on fixed value step.
 
-   Float_t v1 = fProjection->GetValForScreenPos(ax, p1);
-   Float_t v2 = fProjection->GetValForScreenPos(ax, p2);
 
    TGLAxisPainter::LabVec_t &labVec =  fAxisPainter.RefLabVec();
    TGLAxisPainter::TMVec_t  &tmVec  =  fAxisPainter.RefTMVec();
@@ -228,13 +220,22 @@
    Int_t n1a = TMath::FloorNint(fM->GetNdivisions() / 100);
    Int_t n2a = fM->GetNdivisions() - n1a * 100;
    Int_t bn1, bn2;
-   Double_t bw1, bw2;           // bin width first / second order
-   Double_t bl1, bh1, bl2, bh2; // bin low, high first / second order
-   THLimitsFinder::Optimize(v1, v2, n1a, bl1, bh1, bn1, bw1);
+   Double_t bw1, bw2;                   // bin width first / second order
+   Double_t bl1=0, bh1=0, bl2=0, bh2=0; // bin low, high first / second order
+   Float_t v1 = fProjection->GetValForScreenPos(ax, p1);
+   Float_t v2 = fProjection->GetValForScreenPos(ax, p2);
+   THLimitsFinder::Optimize(v1,  v2,      n1a, bl1, bh1, bn1, bw1);
    THLimitsFinder::Optimize(bl1, bl1+bw1, n2a, bl2, bh2, bn2, bw2);
 
    Float_t pFirst, pSecond; // position of first, second order of tickmarks
    Float_t v = bl1;
+
+   // cache values here
+   TEveVector dirVec;
+   fProjection->SetDirectionalVector(ax, dirVec);
+   TEveVector oCenter;
+   fProjection->GetOrthogonalCenter(ax, oCenter);
+
    // step
    for (Int_t l=0; l<=bn1; l++)
    {
@@ -246,7 +247,7 @@
       // Tickmarks.
       for (Int_t k=1; k<bn2; k++)
       {
-         pSecond = fProjection->GetScreenVal(ax, v+k*bw2);
+         pSecond = fProjection->GetScreenVal(ax, v+k*bw2, dirVec, oCenter);
          if (pSecond > p2)  break;
          tmVec.push_back(TGLAxisPainter::TM_t(pSecond, 1));
       }
@@ -257,7 +258,7 @@
    v = bl1 -bw2;
    while ( v > v1)
    {
-      pSecond = fProjection->GetScreenVal(ax, v);
+      pSecond = fProjection->GetScreenVal(ax, v, dirVec, oCenter);
       if (pSecond < p1)  break;
       tmVec.push_back(TGLAxisPainter::TM_t(pSecond, 1));
       v -= bw2;
@@ -267,22 +268,34 @@
 //______________________________________________________________________________
 void TEveProjectionAxesGL::GetRange(Int_t ax, Float_t frustMin, Float_t frustMax, Float_t& min, Float_t& max) const
 {
-   // Get range from bounding box of projection manager
+   // Get range from bounding box of projection manager and furstum size.
+
+   Float_t* bb = fM->fManager->GetBBox();
+   // enlarge bbox times 2
+   Float_t bbMin = bb[ax*2];
+   Float_t bbMax = bb[ax*2 + 1];
+   Float_t off = ( bb[ax*2 + 1] - bb[ax*2]) * 0.5;
+   bbMin -= off;
+   bbMax += off;
 
 
-   // Compare frustum range with bbox and take larger.
+   // minimum
+   if (frustMin > bbMin)   {
+      min = frustMin;
+      min += (frustMax - frustMin) * 0.1;
+   }
+   else {
+      min = bbMin;
+   }
 
-   Float_t frng = (frustMax -frustMin)*0.4;
-   Float_t c = 0.5*(frustMax +frustMin);
-   min = c - frng;
-   max = c + frng;
-
-   // Check projection  limits.
-   // Set limit factor in case of divergence.
-   Float_t dLim = fProjection->GetLimit(ax, 0);
-   Float_t uLim = fProjection->GetLimit(ax, 1);
-   if (min < dLim) min = dLim*0.98;
-   if (max > uLim) max   = uLim*0.98;
+   // maximum
+   if (frustMax < bbMax) {
+      max = frustMax;
+      max -= (frustMax - frustMin) * 0.1;
+   }
+   else {
+      max = bbMax;
+   }
 }
 
 //______________________________________________________________________________
@@ -302,7 +315,7 @@
    // Actual rendering code.
    // Virtual from TGLLogicalShape.
 
-   if (rnrCtx.Selection() || rnrCtx.Highlight()) return;
+   if (rnrCtx.Selection() || rnrCtx.Highlight() || fM->fManager->GetBBox() == 0) return;
 
    glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
 
@@ -326,8 +339,8 @@
 
    if (fM->fUseColorSet)
    {
-       TGLUtil::Color(rnrCtx.ColorSet().Markup());
-       fAxisPainter.SetUseAxisColors(kFALSE);
+      TGLUtil::Color(rnrCtx.ColorSet().Markup());
+      fAxisPainter.SetUseAxisColors(kFALSE);
    }
 
    fProjection = fM->GetManager()->GetProjection();
@@ -361,14 +374,14 @@
 
    //
    // Axes.
-   {
+   try {
       using namespace TMath;
       GLint   vp[4];
       glGetIntegerv(GL_VIEWPORT, vp);
       Float_t refLength =  TMath::Sqrt((TMath::Power(vp[2]-vp[0], 2) + TMath::Power(vp[3]-vp[1], 2)));
       Float_t tickLength = TMath::Sqrt((TMath::Power(r-l, 2) + TMath::Power(t-b, 2)));
       fAxisPainter.SetFontMode(TGLFont::kPixmap);
-      fAxisPainter.SetLabelFont(rnrCtx, TGLFontManager::GetFontNameFromId(fM->GetLabelFont()),  TMath::CeilNint(refLength*0.02), tickLength*fM->GetLabelSize());
+      fAxisPainter.SetLabelFont(rnrCtx, TGLFontManager::GetFontNameFromId(fM->GetLabelFont()),  TMath::CeilNint(refLength*fM->GetLabelSize()), tickLength*fM->GetLabelSize());
 
       Float_t min, max;
       // X-axis.
@@ -378,6 +391,9 @@
          GetRange(0, l, r, min, max);
          SplitInterval(min, max, 0);
 
+         FilterOverlappingLabels(0, r-l);
+         fAxisPainter.RefTMVec().push_back(TGLAxisPainter::TM_t(max, -1));
+
          fAxisPainter.RefDir().Set(1, 0, 0);
          fAxisPainter.RefTMOff(0).Set(0, tickLength, 0);
 
@@ -388,7 +404,7 @@
          fAxisPainter.RnrLabels();
          fAxisPainter.RnrLines();
          glPopMatrix();
-
+         
          // Top.
          glPushMatrix();
          glTranslatef( 0, t, 0);
@@ -406,6 +422,9 @@
          GetRange(1, b, t, min, max);
          SplitInterval(min, max, 1);
 
+         FilterOverlappingLabels(1, t-b);
+         fAxisPainter.RefTMVec().push_back(TGLAxisPainter::TM_t(max, -1));
+
          fAxisPainter.RefDir().Set(0, 1, 0);
          fAxisPainter.RefTMOff(0).Set(tickLength, 0 , 0);
 
@@ -427,6 +446,11 @@
          glPopMatrix();
       }
    }
+   catch (TEveException& exc)
+   {
+      Warning("TEveProjectionAxesGL::DirectDraw", "caught exception: '%s'.", exc.Data());
+   }
+
    glDepthRange(old_depth_range[0], old_depth_range[1]);
 
    glPopAttrib();
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveProjections.cxx root/graf3d/eve/src/TEveProjections.cxx
--- root-old/graf3d/eve/src/TEveProjections.cxx	2010-10-27 07:37:10.000000000 -0700
+++ root/graf3d/eve/src/TEveProjections.cxx	2011-06-14 15:55:28.197752428 -0700
@@ -9,6 +9,8 @@
  * For the list of contributors see $ROOTSYS/README/CREDITS.             *
  *************************************************************************/
 
+#include "TError.h"
+
 #include "TEveProjections.h"
 #include "TEveTrans.h"
 #include "TEveUtil.h"
@@ -38,20 +40,14 @@
    fGeoMode       (kGM_Unknown),
    fName          (0),
    fCenter        (),
+   fDisplaceOrigin (kFALSE),
    fUsePreScale   (kFALSE),
    fDistortion    (0.0f),
    fFixR          (300), fFixZ          (400),
    fPastFixRFac   (0),   fPastFixZFac   (0),
    fScaleR        (1),   fScaleZ        (1),
    fPastFixRScale (1),   fPastFixZScale (1),
-   fMaxTrackStep  (5),
-   fLowLimit(-std::numeric_limits<Float_t>::infinity(),
-             -std::numeric_limits<Float_t>::infinity(),
-             -std::numeric_limits<Float_t>::infinity()),
-   fUpLimit ( std::numeric_limits<Float_t>::infinity(),
-              std::numeric_limits<Float_t>::infinity(),
-              std::numeric_limits<Float_t>::infinity())
-
+   fMaxTrackStep  (5)
 {
    // Constructor.
 }
@@ -260,20 +256,6 @@
 }
 
 //______________________________________________________________________________
-void TEveProjection::UpdateLimit()
-{
-   // Update convergence in +inf and -inf.
-
-   if (fDistortion == 0.0f)
-      return;
-
-   Float_t lim = 1.0f/fDistortion + fFixR;
-   Float_t *c  = GetProjectedCenter();
-   fUpLimit .Set( lim + c[0],  lim + c[1], c[2]);
-   fLowLimit.Set(-lim + c[0], -lim + c[1], c[2]);
-}
-
-//______________________________________________________________________________
 void TEveProjection::SetDistortion(Float_t d)
 {
    // Set distortion.
@@ -283,7 +265,6 @@
    fScaleZ        = 1.0f + fFixZ*fDistortion;
    fPastFixRScale = TMath::Power(10.0f, fPastFixRFac) / fScaleR;
    fPastFixZScale = TMath::Power(10.0f, fPastFixZFac) / fScaleZ;
-   UpdateLimit();
 }
 
 //______________________________________________________________________________
@@ -294,7 +275,6 @@
    fFixR          = r;
    fScaleR        = 1 + fFixR*fDistortion;
    fPastFixRScale = TMath::Power(10.0f, fPastFixRFac) / fScaleR;
-   UpdateLimit();
 }
 
 //______________________________________________________________________________
@@ -305,7 +285,6 @@
    fFixZ          = z;
    fScaleZ        = 1 + fFixZ*fDistortion;
    fPastFixZScale = TMath::Power(10.0f, fPastFixZFac) / fScaleZ;
-   UpdateLimit();
 }
 
 //______________________________________________________________________________
@@ -318,6 +297,32 @@
 }
 
 //______________________________________________________________________________
+Float_t* TEveProjection::GetProjectedCenter()
+{
+   // Get projected center.
+
+   static TEveVector zero;
+
+   if (fDisplaceOrigin)
+      return zero.Arr();
+   else 
+      return fCenter.Arr();
+}
+
+//______________________________________________________________________________
+void  TEveProjection::SetDisplaceOrigin(Bool_t x)
+{
+   // Set flag to displace for center.
+   // This options is useful if want to have projected center
+   // at (0, 0) position in projected coordinates and want to dismiss
+   // gap around projected center in RhoZ projection. 
+
+   fDisplaceOrigin = x;
+   // update projected center
+   SetCenter(fCenter);
+}
+
+//______________________________________________________________________________
 void TEveProjection::SetPastFixZFac(Float_t x)
 {
    // Set 2's-exponent for relative scaling beyond FixZ.
@@ -327,15 +332,37 @@
 }
 
 //______________________________________________________________________________
-void TEveProjection::BisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t eps_sqr)
+void TEveProjection::BisectBreakPoint(TEveVector& vL, TEveVector& vR, Float_t /*eps_sqr*/)
 {
    // Find break-point on both sides of the discontinuity.
-   // They still need to be projected.
+   // They still need to be projected after the call.
+   // This is an obsolete version of the method that required manual
+   // specification of precision -- this lead to (infrequent) infinite loops.
+
+   static Bool_t warnedp = kFALSE;
+
+   if (!warnedp)
+   {
+      Warning("BisectBreakPoint", "call with eps_sqr argument is obsolete - please use the new signature.");
+      warnedp = kTRUE;
+   }
+
+   BisectBreakPoint(vL, vR, kFALSE);
+}
+
+//______________________________________________________________________________
+void TEveProjection::BisectBreakPoint(TEveVector& vL, TEveVector& vR,
+                                      Bool_t project_result, Float_t depth)
+{
+   // Find break-point on both sides of the discontinuity.
+   // If project_result is true, the resulting break points will be projected
+   // with given depth value.
 
    TEveVector vM, vLP, vMP;
-   while ((vL-vR).Mag2() > eps_sqr)
+   Int_t n_loops = TMath::CeilNint(TMath::Log2(1e12 * (vL-vR).Mag2() / (0.5f*(vL+vR)).Mag2()) / 2);
+   while (--n_loops >= 0)
    {
-      vM.Mult(vL+vR, 0.5f);
+      vM.Mult(vL + vR, 0.5f);
       vLP.Set(vL); ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
       vMP.Set(vM); ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
 
@@ -343,14 +370,34 @@
       {
          vL.Set(vM);
          vR.Set(vM);
-         return;
+         break;
       }
 
       if (AcceptSegment(vLP, vMP, 0.0f))
+      {
          vL.Set(vM);
+      }
       else
+      {
          vR.Set(vM);
+      }
    }
+
+   if (project_result)
+   {
+      ProjectVector(vL, depth);
+      ProjectVector(vR, depth);
+   }
+}
+
+//______________________________________________________________________________
+Float_t TEveProjection::GetLimit(Int_t, Bool_t)
+{
+   // Method previously used by  TEveProjectionAxesGL. Now obsolete.
+
+  ::Warning("TEveProjection::GetLimits", "method is obsolete");
+
+   return 0;
 }
 
 //______________________________________________________________________________
@@ -365,41 +412,79 @@
 }
 
 //______________________________________________________________________________
-Float_t TEveProjection::GetValForScreenPos(Int_t i, Float_t sv)
+TEveVector TEveProjection::GetOrthogonalCenter(int i, TEveVector& centerOO)
+{
+   // Get center ortogonal to given axis index.
+
+   TEveVector dirVec;
+   SetDirectionalVector(i, dirVec);
+
+   TEveVector dirCenter;
+   dirCenter.Mult(dirVec, fCenter.Dot(dirVec));
+   centerOO = fCenter - dirCenter;
+
+
+   return  centerOO;
+}
+
+//______________________________________________________________________________
+Float_t TEveProjection::GetValForScreenPos(Int_t axisIdx, Float_t sv)
 {
    // Inverse projection.
 
    static const TEveException eH("TEveProjection::GetValForScreenPos ");
 
+   static const int kMaxSteps = 5000;
+   static const int kMaxVal = 10;
+
    Float_t xL, xM, xR;
    TEveVector vec;
+
    TEveVector dirVec;
-   SetDirectionalVector(i, dirVec);
-   if (fDistortion > 0.0f && ((sv > 0 && sv > fUpLimit[i]) || (sv < 0 && sv < fLowLimit[i])))
-      throw(eH + Form("screen value '%f' out of limit '%f'.", sv, sv > 0 ? fUpLimit[i] : fLowLimit[i]));
+   SetDirectionalVector(axisIdx, dirVec);
+
+   TEveVector zero;
+   if (fDisplaceOrigin) zero = fCenter;
+
+   TEveVector zeroProjected = zero;
+   ProjectVector(zeroProjected, 0.f);
 
-   TEveVector zero; ProjectVector(zero, 0);
    // search from -/+ infinity according to sign of screen value
-   if (sv > zero[i])
+   if (sv > zeroProjected[axisIdx])
    {
-      xL = 0; xR = 1000;
-      while (1)
+      xL = 0;
+      xR = kMaxVal;
+      
+      int cnt = 0;
+      while (cnt < kMaxSteps)
       {
-         vec.Mult(dirVec, xR); ProjectVector(vec, 0);
-         // printf("positive projected %f, value %f,xL, xR ( %f, %f)\n", vec[i], sv, xL, xR);
-         if (vec[i] > sv || vec[i] == sv) break;
+         vec.Mult(dirVec, xR);
+         if (fDisplaceOrigin) vec += fCenter;
+
+         ProjectVector(vec, 0);
+         if (vec[axisIdx] >= sv) break;
          xL = xR; xR *= 2;
+
+         if (++cnt >= kMaxSteps)
+            throw eH + Form("positive projected %f, value %f,xL, xR ( %f, %f)\n", vec[axisIdx], sv, xL, xR);
       }
    }
-   else if (sv < zero[i])
+   else if (sv < zeroProjected[axisIdx])
    {
-      xR = 0; xL = -1000;
-      while (1)
+      xR = 0;
+      xL = -kMaxVal;
+
+      int cnt = 0;
+      while (cnt < kMaxSteps)
       {
-         vec.Mult(dirVec, xL); ProjectVector(vec, 0);
-         // printf("negative projected %f, value %f,xL, xR ( %f, %f)\n", vec[i], sv, xL, xR);
-         if (vec[i] < sv || vec[i] == sv) break;
+         vec.Mult(dirVec, xL); 
+         if (fDisplaceOrigin) vec += fCenter;
+
+         ProjectVector(vec, 0);
+         if (vec[axisIdx] <= sv) break;
          xR = xL; xL *= 2;
+         if (++cnt >= kMaxSteps) 
+            throw eH + Form("negative projected %f, value %f,xL, xR ( %f, %f)\n", vec[axisIdx], sv, xL, xR);
       }
    }
    else
@@ -407,19 +492,41 @@
       return 0.0f;
    }
 
+   //  printf("search for value %f in rng[%f, %f] \n", sv, xL, xR);
+   int cnt = 0;
    do
    {
+      //printf("search value with bisection xL=%f, xR=%f; vec[axisIdx]=%f, sv=%f\n", xL, xR, vec[axisIdx], sv);
       xM = 0.5f * (xL + xR);
       vec.Mult(dirVec, xM);
+      if (fDisplaceOrigin) vec += fCenter;
       ProjectVector(vec, 0);
-      // printf("safr xL=%f, xR=%f; vec[i]=%f, sv=%f\n", xL, xR, vec[i], sv);
-      if (vec[i] > sv)
+      if (vec[axisIdx] > sv)
          xR = xM;
       else
          xL = xM;
-   } while (TMath::Abs(vec[i] - sv) >= fgEps);
+      if (++cnt >= kMaxSteps) 
+         throw eH + Form("can't converge %f %f, l/r %f/%f, idx=%d\n", vec[axisIdx], sv, xL, xR, axisIdx);
+
+   } while (TMath::Abs(vec[axisIdx] - sv) >= fgEps);
+
+
+   return xM; 
+}
+
+//______________________________________________________________________________
+Float_t TEveProjection::GetScreenVal(Int_t i, Float_t x, TEveVector& dirVec, TEveVector& /*oCenter*/)
+{
+   // Project point on given axis and return projected value.
+
+   TEveVector pos = dirVec*x;
 
-   return xM;
+   if (fDisplaceOrigin)
+      pos += fCenter;
+
+   ProjectVector(pos , 0.f);
+
+   return pos[i];
 }
 
 //______________________________________________________________________________
@@ -427,10 +534,11 @@
 {
    // Project point on given axis and return projected value.
 
-   TEveVector dv;
-   SetDirectionalVector(i, dv); dv = dv*x;
-   ProjectVector(dv, 0);
-   return dv[i];
+   TEveVector dirVec;
+   SetDirectionalVector(i, dirVec);
+   TEveVector oCenter;
+   // GetOrthogonalCenter(i, oCenter);
+   return GetScreenVal(i, x, dirVec, oCenter);
 }
 
 
@@ -464,6 +572,11 @@
 
    using namespace TMath;
 
+   if (fDisplaceOrigin) {
+      x -= fCenter.fX; 
+      y -= fCenter.fY;
+      z -= fCenter.fZ;
+   }
    if (proc == kPP_Plane || proc == kPP_Full)
    {
       // project
@@ -475,11 +588,14 @@
       if (fUsePreScale)
          PreScalePoint(y, x);
 
-      // move to center
-      x -= fProjectedCenter.fX;
-      y -= fProjectedCenter.fY;
 
       // distort
+
+      if (!fDisplaceOrigin) {  
+         x -= fProjectedCenter.fX;
+         y -= fProjectedCenter.fY;
+      }
+
       if (x > fFixZ)
          x =  fFixZ + fPastFixZScale*(x - fFixZ);
       else if (x < -fFixZ)
@@ -494,13 +610,15 @@
       else
          y =  y * fScaleR / (1.0f + Abs(y)*fDistortion);
 
-      // move back from center
-      x += fProjectedCenter.fX;
-      y += fProjectedCenter.fY;
+      if (!fDisplaceOrigin) {  
+         x += fProjectedCenter.fX;
+         y += fProjectedCenter.fY;
+      }
    }
    z = d;
 }
 
+
 //______________________________________________________________________________
 void TEveRhoZProjection::SetCenter(TEveVector& v)
 {
@@ -508,26 +626,17 @@
 
    fCenter = v;
 
-   Float_t r = TMath::Sqrt(v.fX*v.fX + v.fY*v.fY);
-   fProjectedCenter.fX = fCenter.fZ;
-   fProjectedCenter.fY = TMath::Sign(r, fCenter.fY);
-   fProjectedCenter.fZ = 0;
-   UpdateLimit();
-}
-
-//______________________________________________________________________________
-void TEveRhoZProjection::UpdateLimit()
-{
-   // Update convergence in +inf and -inf.
-
-   if (fDistortion == 0.0f)
-      return;
-
-   Float_t limR = 1.0f/fDistortion + fFixR;
-   Float_t limZ = 1.0f/fDistortion + fFixZ;
-   Float_t *c   = GetProjectedCenter();
-   fUpLimit .Set( limZ + c[0],  limR + c[1], c[2]);
-   fLowLimit.Set(-limZ + c[0], -limR + c[1], c[2]);
+   if (fDisplaceOrigin)
+   {
+      fProjectedCenter.Set(0.f, 0.f, 0.f);
+   }
+   else
+   {
+      Float_t r = TMath::Sqrt(v.fX*v.fX + v.fY*v.fY);
+      fProjectedCenter.fX = fCenter.fZ;
+      fProjectedCenter.fY = TMath::Sign(r, fCenter.fY);
+      fProjectedCenter.fZ = 0;
+   }
 }
 
 //______________________________________________________________________________
@@ -620,6 +729,13 @@
    // Project point.
 
    using namespace TMath;
+ 
+   if (fDisplaceOrigin)
+   {
+      x  -= fCenter.fX;
+      y  -= fCenter.fY;
+      z  -= fCenter.fZ;
+   }
 
    if (proc != kPP_Plane)
    {
@@ -633,8 +749,12 @@
          y = r*Sin(phi);
       }
 
-      x  -= fCenter.fX;
-      y  -= fCenter.fY;
+      if (!fDisplaceOrigin)
+      {
+         x  -= fCenter.fX;
+         y  -= fCenter.fY;
+      }
+
       r   = Sqrt(x*x + y*y);
       phi = (x == 0.0f && y == 0.0f) ? 0.0f : ATan2(y, x);
 
@@ -645,8 +765,14 @@
       else
          r =  r * fScaleR / (1.0f + r*fDistortion);
 
-      x = r*Cos(phi) + fCenter.fX;
-      y = r*Sin(phi) + fCenter.fY;
+      x = r*Cos(phi);
+      y = r*Sin(phi);
+
+      if (!fDisplaceOrigin)
+      {
+         x += fCenter.fX;
+         y += fCenter.fY;
+      }
    }
    z = d;
 }
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveStraightLineSet.cxx root/graf3d/eve/src/TEveStraightLineSet.cxx
--- root-old/graf3d/eve/src/TEveStraightLineSet.cxx	2010-12-15 08:33:06.000000000 -0800
+++ root/graf3d/eve/src/TEveStraightLineSet.cxx	2011-06-14 15:55:30.395752428 -0700
@@ -306,9 +306,7 @@
             trans->MultiplyIP(bp1);
             trans->MultiplyIP(bp2);
          }
-         proj.BisectBreakPoint(bp1, bp2, 1e-10f);
-         proj.ProjectVector(bp1, fDepth);
-         proj.ProjectVector(bp2, fDepth);
+         proj.BisectBreakPoint(bp1, bp2, kTRUE, fDepth);
 
          AddLine(p1, bp1)->fId = l->fId;
          AddLine(bp2, p2)->fId = l->fId;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveStraightLineSetGL.cxx root/graf3d/eve/src/TEveStraightLineSetGL.cxx
--- root-old/graf3d/eve/src/TEveStraightLineSetGL.cxx	2010-10-27 07:48:32.000000000 -0700
+++ root/graf3d/eve/src/TEveStraightLineSetGL.cxx	2011-04-04 08:03:06.000000000 -0700
@@ -88,7 +88,8 @@
 
    TEveStraightLineSet& mL = * fM;
 
-   if (mL.GetDepthTest() == kFALSE)
+   // set depth range when selection is disabled, else can't pick camera center
+   if (mL.GetDepthTest() == kFALSE && rnrCtx.Selection() == kFALSE)
    {
       glPushAttrib(GL_VIEWPORT_BIT);
       glDepthRange(0, 0.1); 
@@ -187,7 +188,7 @@
       delete [] pnts;
    }
 
-   if (mL.GetDepthTest() == kFALSE)
+   if (mL.GetDepthTest() == kFALSE && rnrCtx.Selection() == kFALSE)
       glPopAttrib();
 }
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrack.cxx root/graf3d/eve/src/TEveTrack.cxx
--- root-old/graf3d/eve/src/TEveTrack.cxx	2010-10-27 07:37:10.000000000 -0700
+++ root/graf3d/eve/src/TEveTrack.cxx	2011-04-04 08:03:06.000000000 -0700
@@ -12,7 +12,6 @@
 #include "TEveTrack.h"
 #include "TEveTrackPropagator.h"
 #include "TEvePointSet.h"
-#include "TEveVSDStructs.h"
 
 #include "TPolyLine3D.h"
 #include "TMarker.h"
@@ -129,6 +128,32 @@
 }
 
 //______________________________________________________________________________
+TEveTrack::TEveTrack(TEveRecTrackD* t, TEveTrackPropagator* prop) :
+   TEveLine(),
+
+   fV(t->fV),
+   fP(t->fP),
+   fPEnd(),
+   fBeta(t->fBeta),
+   fPdg(0),
+   fCharge(t->fSign),
+   fLabel(t->fLabel),
+   fIndex(t->fIndex),
+   fStatus(t->fStatus),
+   fLockPoints(kFALSE),
+   fPathMarks(),
+   fLastPMIdx(0),
+   fPropagator(0)
+{
+   // Constructor from TEveRecTrack<double> reconstructed track.
+
+   SetPropagator(prop);
+   fMainColorPtr = &fLineColor;
+
+   SetName(t->GetName());
+}
+
+//______________________________________________________________________________
 TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop) :
    TEveLine(),
 
@@ -146,7 +171,9 @@
    fLastPMIdx(0),
    fPropagator(0)
 {
-   // Constructor from TEveUtil reconstructed track.
+   // Constructor from TEveRecTrack<float> reconstructed track.
+   // It is recomended to use constructor with  TEveRecTrack<double> since
+   // TEveTrackPropagator operates with double type.
 
    SetPropagator(prop);
    fMainColorPtr = &fLineColor;
@@ -218,7 +245,7 @@
       }
       for (vPathMark_ci i = fPathMarks.begin(); i != fPathMarks.end(); ++i)
       {
-         BBoxCheckPoint(i->fV);
+         BBoxCheckPoint(i->fV.fX, i->fV.fY,i->fV.fZ);
       }
    }
    else
@@ -319,17 +346,17 @@
 
       TEveTrackPropagator& rTP((fPropagator != 0) ? *fPropagator : TEveTrackPropagator::fgDefault);
 
-      const Float_t maxRsq = rTP.GetMaxR() * rTP.GetMaxR();
-      const Float_t maxZ   = rTP.GetMaxZ();
+      const Double_t maxRsq = rTP.GetMaxR() * rTP.GetMaxR();
+      const Double_t maxZ   = rTP.GetMaxZ();
 
       if ( ! TEveTrackPropagator::IsOutsideBounds(fV, maxRsq, maxZ))
       {
-         TEveVector currP = fP;
+         TEveVectorD currP = fP;
          Bool_t decay = kFALSE;
          fPropagator->InitTrack(fV, fCharge);
          for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm, ++fLastPMIdx)
          {
-            if (rTP.GetFitReferences() && pm->fType == TEvePathMark::kReference)
+            if (rTP.GetFitReferences() && pm->fType == TEvePathMarkD::kReference)
             {
                if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
                   break;
@@ -342,7 +369,7 @@
                   break;
                }
             }
-            else if (rTP.GetFitDaughters() && pm->fType == TEvePathMark::kDaughter)
+            else if (rTP.GetFitDaughters() && pm->fType == TEvePathMarkD::kDaughter)
             {
                if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
                   break;
@@ -355,7 +382,7 @@
                   break;
                }
             }
-            else if (rTP.GetFitDecay() && pm->fType == TEvePathMark::kDecay)
+            else if (rTP.GetFitDecay() && pm->fType == TEvePathMarkD::kDecay)
             {
                if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
                   break;
@@ -365,13 +392,13 @@
                ++fLastPMIdx;
                break;
             }
-            else if (rTP.GetFitCluster2Ds() && pm->fType == TEvePathMark::kCluster2D)
+            else if (rTP.GetFitCluster2Ds() && pm->fType == TEvePathMarkD::kCluster2D)
             {
-               TEveVector itsect;
+               TEveVectorD itsect;
                if (fPropagator->IntersectPlane(currP, pm->fV, pm->fP, itsect))
                {
-                  TEveVector delta   = itsect - pm->fV;
-                  TEveVector vtopass = pm->fV + pm->fE*(pm->fE.Dot(delta));
+                  TEveVectorD delta   = itsect - pm->fV;
+                  TEveVectorD vtopass = pm->fV + pm->fE*(pm->fE.Dot(delta));
                   if (TEveTrackPropagator::IsOutsideBounds(vtopass, maxRsq, maxZ))
                      break;
                   if ( ! fPropagator->GoToVertex(vtopass, currP))
@@ -451,7 +478,7 @@
 {
    struct Cmp_pathmark_t
    {
-      bool operator()(TEvePathMark const & a, TEvePathMark const & b)
+      bool operator()(TEvePathMarkD const & a, TEvePathMarkD const & b)
       { return a.fTime < b.fTime; }
    };
 }
@@ -666,20 +693,23 @@
 
    fLimPt = fLimP = 0;
 
-   for (List_i i=BeginChildren(); i!=EndChildren(); ++i)
+   if (HasChildren())
    {
-      TEveTrack* track = dynamic_cast<TEveTrack*>(*i);
-      if (track)
+      for (List_i i=BeginChildren(); i!=EndChildren(); ++i)
       {
-         fLimPt = TMath::Max(fLimPt, track->fP.Perp());
-         fLimP  = TMath::Max(fLimP,  track->fP.Mag());
+         TEveTrack* track = dynamic_cast<TEveTrack*>(*i);
+         if (track)
+         {
+            fLimPt = TMath::Max(fLimPt, track->fP.Perp());
+            fLimP  = TMath::Max(fLimP,  track->fP.Mag());
+         }
+         if (recurse)
+            FindMomentumLimits(*i, recurse);
       }
-      if (recurse)
-         FindMomentumLimits(*i, recurse);
-   }
 
-   fLimPt = RoundMomentumLimit(fLimPt);
-   fLimP  = RoundMomentumLimit(fLimP);
+      fLimPt = RoundMomentumLimit(fLimPt);
+      fLimP  = RoundMomentumLimit(fLimP);
+   }
 
    SanitizeMinMaxCuts();
 }
@@ -704,12 +734,14 @@
 }
 
 //______________________________________________________________________________
-Float_t TEveTrackList::RoundMomentumLimit(Float_t x)
+Double_t TEveTrackList::RoundMomentumLimit(Double_t x)
 {
    // Round the momentum limit up to a nice value.
 
    using namespace TMath;
 
+   if (x < 1e-3) return 1e-3;
+
    Double_t fac = Power(10, 1 - Floor(Log10(x)));
    return Ceil(fac*x) / fac;
 }
@@ -1003,7 +1035,7 @@
 //==============================================================================
 
 //______________________________________________________________________________
-void TEveTrackList::SelectByPt(Float_t min_pt, Float_t max_pt)
+void TEveTrackList::SelectByPt(Double_t min_pt, Double_t max_pt)
 {
    // Select visibility of tracks by transverse momentum.
    // If data-member fRecurse is set, the selection is applied
@@ -1012,12 +1044,12 @@
    fMinPt = min_pt;
    fMaxPt = max_pt;
 
-   const Float_t minptsq = min_pt*min_pt;
-   const Float_t maxptsq = max_pt*max_pt;
+   const Double_t minptsq = min_pt*min_pt;
+   const Double_t maxptsq = max_pt*max_pt;
 
    for (List_i i=BeginChildren(); i!=EndChildren(); ++i)
    {
-      const Float_t ptsq = ((TEveTrack*)(*i))->fP.Perp2();
+      const Double_t ptsq = ((TEveTrack*)(*i))->fP.Perp2();
       Bool_t on = ptsq >= minptsq && ptsq <= maxptsq;
       (*i)->SetRnrState(on);
       if (on && fRecurse)
@@ -1026,19 +1058,19 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackList::SelectByPt(Float_t min_pt, Float_t max_pt, TEveElement* el)
+void TEveTrackList::SelectByPt(Double_t min_pt, Double_t max_pt, TEveElement* el)
 {
    // Select visibility of el's children tracks by transverse momentum.
 
-   const Float_t minptsq = min_pt*min_pt;
-   const Float_t maxptsq = max_pt*max_pt;
+   const Double_t minptsq = min_pt*min_pt;
+   const Double_t maxptsq = max_pt*max_pt;
 
    for (List_i i=el->BeginChildren(); i!=el->EndChildren(); ++i)
    {
       TEveTrack* track = dynamic_cast<TEveTrack*>(*i);
       if (track)
       {
-         const Float_t ptsq = track->fP.Perp2();
+         const Double_t ptsq = track->fP.Perp2();
          Bool_t on = ptsq >= minptsq && ptsq <= maxptsq;
          track->SetRnrState(on);
          if (on && fRecurse)
@@ -1047,8 +1079,8 @@
    }
 }
 
-//______________________________________________________________________________
-void TEveTrackList::SelectByP(Float_t min_p, Float_t max_p)
+//_________ ___________________________________________________________________
+void TEveTrackList::SelectByP(Double_t min_p, Double_t max_p)
 {
    // Select visibility of tracks by momentum.
    // If data-member fRecurse is set, the selection is applied
@@ -1057,12 +1089,12 @@
    fMinP = min_p;
    fMaxP = max_p;
 
-   const Float_t minpsq = min_p*min_p;
-   const Float_t maxpsq = max_p*max_p;
+   const Double_t minpsq = min_p*min_p;
+   const Double_t maxpsq = max_p*max_p;
 
    for (List_i i=BeginChildren(); i!=EndChildren(); ++i)
    {
-      const Float_t psq  = ((TEveTrack*)(*i))->fP.Mag2();
+      const Double_t psq  = ((TEveTrack*)(*i))->fP.Mag2();
       Bool_t on = psq >= minpsq && psq <= maxpsq;
       (*i)->SetRnrState(psq >= minpsq && psq <= maxpsq);
       if (on && fRecurse)
@@ -1071,19 +1103,19 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackList::SelectByP(Float_t min_p, Float_t max_p, TEveElement* el)
+void TEveTrackList::SelectByP(Double_t min_p, Double_t max_p, TEveElement* el)
 {
    // Select visibility of el's children tracks by momentum.
 
-   const Float_t minpsq = min_p*min_p;
-   const Float_t maxpsq = max_p*max_p;
+   const Double_t minpsq = min_p*min_p;
+   const Double_t maxpsq = max_p*max_p;
 
    for (List_i i=el->BeginChildren(); i!=el->EndChildren(); ++i)
    {
       TEveTrack* track = dynamic_cast<TEveTrack*>(*i);
       if (track)
       {
-         const Float_t psq  = ((TEveTrack*)(*i))->fP.Mag2();
+         const Double_t psq  = ((TEveTrack*)(*i))->fP.Mag2();
          Bool_t on = psq >= minpsq && psq <= maxpsq;
          track->SetRnrState(on);
          if (on && fRecurse)
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackGL.cxx root/graf3d/eve/src/TEveTrackGL.cxx
--- root-old/graf3d/eve/src/TEveTrackGL.cxx	2010-10-27 07:48:32.000000000 -0700
+++ root/graf3d/eve/src/TEveTrackGL.cxx	2011-04-04 08:03:06.000000000 -0700
@@ -91,11 +91,11 @@
       Int_t    n    = 0;
       for (Int_t i = 0; i < fTrack->fLastPMIdx; ++i)
       {
-         const TEvePathMark &pm = pms[i];
-         if ((pm.fType == TEvePathMark::kDaughter  && rTP.GetRnrDaughters())  ||
-             (pm.fType == TEvePathMark::kReference && rTP.GetRnrReferences()) ||
-             (pm.fType == TEvePathMark::kDecay     && rTP.GetRnrDecay())      ||
-             (pm.fType == TEvePathMark::kCluster2D && rTP.GetRnrCluster2Ds()))
+         const TEvePathMarkD &pm = pms[i];
+         if ((pm.fType == TEvePathMarkD::kDaughter  && rTP.GetRnrDaughters())  ||
+             (pm.fType == TEvePathMarkD::kReference && rTP.GetRnrReferences()) ||
+             (pm.fType == TEvePathMarkD::kDecay     && rTP.GetRnrDecay())      ||
+             (pm.fType == TEvePathMarkD::kCluster2D && rTP.GetRnrCluster2Ds()))
          {
             pnts[n  ] = pm.fV.fX;
             pnts[n+1] = pm.fV.fY;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackProjected.cxx root/graf3d/eve/src/TEveTrackProjected.cxx
--- root-old/graf3d/eve/src/TEveTrackProjected.cxx	2010-10-27 07:37:10.000000000 -0700
+++ root/graf3d/eve/src/TEveTrackProjected.cxx	2011-06-14 15:55:29.293752426 -0700
@@ -79,40 +79,6 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackProjected::GetBreakPoint(Int_t idx, Bool_t back,
-                                       Float_t& x, Float_t& y, Float_t& z)
-{
-   // With bisection calculate break-point vertex.
-
-   TEveProjection *projection = fManager->GetProjection();
-
-   TEveVector vL = fOrigPnts[idx];
-   TEveVector vR = fOrigPnts[idx+1];
-   TEveVector vM, vLP, vMP;
-   while ((vL-vR).Mag2() > 1e-10f)
-   {
-      vM.Mult(vL+vR, 0.5f);
-      vLP.Set(vL); projection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
-      vMP.Set(vM); projection->ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
-      if (projection->AcceptSegment(vLP, vMP, 0.0f))
-      {
-         vL.Set(vM);
-      }
-      else
-      {
-         vR.Set(vM);
-      }
-   }
-
-   if (back) {
-      x = vL.fX; y = vL.fY; z = vL.fZ;
-   } else {
-      x = vR.fX; y = vR.fY; z = vR.fZ;
-   }
-   projection->ProjectPoint(x, y, z, fDepth);
-}
-
-//______________________________________________________________________________
 Int_t TEveTrackProjected::GetBreakPointIdx(Int_t start)
 {
    // Findex index of the last point that lies within the same
@@ -124,20 +90,23 @@
 
    Int_t val = fLastPoint;
 
-   TEveVector v1, v2;
-   if (Size() > 1)
+   if (projection->HasSeveralSubSpaces())
    {
-      Int_t i = start;
-      while(i < fLastPoint)
+      TEveVector v1, v2;
+      if (Size() > 1)
       {
-         GetPoint(i,   v1.fX, v1.fY, v1.fZ);
-         GetPoint(i+1, v2.fX, v2.fY, v2.fZ);
-         if(projection->AcceptSegment(v1, v2, fPropagator->GetDelta()) == kFALSE)
+         Int_t i = start;
+         while(i < fLastPoint)
          {
-            val = i;
-            break;
+            GetPoint(i,   v1.fX, v1.fY, v1.fZ);
+            GetPoint(i+1, v2.fX, v2.fY, v2.fZ);
+            if(projection->AcceptSegment(v1, v2, fPropagator->GetDelta()) == kFALSE)
+            {
+               val = i;
+               break;
+            }
+            i++;
          }
-         i++;
       }
    }
    return val;
@@ -197,9 +166,12 @@
       if (bR == fLastPoint)
          break;
 
-      GetBreakPoint(bR, kTRUE,  x, y, z); vvec.push_back(TEveVector(x, y, z));
+      TEveVector vL = fOrigPnts[bR];
+      TEveVector vR = fOrigPnts[bR + 1];
+      projection->BisectBreakPoint(vL, vR, kTRUE, fDepth);
+      vvec.push_back(vL);
       fBreakPoints.push_back((Int_t)vvec.size());
-      GetBreakPoint(bR, kFALSE, x, y, z); vvec.push_back(TEveVector(x, y, z));
+      vvec.push_back(vR);
 
       bL = bR + 1;
       bR = GetBreakPointIdx(bL);
@@ -238,12 +210,12 @@
       else
          SetNextPoint((*i).fX, (*i).fY, (*i).fZ);
    }
-   delete [] fOrigPnts;
+   delete [] fOrigPnts; fOrigPnts = 0;
 
    // Project path-marks
    for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
    {
-      projection->ProjectVector(trans, pm->fV, fDepth);
+      projection->ProjectPointdv(trans, pm->fV.Arr(), pm->fV.Arr(), fDepth);
    }
 }
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveTrackPropagator.cxx root/graf3d/eve/src/TEveTrackPropagator.cxx
--- root-old/graf3d/eve/src/TEveTrackPropagator.cxx	2010-10-27 07:48:23.000000000 -0700
+++ root/graf3d/eve/src/TEveTrackPropagator.cxx	2011-05-19 21:25:10.000000000 -0700
@@ -20,10 +20,10 @@
 
 namespace
 {
-   const Float_t kBMin     = 1e-6;
-   const Float_t kPtMinSqr = 1e-20;
-   const Float_t kAMin     = 1e-10;
-   const Float_t kStepEps  = 1e-3;
+   const Double_t kBMin     = 1e-6;
+   const Double_t kPtMinSqr = 1e-20;
+   const Double_t kAMin     = 1e-10;
+   const Double_t kStepEps  = 1e-3;
 }
 
 //______________________________________________________________________________
@@ -32,14 +32,14 @@
    fMaxAng(45), fMaxStep(20.f), fDelta(0.1),
    fPhi(0), fValid(kFALSE),
    fLam(-1), fR(-1), fPhiStep(-1), fSin(-1), fCos(-1),
-   fRKStep(20.0f),
+   fRKStep(20.0),
    fPtMag(-1), fPlMag(-1), fLStep(-1)
 {
    // Default constructor.
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVector& p, const TEveVector& b)
+void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVectorD& p, const TEveVectorD& b)
 {
    // Common update code for helix and RK propagation.
 
@@ -58,7 +58,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b,
+void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVectorD& p, const TEveVectorD& b,
                                                Bool_t full_update, Bool_t enforce_max_step)
 {
    // Update helix parameters.
@@ -72,7 +72,7 @@
    if (full_update)
    {
       using namespace TMath;
-      Float_t a = fgkB2C * b.Mag() * Abs(fCharge);
+      Double_t a = fgkB2C * b.Mag() * Abs(fCharge);
       if (a > kAMin && fPtMag*fPtMag > kPtMinSqr)
       {
          fValid = kTRUE;
@@ -84,13 +84,13 @@
          fPhiStep = fMaxAng * DegToRad();
          if (fR > fDelta)
          {
-            Float_t ang  = 2.0 * ACos(1.0f - fDelta/fR);
+            Double_t ang  = 2.0 * ACos(1.0f - fDelta/fR);
             if (ang < fPhiStep)
                fPhiStep = ang;
          }
 
          // check max step size
-         Float_t curr_step = fR * fPhiStep * Sqrt(1.0f + fLam*fLam);
+         Double_t curr_step = fR * fPhiStep * Sqrt(1.0f + fLam*fLam);
          if (curr_step > fMaxStep || enforce_max_step)
             fPhiStep *= fMaxStep / curr_step;
 
@@ -106,7 +106,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateRK(const TEveVector& p, const TEveVector& b)
+void TEveTrackPropagator::Helix_t::UpdateRK(const TEveVectorD& p, const TEveVectorD& b)
 {
    // Update helix for stepper RungeKutta.
 
@@ -127,8 +127,8 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::Step(const TEveVector4& v, const TEveVector& p,
-                                        TEveVector4& vOut, TEveVector& pOut)
+void TEveTrackPropagator::Helix_t::Step(const TEveVector4D& v, const TEveVectorD& p,
+                                        TEveVector4D& vOut, TEveVectorD& pOut)
 {
    // Step helix for given momentum p from vertex v.
 
@@ -136,7 +136,7 @@
 
    if (fValid)
    {
-      TEveVector d = fE2*(fR*fSin) + fE3*(fR*(1-fCos)) + fE1*fLStep;
+      TEveVectorD d = fE2*(fR*fSin) + fE3*(fR*(1-fCos)) + fE1*fLStep;
       vOut    += d;
       vOut.fT += TMath::Abs(fLStep);
 
@@ -177,12 +177,12 @@
 
 ClassImp(TEveTrackPropagator);
 
-Float_t             TEveTrackPropagator::fgDefMagField = 0.5;
-const Float_t       TEveTrackPropagator::fgkB2C        = 0.299792458e-2;
-TEveTrackPropagator TEveTrackPropagator::fgDefault;
+Double_t             TEveTrackPropagator::fgDefMagField = 0.5;
+const Double_t       TEveTrackPropagator::fgkB2C        = 0.299792458e-2;
+TEveTrackPropagator  TEveTrackPropagator::fgDefault;
 
-Float_t             TEveTrackPropagator::fgEditorMaxR  = 2000;
-Float_t             TEveTrackPropagator::fgEditorMaxZ  = 4000;
+Double_t             TEveTrackPropagator::fgEditorMaxR  = 2000;
+Double_t             TEveTrackPropagator::fgEditorMaxZ  = 4000;
 
 //______________________________________________________________________________
 TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
@@ -281,14 +281,11 @@
 //==============================================================================
 
 //______________________________________________________________________________
-void TEveTrackPropagator::InitTrack(TEveVector &v,  Int_t charge)
+void TEveTrackPropagator::InitTrack(const TEveVectorD &v, Int_t charge)
 {
    // Initialize internal data-members for given particle parameters.
 
-   fV.fX = v.fX;
-   fV.fY = v.fY;
-   fV.fZ = v.fZ;
-
+   fV = v;
    fPoints.push_back(fV);
 
    // init helix
@@ -297,6 +294,15 @@
 }
 
 //______________________________________________________________________________
+void TEveTrackPropagator::InitTrack(const TEveVectorF& v, Int_t charge)
+{
+   // TEveVectorF wrapper.
+
+   TEveVectorD vd(v);
+   InitTrack(vd, charge);
+}
+
+//______________________________________________________________________________
 void TEveTrackPropagator::ResetTrack()
 {
    // Reset cache holding particle trajectory.
@@ -308,7 +314,7 @@
 }
 
 //______________________________________________________________________________
-Bool_t TEveTrackPropagator::GoToVertex(TEveVector& v, TEveVector& p)
+Bool_t TEveTrackPropagator::GoToVertex(TEveVectorD& v, TEveVectorD& p)
 {
    // Propagate particle with momentum p to vertex v.
 
@@ -324,7 +330,18 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::GoToBounds(TEveVector& p)
+Bool_t TEveTrackPropagator::GoToVertex(TEveVectorF& v, TEveVectorF& p)
+{
+   // TEveVectorF wrapper.
+
+   TEveVectorD vd(v), pd(p);
+   Bool_t result = GoToVertex(vd, pd);
+   v = vd; p = pd;
+   return result;
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::GoToBounds(TEveVectorD& p)
 {
    // Propagate particle to bounds.
    // Return TRUE if hit bounds.
@@ -335,24 +352,34 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Update(const TEveVector4& v, const TEveVector& p,
+void TEveTrackPropagator::GoToBounds(TEveVectorF& p)
+{
+   // TEveVectorF wrapper.
+
+   TEveVectorD pd(p);
+   GoToBounds(pd);
+   p = pd;
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::Update(const TEveVector4D& v, const TEveVectorD& p,
                                  Bool_t full_update, Bool_t enforce_max_step)
 {
    // Update helix / B-field projection state.
 
    if (fStepper == kHelix)
    {
-      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst() || full_update, enforce_max_step);
+      fH.UpdateHelix(p, fMagFieldObj->GetFieldD(v), !fMagFieldObj->IsConst() || full_update, enforce_max_step);
    }
    else
    {
-      fH.UpdateRK(p, fMagFieldObj->GetField(v));
+      fH.UpdateRK(p, fMagFieldObj->GetFieldD(v));
 
       if (full_update)
       {
          using namespace TMath;
 
-         Float_t a = fgkB2C * fMagFieldObj->GetMaxFieldMag() * Abs(fH.fCharge);
+         Float_t a = fgkB2C * fMagFieldObj->GetMaxFieldMagD() * Abs(fH.fCharge);
 	 if (a > kAMin)
 	 {
             fH.fR = p.Mag() / a;
@@ -361,7 +388,7 @@
             fH.fPhiStep = fH.fMaxAng * DegToRad();
             if (fH.fR > fH.fDelta )
             {
-               Float_t ang  = 2.0 * ACos(1.0f - fH.fDelta/fH.fR);
+               Double_t ang  = 2.0 * ACos(1.0f - fH.fDelta/fH.fR);
                if (ang < fH.fPhiStep)
                   fH.fPhiStep = ang;
             }
@@ -383,7 +410,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Step(const TEveVector4 &v, const TEveVector &p, TEveVector4 &vOut, TEveVector &pOut)
+void TEveTrackPropagator::Step(const TEveVector4D &v, const TEveVectorD &p, TEveVector4D &vOut, TEveVectorD &pOut)
 {
    // Wrapper to step helix.
 
@@ -419,19 +446,19 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::LoopToBounds(TEveVector& p)
+void TEveTrackPropagator::LoopToBounds(TEveVectorD& p)
 {
    // Propagate charged particle with momentum p to bounds.
    // It is expected that Update() with full-update was called before.
 
-   const Float_t maxRsq = fMaxR*fMaxR;
+   const Double_t maxRsq = fMaxR*fMaxR;
 
-   TEveVector4 currV(fV);
-   TEveVector4 forwV(fV);
-   TEveVector  forwP (p);
+   TEveVector4D currV(fV);
+   TEveVector4D forwV(fV);
+   TEveVectorD  forwP (p);
 
    Int_t np = fPoints.size();
-   Float_t maxPhi = fMaxOrbs*TMath::TwoPi();
+   Double_t maxPhi = fMaxOrbs*TMath::TwoPi();
 
    while (fH.fPhi < maxPhi && np<fNMax)
    {
@@ -447,7 +474,7 @@
                     t, currV.R(), forwV.R(), fMaxR);
             return;
          }
-         TEveVector d(forwV);
+         TEveVectorD d(forwV);
          d -= currV;
          d *= t;
          d += currV;
@@ -458,14 +485,14 @@
       // cross Z
       else if (TMath::Abs(forwV.fZ) > fMaxZ)
       {
-         Float_t t = (fMaxZ - TMath::Abs(currV.fZ)) / TMath::Abs((forwV.fZ - currV.fZ));
+         Double_t t = (fMaxZ - TMath::Abs(currV.fZ)) / TMath::Abs((forwV.fZ - currV.fZ));
          if (t < 0 || t > 1)
          {
             Warning("HelixToBounds", "In MaxZ crossing expected t>=0 && t<=1: t=%f, z1=%f, z2=%f, MaxZ=%f.",
                     t, currV.fZ, forwV.fZ, fMaxZ);
             return;
          }
-         TEveVector d(forwV -currV);
+         TEveVectorD d(forwV -currV);
          d *= t;
          d += currV;
          fPoints.push_back(d);
@@ -482,21 +509,21 @@
 }
 
 //______________________________________________________________________________
-Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
+Bool_t TEveTrackPropagator::LoopToVertex(TEveVectorD& v, TEveVectorD& p)
 {
    // Propagate charged particle with momentum p to vertex v.
    // It is expected that Update() with full-update was called before.
 
-   const Float_t maxRsq = fMaxR * fMaxR;
+   const Double_t maxRsq = fMaxR * fMaxR;
 
-   TEveVector4 currV(fV);
-   TEveVector4 forwV(fV);
-   TEveVector  forwP(p);
+   TEveVector4D currV(fV);
+   TEveVector4D forwV(fV);
+   TEveVectorD  forwP(p);
 
    Int_t first_point = fPoints.size();
    Int_t np          = first_point;
 
-   Float_t prod0=0, prod1;
+   Double_t prod0=0, prod1;
 
    do
    {
@@ -526,7 +553,7 @@
    {
       if ((v - currV).Mag() > kStepEps)
       {
-         Float_t step_frac = prod0 / (prod0 - prod1);
+         Double_t step_frac = prod0 / (prod0 - prod1);
          if (step_frac > 0)
          {
             // Step for fraction of previous step size.
@@ -544,12 +571,12 @@
 
          // Distribute offset to desired crossing point over all segment.
 
-         TEveVector off(v - currV);
+         TEveVectorD off(v - currV);
          off *= 1.0f / currV.fT;
 
          // Calculate the required momentum rotation.
          // lpd - last-points-delta
-         TEveVector lpd0(fPoints[np-1]);
+         TEveVectorD lpd0(fPoints[np-1]);
          lpd0 -= fPoints[np-2];
          lpd0.Normalize();
 
@@ -558,14 +585,14 @@
             fPoints[i] += off * fPoints[i].fT;
          }
 
-         TEveVector lpd1(fPoints[np-1]);
+         TEveVectorD lpd1(fPoints[np-1]);
          lpd1 -= fPoints[np-2];
          lpd1.Normalize();
 
          TEveTrans tt;
          tt.SetupFromToVec(lpd0, lpd1);
 
-         // TEveVector pb4(p);
+         // TEveVectorD pb4(p);
          // printf("Rotating momentum: p0 = "); p.Dump();
          tt.RotateIP(p);
          // printf("                   p1 = "); p.Dump();
@@ -583,11 +610,11 @@
 }
 
 //______________________________________________________________________________
-Bool_t TEveTrackPropagator::LineToVertex(TEveVector& v)
+Bool_t TEveTrackPropagator::LineToVertex(TEveVectorD& v)
 {
    // Propagate neutral particle to vertex v.
 
-   TEveVector4 currV = v;
+   TEveVector4D currV = v;
 
    currV.fX = v.fX;
    currV.fY = v.fY;
@@ -599,11 +626,11 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::LineToBounds(TEveVector& p)
+void TEveTrackPropagator::LineToBounds(TEveVectorD& p)
 {
    // Propagatate neutral particle with momentum p to bounds.
 
-   Float_t tZ = 0, tR = 0, tB = 0;
+   Double_t tZ = 0, tR = 0, tB = 0;
 
    // time where particle intersect +/- fMaxZ
    if (p.fZ > 0)
@@ -626,40 +653,40 @@
    } else {
       tB = tZ;
    }
-   TEveVector nv(fV.fX + p.fX*tB, fV.fY + p.fY*tB, fV.fZ + p.fZ*tB);
+   TEveVectorD nv(fV.fX + p.fX*tB, fV.fY + p.fY*tB, fV.fZ + p.fZ*tB);
    LineToVertex(nv);
 }
 
 //______________________________________________________________________________
-Bool_t TEveTrackPropagator::HelixIntersectPlane(const TEveVector& p,
-                                                const TEveVector& point,
-                                                const TEveVector& normal,
-                                                TEveVector& itsect)
+Bool_t TEveTrackPropagator::HelixIntersectPlane(const TEveVectorD& p,
+                                                const TEveVectorD& point,
+                                                const TEveVectorD& normal,
+                                                TEveVectorD& itsect)
 {
    // Intersect helix with a plane. Current position and argument p define
    // the helix.
 
-   TEveVector pos(fV);
-   TEveVector mom(p);
+   TEveVectorD pos(fV);
+   TEveVectorD mom(p);
    if (fMagFieldObj->IsConst())
-      fH.UpdateHelix(mom, fMagFieldObj->GetField(pos), kFALSE, kFALSE);
+      fH.UpdateHelix(mom, fMagFieldObj->GetFieldD(pos), kFALSE, kFALSE);
 
-   TEveVector n(normal);
-   TEveVector delta = pos - point;
-   Float_t d = delta.Dot(n);
+   TEveVectorD n(normal);
+   TEveVectorD delta = pos - point;
+   Double_t d = delta.Dot(n);
    if (d > 0) {
       n.NegateXYZ(); // Turn normal around so that we approach from negative side of the plane
       d = -d;
    }
 
-   TEveVector4 forwV;
-   TEveVector  forwP;
-   TEveVector4 pos4(pos);
+   TEveVector4D forwV;
+   TEveVectorD  forwP;
+   TEveVector4D pos4(pos);
    while (kTRUE)
    {
       Update(pos4, mom);
       Step(pos4, mom, forwV , forwP);
-      Float_t new_d = (forwV - point).Dot(n);
+      Double_t new_d = (forwV - point).Dot(n);
       if (new_d < d)
       {
          // We are going further away ... fail intersect.
@@ -678,24 +705,24 @@
 }
 
 //______________________________________________________________________________
-Bool_t TEveTrackPropagator::LineIntersectPlane(const TEveVector& p,
-                                               const TEveVector& point,
-                                               const TEveVector& normal,
-                                                     TEveVector& itsect)
+Bool_t TEveTrackPropagator::LineIntersectPlane(const TEveVectorD& p,
+                                               const TEveVectorD& point,
+                                               const TEveVectorD& normal,
+                                                     TEveVectorD& itsect)
 {
    // Intersect line with a plane. Current position and argument p define
    // the line.
 
-   TEveVector pos(fV.fX, fV.fY, fV.fZ);
-   TEveVector delta = pos - point;
+   TEveVectorD pos(fV.fX, fV.fY, fV.fZ);
+   TEveVectorD delta = pos - point;
 
-   Float_t d = delta.Dot(normal);
+   Double_t d = delta.Dot(normal);
    if (d == 0) {
       itsect = pos;
       return kTRUE;
    }
 
-   Float_t t = (p.Dot(normal)) / d;
+   Double_t t = (p.Dot(normal)) / d;
    if (t < 0) {
       return kFALSE;
    } else {
@@ -705,10 +732,10 @@
 }
 
 //______________________________________________________________________________
-Bool_t TEveTrackPropagator::IntersectPlane(const TEveVector& p,
-                                           const TEveVector& point,
-                                           const TEveVector& normal,
-                                                 TEveVector& itsect)
+Bool_t TEveTrackPropagator::IntersectPlane(const TEveVectorD& p,
+                                           const TEveVectorD& point,
+                                           const TEveVectorD& normal,
+                                                 TEveVectorD& itsect)
 {
    // Find intersection of currently propagated track with a plane.
    // Current track position is used as starting point.
@@ -736,7 +763,7 @@
    ps->Reset(size);
    for (Int_t i = 0; i < size; ++i)
    {
-      const TEveVector4& v = fPoints[i];
+      const TEveVector4D& v = fPoints[i];
       ps->SetNextPoint(v.fX, v.fY, v.fZ);
    }
 }
@@ -760,7 +787,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMagField(Float_t bX, Float_t bY, Float_t bZ)
+void TEveTrackPropagator::SetMagField(Double_t bX, Double_t bY, Double_t bZ)
 {
    // Set constant magnetic field and rebuild tracks.
 
@@ -781,13 +808,13 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::PrintMagField(Float_t x, Float_t y, Float_t z) const
+void TEveTrackPropagator::PrintMagField(Double_t x, Double_t y, Double_t z) const
 {
    if (fMagFieldObj) fMagFieldObj->PrintField(x, y, z);
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMaxR(Float_t x)
+void TEveTrackPropagator::SetMaxR(Double_t x)
 {
    // Set maximum radius and rebuild tracks.
 
@@ -796,7 +823,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMaxZ(Float_t x)
+void TEveTrackPropagator::SetMaxZ(Double_t x)
 {
    // Set maximum z and rebuild tracks.
 
@@ -805,7 +832,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMaxOrbs(Float_t x)
+void TEveTrackPropagator::SetMaxOrbs(Double_t x)
 {
    // Set maximum number of orbits and rebuild tracks.
 
@@ -814,7 +841,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMinAng(Float_t x)
+void TEveTrackPropagator::SetMinAng(Double_t x)
 {
    // Set maximum step angle and rebuild tracks.
    // WARNING -- this method / variable was mis-named.
@@ -823,7 +850,7 @@
    SetMaxAng(x);
 }
 //______________________________________________________________________________
-Float_t TEveTrackPropagator::GetMinAng() const
+Double_t TEveTrackPropagator::GetMinAng() const
 {
    // Get maximum step angle.
    // WARNING -- this method / variable was mis-named.
@@ -833,7 +860,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMaxAng(Float_t x)
+void TEveTrackPropagator::SetMaxAng(Double_t x)
 {
    // Set maximum step angle and rebuild tracks.
 
@@ -842,7 +869,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMaxStep(Float_t x)
+void TEveTrackPropagator::SetMaxStep(Double_t x)
 {
    // Set maximum step-size and rebuild tracks.
 
@@ -851,7 +878,7 @@
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetDelta(Float_t x)
+void TEveTrackPropagator::SetDelta(Double_t x)
 {
    // Set maximum error and rebuild tracks.
 
@@ -1081,7 +1108,7 @@
     xyzt[1] = yt;
     xyzt[2] = zt;
 
-    fH.fB = fMagFieldObj->GetField(xt, yt, zt);
+    fH.fB = fMagFieldObj->GetFieldD(xt, yt, zt);
     f[0] = -fH.fB.fX;
     f[1] = -fH.fB.fY;
     f[2] = -fH.fB.fZ;
@@ -1120,7 +1147,7 @@
     xyzt[1] = yt;
     xyzt[2] = zt;
 
-    fH.fB = fMagFieldObj->GetField(xt, yt, zt);
+    fH.fB = fMagFieldObj->GetFieldD(xt, yt, zt);
     f[0] = -fH.fB.fX;
     f[1] = -fH.fB.fY;
     f[2] = -fH.fB.fZ;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveVSDStructs.cxx root/graf3d/eve/src/TEveVSDStructs.cxx
--- root-old/graf3d/eve/src/TEveVSDStructs.cxx	2010-10-27 07:37:10.000000000 -0700
+++ root/graf3d/eve/src/TEveVSDStructs.cxx	2011-04-04 08:03:06.000000000 -0700
@@ -20,8 +20,12 @@
 ClassImp(TEveMCTrack);
 ClassImp(TEveHit);
 ClassImp(TEveCluster);
-ClassImp(TEveRecTrack);
+ClassImp(TEveRecTrackT<Float_t>);
+ClassImp(TEveRecTrackT<Double_t>);
 ClassImp(TEveRecKink);
 ClassImp(TEveRecV0);
 ClassImp(TEveRecCascade);
 ClassImp(TEveMCRecCrossRef);
+
+template class TEveRecTrackT<Float_t>;
+template class TEveRecTrackT<Double_t>;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/eve/src/TEveViewer.cxx root/graf3d/eve/src/TEveViewer.cxx
--- root-old/graf3d/eve/src/TEveViewer.cxx	2010-12-15 08:34:09.000000000 -0800
+++ root/graf3d/eve/src/TEveViewer.cxx	2011-05-26 17:22:31.000000000 -0700
@@ -42,6 +42,11 @@
 // will delete that. TGLSAViewer and TGEmbeddedViewer both do so.
 // This could be an optional argument to SetGLViewer. A frame could be
 // passed as well.
+//
+// When stand-alone viewer is requested, it will come up with menu-hiding
+// enabled by default. If you dislike this, add the following line to rootrc
+// file (or set corresponding gEnv entry in application initialization):
+//   Eve.Viewer.HideMenus: off
 
 ClassImp(TEveViewer);
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLAutoRotator.h root/graf3d/gl/inc/TGLAutoRotator.h
--- root-old/graf3d/gl/inc/TGLAutoRotator.h	2010-10-27 07:48:24.000000000 -0700
+++ root/graf3d/gl/inc/TGLAutoRotator.h	2011-06-14 15:55:51.156752426 -0700
@@ -13,6 +13,7 @@
 #define ROOT_TGLAutoRotator
 
 #include "TObject.h"
+#include "TString.h"
 
 class TGLCamera;
 class TGLViewer;
@@ -39,10 +40,18 @@
    Double_t   fThetaA0, fDollyA0;
    Bool_t     fTimerRunning;
 
+   TString    fImageName;
+   Int_t      fImageCount;
+   Bool_t     fImageAutoSave;
+
+   TString    fImageGUIBaseName;
+   Int_t      fImageGUIOutMode;
+
 public:
    TGLAutoRotator(TGLViewer* v);
    virtual ~TGLAutoRotator();
 
+   TGLViewer* GetViewer() const { return fViewer; }
    TGLCamera* GetCamera() const { return fCamera; }
 
    // --------------------------------
@@ -72,7 +81,26 @@
    Double_t GetADolly() const     { return fADolly; }
    void     SetADolly(Double_t a);
 
-   ClassDef(TGLAutoRotator, 0); // Short description.
+   TString  GetImageName() const              { return fImageName;  }
+   void     SetImageName(const TString& name) { fImageName = name;  }
+   Int_t    GetImageCount() const             { return fImageCount; }
+   void     SetImageCount(Int_t ic)           { fImageCount = ic;   }
+   Bool_t   GetImageAutoSave() const          { return fImageAutoSave; }
+   void     SetImageAutoSave(Bool_t s)        { fImageAutoSave = s; }
+
+   void     StartImageAutoSaveAnimatedGif(const TString& filename);
+   void     StartImageAutoSave(const TString& filename);
+   void     StopImageAutoSave();
+
+   TString  GetImageGUIBaseName() const               { return fImageGUIBaseName;  }
+   void     SetImageGUIBaseName(const TString& gname) { fImageGUIBaseName = gname; }
+
+   Int_t    GetImageGUIOutMode() const  { return fImageGUIOutMode; }
+   void     SetImageGUIOutMode(Int_t m);
+
+   void     StartImageAutoSaveWithGUISettings();
+
+   ClassDef(TGLAutoRotator, 0); // Automatic, timer-based, rotation of GL-viewer's camera.
 };
 
 #endif
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/inc/TGLViewerEditor.h root/graf3d/gl/inc/TGLViewerEditor.h
--- root-old/graf3d/gl/inc/TGLViewerEditor.h	2010-10-27 07:48:24.000000000 -0700
+++ root/graf3d/gl/inc/TGLViewerEditor.h	2011-06-14 15:55:52.249752427 -0700
@@ -30,6 +30,7 @@
 class TGColorSelect;
 class TGComboBox;
 class TGButton;
+class TGTextEntry;
 class TGLViewer;
 class TGTab;
 
@@ -95,11 +96,14 @@
    TGNumberEntry    *fARotATheta, *fARotWTheta;
    TGNumberEntry    *fARotADolly, *fARotWDolly;
 
+   TGTextEntry      *fASavImageGUIBaseName;
+   TGButtonGroup    *fASavImageGUIOutMode;
+
    TGNumberEntry    *fStereoZeroParallax;
    TGNumberEntry    *fStereoEyeOffsetFac;
    TGNumberEntry    *fStereoFrustumAsymFac;
 
-   //Model
+   // Model
    TGLViewer        *fViewer;
    Bool_t	     fIsInPad;
 
@@ -137,7 +141,7 @@
    void DoAnnotation();
    void DoDrawCameraCenter();
    void UpdateCameraCenter();
-   //Axis manipulation
+   // Axis manipulation
    void UpdateViewerAxes(Int_t id);
    void UpdateViewerReference();
    void DoCameraOverlay();
@@ -145,6 +149,10 @@
    void UpdateRotator();
    void DoRotatorStart();
    void DoRotatorStop();
+   void DoASavImageGUIBaseName(const char* t);
+   void DoASavImageGUIOutMode(Int_t m);
+   void DoASavImageStart();
+   void DoASavImageStop();
    void UpdateStereo();
 
    void DetachFromPad(){fIsInPad = kFALSE;}
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLAutoRotator.cxx root/graf3d/gl/src/TGLAutoRotator.cxx
--- root-old/graf3d/gl/src/TGLAutoRotator.cxx	2010-10-27 07:48:23.000000000 -0700
+++ root/graf3d/gl/src/TGLAutoRotator.cxx	2011-06-14 15:55:49.331752428 -0700
@@ -25,6 +25,13 @@
 // W's are angular velocities.
 // ATheta -- Theta amplitude in units of Pi/2.
 // ADolly -- In/out amplitude in units of initial distance.
+//
+// Can also save images automatically.
+
+// fGUIOutMode is used internally between TGLAutoRotator and TGLViewerEditor,
+// allowed values are:
+//   1 - animated gif
+//   2 - a series of png images
 
 ClassImp(TGLAutoRotator);
 
@@ -36,7 +43,9 @@
    fWPhi  (0.40),
    fWTheta(0.15), fATheta(0.5),
    fWDolly(0.30), fADolly(0.4),
-   fTimerRunning(kFALSE)
+   fTimerRunning(kFALSE),
+   fImageCount(0), fImageAutoSave(kFALSE),
+   fImageGUIBaseName("animation"), fImageGUIOutMode(1)
 {
    // Constructor.
 
@@ -101,6 +110,8 @@
 //______________________________________________________________________________
 void TGLAutoRotator::Start()
 {
+   // Start the auto-rotator.
+
    if (fTimerRunning)
    {
       Stop();
@@ -121,6 +132,8 @@
 //______________________________________________________________________________
 void TGLAutoRotator::Stop()
 {
+   // Stop the auto-rotator.
+
    if (fTimerRunning)
    {
       fWatch->Stop();
@@ -132,6 +145,9 @@
 //______________________________________________________________________________
 void TGLAutoRotator::Timeout()
 {
+   // Called on every timer timeout. Moves / rotates the camera and optionally
+   // produces a screenshot.
+
    if (!fTimerRunning || gTQSender != fTimer)
    {
       Error("Timeout", "Not running or not called via timer.");
@@ -156,4 +172,104 @@
    fCamera->RefCamTrans().MoveLF(1, -delta_d);
 
    fViewer->RequestDraw(TGLRnrCtx::kLODHigh);
+
+   if (fImageAutoSave)
+   {
+      TString filename;
+      if (fImageName.Contains("%"))
+      {
+         filename.Form(fImageName, fImageCount);
+      }
+      else
+      {
+         filename = fImageName;
+      }
+      fViewer->SavePicture(filename);
+      ++fImageCount;
+   }
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void TGLAutoRotator::StartImageAutoSaveAnimatedGif(const TString& filename)
+{
+   // Start saving into animated gif. The provided name will be used as it is,
+   // so make sure to end it with '.gif+'.
+   // Use convert tool from ImageMagic if you want to set a different delay or
+   // enable looping.
+
+   if ( ! filename.Contains(".gif+"))
+   {
+      Error("StartImageAutoSaveAnimatedGif", "Name should end with '.gif+'. Not starting.");
+      return;
+   }
+
+   fImageName     = filename;
+   fImageCount    = 0;
+   fImageAutoSave = kTRUE;
+}
+
+//______________________________________________________________________________
+void TGLAutoRotator::StartImageAutoSave(const TString& filename)
+{
+   // Start saving into a set of images. The provided name will be used as a
+   // format to insert additional image sequence number so it should include
+   // an '%' character. A good name would be something like:
+   //   "image-%04d.png"
+   // On GNU/Linux use mencoder and/or ffmpeg to bundle images into a movie.
+
+   if ( ! filename.Contains("%"))
+   {
+      Error("StartImageAutoSave", "Name should include a '%%' character, like 'image-%%05d.png'. Not starting.");
+      return;
+   }
+
+   fImageName     = filename;
+   fImageCount    = 0;
+   fImageAutoSave = kTRUE;
+}
+
+//______________________________________________________________________________
+void TGLAutoRotator::StopImageAutoSave()
+{
+   // Stops automatic saving of images.
+
+   fImageAutoSave = kFALSE;
+}
+
+//______________________________________________________________________________
+void TGLAutoRotator::SetImageGUIOutMode(Int_t m)
+{
+   // Set output mode for GUI operation:
+   //   1 - animated gif;
+   //   2 - a series of pngs
+
+   if (m < 1 || m > 2)
+   {
+      Warning("SetImageGUIOutMode", "Invalid value, ignoring");
+      return;
+   }
+   fImageGUIOutMode = m;
+}
+
+//______________________________________________________________________________
+void TGLAutoRotator::StartImageAutoSaveWithGUISettings()
+{
+   // Start auto-saving images as set-up via GUI.
+
+   if (fImageGUIOutMode == 1)
+   {
+      TString name = fImageGUIBaseName + ".gif+";
+      StartImageAutoSaveAnimatedGif(name);
+   }
+   else if (fImageGUIOutMode == 2)
+   {
+      TString name = fImageGUIBaseName + "-%05d.png";
+      StartImageAutoSave(name);
+   }
+   else
+   {
+      Warning("StartImageAutoSaveWithGUISettings", "Unsupported mode '%d'.", fImageGUIOutMode);
+   }
 }
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLAxis.cxx root/graf3d/gl/src/TGLAxis.cxx
--- root-old/graf3d/gl/src/TGLAxis.cxx	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/gl/src/TGLAxis.cxx	2011-05-19 21:25:27.000000000 -0700
@@ -371,7 +371,7 @@
    // Compute ticks positions. Linear and optimized.
 
    Int_t i, j, k, nDivOpt;
-   Double_t step1=0, step2=0, wmin2, wmax2;
+   Double_t step1=0, step2=0, wmin2=0, wmax2=0;
    Double_t wmin = fWmin;
    Double_t wmax = fWmax;
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLAxisPainter.cxx root/graf3d/gl/src/TGLAxisPainter.cxx
--- root-old/graf3d/gl/src/TGLAxisPainter.cxx	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/gl/src/TGLAxisPainter.cxx	2011-05-19 21:25:27.000000000 -0700
@@ -350,11 +350,11 @@
    Int_t n1a = TMath::FloorNint(fAttAxis->GetNdivisions() / 100);
    Int_t n2a = fAttAxis->GetNdivisions() - n1a * 100;
    Int_t bn1, bn2;
-   Double_t bw1, bw2; // primary , secondary bin width
-   Double_t bl1, bh1, bl2, bh2; // bin low, high values
+   Double_t bw1, bw2;                   // primary , secondary bin width
+   Double_t bl1=0, bh1=0, bl2=0, bh2=0; // bin low, high values
 
    // Read limits from users range
-   THLimitsFinder::Optimize(min, max, n1a, bl1, bh1, bn1, bw1);
+   THLimitsFinder::Optimize(min, max,       n1a, bl1, bh1, bn1, bw1);
    THLimitsFinder::Optimize(bl1, bl1 + bw1, n2a, bl2, bh2, bn2, bw2);
 
    //______________________________________________________________________________
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLCameraOverlay.cxx root/graf3d/gl/src/TGLCameraOverlay.cxx
--- root-old/graf3d/gl/src/TGLCameraOverlay.cxx	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/gl/src/TGLCameraOverlay.cxx	2011-06-14 15:55:13.607752428 -0700
@@ -262,14 +262,13 @@
          glLineStipple(1, stipple);
 
          glBegin(GL_LINES);
-         Int_t ondiv;
-         Double_t omin, omax, bw1;
-         Double_t val =0;
+         Int_t    ondiv = 0;
+         Double_t omin = 0, omax = 0, bw1 = 0;
          THLimitsFinder::Optimize(labs[0].second, labs[1].second, secSteps, omin, omax, ondiv, bw1);
-         val =  labs[0].second;
-         while(val < fFrustum[2])
+         Double_t val = labs[0].second;
+         while (val < fFrustum[2])
          {
-            for(Int_t k=0; k<ondiv; k++)
+            for (Int_t k=0; k<ondiv; k++)
             {
                val += bw1;
                tmp = vy1 + xdir * val;
@@ -340,11 +339,11 @@
          glLineStipple(1, stipple);
 
          glBegin(GL_LINES);
-         Int_t ondiv;
-         Double_t omin, omax, bw1;
-         Double_t val =0;
+         Int_t    ondiv;
+         Double_t omin = 0, omax = 0, bw1 = 0;
+         Double_t val  = 0;
          THLimitsFinder::Optimize(labs[0].second, labs[1].second, secSteps, omin, omax, ondiv, bw1);
-         val =  labs[0].second;
+         val = labs[0].second;
          while(val < fFrustum[3])
          {
             for(Int_t k=0; k<ondiv; k++)
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLFBO.cxx root/graf3d/gl/src/TGLFBO.cxx
--- root-old/graf3d/gl/src/TGLFBO.cxx	2010-12-15 08:32:19.000000000 -0800
+++ root/graf3d/gl/src/TGLFBO.cxx	2011-06-14 15:56:07.098752427 -0700
@@ -130,12 +130,16 @@
 
          delete [] modes;
       }
-      Info(eh.c_str(), "InitMultiSample coverage_samples=%d, color_samples=%d.", fMSCoverageSamples, fMSSamples);
+      if (gDebug > 0) {
+         Info(eh.c_str(), "InitMultiSample coverage_samples=%d, color_samples=%d.", fMSCoverageSamples, fMSSamples);
+      }
       InitMultiSample();
    }
    else
    {
-      printf("TGLFBO::Init InitStandard ...\n");
+      if (gDebug > 0) {
+         Info(eh.c_str(), "InitStandard (no multi-sampling).");
+      }
       InitStandard();
    }
 
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLFontManager.cxx root/graf3d/gl/src/TGLFontManager.cxx
--- root-old/graf3d/gl/src/TGLFontManager.cxx	2010-10-27 07:37:11.000000000 -0700
+++ root/graf3d/gl/src/TGLFontManager.cxx	2011-05-19 21:25:18.000000000 -0700
@@ -457,7 +457,7 @@
    Int_t cnt = 0;
    while ((os = (TObjString*) next()) != 0)
    {
-      if (os->GetString() == name)
+      if (os->String() == name)
          break;
       cnt++;
    }
@@ -537,7 +537,7 @@
    if (fgStaticInitDone == kFALSE) InitStatics();
 
    TObjString* os = (TObjString*)fgFontFileArray[id / 10];
-   return os->GetString().Data();
+   return os->String().Data();
 }
 
 //______________________________________________________________________________
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLFormat.cxx root/graf3d/gl/src/TGLFormat.cxx
--- root-old/graf3d/gl/src/TGLFormat.cxx	2010-12-15 08:32:18.000000000 -0800
+++ root/graf3d/gl/src/TGLFormat.cxx	2011-05-26 17:22:36.000000000 -0700
@@ -36,7 +36,10 @@
 #ifdef WIN32
    fDepthSize(32),
 #else
-   fDepthSize(16),//FIXFIX
+   // 16-bits needed for some virtual machines (VirtualBox) and Xming-mesa
+   // (when running ssh from windows to linux).
+   // All others seem to have 24-bit depth-buffers only and use this anyway.
+   fDepthSize(16),
 #endif
    fAccumSize(0),
    fStencilSize(8),
@@ -208,11 +211,18 @@
 {
    // Return default number of samples for multi-sampling.
 
+   Int_t req = gEnv->GetValue("OpenGL.Framebuffer.Multisample", 0);
+
+   // Avoid query of available multi-sample modes when not required.
+   // Over ssh, SLC5 lies about supporting the GLX_SAMPLES_ARB
+   // extension and then dies horribly when the query is made.
+   if (req == 0) {
+      return 0;
+   }
+
    if (fgAvailableSamples.empty())
       InitAvailableSamples();
 
-   Int_t req = gEnv->GetValue("OpenGL.Framebuffer.Multisample", 0);
-
    std::vector<Int_t>::iterator i = fgAvailableSamples.begin();
    while (i != fgAvailableSamples.end() - 1 && *i < req)
       ++i;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLViewerEditor.cxx root/graf3d/gl/src/TGLViewerEditor.cxx
--- root-old/graf3d/gl/src/TGLViewerEditor.cxx	2010-10-27 07:48:23.000000000 -0700
+++ root/graf3d/gl/src/TGLViewerEditor.cxx	2011-06-14 15:55:48.233752428 -0700
@@ -15,6 +15,7 @@
 #include "TGNumberEntry.h"
 #include "TGButtonGroup.h"
 #include "TGColorSelect.h"
+#include "TGTextEntry.h"
 #include "TVirtualGL.h"
 #include "TG3DLine.h"
 #include "TGButton.h"
@@ -77,6 +78,7 @@
    fCamOverlayOn(0),
    fClipSet(0),
    fARotDt(0), fARotWPhi(0), fARotATheta(0), fARotWTheta(0), fARotADolly(0), fARotWDolly(0),
+   fASavImageGUIBaseName(0), fASavImageGUIOutMode(0),
    fStereoZeroParallax(0), fStereoEyeOffsetFac(0), fStereoFrustumAsymFac(0),
    fViewer(0),
    fIsInPad(kTRUE)
@@ -142,6 +144,9 @@
    fARotADolly->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateRotator()");
    fARotWDolly->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateRotator()");
 
+   fASavImageGUIBaseName->Connect("TextChanged(char*", "TGLViewerEditor", this, "DoASavImageGUIBaseName(char*)");
+   fASavImageGUIOutMode->Connect("Clicked(Int_t)", "TGLViewerEditor", this, "DoASavImageGUIOutMode(Int_t)");
+
    fStereoZeroParallax  ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
    fStereoEyeOffsetFac  ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
    fStereoFrustumAsymFac->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
@@ -218,6 +223,9 @@
       fARotWTheta->SetNumber(r->GetWTheta());
       fARotADolly->SetNumber(r->GetADolly());
       fARotWDolly->SetNumber(r->GetWDolly());
+
+      fASavImageGUIBaseName->SetText(r->GetImageGUIBaseName());
+      fASavImageGUIOutMode ->SetButton(r->GetImageGUIOutMode());
    }
 
    if (fViewer->GetStereo())
@@ -603,6 +611,36 @@
 
    tab->AddFrame(p, new TGLayoutHints(kLHintsTop | kLHintsExpandX));
 
+   // ----- Auto Save Images -----
+
+   p = new TGGroupFrame(tab, "Auto save images", kVerticalFrame);
+
+   fASavImageGUIBaseName = new TGTextEntry(p);
+   fASavImageGUIBaseName->SetDefaultSize(160, 0);
+   p->AddFrame(fASavImageGUIBaseName, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 0, 0, 4, 0));
+
+   fASavImageGUIOutMode = new TGButtonGroup(p, "Output mode", kChildFrame|kHorizontalFrame);
+   new TGRadioButton(fASavImageGUIOutMode, "GIF+      ");
+   new TGRadioButton(fASavImageGUIOutMode, "PNG set   ");
+   fASavImageGUIOutMode->SetLayoutHints(new TGLayoutHints(kLHintsLeft | kLHintsBottom, 0, 0, 2, -10));
+   p->AddFrame(fASavImageGUIOutMode, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
+
+   {
+      TGCompositeFrame *l = new TGHorizontalFrame(p);
+
+      TGTextButton *b = new TGTextButton(l, "Start");
+      b->Connect("Clicked()", "TGLViewerEditor", this, "DoASavImageStart()");
+      l->AddFrame(b, new TGLayoutHints(kLHintsLeft | kLHintsExpandX));
+
+      b = new TGTextButton(l, "Stop");
+      b->Connect("Clicked()", "TGLViewerEditor", this, "DoASavImageStop()");
+      l->AddFrame(b, new TGLayoutHints(kLHintsLeft | kLHintsExpandX));
+
+      p->AddFrame(l, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 0, 0, 4, 0));
+   }
+
+   tab->AddFrame(p, new TGLayoutHints(kLHintsTop | kLHintsExpandX));
+
    // ----- Stereo -----
 
    fStereoFrame = p = new TGGroupFrame(tab, "Stereo", kVerticalFrame);
@@ -720,6 +758,54 @@
 }
 
 //______________________________________________________________________________
+void TGLViewerEditor::DoASavImageGUIBaseName(const char* t)
+{
+   // Update base-name.
+
+   TGLAutoRotator *r = fViewer->GetAutoRotator();
+   r->SetImageGUIBaseName(t);
+}
+
+//______________________________________________________________________________
+void TGLViewerEditor::DoASavImageGUIOutMode(Int_t m)
+{
+   // Update output mode.
+
+   TGLAutoRotator *r = fViewer->GetAutoRotator();
+   r->SetImageGUIOutMode(m);
+}
+
+//______________________________________________________________________________
+void TGLViewerEditor::DoASavImageStart()
+{
+   // Start auto-rotator image auto-save.
+
+   TGLAutoRotator *r = fViewer->GetAutoRotator();
+   if (r->GetImageAutoSave())
+   {
+      Warning("DoASavImageStart", "AutoSave in progress.");
+      return;
+   }
+
+   r->StartImageAutoSaveWithGUISettings();
+}
+
+//______________________________________________________________________________
+void TGLViewerEditor::DoASavImageStop()
+{
+   // Stop auto-rotator image auto-save.
+
+   TGLAutoRotator *r = fViewer->GetAutoRotator();
+   if (!r->GetImageAutoSave())
+   {
+      Warning("DoASavImageStop", "AutoSave not in progress.");
+      return;
+   }
+
+   r->StopImageAutoSave();
+}
+
+//______________________________________________________________________________
 void TGLViewerEditor::UpdateStereo()
 {
    // Update stereo related variables.
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/gl/src/TGLWidget.cxx root/graf3d/gl/src/TGLWidget.cxx
--- root-old/graf3d/gl/src/TGLWidget.cxx	2010-12-15 08:32:18.000000000 -0800
+++ root/graf3d/gl/src/TGLWidget.cxx	2011-04-04 08:02:54.000000000 -0700
@@ -388,11 +388,11 @@
    {
       format.push_back(GLX_RGBA);
       format.push_back(GLX_RED_SIZE);
-      format.push_back(1);
+      format.push_back(8);
       format.push_back(GLX_GREEN_SIZE);
-      format.push_back(1);
+      format.push_back(8);
       format.push_back(GLX_BLUE_SIZE);
-      format.push_back(1);
+      format.push_back(8);
 
       if (request.IsDoubleBuffered())
          format.push_back(GLX_DOUBLEBUFFER);
@@ -409,11 +409,11 @@
 
       if (request.HasAccumBuffer()) {
          format.push_back(GLX_ACCUM_RED_SIZE);
-         format.push_back(1);
+         format.push_back(8);
          format.push_back(GLX_ACCUM_GREEN_SIZE);
-         format.push_back(1);
+         format.push_back(8);
          format.push_back(GLX_ACCUM_BLUE_SIZE);
-         format.push_back(1);
+         format.push_back(8);
       }
 
       if (request.IsStereo()) {
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/graf3d/glew/src/glew.c root/graf3d/glew/src/glew.c
--- root-old/graf3d/glew/src/glew.c	2010-12-15 08:32:23.000000000 -0800
+++ root/graf3d/glew/src/glew.c	2011-04-04 07:55:52.000000000 -0700
@@ -6168,9 +6168,15 @@
 
 /* ------------------------------------------------------------------------- */
 
-#ifndef GLEW_MX
-static
-#endif
+/*
+ * MT 2010-12-22: Always export this symbol so that AGL can be used on mac
+ * by calling this function instead of glewInit() wrapper -- which would also
+ * invoke GLX init -- and fail for pure AGL programs.
+
+ * #ifndef GLEW_MX
+ * static
+ * #endif
+*/
 GLenum glewContextInit (GLEW_CONTEXT_ARG_DEF_LIST)
 {
   const GLubyte* s;
diff -Naur --exclude=.svn -I '@(#)root' -I '// Author' -I '\$Id' root-old/tutorials/eve/track.C root/tutorials/eve/track.C
--- root-old/tutorials/eve/track.C	2010-10-27 16:48:41.000000000 +0200
+++ root/tutorials/eve/track.C	2011-04-04 17:04:41.000000000 +0200
@@ -49,11 +49,11 @@
    ~GappedField(){};
    using   TEveMagField::GetField;
 
-   virtual TEveVector GetField(Float_t /*x*/, Float_t /*y*/, Float_t z) const
+   virtual TEveVectorD GetFieldD(Double_t /*x*/, Double_t /*y*/, Double_t z) const
    {
-      if (TMath::Abs(z) < 300) return TEveVector(0, 0, -4);
-      if (TMath::Abs(z) < 600) return TEveVector(0, 0, 0);
-      return TEveVector(0, 0, 4);
+      if (TMath::Abs(z) < 300) return TEveVectorD(0, 0, -4);
+      if (TMath::Abs(z) < 600) return TEveVectorD(0, 0, 0);
+      return TEveVectorD(0, 0, 4);
    }
 };
 
@@ -72,7 +72,7 @@
       m_simpleModel(true){}
 
    virtual ~CmsMagField(){}
-   virtual Float_t    GetMaxFieldMag() const { return m_magnetIsOn ? 3.8 : 0.0; }
+   virtual Double_t   GetMaxFieldMagD() const { return m_magnetIsOn ? 3.8 : 0.0; }
    void               setMagnetState( bool state )
    {
       if (state != m_magnetIsOn)
@@ -93,7 +93,7 @@
 
    using   TEveMagField::GetField;
 
-   virtual TEveVector GetField(Float_t x, Float_t y, Float_t z) const
+   virtual TEveVectorD GetFieldD(Double_t x, Double_t y, Double_t z) const
    {
       double R = sqrt(x*x+y*y);
       double field = m_reverse?-GetMaxFieldMag():GetMaxFieldMag();
@@ -101,23 +101,23 @@
       if ( TMath::Abs(z)<724 )
       {
          //inside solenoid
-         if ( R < 300) return TEveVector(0,0,field);
+         if ( R < 300) return TEveVectorD(0,0,field);
          // outside solinoid
          if ( m_simpleModel ||
               ( R>461.0 && R<490.5 ) ||
               ( R>534.5 && R<597.5 ) ||
               ( R>637.0 && R<700.0 ) )
-            return TEveVector(0,0,-field/3.8*1.2);
+            return TEveVectorD(0,0,-field/3.8*1.2);
  
       } else {
          // endcaps
          if (m_simpleModel)
          {
-            if ( R < 50 ) return TEveVector(0,0,field);
+            if ( R < 50 ) return TEveVectorD(0,0,field);
             if ( z > 0 )
-               return TEveVector(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
+               return TEveVectorD(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
             else
-               return TEveVector(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
+               return TEveVectorD(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
          }
          // proper model
          if ( ( TMath::Abs(z)>724 && TMath::Abs(z)<786  ) ||
@@ -125,12 +125,12 @@
               ( TMath::Abs(z)>975 && TMath::Abs(z)<1003 ) )
          {
             if ( z > 0 )
-               return TEveVector(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
+               return TEveVectorD(x/R*field/3.8*2.0, y/R*field/3.8*2.0, 0);
             else
-               return TEveVector(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
+               return TEveVectorD(-x/R*field/3.8*2.0, -y/R*field/3.8*2.0, 0);
          }
       }
-      return TEveVector(0,0,0);
+      return TEveVectorD(0,0,0);
    }
 };
 
@@ -144,7 +144,7 @@
   // Make track with given propagator.
   // Add to math-marks to test fit.
 
-  TEveRecTrack *rc = new TEveRecTrack();
+  TEveRecTrackD *rc = new TEveRecTrackD();
   rc->fV.Set(0.028558, -0.000918, 3.691919);
   rc->fP.Set(0.767095, -2.400006, -0.313103);
   rc->fSign = sign;
@@ -152,11 +152,11 @@
   TEveTrack* track = new TEveTrack(rc, prop);
   track->SetName(Form("Charge %d", sign));
   // daughter 0
-  TEvePathMark* pm1 = new TEvePathMark(TEvePathMark::kDaughter);
+  TEvePathMarkD* pm1 = new TEvePathMarkD(TEvePathMarkD::kDaughter);
   pm1->fV.Set(1.479084, -4.370661, 3.119761);
   track->AddPathMark(*pm1);
   // daughter 1
-  TEvePathMark* pm2 = new TEvePathMark(TEvePathMark::kDaughter);
+  TEvePathMarkD* pm2 = new TEvePathMarkD(TEvePathMarkD::kDaughter);
   pm2->fV.Set(57.72345, -89.77011, -9.783746);
   track->AddPathMark(*pm2);
 
@@ -164,7 +164,7 @@
 }
 
 
-void track(Int_t mode = 5, Bool_t isRungeKutta = kTRUE)
+void track(Int_t mode = 1, Bool_t isRungeKutta = kTRUE)
 {
 #if defined (__CINT__)
    Error("track.C", "Must be run in compiled mode!");
@@ -226,7 +226,7 @@
          list->SetElementName(Form("%s, gappedB", list->GetElementName()));
 
       
-         TEveRecTrack *rc = new TEveRecTrack();
+         TEveRecTrackD *rc = new TEveRecTrackD();
          rc->fV.Set(0.028558, -0.000918, 3.691919);
          rc->fP.Set(0.767095, -0.400006, 2.313103);
          rc->fSign = 1;
@@ -256,17 +256,22 @@
          list->SetElementName(Form("%s, CMS field", list->GetElementName()));
 
       
-         TEveRecTrack *rc = new TEveRecTrack();
+         TEveRecTrackD *rc = new TEveRecTrackD();
          rc->fV.Set(0.027667, 0.007919, 0.895964);
          rc->fP.Set(3.903134, 2.252232, -3.731366);
          rc->fSign = -1;
          track = new TEveTrack(rc, prop);
 
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(3.576755e+00, 2.080579e+00, -2.507230e+00)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(8.440379e+01, 6.548286e+01, -8.788129e+01)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.841321e+02, 3.915693e+02, -3.843072e+02)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.946167e+02, 4.793932e+02, -4.615060e+02)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDecay,    TEveVector(2.249656e+02, 5.835767e+02, -5.565275e+02)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(3.576755e+00, 2.080579e+00, -2.507230e+00)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(8.440379e+01, 6.548286e+01, -8.788129e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(1.841321e+02, 3.915693e+02, -3.843072e+02)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(1.946167e+02, 4.793932e+02, -4.615060e+02)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDecay,
+                  TEveVectorD(2.249656e+02, 5.835767e+02, -5.565275e+02)));
 
 	 track->SetRnrPoints(kTRUE);
 	 track->SetMarkerStyle(4);
@@ -290,19 +295,29 @@
 	 prop->RefPMAtt().SetMarkerStyle(4);
          list->SetElementName(Form("%s, CMS field", list->GetElementName()));
       
-         TEveRecTrack *rc = new TEveRecTrack();
+         TEveRecTrackD *rc = new TEveRecTrackD();
          rc->fV.Set(-16.426592, 16.403185, -19.782692);
          rc->fP.Set(3.631100, 3.643450, 0.682254);
          rc->fSign = -1;
          track = new TEveTrack(rc, prop);
 
-         track->AddPathMark(TEvePathMark(TEvePathMark::kReference, TEveVector(-1.642659e+01, 1.640318e+01, -1.978269e+01), TEveVector(3.631100, 3.643450, 0.682254)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kReference, TEveVector(-1.859987e+00, 3.172243e+01, -1.697866e+01), TEveVector(3.456056, 3.809894, 0.682254)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kReference, TEveVector(4.847579e+01, 9.871711e+01, -5.835719e+00), TEveVector(2.711614, 4.409945, 0.687656)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.342045e+02, 4.203950e+02, 3.846268e+01)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.483827e+02, 5.124750e+02, 5.064311e+01)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.674676e+02, 6.167731e+02, 6.517403e+01)));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDecay,    TEveVector(1.884976e+02, 7.202000e+02, 7.919290e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kReference,
+                  TEveVectorD(-1.642659e+01, 1.640318e+01, -1.978269e+01),
+                  TEveVectorD(3.631100, 3.643450, 0.682254)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kReference,
+                  TEveVectorD(-1.859987e+00, 3.172243e+01, -1.697866e+01),
+                  TEveVectorD(3.456056, 3.809894, 0.682254)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kReference,
+                  TEveVectorD(4.847579e+01, 9.871711e+01, -5.835719e+00),
+                  TEveVectorD(2.711614, 4.409945, 0.687656)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(1.342045e+02, 4.203950e+02, 3.846268e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(1.483827e+02, 5.124750e+02, 5.064311e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(1.674676e+02, 6.167731e+02, 6.517403e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDecay,
+                  TEveVectorD(1.884976e+02, 7.202000e+02, 7.919290e+01)));
 
 	 track->SetRnrPoints(kTRUE);
 	 track->SetMarkerStyle(4);
@@ -322,15 +337,18 @@
 	 prop->RefPMAtt().SetMarkerStyle(4);
          list->SetElementName(Form("%s, Some ILC Detector field", list->GetElementName()));
 
-         TEveRecTrack *rc = new TEveRecTrack();
+         TEveRecTrackD *rc = new TEveRecTrackD();
          rc->fV.Set(57.1068, 31.2401, -7.07629);
          rc->fP.Set(4.82895, 2.35083, -0.611757);
          rc->fSign = 1;
          track = new TEveTrack(rc, prop);
 
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(1.692235e+02, 7.047929e+01, -2.064785e+01), TEveVector()));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDaughter, TEveVector(5.806180e+02, 6.990633e+01, -6.450000e+01), TEveVector()));
-         track->AddPathMark(TEvePathMark(TEvePathMark::kDecay,    TEveVector(6.527213e+02, 1.473249e+02, -8.348498e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(1.692235e+02, 7.047929e+01, -2.064785e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDaughter,
+                  TEveVectorD(5.806180e+02, 6.990633e+01, -6.450000e+01)));
+         track->AddPathMark(TEvePathMarkD(TEvePathMarkD::kDecay,
+                  TEveVectorD(6.527213e+02, 1.473249e+02, -8.348498e+01)));
 
 	 track->SetRnrPoints(kTRUE);
 	 track->SetMarkerStyle(4);
