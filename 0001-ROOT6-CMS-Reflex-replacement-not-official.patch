From e6268c9d4aab2b09710efe96bc8caf52ffc934ac Mon Sep 17 00:00:00 2001
From: David Abdurachmanov <David.Abdurachmanov@cern.ch>
Date: Thu, 21 Nov 2013 14:48:39 +0100
Subject: [PATCH] ROOT6 CMS Reflex replacement (not official)

Signed-off-by: David Abdurachmanov <David.Abdurachmanov@cern.ch>
---
 config/Makefile.linuxx8664gcc      |    2 +-
 core/meta/inc/TDictionary.h        |    3 +-
 core/meta/inc/TEnum.h              |    5 +-
 core/meta/inc/TFunction.h          |    1 +
 core/meta/inc/TInterpreter.h       |   50 +++
 core/meta/src/TCling.cxx           |  809 +++++++++++++++++++++++++++++++++++-
 core/meta/src/TCling.h             |   40 ++-
 core/meta/src/TClingCallFunc.cxx   |   25 ++
 core/meta/src/TClingCallFunc.h     |    6 +
 core/meta/src/TClingMethodInfo.cxx |    6 +-
 core/meta/src/TEnum.cxx            |   10 +-
 core/meta/src/TFunction.cxx        |   11 +
 12 files changed, 953 insertions(+), 15 deletions(-)

diff --git a/config/Makefile.linuxx8664gcc b/config/Makefile.linuxx8664gcc
index 7a87d62..b8c8d35 100644
--- a/config/Makefile.linuxx8664gcc
+++ b/config/Makefile.linuxx8664gcc
@@ -4,7 +4,7 @@
 
 PLATFORM      = linux
 
-DEBUGFLAGS    = -g
+DEBUGFLAGS    = -g -gdwarf-2 -O0
 #DEBUGFLAGS    = -gstabs
 OPTFLAGS      = -O2
 # Optional compiler options for gcc >= 3.4.0
diff --git a/core/meta/inc/TDictionary.h b/core/meta/inc/TDictionary.h
index a02ddae..9b10794 100644
--- a/core/meta/inc/TDictionary.h
+++ b/core/meta/inc/TDictionary.h
@@ -122,7 +122,8 @@ enum EFunctionProperty {
 */
    kIsConstructor = 0x00000001,
    kIsConversion  = 0x00000002,
-   kIsDestructor  = 0x00000004
+   kIsDestructor  = 0x00000004,
+   kIsOperator    = 0x00000008
 };
 
 enum EClassProperty {
diff --git a/core/meta/inc/TEnum.h b/core/meta/inc/TEnum.h
index 160bc1b..4124599 100644
--- a/core/meta/inc/TEnum.h
+++ b/core/meta/inc/TEnum.h
@@ -30,6 +30,7 @@
 #include "TString.h"
 #endif
 
+class TClass;
 class TEnumConstant;
 
 class TEnum : public TNamed {
@@ -37,14 +38,16 @@ class TEnum : public TNamed {
 private:
    THashList fConstantList;     //list of constants the enum type
    void*     fInfo;             //interpreter implementation provided declaration
+   TClass*   fClass;            //owning class
 
 public:
 
    TEnum(): fInfo(0) {}
-   TEnum(const char* name, bool isGlobal, void* info);
+   TEnum(const char* name, bool isGlobal, void* info, TClass* cls);
    virtual ~TEnum();
 
    void AddConstant(TEnumConstant* constant);
+   TClass* GetClass() const { return fClass; }
    const TSeqCollection* GetConstants() const { return &fConstantList; }
    const TEnumConstant* GetConstant(const char* name) const {
       return (TEnumConstant*) fConstantList.FindObject(name);
diff --git a/core/meta/inc/TFunction.h b/core/meta/inc/TFunction.h
index 7e83739..2e4261c 100644
--- a/core/meta/inc/TFunction.h
+++ b/core/meta/inc/TFunction.h
@@ -47,6 +47,7 @@ public:
    virtual            ~TFunction();
    virtual TObject    *Clone(const char *newname="") const;
    virtual const char *GetMangledName() const;
+   virtual const char *GetName() const;
    virtual const char *GetPrototype() const;
    const char         *GetSignature();
    const char         *GetReturnTypeName() const;
diff --git a/core/meta/inc/TInterpreter.h b/core/meta/inc/TInterpreter.h
index 579a44c..67d59f6 100644
--- a/core/meta/inc/TInterpreter.h
+++ b/core/meta/inc/TInterpreter.h
@@ -32,6 +32,8 @@
 #include "TMethodCall.h"
 #endif
 
+#include <vector>
+
 class TClass;
 class TEnv;
 class TFunction;
@@ -39,6 +41,13 @@ class TInterpreterValue;
 class TMethod;
 class TObjArray;
 class TVirtualMutex;
+class TType;
+
+namespace ROOT {
+namespace TMetaUtils {
+class TNormalizedCtxt;
+} // namespace TMetaUtils
+} // namespace ROOT
 
 R__EXTERN TVirtualMutex *gInterpreterMutex;
 
@@ -89,7 +98,12 @@ public:
    TInterpreter(const char *name, const char *title = "Generic Interpreter");
    virtual ~TInterpreter() { }
 
+   virtual void    *GetBackendInterpreter() const { return 0; }
+   ROOT::TMetaUtils::TNormalizedCtxt *GetNormalizedCtxt() const { return 0; }
+
    virtual void     AddIncludePath(const char *path) = 0;
+   virtual void    *SetAutoLoadCallBack(void* /*cb*/) { return 0; }
+   virtual void    *GetAutoLoadCallBack() const { return 0; }
    virtual Int_t    AutoLoad(const char *classname) = 0;
    virtual Int_t    AutoLoad(const type_info& typeinfo) = 0;
    virtual void     ClearFileBusy() = 0;
@@ -163,6 +177,7 @@ public:
    virtual void     Execute(const char *function, const char *params, int *error = 0) = 0;
    virtual void     Execute(TObject *obj, TClass *cl, const char *method, const char *params, int *error = 0) = 0;
    virtual void     Execute(TObject *obj, TClass *cl, TMethod *method, TObjArray *params, int *error = 0) = 0;
+   virtual void     ExecuteWithArgsAndReturn(TMethod *method, void* address, const std::vector<void*>& args = std::vector<void*>(), void* ret= 0) const = 0;
    virtual Long_t   ExecuteMacro(const char *filename, EErrorCode *error = 0) = 0;
    virtual Bool_t   IsErrorMessagesEnabled() const = 0;
    virtual Bool_t   SetErrorMessages(Bool_t enable = kTRUE) = 0;
@@ -223,6 +238,7 @@ public:
    virtual void   CallFunc_Exec(CallFunc_t * /* func */, void * /* address */) const {;}
    virtual void   CallFunc_Exec(CallFunc_t * /* func */, void * /* address */, TInterpreterValue& /* val */) const {;}
    virtual void   CallFunc_ExecWithReturn(CallFunc_t * /* func */, void * /* address */, void * /* ret */) const {;}
+   virtual void   CallFunc_ExecWithArgsAndReturn(CallFunc_t * /* func */, void * /* address */, const std::vector<void*>& /* args */ = std::vector<void*>(), void * /* ret */ = 0) const {}
    virtual Long_t    CallFunc_ExecInt(CallFunc_t * /* func */, void * /* address */) const {return 0;}
    virtual Long64_t  CallFunc_ExecInt64(CallFunc_t * /* func */, void * /* address */) const {return 0;}
    virtual Double_t  CallFunc_ExecDouble(CallFunc_t * /* func */, void * /* address */) const {return 0;}
@@ -396,6 +412,40 @@ public:
    virtual const char *TypedefInfo_Name(TypedefInfo_t * /* tinfo */) const {return 0;}
    virtual const char *TypedefInfo_Title(TypedefInfo_t * /* tinfo */) const {return 0;}
 
+
+   // Type interface
+   virtual bool Type_Bool(void* /*obj*/) const { return false; }
+   virtual bool Type_CheckType(void* /*obj*/, bool /*noComponents*/ = false) const { return false; }
+   virtual void Type_Delete(void* /*obj*/) const {}
+   virtual void Type_Dump(void* /*obj*/) const {}
+   virtual TType* Type_Factory() const { return 0; }
+   virtual TType* Type_Factory(const char* /*name*/) const { return 0; }
+   virtual TType* Type_Factory(const std::string& /*name*/) const { return 0; }
+   virtual TType* Type_Factory(const std::type_info& /*ti*/) const { return 0; }
+   virtual TType* Type_GetParent(void* /*obj*/) const { return 0; };
+   virtual void Type_Init(void* /*obj*/, const char* /*name*/) const {}
+   virtual void Type_Init(void* /*obj*/, const std::string& /*name*/) const {}
+   virtual void Type_Init(void* /*obj*/, const std::type_info& /*ti*/) const {}
+   virtual void Type_InitWithTypeInfoName(void* /*obj*/, const char* /*name*/) const {}
+   virtual bool Type_IsAbstract(void* /*obj*/) const { return false; }
+   virtual bool Type_IsClass(void* /*obj*/) const { return false; }
+   virtual bool Type_IsConst(void* /*obj*/) const { return false; }
+   virtual bool Type_IsDynamicClass(void* /*obj*/) const { return false; }
+   virtual bool Type_IsEnum(void* /*obj*/) const { return false; }
+   virtual bool Type_IsFundamental(void* /*obj*/) const { return false; }
+   virtual bool Type_IsPointer(void* /*obj*/) const { return false; }
+   virtual bool Type_IsReference(void* /*obj*/) const { return false; }
+   virtual bool Type_IsStruct(void* /*obj*/) const { return false; }
+   virtual bool Type_IsTemplateInstance(void* /*obj*/) const { return false; }
+   virtual bool Type_IsTypedef(void* /*obj*/) const { return false; }
+   virtual bool Type_IsUnion(void* /*obj*/) const { return false; }
+   virtual bool Type_IsValid(void* /*obj*/) const { return false; }
+   virtual bool Type_IsVirtual(void* /*obj*/) const { return false; }
+   virtual std::string Type_QualifiedName(void* /*obj*/) const { return ""; }
+   virtual unsigned long Type_Size(void* /*obj*/) const { return 0UL; }
+   virtual TType* Type_ToType(void* /*obj*/) const { return 0; }
+   virtual const std::type_info* Type_TypeInfo(void* /*obj*/) const { return 0; }
+
    static TInterpreter *Instance();
 
    ClassDef(TInterpreter,0)  //ABC defining interface to generic interpreter
diff --git a/core/meta/src/TCling.cxx b/core/meta/src/TCling.cxx
index 9165e53..1423d1a 100644
--- a/core/meta/src/TCling.cxx
+++ b/core/meta/src/TCling.cxx
@@ -106,9 +106,11 @@
 #include <stdint.h>
 #include <fstream>
 #include <string>
+#include <typeinfo>
 #include <utility>
 #include <vector>
 
+
 #include <cxxabi.h>
 #include <limits.h>
 #include <stdio.h>
@@ -157,6 +159,8 @@ using namespace ROOT;
 
 R__EXTERN int optind;
 
+static void* fgAutoLoadCallBack = 0;
+
 // The functions are used to bridge cling/clang/llvm compiled with no-rtti and
 // ROOT (which uses rtti)
 
@@ -242,7 +246,7 @@ void TCling::HandleEnumDecl(const clang::Decl* D, bool isGlobal, TClass *cl) con
    const char* name = buf.c_str();
 
    // Create the enum type.
-   TEnum* enumType = new TEnum(name, false /*!global*/, &D);
+   TEnum* enumType = new TEnum(name, false /*!global*/, &D, cl);
    // Check TEnum is created.
    if (!enumType) {
       Error ("HandleEnumDecl", "The enum type %s was not created.", name);
@@ -503,10 +507,29 @@ extern "C" void DestroyInterpreter(TInterpreter *interp)
    delete interp;
 }
 
+void* TCling::SetAutoLoadCallBack(void* cb)
+{
+   void* prev = fgAutoLoadCallBack;
+   fgAutoLoadCallBack = cb;
+   return prev;
+}
+
+void* TCling::GetAutoLoadCallBack() const
+{
+   return fgAutoLoadCallBack;
+}
+
 // Load library containing specified class. Returns 0 in case of error
 // and 1 in case if success.
 extern "C" int TCling__AutoLoadCallback(const char* className)
 {
+   if (fgAutoLoadCallBack) {
+      typedef int (*AutoLoadCallBack_t)(const char*);
+      int success = (*(AutoLoadCallBack_t)fgAutoLoadCallBack)(className);
+      if (success) {
+         return success;
+      }
+   }
    return ((TCling*)gCling)->AutoLoad(className);
 }
 
@@ -949,6 +972,12 @@ TCling::TCling(const char *name, const char *title)
 
 
 //______________________________________________________________________________
+void* TCling::GetBackendInterpreter() const
+{
+   return static_cast<void*>(fInterpreter);
+}
+
+//______________________________________________________________________________
 TCling::~TCling()
 {
    // Destroy the interpreter interface.
@@ -3243,19 +3272,33 @@ void TCling::Execute(TObject* obj, TClass* cl, TMethod* method,
    // 'obj' is unlikely to be the start of the object (as described by IsA()),
    // hence gInterpreter->Execute will improperly correct the offset.
    void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);
+   Long_t offset = 0L;
    TClingCallFunc func(fInterpreter);
    TClingMethodInfo *minfo = (TClingMethodInfo*)method->fInfo;
    func.Init(minfo);
    func.SetArgs(listpar);
-   // Now calculate the 'this' pointer offset for the method
-   // when starting from the class described by cl.
-   const CXXMethodDecl * mdecl = dyn_cast<CXXMethodDecl>(minfo->GetMethodDecl());
-   Long_t offset = ((TClingClassInfo*)cl->GetClassInfo())->GetOffset(mdecl);
    void* address = (void*)((Long_t)addr + offset);
    func.Exec(address);
 }
 
 //______________________________________________________________________________
+void TCling::ExecuteWithArgsAndReturn(TMethod* method, void* address,
+                                      const std::vector<void*>& args
+                                      /*= std::vector()*/,
+                                      void* ret/*= 0*/) const
+{
+   if (!method) {
+      Error("ExecuteWithArgsAndReturn", "No method was defined");
+      return;
+   }
+   R__LOCKGUARD2(gInterpreterMutex);
+   TClingCallFunc func(fInterpreter);
+   TClingMethodInfo* minfo = (TClingMethodInfo*) method->fInfo;
+   func.Init(minfo);
+   func.ExecWithArgsAndReturn(address, args, ret);
+}
+
+//______________________________________________________________________________
 Long_t TCling::ExecuteMacro(const char* filename, EErrorCode* error)
 {
    // Execute a cling macro.
@@ -4561,6 +4604,16 @@ void TCling::CallFunc_ExecWithReturn(CallFunc_t* func, void* address, void* ret)
 }
 
 //______________________________________________________________________________
+void TCling::CallFunc_ExecWithArgsAndReturn(CallFunc_t* func, void* address,
+                                            const std::vector<void*>& args
+                                            /*=std::vector<void*>()*/,
+                                            void* ret/*=0*/) const
+{
+   TClingCallFunc* f = (TClingCallFunc*) func;
+   f->ExecWithArgsAndReturn(address, args, ret);
+}
+
+//______________________________________________________________________________
 Long_t TCling::CallFunc_ExecInt(CallFunc_t* func, void* address) const
 {
    TClingCallFunc* f = (TClingCallFunc*) func;
@@ -5884,3 +5937,749 @@ const char* TCling::TypedefInfo_Title(TypedefInfo_t* tinfo) const
    TClingTypedefInfo* TClinginfo = (TClingTypedefInfo*) tinfo;
    return TClinginfo->Title();
 }
+
+//______________________________________________________________________________
+//
+//  TType
+//
+
+
+static
+std::string
+demangle(const char* mangled_name, int* err_ret)
+{
+  int err = 0;
+  char* name = abi::__cxa_demangle(mangled_name, 0, 0, &err);
+  if (err_ret) {
+    *err_ret = err;
+  }
+  if (err) {
+    if (err == -1) {
+      fprintf(stderr, "demangle: malloc failure!\n");
+    }
+    else if (err == -2) {
+      fprintf(stderr, "demangle: invalid mangled name!\n");
+    }
+    else if (err == -3) {
+      fprintf(stderr, "demangle: invalid argument!\n");
+    }
+    else {
+      fprintf(stderr, "demangle: unknown error!\n");
+    }
+  }
+  std::string retval;
+  if (!err) {
+    retval = std::string(name);
+  }
+  free(name);
+  return retval;
+}
+
+class TType {
+private:
+   cling::Interpreter* fInterp;
+   const std::type_info* fTypeInfo;
+   clang::QualType fType;
+public:
+   virtual ~TType();
+   TType();
+   TType(const TType& rhs);
+   TType& operator=(const TType& rhs);
+   TType(const std::type_info& ti);
+   TType(const char* name);
+   TType(const std::string& name);
+public:
+   operator bool() const;
+   bool CheckType(bool noComponents = false) const;
+   void Dump() const;
+   TType* GetParent() const;
+   void Init(clang::QualType QT);
+   void Init(const char* name);
+   void Init(const std::string& name);
+   void Init(const std::type_info& ti);
+   void InitWithTypeInfoName(const char* name);
+   bool IsAbstract() const;
+   bool IsClass() const;
+   bool IsConst() const;
+   bool IsDynamicClass() const;
+   bool IsEnum() const;
+   bool IsFundamental() const;
+   bool IsPointer() const;
+   bool IsReference() const;
+   bool IsStruct() const;
+   bool IsTemplateInstance() const;
+   bool IsTypedef() const;
+   bool IsUnion() const;
+   bool IsValid() const;
+   bool IsVirtual() const;
+   std::string QualifiedName() const;
+   unsigned long Size() const;
+   TType* ToType() const;
+   const std::type_info* TypeInfo() const;
+};
+
+TType::~TType()
+{
+}
+
+TType::TType()
+   : fInterp(0), fTypeInfo(0)
+{
+   fInterp = reinterpret_cast<cling::Interpreter*>(
+      gInterpreter->GetBackendInterpreter());
+}
+
+TType::TType(const TType& rhs)
+   : fInterp(rhs.fInterp), fTypeInfo(rhs.fTypeInfo), fType(rhs.fType)
+{
+}
+
+TType&
+TType::operator=(const TType& rhs)
+{
+   if (this != &rhs) {
+      fInterp = rhs.fInterp;
+      fTypeInfo = rhs.fTypeInfo;
+      fType = rhs.fType;
+   }
+   return *this;
+}
+
+TType::TType(const std::type_info& ti)
+   : fInterp(0), fTypeInfo(0)
+{
+   fInterp = reinterpret_cast<cling::Interpreter*>(
+      gInterpreter->GetBackendInterpreter());
+   Init(ti);
+}
+
+TType::TType(const char* name)
+   : fInterp(0), fTypeInfo(0)
+{
+   fInterp = reinterpret_cast<cling::Interpreter*>(
+      gInterpreter->GetBackendInterpreter());
+   Init(name);
+}
+
+TType::TType(const std::string& name)
+   : fInterp(0), fTypeInfo(0)
+{
+   fInterp = reinterpret_cast<cling::Interpreter*>(
+      gInterpreter->GetBackendInterpreter());
+   Init(name);
+}
+
+TType::operator bool() const
+{
+  return fInterp && !fType.isNull();
+}
+
+bool
+TType::CheckType(bool noComponents /*=false*/) const
+{
+   const CXXRecordDecl* RD = fType.getCanonicalType()->getAsCXXRecordDecl();
+   if (!RD) {
+      // Not a class, we are not interested.
+      return true;
+   }
+   // This is a class, struct, or union, now get the name.
+   PrintingPolicy Policy(RD->getASTContext().getPrintingPolicy());
+   string name;
+   llvm::raw_string_ostream stream(name);
+   RD->getNameForDiagnostic(stream, Policy, /*Qualified=*/true);
+   // Check for a dictionary.
+   TClass* cl = TClass::GetClass(name.c_str());
+   if (!cl) {
+      // No class bootstrap possible, no chance for a dictionary.
+      return false;
+   }
+   if (!cl->IsLoaded()) {
+      // We do not have a dictionary for this class.
+      return false;
+   }
+   // At this point we have determined that the class has a dictionary.
+   if (noComponents) {
+      // We are not going to check contained types, all done.
+      return true;
+   }
+   //
+   //  For standard library containers, check the contained classes,
+   //  that is, the template arguments.
+   //
+   //  For a non-standard library class, check the base classes and
+   //  the data members of class type for dictionaries.
+   //
+   if (name.find("std::") == 0) {
+      // This is a standard library class.
+      const ClassTemplateSpecializationDecl* CTSD =
+         llvm::dyn_cast<ClassTemplateSpecializationDecl>(RD);
+      if (!CTSD) {
+         // Not a container, we are not interested.
+         return true;
+      }
+      // The class is a template specialization, assume it is a
+      // standard library container and check the template
+      // arguments for dictionaries.
+      const TemplateArgumentList& TAL = CTSD->getTemplateArgs();
+      for (unsigned I = 0U, E = TAL.size(); I != E; ++I) {
+            const TemplateArgument& TA = TAL[I];
+         TemplateArgument::ArgKind AK = TA.getKind();
+         if (AK == TemplateArgument::Type) {
+           // A type template argument.
+           QualType QT = TA.getAsType();
+           TType Ty(*this);
+           Ty.Init(QT);
+           if (!Ty.CheckType()) {
+             return false;
+           }
+         }
+      }
+      return true;
+   }
+   // This is not a standard library class, check the base classes.
+   for (CXXRecordDecl::base_class_const_iterator I = RD->bases_begin(),
+         E = RD->bases_end(); I != E; ++I) {
+      const CXXBaseSpecifier& BS = *I;
+      QualType QT = BS.getType();
+      const CXXRecordDecl* BRD = QT.getCanonicalType()->getAsCXXRecordDecl();
+      if (!BRD) {
+         // Note: This cannot happen, but we test to keep static analyzers happy.
+         continue;
+      }
+      TType Ty(*this);
+      Ty.Init(QT);
+      if (!Ty.CheckType()) {
+         return false;
+      }
+   }
+   // This is not a standard library class, check the non-static data members
+   // of class type.
+   for (CXXRecordDecl::field_iterator I = RD->field_begin(),
+         E = RD->field_end(); I != E; ++I) {
+      // We are looping over non-static data members.
+      const FieldDecl* FD = *I;
+      QualType QT = FD->getType();
+      const CXXRecordDecl* FRD = QT.getCanonicalType()->getAsCXXRecordDecl();
+      if (!FRD) {
+         // Data member is not of class type, skip it.
+         continue;
+      }
+      if (FD->hasAttrs()) {
+         // The data member has attributes, look for the annotated attribute
+         // that rootcling/genreflex may have attached, and if there is one,
+         // check if the data member is marked transient/non-persistent and
+         // skip it if so.
+         bool skipIt = false;
+         for (Decl::attr_iterator AI = FD->attr_begin(), AE = FD->attr_end();
+               AI != AE; ++AI) {
+            AnnotateAttr* Attr = llvm::dyn_cast<AnnotateAttr>(*AI);
+            if (!Attr) {
+               // Not an annotation attribute, skip it.
+               continue;
+            }
+            string val = Attr->getAnnotation();
+            if (val.substr(0, 3) == "//!") {
+               // Data member is marked transient/not-persistent, skip it.
+               skipIt = true;
+               break;
+            }
+         }
+         if (skipIt) {
+            // Data member is marked transient/not-persistent, skip it.
+            continue;
+         }
+      }
+      // Not marked transient/not-persistent, check the type.
+      TType Ty(*this);
+      Ty.Init(QT);
+      if (!Ty.CheckType()) {
+         return false;
+      }
+   }
+   return true;
+}
+
+void
+TType::Dump() const
+{
+   fType.dump();
+}
+
+TType*
+TType::GetParent() const
+{
+   const Type* Ty = fType.getCanonicalType().getTypePtr();
+   if (const TagType* TT = Ty->getAs<TagType>()) {
+      const TagDecl* TD = TT->getDecl();
+      const DeclContext* DC = TD->getDeclContext();
+      if (DC->isTranslationUnit() || DC->isNamespace()) {
+         return 0;
+      }
+      if (DC->isRecord()) {
+         const Type* ParentTy = llvm::cast<RecordDecl>(DC)->getTypeForDecl();
+         TType* ret = new TType();
+         ret->Init(QualType(ParentTy, 0));
+         return ret;
+      }
+      if (DC->isFunctionOrMethod()) {
+         return 0;
+      }
+      // FIXME: Check for TagDecl
+      return 0;
+   }
+   return 0;
+}
+
+void
+TType::Init(QualType QT)
+{
+   fTypeInfo = 0;
+   fType = QT;
+   ASTContext& Context = fInterp->getCI()->getASTContext();
+   PrintingPolicy Policy(Context.getPrintingPolicy());
+   string name;
+   QT.getAsStringInternal(name, Policy);
+   string typeid_expr("&typeid(");
+   typeid_expr += name;
+   typeid_expr += ");";
+   cling::StoredValueRef valRef;
+   cling::Interpreter::CompilationResult cr = fInterp->evaluate(typeid_expr, valRef);
+   if (cr != cling::Interpreter::kSuccess) {
+      return;
+   }
+   if (!valRef.isValid()) {
+      return;
+   }
+   if (valRef.get().isVoid(fInterp->getCI()->getASTContext())) {
+      return;
+   }
+   fTypeInfo = (const std::type_info*) valRef.get().simplisticCastAs<unsigned long>();
+}
+
+void
+TType::Init(const char* name)
+{
+   fTypeInfo = 0;
+   const cling::LookupHelper& LH = fInterp->getLookupHelper();
+   fType = LH.findType(name);
+   if (fType.isNull()) {
+      if (gDebug > 0) {
+      }
+      return;
+   }
+   else {
+      if (gDebug > 0) {
+      }
+   }
+   string typeid_expr("&typeid(");
+   typeid_expr += name;
+   typeid_expr += ");";
+   cling::StoredValueRef valRef;
+   cling::Interpreter::CompilationResult cr = fInterp->evaluate(typeid_expr, valRef);
+   if (cr != cling::Interpreter::kSuccess) {
+      return;
+   }
+   if (!valRef.isValid()) {
+      return;
+   }
+   if (valRef.get().isVoid(fInterp->getCI()->getASTContext())) {
+      return;
+   }
+   fTypeInfo = (const std::type_info*) valRef.get().simplisticCastAs<unsigned long>();
+}
+
+void
+TType::Init(const string& name)
+{
+   Init(name.c_str());
+}
+
+void
+TType::Init(const std::type_info& ti)
+{
+   //fTypeInfo = &ti;
+   int err = 0;
+   std::string demangled_name = demangle(ti.name(), &err);
+   Init(demangled_name);
+}
+
+void
+TType::InitWithTypeInfoName(const char* name)
+{
+   fTypeInfo = 0;
+   int err = 0;
+   std::string demangled_name = demangle(name, &err);
+   Init(demangled_name);
+}
+
+bool
+TType::IsAbstract() const
+{
+   // Class has at least one pure virtual function.
+   const Type* Ty = fType.getCanonicalType().getTypePtr();
+   if (const CXXRecordDecl* RD = Ty->getAsCXXRecordDecl()) {
+      return RD->isAbstract();
+   }
+   if (const InjectedClassNameType* ICNTy =
+         Ty->getAs<InjectedClassNameType>()) {
+      const CXXRecordDecl* CRD = ICNTy->getDecl();
+      return CRD->isAbstract();
+   }
+   return false;
+}
+
+bool
+TType::IsClass() const
+{
+   // Note: This really means class, struct, or union.
+   const Type* Ty = fType.getCanonicalType().getTypePtr();
+   if (Ty->getAs<RecordType>()) {
+      return true;
+   }
+   if (Ty->getAs<InjectedClassNameType>()) {
+      return true;
+   }
+   return false;
+}
+
+bool
+TType::IsConst() const
+{
+   return fType.isConstQualified();
+}
+
+bool
+TType::IsDynamicClass() const
+{
+   // Class has a virtual table because it has at least one virtual
+   // member function, or at least one virtual base, or both.
+   const Type* Ty = fType.getCanonicalType().getTypePtr();
+   if (const CXXRecordDecl* RD = Ty->getAsCXXRecordDecl()) {
+      return RD->isDynamicClass();
+   }
+   if (const InjectedClassNameType* ICNTy =
+         Ty->getAs<InjectedClassNameType>()) {
+      const CXXRecordDecl* CRD = ICNTy->getDecl();
+      return CRD->isDynamicClass();
+   }
+   return false;
+}
+
+bool
+TType::IsEnum() const
+{
+   return fType.getCanonicalType()->isEnumeralType();
+}
+
+bool
+TType::IsFundamental() const
+{
+   return fType.getCanonicalType()->isFundamentalType();
+}
+
+bool
+TType::IsPointer() const
+{
+   return fType.getCanonicalType()->isPointerType();
+}
+
+bool
+TType::IsReference() const
+{
+   return fType.getCanonicalType()->isReferenceType();
+}
+
+bool
+TType::IsStruct() const
+{
+   // Note: Test for injected class name here?
+   return fType.getCanonicalType()->isStructureType();
+}
+
+bool
+TType::IsTemplateInstance() const
+{
+   if (CXXRecordDecl* RD = fType.getCanonicalType()->getAsCXXRecordDecl()) {
+      if (llvm::dyn_cast<ClassTemplateSpecializationDecl>(RD)) {
+         return true;
+      }
+   }
+   return false;
+}
+
+bool
+TType::IsTypedef() const
+{
+   return fType->getAs<TypedefType>();
+}
+
+bool
+TType::IsUnion() const
+{
+   // Note: Test for injected class name here?
+   return fType.getCanonicalType()->isUnionType();
+}
+
+bool
+TType::IsValid() const
+{
+   return !fType.isNull();
+}
+
+bool
+TType::IsVirtual() const
+{
+   // Class has at least one virtual member function.
+   const Type* Ty = fType.getCanonicalType().getTypePtr();
+   if (const CXXRecordDecl* RD = Ty->getAsCXXRecordDecl()) {
+      return RD->isPolymorphic();
+   }
+   if (const InjectedClassNameType* ICNTy =
+         Ty->getAs<InjectedClassNameType>()) {
+      const CXXRecordDecl* CRD = ICNTy->getDecl();
+      return CRD->isPolymorphic();
+   }
+   return false;
+}
+
+string
+TType::QualifiedName() const
+{
+   string name;
+   if (!IsValid()) {
+      return name;
+   }
+   ASTContext& Context = fInterp->getCI()->getASTContext();
+   PrintingPolicy Policy(Context.getPrintingPolicy());
+   fType.getAsStringInternal(name, Policy);
+   return name;
+}
+
+unsigned long
+TType::Size() const
+{
+   ASTContext& Context = fInterp->getCI()->getASTContext();
+   unsigned long ret =
+      Context.getTypeInfoDataSizeInChars(fType).first.getQuantity();
+   return ret;
+}
+
+TType*
+TType::ToType() const
+{
+   TType* ret = new TType();
+   if (!IsValid()) {
+      return ret;
+   }
+   QualType QT = fType.getCanonicalType();
+   if (QT->isReferenceType()) {
+      QT = llvm::cast<ReferenceType>(QT)->getPointeeType();
+      ret->Init(QT);
+      return ret;
+   }
+   else if (QT->isPointerType()) {
+      QT = llvm::cast<PointerType>(QT)->getPointeeType();
+      ret->Init(QT);
+      return ret;
+   }
+   else if (QT->isMemberPointerType()) {
+      QT = llvm::cast<MemberPointerType>(QT)->getPointeeType();
+      ret->Init(QT);
+      return ret;
+   }
+   else if (QT->isArrayType()) {
+      QT = llvm::cast<ArrayType>(QT)->getElementType();
+      ret->Init(QT);
+      return ret;
+   }
+   return ret;
+}
+
+const std::type_info*
+TType::TypeInfo() const
+{
+   return fTypeInfo;
+}
+
+bool TCling::Type_Bool(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->operator bool();
+}
+
+bool TCling::Type_CheckType(void* obj, bool noComponents /*= false*/) const
+{
+   TType* p = (TType*) obj;
+   return p->CheckType(noComponents);
+}
+
+void TCling::Type_Delete(void* obj) const
+{
+   TType* p = (TType*) obj;
+   delete p;
+}
+
+void TCling::Type_Dump(void* obj) const
+{
+   TType* p = (TType*) obj;
+   p->Dump();
+}
+
+TType* TCling::Type_Factory() const
+{
+   return new TType();
+}
+
+TType* TCling::Type_Factory(const char* name) const
+{
+   return new TType(name);
+}
+
+TType* TCling::Type_Factory(const std::string& name) const
+{
+   return new TType(name);
+}
+
+TType* TCling::Type_Factory(const std::type_info& ti) const
+{
+   return new TType(ti);
+}
+
+TType* TCling::Type_GetParent(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->GetParent();
+}
+
+void TCling::Type_Init(void* obj, const char* name) const
+{
+   TType* p = (TType*) obj;
+   p->Init(name);
+}
+
+void TCling::Type_Init(void* obj, const std::string& name) const
+{
+   TType* p = (TType*) obj;
+   p->Init(name);
+}
+
+void TCling::Type_Init(void* obj, const std::type_info& ti) const
+{
+   TType* p = (TType*) obj;
+   p->Init(ti);
+}
+
+void TCling::Type_InitWithTypeInfoName(void* obj, const char* name) const
+{
+   TType* p = (TType*) obj;
+   p->InitWithTypeInfoName(name);
+}
+
+bool TCling::Type_IsAbstract(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsAbstract();
+}
+
+bool TCling::Type_IsClass(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsClass();
+}
+
+bool TCling::Type_IsConst(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsConst();
+}
+
+bool TCling::Type_IsDynamicClass(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsDynamicClass();
+}
+
+bool TCling::Type_IsEnum(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsEnum();
+}
+
+bool TCling::Type_IsFundamental(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsFundamental();
+}
+
+bool TCling::Type_IsPointer(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsPointer();
+}
+
+bool TCling::Type_IsReference(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsReference();
+}
+
+bool TCling::Type_IsStruct(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsStruct();
+}
+
+bool TCling::Type_IsTemplateInstance(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsTemplateInstance();
+}
+
+bool TCling::Type_IsTypedef(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsTypedef();
+}
+
+bool TCling::Type_IsUnion(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsUnion();
+}
+
+bool TCling::Type_IsValid(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsValid();
+}
+
+bool TCling::Type_IsVirtual(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->IsVirtual();
+}
+
+std::string TCling::Type_QualifiedName(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->QualifiedName();
+}
+
+unsigned long TCling::Type_Size(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->Size();
+}
+
+TType* TCling::Type_ToType(void* obj) const
+{
+   TType* p = (TType*) obj;
+   return p->ToType();
+}
+
+const std::type_info* TCling::Type_TypeInfo(void *obj) const
+{
+   TType* p = (TType*) obj;
+   return p->TypeInfo();
+}
+
diff --git a/core/meta/src/TCling.h b/core/meta/src/TCling.h
index ed322a1..8e9a410 100644
--- a/core/meta/src/TCling.h
+++ b/core/meta/src/TCling.h
@@ -61,6 +61,7 @@ class THashTable;
 class TInterpreterValue;
 class TMethod;
 class TObjArray;
+class TType;
 
 namespace ROOT {
    namespace TMetaUtils {
@@ -125,9 +126,12 @@ public: // Public Interface
    virtual ~TCling();
    TCling(const char* name, const char* title);
 
-   cling::Interpreter *GetInterpreter() { return fInterpreter; }
+   void   *GetBackendInterpreter() const;
+   ROOT::TMetaUtils::TNormalizedCtxt *GetNormalizedCtxt() const { return fNormalizedCtxt; }
 
    void    AddIncludePath(const char* path);
+   void   *SetAutoLoadCallBack(void* cb);
+   void   *GetAutoLoadCallBack() const;
    Int_t   AutoLoad(const char* cls);
    Int_t   AutoLoad(const type_info& typeinfo);
    Bool_t  IsAutoLoadNamespaceCandidate(const char* name);
@@ -215,6 +219,7 @@ public: // Public Interface
    void    Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0);
    void    Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = 0);
    void    Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0);
+   void    ExecuteWithArgsAndReturn(TMethod* method, void* address, const std::vector<void*>& args = std::vector<void*>(), void* ret= 0) const;
    Long_t  ExecuteMacro(const char* filename, EErrorCode* error = 0);
    void    RecursiveRemove(TObject* obj);
    Bool_t  IsErrorMessagesEnabled() const;
@@ -271,6 +276,7 @@ public: // Public Interface
    virtual void   CallFunc_Exec(CallFunc_t* func, void* address) const;
    virtual void   CallFunc_Exec(CallFunc_t* func, void* address, TInterpreterValue& val) const;
    virtual void   CallFunc_ExecWithReturn(CallFunc_t* func, void* address, void* ret) const;
+   virtual void   CallFunc_ExecWithArgsAndReturn(CallFunc_t* func, void* address, const std::vector<void*>& args = std::vector<void*>(), void* ret = 0) const;
    virtual Long_t    CallFunc_ExecInt(CallFunc_t* func, void* address) const;
    virtual Long64_t  CallFunc_ExecInt64(CallFunc_t* func, void* address) const;
    virtual Double_t  CallFunc_ExecDouble(CallFunc_t* func, void* address) const;
@@ -444,6 +450,38 @@ public: // Public Interface
    virtual const char* TypedefInfo_Name(TypedefInfo_t* tinfo) const;
    virtual const char* TypedefInfo_Title(TypedefInfo_t* tinfo) const;
 
+   virtual bool Type_Bool(void* obj) const;
+   virtual bool Type_CheckType(void* obj, bool noComponents = false) const;
+   virtual void Type_Delete(void* obj) const;
+   virtual void Type_Dump(void* obj) const;
+   virtual TType* Type_Factory() const;
+   virtual TType* Type_Factory(const char* name) const;
+   virtual TType* Type_Factory(const std::string& name) const;
+   virtual TType* Type_Factory(const std::type_info& ti) const;
+   virtual TType* Type_GetParent(void* obj) const;
+   virtual void Type_Init(void* obj, const char* name) const;
+   virtual void Type_Init(void* obj, const std::string& name) const;
+   virtual void Type_Init(void* obj, const std::type_info& ti) const;
+   virtual void Type_InitWithTypeInfoName(void* obj, const char* name) const;
+   virtual bool Type_IsAbstract(void* obj) const;
+   virtual bool Type_IsClass(void* obj) const;
+   virtual bool Type_IsConst(void* obj) const;
+   virtual bool Type_IsDynamicClass(void* obj) const;
+   virtual bool Type_IsEnum(void* obj) const;
+   virtual bool Type_IsFundamental(void* obj) const;
+   virtual bool Type_IsPointer(void* obj) const;
+   virtual bool Type_IsReference(void* obj) const;
+   virtual bool Type_IsStruct(void* obj) const;
+   virtual bool Type_IsTemplateInstance(void* obj) const;
+   virtual bool Type_IsTypedef(void* obj) const;
+   virtual bool Type_IsUnion(void* obj) const;
+   virtual bool Type_IsValid(void* obj) const;
+   virtual bool Type_IsVirtual(void* obj) const;
+   virtual std::string Type_QualifiedName(void* obj) const;
+   virtual unsigned long Type_Size(void* obj) const;
+   virtual TType* Type_ToType(void* obj) const;
+   virtual const std::type_info* Type_TypeInfo(void* obj) const;
+
    std::set<TClass*>& GetModTClasses() { return fModTClasses; }
 
    void HandleNewDecl(const void* DV, bool isDeserialized, std::set<TClass*>& modifiedClasses);
diff --git a/core/meta/src/TClingCallFunc.cxx b/core/meta/src/TClingCallFunc.cxx
index 225da67..8fac459 100644
--- a/core/meta/src/TClingCallFunc.cxx
+++ b/core/meta/src/TClingCallFunc.cxx
@@ -2808,6 +2808,17 @@ TClingCallFunc::exec_with_valref_return(void* address, cling::StoredValueRef* re
 }
 
 void
+TClingCallFunc::exec_with_args_and_return(void* address,
+                                          const vector<void*>& args,
+                                          void* ret) const
+{
+   //const FunctionDecl* FD = fMethod->GetMethodDecl();
+   //unsigned num_params = FD->getNumParams();
+   unsigned num_args = args.size();
+   (*fWrapper)(address, (int)num_args, const_cast<void**>(args.data()), ret);
+}
+
+void
 TClingCallFunc::EvaluateArgList(const string& ArgList)
 {
    SmallVector<Expr*, 4> exprs;
@@ -2907,6 +2918,20 @@ TClingCallFunc::ExecDouble(void* address)
 }
 
 void
+TClingCallFunc::ExecWithArgsAndReturn(void* address, const vector<void*>& args
+                                      /*= vector<void*>()*/, void* ret/*= 0*/)
+{
+   IFacePtr();
+   if (!fWrapper) {
+      Error("TClingCallFunc::ExecWithArgsAndReturn(address, args, ret)",
+            "Called with no wrapper, not implemented!");
+      return;
+   }
+   exec_with_args_and_return(address, args, ret);
+   return;
+}
+
+void
 TClingCallFunc::ExecWithReturn(void* address, void* ret/*= 0*/)
 {
    IFacePtr();
diff --git a/core/meta/src/TClingCallFunc.h b/core/meta/src/TClingCallFunc.h
index 0a5c033..1d29a11 100644
--- a/core/meta/src/TClingCallFunc.h
+++ b/core/meta/src/TClingCallFunc.h
@@ -107,6 +107,9 @@ private:
    void exec(void* address, void* ret) const;
    void exec_with_valref_return(void* address,
                                 cling::StoredValueRef* ret) const;
+   void exec_with_args_and_return(void* address,
+                                  const std::vector<void*>& args,
+                                  void* ret) const;
 
    void EvaluateArgList(const std::string& ArgList);
 
@@ -147,6 +150,9 @@ public:
    void ExecDestructor(const TClingClassInfo* info, void* address = 0,
                        unsigned long nary = 0UL, bool withFree = true);
    void ExecWithReturn(void* address, void* ret = 0);
+   void ExecWithArgsAndReturn(void* address,
+                              const std::vector<void*>& args = std::vector<void*>(),
+                              void* ret = 0);
    void Exec(void* address, TInterpreterValue* interpVal = 0);
    long ExecInt(void* address);
    long long ExecInt64(void* address);
diff --git a/core/meta/src/TClingMethodInfo.cxx b/core/meta/src/TClingMethodInfo.cxx
index a8a6b28..2b97634 100644
--- a/core/meta/src/TClingMethodInfo.cxx
+++ b/core/meta/src/TClingMethodInfo.cxx
@@ -412,8 +412,10 @@ long TClingMethodInfo::ExtraProperty() const
    }
    long property = 0;
    const clang::FunctionDecl *fd = GetMethodDecl();
-   
-   if (llvm::isa<clang::CXXConversionDecl>(fd)) {
+   if (fd->isOverloadedOperator()) {
+      property |= kIsOperator;
+   }
+   else if (llvm::isa<clang::CXXConversionDecl>(fd)) {
       property |= kIsConversion;
    } else if (llvm::isa<clang::CXXConstructorDecl>(fd)) {
       property |= kIsConstructor;
diff --git a/core/meta/src/TEnum.cxx b/core/meta/src/TEnum.cxx
index 63da79c..de1f145 100644
--- a/core/meta/src/TEnum.cxx
+++ b/core/meta/src/TEnum.cxx
@@ -18,19 +18,21 @@
 #include "TEnum.h"
 #include "TEnumConstant.h"
 
-
 ClassImp(TEnum)
+
 //______________________________________________________________________________
-TEnum::TEnum(const char* name, bool isGlobal, void* info)
-: TNamed(name, "An enum type"), fInfo(info) {
+TEnum::TEnum(const char* name, bool isGlobal, void* info, TClass* cls)
+   : TNamed(name, "An enum type"), fInfo(info), fClass(cls)
+{
    //Constructor for TEnum class.
    //It take the name of the TEnum type, specification if it is global
    //and interpreter info.
    //Constant List is owner if enum not on global scope (thus constants not
    //in TROOT::GetListOfGlobals).
 
-   if (!isGlobal)
+   if (!isGlobal) {
       fConstantList.SetOwner(kTRUE);
+   }
 }
 
 //______________________________________________________________________________
diff --git a/core/meta/src/TFunction.cxx b/core/meta/src/TFunction.cxx
index a3f3c78..6f48c4e 100644
--- a/core/meta/src/TFunction.cxx
+++ b/core/meta/src/TFunction.cxx
@@ -222,6 +222,17 @@ const char *TFunction::GetMangledName() const
 }
 
 //______________________________________________________________________________
+const char *TFunction::GetName() const
+{
+   // Returns the unqualified function name, or 0 in case of error.
+   // Note: The caller must immediately make a copy of this value.
+   if (!fInfo) {
+      return 0;
+   }
+   return gInterpreter->MethodInfo_Name(fInfo);
+}
+
+//______________________________________________________________________________
 const char *TFunction::GetPrototype() const
 {
    // Returns the prototype of a function as defined by CINT, or 0 in
-- 
1.7.4.1

