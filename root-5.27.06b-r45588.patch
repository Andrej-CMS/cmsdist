Index: tree/tree/src/TTree.cxx
===================================================================
--- tree/tree/src/TTree.cxx	(revision 45587)
+++ tree/tree/src/TTree.cxx	(revision 45588)
@@ -359,6 +359,7 @@
 #include <sstream>
 #include <string>
 #include <stdio.h>
+#include <limits.h>
 
 Int_t    TTree::fgBranchStyle = 1;  // Use new TBranch style with TBranchElement.
 Long64_t TTree::fgMaxTreeSize = 100000000000LL;
@@ -7061,7 +7062,28 @@
          if (fEstimate <= 10000) {
             fEstimate = 1000000;
          }
-         fCacheSize    = fAutoFlush;
+         if (fAutoFlush < 0) {
+            // If there is no autoflush set, let's keep the cache completely
+            // disabled by default for now.
+            fCacheSize = fAutoFlush; 
+         } else if (fAutoFlush != 0) {
+            // Estimate the cluster size.
+            // This will allow TTree::Process to enable the cache.
+            if (fZipBytes != 0) {
+               fCacheSize =  fAutoFlush*(fZipBytes/fEntries);
+            } else if (fTotBytes != 0) {
+               fCacheSize =  fAutoFlush*(fTotBytes/fEntries);                  
+            } else {
+               fCacheSize = 30000000;
+            }
+            if (fCacheSize >= (INT_MAX / 4)) {
+               fCacheSize = INT_MAX / 4;
+            } else if (fCacheSize == 0) {
+               fCacheSize = 30000000;                  
+            }
+         } else {
+            fCacheSize = 0;
+         }
          ResetBit(kMustCleanup);
          return;
       }
Index: tree/tree/src/TTreeCache.cxx
===================================================================
--- tree/tree/src/TTreeCache.cxx	(revision 45587)
+++ tree/tree/src/TTreeCache.cxx	(revision 45588)
@@ -492,40 +492,110 @@
    Int_t flushIntervals = 0;
    Long64_t minEntry = fEntryCurrent;
    Long64_t prevNtot;
+   Long64_t maxReadEntry = minEntry; // If we are stopped before the end of the 2nd pass, this marker will where we need to start next time.
    do {
       prevNtot = fNtot;
-      for (Int_t i=0;i<fNbranches;i++) {
-         TBranch *b = (TBranch*)fBranches->UncheckedAt(i);
-         if (b->GetDirectory()==0) continue;
-         if (b->GetDirectory()->GetFile() != fFile) continue;
-         Int_t nb = b->GetMaxBaskets();
-         Int_t *lbaskets   = b->GetBasketBytes();
-         Long64_t *entries = b->GetBasketEntry();
-         if (!lbaskets || !entries) continue;
-         //we have found the branch. We now register all its baskets
-         //from the requested offset to the basket below fEntrymax
-         Int_t blistsize = b->GetListOfBaskets()->GetSize();
-         for (Int_t j=0;j<nb;j++) {
-            // This basket has already been read, skip it
-            if (j<blistsize && b->GetListOfBaskets()->UncheckedAt(j)) continue;
+      UInt_t pass = 0;
+      while (pass < 2) {
+         // The first pass we add one basket per branches.
+         // then in the second pass we add the other baskets of the cluster.
+         // This is to support the case where the cache is too small to hold a full cluster.
+         ++pass;
+         for (Int_t i=0;i<fNbranches;i++) {
+            TBranch *b = (TBranch*)fBranches->UncheckedAt(i);
+            if (b->GetDirectory()==0) continue;
+            if (b->GetDirectory()->GetFile() != fFile) continue;
+            Int_t nb = b->GetMaxBaskets();
+            Int_t *lbaskets   = b->GetBasketBytes();
+            Long64_t *entries = b->GetBasketEntry();
+            if (!lbaskets || !entries) continue;
+            //we have found the branch. We now register all its baskets
+            //from the requested offset to the basket below fEntrymax
+            Int_t blistsize = b->GetListOfBaskets()->GetSize();
+            Bool_t firstBasketSeen = kFALSE;
+            for (Int_t j=0;j<nb;j++) {
+               // This basket has already been read, skip it
+               if (j<blistsize && b->GetListOfBaskets()->UncheckedAt(j)) continue;
+               
+               Long64_t pos = b->GetBasketSeek(j);
+               Int_t len = lbaskets[j];
+               if (pos <= 0 || len <= 0) continue;
+               if (len > fBufferSizeMin) {
+                  // Do not cache a basket if it is bigger than the cache size!
+                  continue;
+               }
+               //important: do not try to read fEntryNext, otherwise you jump to the next autoflush
+               if (entries[j] >= fEntryNext) continue;
+               if (entries[j] < minEntry && (j<nb-1 && entries[j+1] <= minEntry)) continue;
+               if (elist) {
+                  Long64_t emax = fEntryMax;
+                  if (j<nb-1) emax = entries[j+1]-1;
+                  if (!elist->ContainsRange(entries[j]+chainOffset,emax+chainOffset)) continue;
+               }
+               if (pass==2 && !firstBasketSeen) {
+                  // Okay, this has already been requested in the first pass.
+                  firstBasketSeen = kTRUE;
+                  continue;
+               }
+               fNReadPref++;
+               if ( (fNtot+len) > fBufferSizeMin ) {
+                  // Humm ... we are going to go over the requested size.
+                  if (flushIntervals > 0) {
+                     // We already have a full cluster and now we would go over the requested
+                     // size, let's stop caching (and make sure we start next time from the
+                     // end of the previous cluster).
+                     if (gDebug > 5) {
+                        Info("FillBuffer","Breaking early because %d is greater than %d at cluster iteration %d will restart at %lld",(fNtot+len), fBufferSizeMin, flushIntervals,minEntry);
+                     }
+                     fEntryNext = minEntry;
+                     break;
+                  } else {
+                     if (pass == 1) {
+                        if ( (fNtot+len) > 4*fBufferSizeMin ) {
+                           // Okay, so we have not even made one pass and we already have
+                           // accumulated request for more than twice the memory size ...
+                           // So stop for now, and will restart at the same point, hoping
+                           // that the basket will still be in memory and not asked again ..
+                           fEntryNext = maxReadEntry;
+                           if (gDebug > 5) {
+                              Info("FillBuffer","Breaking early because %d is greater than 2*%d at cluster iteration %d pass %d will restart at %lld",(fNtot+len), fBufferSizeMin, flushIntervals,pass,fEntryNext);
+                           }
+                           break;
+                        }
+                     } else {
+                        // We have made one pass through the branches and thus already
+                        // requested one basket per branch, let's stop prefetching
+                        // now.
+                        if ( (fNtot+len) > 2*fBufferSizeMin ) {
+                           fEntryNext = maxReadEntry;
+                           if (gDebug > 5) {
+                              Info("FillBuffer","Breaking early because %d is greater than 2*%d at cluster iteration %d pass %d will restart at %lld",(fNtot+len), fBufferSizeMin, flushIntervals,pass,fEntryNext);
+                           }
+                           break;
+                        }
+                     }
+                  }
+               }
 
-            Long64_t pos = b->GetBasketSeek(j);
-            Int_t len = lbaskets[j];
-            if (pos <= 0 || len <= 0) continue;
-            //important: do not try to read fEntryNext, otherwise you jump to the next autoflush
-            if (entries[j] >= fEntryNext) continue;
-            if (entries[j] < minEntry && (j<nb-1 && entries[j+1] <= minEntry)) continue;
-            if (elist) {
-               Long64_t emax = fEntryMax;
-               if (j<nb-1) emax = entries[j+1]-1;
-               if (!elist->ContainsRange(entries[j]+chainOffset,emax+chainOffset)) continue;
+               TFileCacheRead::Prefetch(pos,len);
+               if ( ( j < (nb-1) ) && entries[j+1] > maxReadEntry ) {
+                  maxReadEntry = entries[j+1];
+               }
+               if (fNtot > 4*fBufferSizeMin) {
+                  // Humm something wrong happened.
+                  Warning("FillBuffer","There is more data in this cluster (starting at entry %lld to %lld, current=%lld) than usual ... with %d %.3f%% of the branches we already have %d bytes (instead of %d)",
+                          fEntryCurrent,fEntryNext, entries[j], i, (100.0*i) / ((float)fNbranches), fNtot,fBufferSizeMin);
+         
+               }
+               if (pass==1) {
+                  // In the first pass, we record one basket per branch and move on to the next branch.
+                  break;
+               }
             }
-            fNReadPref++;
-
-            TFileCacheRead::Prefetch(pos,len);
+            
+            if (gDebug > 0) printf("Entry: %lld, registering baskets branch %s, fEntryNext=%lld, fNseek=%d, fNtot=%d\n",minEntry,((TBranch*)fBranches->UncheckedAt(i))->GetName(),fEntryNext,fNseek,fNtot);
          }
-         if (gDebug > 0) printf("Entry: %lld, registering baskets branch %s, fEntryNext=%lld, fNseek=%d, fNtot=%d\n",minEntry,((TBranch*)fBranches->UncheckedAt(i))->GetName(),fEntryNext,fNseek,fNtot);
-      }
+      } // loop for the 2 passes. 
       flushIntervals++;
       minEntry += autoFlush;
 
