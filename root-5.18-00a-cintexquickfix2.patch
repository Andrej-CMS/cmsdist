--- cint/src/v6_init.cxx	(revision 23193)
+++ cint/src/v6_init.cxx	(working copy)
@@ -2457,6 +2457,11 @@
    G__catchexception = mode;
 }
 
+int G__GetCatchException()
+{
+   return G__catchexception;
+}
+
 } /* extern "C" */
 
 /*
--- cint/inc/G__ci.h	(revision 23193)
+++ cint/inc/G__ci.h	(working copy)
@@ -1692,6 +1692,7 @@
 extern G__EXPORT G__parse_hook_t* G__set_beforeparse_hook G__P((G__parse_hook_t* hook));
 extern G__EXPORT void G__set_ioctortype_handler G__P((int (*p2f) G__P((const char*))));
 extern G__EXPORT void G__SetCatchException G__P((int mode));
+extern G__EXPORT int G__GetCatchException G__P((void));
 
 #ifdef G__ASM_WHOLEFUNC
 /**************************************************************************
--- cintex/src/CINTFunctional.cxx	(revision 23193)
+++ cintex/src/CINTFunctional.cxx	(working copy)
@@ -21,6 +21,8 @@
 using namespace ROOT::Reflex;
 using namespace std;
 
+extern "C" int G__GetCatchException();
+
 namespace ROOT { namespace Cintex {
 
    class StubContexts : public vector<StubContext_t*>  {
@@ -184,6 +186,17 @@
       if ( !context->fInitialized ) context->Initialize();
       context->ProcessParam(libp);
   
+      if(!G__GetCatchException()) {
+
+         // Stub Calling
+         void* r = (*context->fStub)((void*)G__getstructoffset(), context->fParam, context->fStubctx);
+         context->ProcessResult(result, r);
+         if ( context->fRet_byvalue )  G__store_tempobject(*result);
+
+         return 1;
+   
+      }  
+
       // Catch here everything since going through the adaptor in the data section
       // does not transmit the exception 
       try {
