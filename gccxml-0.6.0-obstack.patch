diff -Naur orig.gccxml-0.6.0/GCC/include/obstack.h gccxml-0.6.0/GCC/include/obstack.h
--- orig.gccxml-0.6.0/GCC/include/obstack.h	2003-11-20 23:02:38.000000000 +0100
+++ gccxml-0.6.0/GCC/include/obstack.h	2007-10-25 17:49:10.000000000 +0200
@@ -91,17 +91,17 @@
 break the ordinary 'growth' macro.
 
 Summary:
-	We allocate large chunks.
-	We carve out one object at a time from the current chunk.
-	Once carved, an object never moves.
-	We are free to append data of any size to the currently
-	  growing object.
-	Exactly one object is growing in an obstack at any one time.
-	You can run one obstack per control block.
-	You may have as many control blocks as you dare.
-	Because of the way we do it, you can `unwind' an obstack
-	  back to a previous state. (You may remove objects much
-	  as you would with a stack.)
+        We allocate large chunks.
+        We carve out one object at a time from the current chunk.
+        Once carved, an object never moves.
+        We are free to append data of any size to the currently
+          growing object.
+        Exactly one object is growing in an obstack at any one time.
+        You can run one obstack per control block.
+        You may have as many control blocks as you dare.
+        Because of the way we do it, you can `unwind' an obstack
+          back to a previous state. (You may remove objects much
+          as you would with a stack.)
 */
 
 
@@ -158,42 +158,42 @@
 # endif
 #endif
 
-struct _obstack_chunk		/* Lives at front of each chunk. */
+struct _obstack_chunk           /* Lives at front of each chunk. */
 {
-  char  *limit;			/* 1 past end of this chunk */
-  struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
-  char	contents[4];		/* objects begin here */
+  char  *limit;                 /* 1 past end of this chunk */
+  struct _obstack_chunk *prev;  /* address of prior chunk or NULL */
+  char  contents[4];            /* objects begin here */
 };
 
-struct obstack		/* control current object in current chunk */
+struct obstack          /* control current object in current chunk */
 {
-  long	chunk_size;		/* preferred size to allocate chunks in */
-  struct _obstack_chunk *chunk;	/* address of current struct obstack_chunk */
-  char	*object_base;		/* address of object we are building */
-  char	*next_free;		/* where to add next char to current object */
-  char	*chunk_limit;		/* address of char after current chunk */
-  PTR_INT_TYPE temp;		/* Temporary for some macros.  */
-  int   alignment_mask;		/* Mask of alignment for each object. */
+  long  chunk_size;             /* preferred size to allocate chunks in */
+  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */
+  char  *object_base;           /* address of object we are building */
+  char  *next_free;             /* where to add next char to current object */
+  char  *chunk_limit;           /* address of char after current chunk */
+  PTR_INT_TYPE temp;            /* Temporary for some macros.  */
+  int   alignment_mask;         /* Mask of alignment for each object. */
 #if defined __STDC__ && __STDC__
   /* These prototypes vary based on `use_extra_arg', and we use
      casts to the prototypeless function type in all assignments,
      but having prototypes here quiets -Wstrict-prototypes.  */
   struct _obstack_chunk *(*chunkfun) (void *, long);
   void (*freefun) (void *, struct _obstack_chunk *);
-  void *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
+  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */
 #else
   struct _obstack_chunk *(*chunkfun) (); /* User's fcn to allocate a chunk.  */
-  void (*freefun) ();		/* User's function to free a chunk.  */
-  char *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
+  void (*freefun) ();           /* User's function to free a chunk.  */
+  char *extra_arg;              /* first arg for chunk alloc/dealloc funcs */
 #endif
-  unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
+  unsigned use_extra_arg:1;     /* chunk alloc/dealloc funcs take extra arg */
   unsigned maybe_empty_object:1;/* There is a possibility that the current
-				   chunk contains a zero-length object.  This
-				   prevents freeing the chunk if we allocate
-				   a bigger chunk to replace it. */
-  unsigned alloc_failed:1;	/* No longer used, as we now call the failed
-				   handler on error, but retained for binary
-				   compatibility.  */
+                                   chunk contains a zero-length object.  This
+                                   prevents freeing the chunk if we allocate
+                                   a bigger chunk to replace it. */
+  unsigned alloc_failed:1;      /* No longer used, as we now call the failed
+                                   handler on error, but retained for binary
+                                   compatibility.  */
 };
 
 /* Declare the external functions we use; they are in obstack.c.  */
@@ -202,10 +202,10 @@
 extern void _obstack_newchunk (struct obstack *, int);
 extern void _obstack_free (struct obstack *, void *);
 extern int _obstack_begin (struct obstack *, int, int,
-			    void *(*) (long), void (*) (void *));
+                            void *(*) (long), void (*) (void *));
 extern int _obstack_begin_1 (struct obstack *, int, int,
-			     void *(*) (void *, long),
-			     void (*) (void *, void *), void *);
+                             void *(*) (void *, long),
+                             void (*) (void *, void *), void *);
 extern int _obstack_memory_used (struct obstack *);
 #else
 extern void _obstack_newchunk ();
@@ -284,7 +284,7 @@
 
 /* Pointer to next byte not yet allocated in current chunk.  */
 
-#define obstack_next_free(h)	((h)->next_free)
+#define obstack_next_free(h)    ((h)->next_free)
 
 /* Mask specifying low bits that should be clear in address of an object.  */
 
@@ -296,20 +296,20 @@
 
 # define obstack_init(h) \
   _obstack_begin ((h), 0, 0, \
-		  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)
+                  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)
 
 # define obstack_begin(h, size) \
   _obstack_begin ((h), (size), 0, \
-		  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)
+                  (void *(*) (long)) obstack_chunk_alloc, (void (*) (void *)) obstack_chunk_free)
 
 # define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
   _obstack_begin ((h), (size), (alignment), \
-		    (void *(*) (long)) (chunkfun), (void (*) (void *)) (freefun))
+                    (void *(*) (long)) (chunkfun), (void (*) (void *)) (freefun))
 
 # define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
   _obstack_begin_1 ((h), (size), (alignment), \
-		    (void *(*) (void *, long)) (chunkfun), \
-		    (void (*) (void *, void *)) (freefun), (arg))
+                    (void *(*) (void *, long)) (chunkfun), \
+                    (void (*) (void *, void *)) (freefun), (arg))
 
 # define obstack_chunkfun(h, newchunkfun) \
   ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))
@@ -321,19 +321,19 @@
 
 # define obstack_init(h) \
   _obstack_begin ((h), 0, 0, \
-		  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)
+                  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)
 
 # define obstack_begin(h, size) \
   _obstack_begin ((h), (size), 0, \
-		  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)
+                  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)
 
 # define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
   _obstack_begin ((h), (size), (alignment), \
-		    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))
+                    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))
 
 # define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
   _obstack_begin_1 ((h), (size), (alignment), \
-		    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))
+                    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))
 
 # define obstack_chunkfun(h, newchunkfun) \
   ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))
@@ -343,7 +343,7 @@
 
 #endif
 
-#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)
+#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))
 
 #define obstack_blank_fast(h,n) ((h)->next_free += (n))
 
@@ -362,132 +362,141 @@
    without using a global variable.
    Also, we can avoid using the `temp' slot, to make faster code.  */
 
-# define obstack_object_size(OBSTACK)					\
-  __extension__								\
-  ({ struct obstack *__o = (OBSTACK);					\
+# define obstack_object_size(OBSTACK)                                   \
+  __extension__                                                         \
+  ({ struct obstack *__o = (OBSTACK);                                   \
      (unsigned) (__o->next_free - __o->object_base); })
 
-# define obstack_room(OBSTACK)						\
-  __extension__								\
-  ({ struct obstack *__o = (OBSTACK);					\
+# define obstack_room(OBSTACK)                                          \
+  __extension__                                                         \
+  ({ struct obstack *__o = (OBSTACK);                                   \
      (unsigned) (__o->chunk_limit - __o->next_free); })
 
-# define obstack_make_room(OBSTACK,length)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->chunk_limit - __o->next_free < __len)			\
-     _obstack_newchunk (__o, __len);					\
+# define obstack_make_room(OBSTACK,length)                              \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   int __len = (length);                                                \
+   if (__o->chunk_limit - __o->next_free < __len)                       \
+     _obstack_newchunk (__o, __len);                                    \
    (void) 0; })
 
-# define obstack_empty_p(OBSTACK)					\
-  __extension__								\
-  ({ struct obstack *__o = (OBSTACK);					\
+# define obstack_empty_p(OBSTACK)                                       \
+  __extension__                                                         \
+  ({ struct obstack *__o = (OBSTACK);                                   \
      (__o->chunk->prev == 0 && __o->next_free - __o->chunk->contents == 0); })
 
-# define obstack_grow(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->next_free + __len > __o->chunk_limit)			\
-     _obstack_newchunk (__o, __len);					\
-   _obstack_memcpy (__o->next_free, (where), __len);			\
-   __o->next_free += __len;						\
+# define obstack_grow(OBSTACK,where,length)                             \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   int __len = (length);                                                \
+   if (__o->next_free + __len > __o->chunk_limit)                       \
+     _obstack_newchunk (__o, __len);                                    \
+   _obstack_memcpy (__o->next_free, (where), __len);                    \
+   __o->next_free += __len;                                             \
    (void) 0; })
 
-# define obstack_grow0(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->next_free + __len + 1 > __o->chunk_limit)			\
-     _obstack_newchunk (__o, __len + 1);				\
-   _obstack_memcpy (__o->next_free, (where), __len);			\
-   __o->next_free += __len;						\
-   *(__o->next_free)++ = 0;						\
+# define obstack_grow0(OBSTACK,where,length)                            \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   int __len = (length);                                                \
+   if (__o->next_free + __len + 1 > __o->chunk_limit)                   \
+     _obstack_newchunk (__o, __len + 1);                                \
+   _obstack_memcpy (__o->next_free, (where), __len);                    \
+   __o->next_free += __len;                                             \
+   *(__o->next_free)++ = 0;                                             \
    (void) 0; })
 
-# define obstack_1grow(OBSTACK,datum)					\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   if (__o->next_free + 1 > __o->chunk_limit)				\
-     _obstack_newchunk (__o, 1);					\
-   *(__o->next_free)++ = (datum);					\
+# define obstack_1grow(OBSTACK,datum)                                   \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   if (__o->next_free + 1 > __o->chunk_limit)                           \
+     _obstack_newchunk (__o, 1);                                        \
+   obstack_1grow_fast (__o, datum);                                     \
    (void) 0; })
 
 /* These assume that the obstack alignment is good enough for pointers or ints,
    and that the data added so far to the current object
    shares that much alignment.  */
 
-# define obstack_ptr_grow(OBSTACK,datum)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
-     _obstack_newchunk (__o, sizeof (void *));				\
-   *((void **)__o->next_free)++ = ((void *)datum);			\
+# define obstack_ptr_grow(OBSTACK,datum)                                \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   if (__o->next_free + sizeof (void *) > __o->chunk_limit)             \
+     _obstack_newchunk (__o, sizeof (void *));                          \
+   obstack_ptr_grow_fast (__o, datum); })
+
+# define obstack_int_grow(OBSTACK,datum)                                \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   if (__o->next_free + sizeof (int) > __o->chunk_limit)                \
+     _obstack_newchunk (__o, sizeof (int));                             \
+   obstack_int_grow_fast (__o, datum); })
+
+# define obstack_ptr_grow_fast(OBSTACK,aptr)                            \
+__extension__                                                           \
+({ struct obstack *__o1 = (OBSTACK);                                    \
+   *(const void **) __o1->next_free = (aptr);                           \
+   __o1->next_free += sizeof (const void *);                            \
    (void) 0; })
 
-# define obstack_int_grow(OBSTACK,datum)				\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
-     _obstack_newchunk (__o, sizeof (int));				\
-   *((int *)__o->next_free)++ = ((int)datum);				\
+# define obstack_int_grow_fast(OBSTACK,aint)                            \
+__extension__                                                           \
+({ struct obstack *__o1 = (OBSTACK);                                    \
+   *(int *) __o1->next_free = (aint);                                   \
+   __o1->next_free += sizeof (int);                                     \
    (void) 0; })
 
-# define obstack_ptr_grow_fast(h,aptr) (*((void **) (h)->next_free)++ = (void *)aptr)
-# define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)
-
-# define obstack_blank(OBSTACK,length)					\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   int __len = (length);						\
-   if (__o->chunk_limit - __o->next_free < __len)			\
-     _obstack_newchunk (__o, __len);					\
-   __o->next_free += __len;						\
+# define obstack_blank(OBSTACK,length)                                  \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   int __len = (length);                                                \
+   if (__o->chunk_limit - __o->next_free < __len)                       \
+     _obstack_newchunk (__o, __len);                                    \
+   obstack_blank_fast (__o, __len);                                     \
    (void) 0; })
 
-# define obstack_alloc(OBSTACK,length)					\
-__extension__								\
-({ struct obstack *__h = (OBSTACK);					\
-   obstack_blank (__h, (length));					\
+# define obstack_alloc(OBSTACK,length)                                  \
+__extension__                                                           \
+({ struct obstack *__h = (OBSTACK);                                     \
+   obstack_blank (__h, (length));                                       \
    obstack_finish (__h); })
 
-# define obstack_copy(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__h = (OBSTACK);					\
-   obstack_grow (__h, (where), (length));				\
+# define obstack_copy(OBSTACK,where,length)                             \
+__extension__                                                           \
+({ struct obstack *__h = (OBSTACK);                                     \
+   obstack_grow (__h, (where), (length));                               \
    obstack_finish (__h); })
 
-# define obstack_copy0(OBSTACK,where,length)				\
-__extension__								\
-({ struct obstack *__h = (OBSTACK);					\
-   obstack_grow0 (__h, (where), (length));				\
+# define obstack_copy0(OBSTACK,where,length)                            \
+__extension__                                                           \
+({ struct obstack *__h = (OBSTACK);                                     \
+   obstack_grow0 (__h, (where), (length));                              \
    obstack_finish (__h); })
 
 /* The local variable is named __o1 to avoid a name conflict
    when obstack_blank is called.  */
-# define obstack_finish(OBSTACK)  					\
-__extension__								\
-({ struct obstack *__o1 = (OBSTACK);					\
-   void *value;								\
-   value = (void *) __o1->object_base;					\
-   if (__o1->next_free == value)					\
-     __o1->maybe_empty_object = 1;					\
-   __o1->next_free							\
+# define obstack_finish(OBSTACK)                                        \
+__extension__                                                           \
+({ struct obstack *__o1 = (OBSTACK);                                    \
+   void *value;                                                         \
+   value = (void *) __o1->object_base;                                  \
+   if (__o1->next_free == value)                                        \
+     __o1->maybe_empty_object = 1;                                      \
+   __o1->next_free                                                      \
      = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\
-		     & ~ (__o1->alignment_mask));			\
-   if (__o1->next_free - (char *)__o1->chunk				\
-       > __o1->chunk_limit - (char *)__o1->chunk)			\
-     __o1->next_free = __o1->chunk_limit;				\
-   __o1->object_base = __o1->next_free;					\
+                     & ~ (__o1->alignment_mask));                       \
+   if (__o1->next_free - (char *)__o1->chunk                            \
+       > __o1->chunk_limit - (char *)__o1->chunk)                       \
+     __o1->next_free = __o1->chunk_limit;                               \
+   __o1->object_base = __o1->next_free;                                 \
    value; })
 
-# define obstack_free(OBSTACK, OBJ)					\
-__extension__								\
-({ struct obstack *__o = (OBSTACK);					\
-   void *__obj = (OBJ);							\
+# define obstack_free(OBSTACK, OBJ)                                     \
+__extension__                                                           \
+({ struct obstack *__o = (OBSTACK);                                     \
+   void *__obj = (void *) (OBJ);                                        \
    if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
-     __o->next_free = __o->object_base = __obj;				\
+     __o->next_free = __o->object_base = (char *) __obj;                \
    else (obstack_free) (__o, __obj); })
 
 #else /* not __GNUC__ or not __STDC__ */
@@ -495,7 +504,7 @@
 # define obstack_object_size(h) \
  (unsigned) ((h)->next_free - (h)->object_base)
 
-# define obstack_room(h)		\
+# define obstack_room(h)                \
  (unsigned) ((h)->chunk_limit - (h)->next_free)
 
 # define obstack_empty_p(h) \
@@ -507,93 +516,96 @@
    Casting the third operand to void was tried before,
    but some compilers won't accept it.  */
 
-# define obstack_make_room(h,length)					\
-( (h)->temp = (length),							\
-  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
+# define obstack_make_room(h,length)                                    \
+( (h)->temp = (length),                                                 \
+  (((h)->next_free + (h)->temp > (h)->chunk_limit)                      \
    ? (_obstack_newchunk ((h), (h)->temp), 0) : 0))
 
-# define obstack_grow(h,where,length)					\
-( (h)->temp = (length),							\
-  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
-  _obstack_memcpy ((h)->next_free, (where), (h)->temp),			\
+# define obstack_grow(h,where,length)                                   \
+( (h)->temp = (length),                                                 \
+  (((h)->next_free + (h)->temp > (h)->chunk_limit)                      \
+   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),                      \
+  _obstack_memcpy ((h)->next_free, (where), (h)->temp),                 \
   (h)->next_free += (h)->temp)
 
-# define obstack_grow0(h,where,length)					\
-( (h)->temp = (length),							\
-  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)			\
-   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),			\
-  _obstack_memcpy ((h)->next_free, (where), (h)->temp),			\
-  (h)->next_free += (h)->temp,						\
+# define obstack_grow0(h,where,length)                                  \
+( (h)->temp = (length),                                                 \
+  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)                  \
+   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),                  \
+  _obstack_memcpy ((h)->next_free, (where), (h)->temp),                 \
+  (h)->next_free += (h)->temp,                                          \
   *((h)->next_free)++ = 0)
 
-# define obstack_1grow(h,datum)						\
-( (((h)->next_free + 1 > (h)->chunk_limit)				\
-   ? (_obstack_newchunk ((h), 1), 0) : 0),				\
-  (*((h)->next_free)++ = (datum)))
-
-# define obstack_ptr_grow(h,datum)					\
-( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
-   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
-  (*((char **) (((h)->next_free+=sizeof(char *))-sizeof(char *))) = ((char *) datum)))
-
-# define obstack_int_grow(h,datum)					\
-( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
-   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
-  (*((int *) (((h)->next_free+=sizeof(int))-sizeof(int))) = ((int) datum)))
-
-# define obstack_ptr_grow_fast(h,aptr) (*((char **) (h)->next_free)++ = (char *) aptr)
-# define obstack_int_grow_fast(h,aint) (*((int *) (h)->next_free)++ = (int) aint)
-
-# define obstack_blank(h,length)					\
-( (h)->temp = (length),							\
-  (((h)->chunk_limit - (h)->next_free < (h)->temp)			\
-   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
-  ((h)->next_free += (h)->temp))
+# define obstack_1grow(h,datum)                                         \
+( (((h)->next_free + 1 > (h)->chunk_limit)                              \
+   ? (_obstack_newchunk ((h), 1), 0) : 0),                              \
+  obstack_1grow_fast (h, datum))
+
+# define obstack_ptr_grow(h,datum)                                      \
+( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)                \
+   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),                \
+  obstack_ptr_grow_fast (h, datum))
+
+# define obstack_int_grow(h,datum)                                      \
+( (((h)->next_free + sizeof (int) > (h)->chunk_limit)                   \
+   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),                   \
+  obstack_int_grow_fast (h, datum))
+
+# define obstack_ptr_grow_fast(h,aptr)                                  \
+  (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))
+
+# define obstack_int_grow_fast(h,aint)                                  \
+  (((int *) ((h)->next_free += sizeof (int)))[-1] = (aptr))
+
+# define obstack_blank(h,length)                                        \
+( (h)->temp = (length),                                                 \
+  (((h)->chunk_limit - (h)->next_free < (h)->temp)                      \
+   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),                      \
+  obstack_blank_fast (h, (h)->temp))
 
-# define obstack_alloc(h,length)					\
+# define obstack_alloc(h,length)                                        \
  (obstack_blank ((h), (length)), obstack_finish ((h)))
 
-# define obstack_copy(h,where,length)					\
+# define obstack_copy(h,where,length)                                   \
  (obstack_grow ((h), (where), (length)), obstack_finish ((h)))
 
-# define obstack_copy0(h,where,length)					\
+# define obstack_copy0(h,where,length)                                  \
  (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
 
-# define obstack_finish(h)  						\
-( ((h)->next_free == (h)->object_base					\
-   ? (((h)->maybe_empty_object = 1), 0)					\
-   : 0),								\
-  (h)->temp = __PTR_TO_INT ((h)->object_base),				\
-  (h)->next_free							\
-    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)	\
-		    & ~ ((h)->alignment_mask)),				\
-  (((h)->next_free - (char *) (h)->chunk				\
-    > (h)->chunk_limit - (char *) (h)->chunk)				\
-   ? ((h)->next_free = (h)->chunk_limit) : 0),				\
-  (h)->object_base = (h)->next_free,					\
+# define obstack_finish(h)                                              \
+( ((h)->next_free == (h)->object_base                                   \
+   ? (((h)->maybe_empty_object = 1), 0)                                 \
+   : 0),                                                                \
+  (h)->temp = __PTR_TO_INT ((h)->object_base),                          \
+  (h)->next_free                                                        \
+    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask) \
+                    & ~ ((h)->alignment_mask)),                         \
+  (((h)->next_free - (char *) (h)->chunk                                \
+    > (h)->chunk_limit - (char *) (h)->chunk)                           \
+   ? ((h)->next_free = (h)->chunk_limit) : 0),                          \
+  (h)->object_base = (h)->next_free,                                    \
   __INT_TO_PTR ((h)->temp))
 
 # if defined __STDC__ && __STDC__
-#  define obstack_free(h,obj)						\
-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,			\
+#  define obstack_free(h,obj)                                           \
+( (h)->temp = (char *) (obj) - (char *) (h)->chunk,                     \
   (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
-   ? (int) ((h)->next_free = (h)->object_base				\
-	    = (h)->temp + (char *) (h)->chunk)				\
+   ? (int) ((h)->next_free = (h)->object_base                           \
+            = (h)->temp + (char *) (h)->chunk)                          \
    : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))
 # else
-#  define obstack_free(h,obj)						\
-( (h)->temp = (char *) (obj) - (char *) (h)->chunk,			\
+#  define obstack_free(h,obj)                                           \
+( (h)->temp = (char *) (obj) - (char *) (h)->chunk,                     \
   (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
-   ? (int) ((h)->next_free = (h)->object_base				\
-	    = (h)->temp + (char *) (h)->chunk)				\
+   ? (int) ((h)->next_free = (h)->object_base                           \
+            = (h)->temp + (char *) (h)->chunk)                          \
    : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))
 # endif
 
 #endif /* not __GNUC__ or not __STDC__ */
 
 #ifdef __cplusplus
-}	/* C++ */
+}       /* C++ */
 #endif
 
 #endif /* obstack.h */
