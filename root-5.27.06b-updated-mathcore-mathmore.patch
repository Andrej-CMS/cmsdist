commit f8432c5081e050208f9441802dda86f368b8988f
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Thu Sep 8 21:33:28 2011 +0200

    Updated mathmore / mathcore to work with roofit 5.30.00.

diff --git a/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h b/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h
index 3d64855..13a7786 100644
--- a/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h
+++ b/math/mathcore/inc/Math/AdaptiveIntegratorMultiDim.h
@@ -1,4 +1,4 @@
-// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
 // Author: M. Slawinska   08/2007 
 
 /**********************************************************************
@@ -43,19 +43,23 @@ class AdaptiveIntegratorMultiDim : public VirtualIntegratorMultiDim {
 public:
 
    /**
-      construct given optionally tolerance (absolute and relative) and maximum size of working array 
+      construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts)  and 
+      size of the working array. 
       The size of working array represents the number of sub-division used for calculating the integral. 
-      Higher the dimension, larger sizes are required for getting the same accuracy. 
+      Higher the dimension, larger sizes are required for getting the same accuracy.
+      The size must be larger than  >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the 
+      minimum allowed will be used
    */
    explicit 
-   AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int size = 100000);
+   AdaptiveIntegratorMultiDim(double absTol = 1.E-6, double relTol = 1E-6, unsigned int maxpts = 100000, unsigned int size = 0);
 
    /**
-      construct with a reference to the integrand function and given optionally 
-      tolerance (absolute and relative) and maximum size of working array.
+      Construct with a reference to the integrand function and given optionally 
+      tolerance (absolute and relative), maximum number of function evaluation (maxpts)  and 
+      size of the working array. 
    */
    explicit
-   AdaptiveIntegratorMultiDim(const IMultiGenFunction &f, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 100000);
+   AdaptiveIntegratorMultiDim(const IMultiGenFunction &f, double absTol = 1.E-9, double relTol = 1E-6,  unsigned int maxcall = 100000, unsigned int size = 0);
 
    /**
       destructor (no operations)
@@ -90,7 +94,7 @@ public:
    int Status() const { return fStatus; }
 
    /// return number of function evaluations in calculating the integral 
-   unsigned int NEval() const { return fNEval; }
+   int NEval() const { return fNEval; }
  
    /// set relative tolerance 
    void SetRelTolerance(double relTol);
@@ -98,6 +102,21 @@ public:
    /// set absolute tolerance
    void SetAbsTolerance(double absTol);
 
+   ///set workspace size 
+   void SetSize(unsigned int size) { fSize = size; }
+
+   ///set min points
+   void SetMinPts(unsigned int n) { fMinPts = n; }
+
+   ///set max points
+   void SetMaxPts(unsigned int n) { fMaxPts = n; }
+
+   /// set the options 
+   void SetOptions(const ROOT::Math::IntegratorMultiDimOptions & opt);
+
+   ///  get the option used for the integration 
+   ROOT::Math::IntegratorMultiDimOptions Options() const;
+
 protected: 
 
    // internal function to compute the integral (if absVal is true compute abs value of function integral
@@ -106,15 +125,16 @@ protected:
  private:
 
    unsigned int fDim;     // dimentionality of integrand
-
+   unsigned int fMinPts;    // minimum number of function evaluation requested 
+   unsigned int fMaxPts;    // maximum number of function evaluation requested 
+   unsigned int fSize;    // max size of working array (explode with dimension)
    double fAbsTol;        // absolute tolerance
    double fRelTol;        // relative tolerance
-   unsigned int fSize;    // max size of working array (explode with dimension)
 
    double fResult;        // last integration result 
    double fError;         // integration error 
    double fRelError;      // Relative error
-   unsigned int  fNEval;  // number of function evaluation
+   int    fNEval;        // number of function evaluation
    int fStatus;   // status of algorithm (error if not zero)
 
    const IMultiGenFunction* fFun;   // pointer to integrand function 
diff --git a/math/mathcore/inc/Math/GenAlgoOptions.h b/math/mathcore/inc/Math/GenAlgoOptions.h
new file mode 100644
index 0000000..205f0ef
--- /dev/null
+++ b/math/mathcore/inc/Math/GenAlgoOptions.h
@@ -0,0 +1,159 @@
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
+// Author: L. Moneta Nov 2010
+
+/**********************************************************************
+ *                                                                    *
+ * Copyright (c) 2010  LCG ROOT Math Team, CERN/PH-SFT                *
+ *                                                                    *
+ *                                                                    *
+ **********************************************************************/
+
+#ifndef ROOT_Math_GenAlgoOptions
+#define ROOT_Math_GenAlgoOptions
+
+
+#ifndef ROOT_Math_IOptions
+#include "Math/IOptions.h"
+#endif
+
+#include <map>
+#include <iomanip>
+
+namespace ROOT { 
+      namespace Math { 
+
+//_______________________________________________________________________________
+/** 
+    class implementing generic options for a numerical algorithm
+    Just store the otions in a maps of string-value pair 
+
+    @ingroup NumAlgo
+*/
+class GenAlgoOptions : public IOptions {
+
+public:
+
+   GenAlgoOptions() /* : fExtraOptions(0) */  {}
+
+   virtual ~GenAlgoOptions() {}// { if (fExtraOptions) delete fExtraOptions; }
+
+   // use default copy constructor and assignment operator
+
+   /** generic  methods for  retrivieng options */
+
+
+   // methods implementing the  IOptions interface
+
+   virtual IOptions * Clone() const { 
+      return new GenAlgoOptions(*this);
+   }
+
+   // t.b.d need probably to implement in a .cxx file for CINT 
+
+
+   virtual bool GetRealValue(const char * name, double & val) const { 
+      const double * pval = FindValue(name, fRealOpts);
+      if (!pval) return false; 
+      val = *pval;
+      return true; 
+   }
+
+   virtual bool GetIntValue(const char * name, int & val) const { 
+      const int * pval = FindValue(name, fIntOpts);
+      if (!pval) return false;
+      val = *pval;
+      return true; 
+   }
+
+   virtual bool GetNamedValue(const char * name, std::string & val) const { 
+      const std::string * pval = FindValue(name, fNamOpts);
+      if (!pval) return false; 
+      val = *pval;
+      return true;
+   }
+
+   /// method wich need to be re-implemented by the derived classes 
+   virtual void SetRealValue(const char * name, double val)  {
+      InsertValue(name, fRealOpts, val);
+   }
+
+   virtual void SetIntValue(const char * name , int val) {
+      InsertValue(name, fIntOpts, val);
+   }
+
+   virtual void SetNamedValue(const char * name, const char * val) {
+      InsertValue(name, fNamOpts, std::string(val));
+   }
+
+
+   /// print options 
+   virtual void Print(std::ostream & os = std::cout ) const {
+      Print(fNamOpts,os);
+      Print(fIntOpts,os);
+      Print(fRealOpts,os);
+   } 
+
+
+   // static methods to retrieve the default options 
+
+   // find the option given a name 
+   // return 0 if the option is not found
+   static IOptions * FindDefault(const char * algoname);
+
+   // retrieve options given the name 
+   // if option is not found create a new GenAlgoOption for the given name 
+   static IOptions & Default(const char * algoname);
+
+   /// print all the default options
+   static void PrintAllDefault(std::ostream & os = std::cout); 
+
+
+protected: 
+
+   
+
+private: 
+   
+   template<class M> 
+   static const typename M::mapped_type * FindValue(const std::string &  name, const M & opts) {
+      typename M::const_iterator pos; 
+      pos = opts.find(name); 
+      if (pos == opts.end()) { 
+         return 0; 
+      }
+      return  &((*pos).second); 
+   }  
+
+   template<class M> 
+   static void InsertValue(const std::string &name, M & opts, const typename M::mapped_type & value) {
+      typename M::iterator pos; 
+      pos = opts.find(name); 
+      if (pos != opts.end()) { 
+         pos->second = value; 
+      }
+      else { 
+         opts.insert(typename M::value_type(name, value) );
+      }
+   }  
+
+   template<class M> 
+   static void Print( const M & opts, std::ostream & os) {
+      //const std::ios_base::fmtflags prevFmt = os.flags(); 
+      for (typename M::const_iterator pos = opts.begin(); pos != opts.end(); ++pos) 
+         os << std::setw(25) << pos->first << " : " << std::setw(15) << pos->second << std::endl;
+   }  
+
+
+   std::map<std::string, double>      fRealOpts;   // map of the real options 
+   std::map<std::string, int>         fIntOpts;    // map of the integer options 
+   std::map<std::string, std::string> fNamOpts;    // map of the named options
+    
+};
+
+
+
+   } // end namespace Math
+
+} // end namespace ROOT
+
+#endif
diff --git a/math/mathcore/inc/Math/IOptions.h b/math/mathcore/inc/Math/IOptions.h
new file mode 100644
index 0000000..ee25bed
--- /dev/null
+++ b/math/mathcore/inc/Math/IOptions.h
@@ -0,0 +1,119 @@
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
+// Author: L. Moneta Fri Aug 15 2008
+
+/**********************************************************************
+ *                                                                    *
+ * Copyright (c) 2008  LCG ROOT Math Team, CERN/PH-SFT                *
+ *                                                                    *
+ *                                                                    *
+ **********************************************************************/
+
+#ifndef ROOT_Math_IOptions
+#define ROOT_Math_IOptions
+
+
+#ifndef ROOT_Math_Error
+#include "Math/Error.h"
+#endif
+
+#include <iostream>
+
+namespace ROOT { 
+   
+
+   namespace Math { 
+
+//_______________________________________________________________________________
+/** 
+    Generic interface for defining configuration options of a numerical algorithm
+
+    @ingroup NumAlgo
+*/
+class IOptions {
+
+public:
+
+   IOptions() /* : fExtraOptions(0) */  {}
+
+   virtual ~IOptions() {}// { if (fExtraOptions) delete fExtraOptions; }
+
+   // copy the options 
+   virtual IOptions * Clone() const = 0; 
+
+   /** generic  methods for  retrivieng options */
+
+   /// set option value 
+   void SetValue(const char * name, double val) { SetRealValue(name,val);}
+   void SetValue(const char * name, int val) { SetIntValue(name,val);}
+   void SetValue(const char * name, const char * val) { SetNamedValue(name,val);}
+
+   
+   double  RValue(const char * name) const {
+      double val = 0;
+      bool ret = GetRealValue(name,val);
+      if (!ret )  MATH_ERROR_MSGVAL("IOptions::RValue"," return 0 - real option not found",name); 
+      return val;
+   }
+
+   int   IValue(const char * name) const {
+      int val = 0;
+      bool ret = GetIntValue(name,val);
+      if (!ret )   MATH_ERROR_MSGVAL("IOptions::IValue"," return 0 - integer option not found",name); 
+      return val;
+   }
+
+   std::string  NamedValue(const char * name) const {
+      std::string val;
+      bool ret = GetNamedValue(name,val);
+      if (!ret )  MATH_ERROR_MSGVAL("IOptions::NamedValue"," return empty string - named option not found",name); 
+      return val;
+   }
+
+
+   // generic method to retrieve  a type 
+   template <typename T>
+   bool GetValue(const char * name, T & t) const { 
+      bool ret = DoGetValue(name, t);
+      //if (!ret )  MATH_ERROR_MSG("IOptions::GetValue","option is not existing - returns 0"); 
+      return ret; 
+   }
+
+
+   // methods to be re-implemented in the derived classes 
+
+
+   virtual bool GetRealValue(const char *, double &) const { return false; }
+
+   virtual bool GetIntValue(const char *, int &) const { return false; }
+
+   virtual bool GetNamedValue(const char *, std::string &) const { return false; }
+
+   /// method wich need to be re-implemented by the derived classes 
+   virtual void SetRealValue(const char * , double )  {MATH_ERROR_MSG("IOptions::SetRealValue","Invalid setter method called"); }
+
+   virtual void SetIntValue(const char * , int ) {MATH_ERROR_MSG("IOptions::SetIntValue","Invalid setter method called"); }
+
+   virtual void SetNamedValue(const char * , const char * ) {MATH_ERROR_MSG("IOptions::SetNamedValue","Invalid setter method called"); }
+
+
+   /// print options 
+   virtual void Print(std::ostream & = std::cout ) const {MATH_INFO_MSG("IOptions::Print","it is not implemented");}
+
+
+private: 
+
+   bool DoGetValue(const char *name, double &val) const { return GetRealValue(name,val); }
+
+   bool DoGetValue(const char *name, int &val) const { return GetIntValue(name,val); }
+
+   bool DoGetValue(const char *name, std::string &val) const { return GetNamedValue(name,val); }
+
+   
+};
+
+
+   } // end namespace Math
+
+} // end namespace ROOT
+
+#endif
diff --git a/math/mathcore/inc/Math/Integrator.h b/math/mathcore/inc/Math/Integrator.h
index 4138c53..2fd4cc7 100644
--- a/math/mathcore/inc/Math/Integrator.h
+++ b/math/mathcore/inc/Math/Integrator.h
@@ -1,4 +1,4 @@
-// @(#)root/mathmore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
+// @(#)root/mathmore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
 // Authors: L. Moneta, M. Slawinska 10/2007
 
  /**********************************************************************
@@ -18,6 +18,10 @@
 #include "Math/AllIntegrationTypes.h"
 #endif
 
+#ifndef ROOT_Math_IntegratorOptions
+#include "Math/IntegratorOptions.h"
+#endif
+
 #ifndef ROOT_Math_IFunction
 #include "Math/IFunction.h"
 #endif
@@ -43,6 +47,7 @@ namespace ROOT {
 namespace Math {
 
 
+   
 
 //____________________________________________________________________________________________
 /**
@@ -81,7 +86,7 @@ class IntegratorOneDim {
 
 public:
 
-
+   typedef IntegrationOneDim::Type Type;   // for the enumerations defining the types 
 
     // constructors
 
@@ -98,9 +103,11 @@ public:
        Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL)
        Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6)
        lower rules are indicated for singular functions while higher for smooth functions to get better accuracies
+
+       NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions 
     */
     explicit
-    IntegratorOneDim(IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVESINGULAR, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, unsigned int rule = 3) :
+    IntegratorOneDim(IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0) :
        fIntegrator(0), fFunc(0)
    { 
       fIntegrator = CreateIntegrator(type, absTol, relTol, size, rule); 
@@ -115,9 +122,11 @@ public:
        @param relTol desired relative Error
        @param size maximum number of sub-intervals
        @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type)  
+
+       NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions 
     */
    explicit 
-   IntegratorOneDim(const IGenFunction &f, IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3) :
+   IntegratorOneDim(const IGenFunction &f, IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0) :
       fIntegrator(0), fFunc(0)
    { 
       fIntegrator = CreateIntegrator(type, absTol, relTol, size, rule); 
@@ -137,7 +146,7 @@ public:
 
    template<class Function>
    explicit
-   IntegratorOneDim(Function & f, IntegrationOneDim::Type type = IntegrationOneDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000, int rule = 3) : 
+   IntegratorOneDim(Function & f, IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0) : 
       fIntegrator(0), fFunc(0)
    { 
       fIntegrator = CreateIntegrator(type, absTol, relTol, size, rule); 
@@ -393,6 +402,12 @@ public:
    */
    int Status() const { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }
 
+   /**
+      return number of function evaluations in calculating the integral 
+      (if integrator do not implement this function returns -1)
+   */
+   int NEval() const { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }
+
 
    // setter for control Parameters  (getters are not needed so far )
 
@@ -412,9 +427,25 @@ public:
    */
    VirtualIntegratorOneDim * GetIntegrator() { return fIntegrator; }  
 
+   /** 
+       set the options 
+   */
+   void SetOptions(const ROOT::Math::IntegratorOneDimOptions & opt) { if (fIntegrator) fIntegrator->SetOptions(opt); }
+
+   /** 
+       retrieve the options 
+   */
+   ROOT::Math::IntegratorOneDimOptions Options() const { return (fIntegrator) ? fIntegrator->Options() : IntegratorOneDimOptions(); }
+
+   /// return name of integrator
+   std::string Name() const { return (fIntegrator) ? Options().Integrator() : std::string(""); }
+
    /// static function to get the enumeration from a string
    static IntegrationOneDim::Type GetType(const char * name);  
 
+   /// static function to get a string from the enumeration
+   static std::string GetName(IntegrationOneDim::Type);  
+
 
 protected: 
 
diff --git a/math/mathcore/inc/Math/IntegratorMultiDim.h b/math/mathcore/inc/Math/IntegratorMultiDim.h
index b841eab..75dc580 100644
--- a/math/mathcore/inc/Math/IntegratorMultiDim.h
+++ b/math/mathcore/inc/Math/IntegratorMultiDim.h
@@ -23,6 +23,9 @@
 #include "Math/AllIntegrationTypes.h"
 #endif
 
+#ifndef ROOT_Math_IntegratorOptions
+#include "Math/IntegratorOptions.h"
+#endif
 
 #ifndef ROOT_Math_VirtualIntegrator
 #include "Math/VirtualIntegrator.h"
@@ -58,6 +61,7 @@ class IntegratorMultiDim {
 
 public:
 
+   typedef IntegrationMultiDim::Type Type;   // for the enumerations defining the types 
 
   
     /** Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method 
@@ -66,9 +70,11 @@ public:
        @param absTol desired absolute Error
        @param relTol desired relative Error
        @param size maximum number of sub-intervals
+
+       In case no parameter  values are passed the default ones used in IntegratorMultiDimOptions are used  
     */
    explicit 
-   IntegratorMultiDim(IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) :
+   IntegratorMultiDim(IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0) :
       fIntegrator(0), fFunc(0)
    { 
        fIntegrator = CreateIntegrator(type, absTol, relTol, ncall); 
@@ -83,7 +89,7 @@ public:
        @param ncall  number of function calls (apply only to MC integratioon methods)
     */
    explicit
-   IntegratorMultiDim(const IMultiGenFunction &f, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) :
+   IntegratorMultiDim(const IMultiGenFunction &f, IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0) :
       fIntegrator(0), fFunc(0)
    { 
       fIntegrator = CreateIntegrator(type, absTol, relTol, ncall); 
@@ -113,6 +119,7 @@ public:
       if (fIntegrator) delete fIntegrator;
    }
 
+
    // disable copy constructur and assignment operator 
 
 private:
@@ -176,12 +183,24 @@ public:
    /// set absolute tolerance
    void SetAbsTolerance(double absTol)  { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }
 
+   /// set the options 
+   void SetOptions(const ROOT::Math::IntegratorMultiDimOptions & opt) { if (fIntegrator) fIntegrator->SetOptions(opt); }
+
+   /// retrieve the options 
+   ROOT::Math::IntegratorMultiDimOptions Options() const { return (fIntegrator) ? fIntegrator->Options() : IntegratorMultiDimOptions(); } 
+
    /// return a pointer to integrator object 
    VirtualIntegratorMultiDim * GetIntegrator() { return fIntegrator; }  
 
+   /// return name of integrator
+   std::string Name() const { return (fIntegrator) ? Options().Integrator() : std::string(""); }
+
    /// static function to get the enumeration from a string
    static IntegrationMultiDim::Type GetType(const char * name);  
 
+   /// static function to get a string from the enumeration
+   static std::string GetName(IntegrationMultiDim::Type);  
+
 protected:
 
    VirtualIntegratorMultiDim * CreateIntegrator(IntegrationMultiDim::Type type , double absTol, double relTol, unsigned int ncall);
diff --git a/math/mathcore/inc/Math/IntegratorOptions.h b/math/mathcore/inc/Math/IntegratorOptions.h
new file mode 100644
index 0000000..3cb83b0
--- /dev/null
+++ b/math/mathcore/inc/Math/IntegratorOptions.h
@@ -0,0 +1,273 @@
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
+// Author: L. Moneta Fri Aug 15 2008
+
+/**********************************************************************
+ *                                                                    *
+ * Copyright (c) 2008  LCG ROOT Math Team, CERN/PH-SFT                *
+ *                                                                    *
+ *                                                                    *
+ **********************************************************************/
+
+#ifndef ROOT_Math_IntegratorOptions
+#define ROOT_Math_IntegratorOptions
+
+#ifndef ROOT_Math_AllIntegrationTypes
+#include "Math/AllIntegrationTypes.h"
+#endif
+
+#include <string>
+#include <iostream>
+
+namespace ROOT { 
+   
+
+namespace Math { 
+
+   class IOptions; 
+
+
+//_______________________________________________________________________________
+/** 
+    Base class for Numerical integration  options 
+    common in 1D and multi-dimension 
+    This is an internal class and is not supposed to be instantiated by the user 
+
+    @ingroup Integration
+*/
+class BaseIntegratorOptions {
+
+protected: 
+
+   /// protected constructor to avoid user creating this class
+   BaseIntegratorOptions(); 
+
+public: 
+
+   // copy constructor 
+   BaseIntegratorOptions(const BaseIntegratorOptions & opt);
+
+   /// assignment operators 
+   BaseIntegratorOptions & operator=(const BaseIntegratorOptions & opt);
+
+
+   /// protected constructor to avoid user creating this class
+   virtual ~BaseIntegratorOptions() { ClearExtra(); }
+
+
+   /// name of 1D integrator
+   virtual std::string  Integrator() const = 0; 
+
+   /** non-static methods for  retrivieng options */
+
+   /// absolute tolerance 
+   double AbsTolerance() const { return  fAbsTolerance; }
+
+   /// absolute tolerance 
+   double RelTolerance() const { return  fRelTolerance; }
+
+   /// size of the workspace
+   unsigned int WKSize() const { return fWKSize; }
+
+
+   /// return extra options 
+   IOptions * ExtraOptions() const { return fExtraOptions; }
+
+   /** non-static methods for setting options */
+
+
+   /// set the abs tolerance
+   void SetAbsTolerance(double tol) { fAbsTolerance = tol; }
+
+   /// set the relative tolerance
+   void SetRelTolerance(double tol) { fRelTolerance = tol; }
+
+   /// set workspace size
+   void SetWKSize(unsigned int size) { fWKSize = size; }
+
+   /// set extra options (in this case pointer is cloned)
+   void  SetExtraOptions(const IOptions & opt); 
+   
+
+protected:
+
+   void ClearExtra(); 
+
+   int       fIntegType;   // Integrator type (value converted from enum)
+
+   unsigned int fWKSize;        // workspace size
+   unsigned int fNCalls;        // (max) funxtion calls
+   double fAbsTolerance;        // absolute tolerance 
+   double fRelTolerance;        // relative tolerance 
+
+
+   // extra options
+   ROOT::Math::IOptions *   fExtraOptions;  // extra options 
+     
+};
+
+//_______________________________________________________________________________
+/** 
+    Numerical one dimensional integration  options 
+
+    @ingroup Integration
+*/
+
+class IntegratorOneDimOptions : public BaseIntegratorOptions {
+
+public:
+
+
+   // constructor using the default options
+   // can pass a pointer to extra options (N.B. pointer will be managed by the class)
+   IntegratorOneDimOptions(IOptions * extraOpts = 0);
+
+   virtual ~IntegratorOneDimOptions() {}
+
+   // copy constructor
+   IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs) : 
+      BaseIntegratorOptions(rhs)
+   {}
+
+   // assignment operator
+   IntegratorOneDimOptions & operator=(const IntegratorOneDimOptions & rhs) { 
+      if (this == &rhs) return *this; 
+      static_cast<BaseIntegratorOptions &>(*this) = rhs;
+      return *this; 
+   }
+
+   // specific method for one-dim
+   /// set number of points rule 
+   /// values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive
+   /// values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator 
+   void SetNPoints(unsigned int n) { fNCalls = n; }
+
+   /// maximum number of function calls
+   unsigned int NPoints() const { return fNCalls; }
+
+   /// name of 1D integrator
+   std::string  Integrator() const;
+
+   /// type of the integrator (return the enumeration type) 
+   IntegrationOneDim::Type IntegratorType() const { return (IntegrationOneDim::Type) fIntegType; }
+
+   /// set 1D integrator name 
+   void SetIntegrator(const char * name); 
+
+   /// print all the options 
+   void Print(std::ostream & os = std::cout) const; 
+
+   // static methods for setting and retrieving the default options 
+
+   static void SetDefaultIntegrator(const char * name);
+   static void SetDefaultAbsTolerance(double tol); 
+   static void SetDefaultRelTolerance(double tol); 
+   static void SetDefaultWKSize(unsigned int size);
+   static void SetDefaultNPoints(unsigned int n);
+
+   static std::string  DefaultIntegrator();
+   static IntegrationOneDim::Type DefaultIntegratorType();
+   static double DefaultAbsTolerance(); 
+   static double DefaultRelTolerance(); 
+   static unsigned int DefaultWKSize();
+   static unsigned int DefaultNPoints();
+
+   /// retrieve specific options - if not existing create a IOptions 
+   static ROOT::Math::IOptions & Default(const char * name);
+
+   // find specific options - return 0 if not existing 
+   static ROOT::Math::IOptions * FindDefault(const char * name);
+
+   /// print only the specified default options 
+   static void PrintDefault(const char * name = 0, std::ostream & os = std::cout); 
+
+
+private: 
+
+
+};
+
+//_______________________________________________________________________________
+/** 
+    Numerical multi dimensional integration  options 
+
+    @ingroup Integration
+*/
+
+class IntegratorMultiDimOptions : public BaseIntegratorOptions {
+
+public:
+
+
+   // constructor using the default options 
+   // can pass a pointer to extra options (N.B. pointer will be managed by the class)
+   IntegratorMultiDimOptions(IOptions * extraOpts = 0);
+
+   virtual ~IntegratorMultiDimOptions() {}
+
+   // copy constructor
+   IntegratorMultiDimOptions(const IntegratorMultiDimOptions & rhs) : 
+      BaseIntegratorOptions(rhs)
+   {}
+
+   // assignment operator
+   IntegratorMultiDimOptions & operator=(const IntegratorMultiDimOptions & rhs) { 
+      if (this == &rhs) return *this; 
+      static_cast<BaseIntegratorOptions &>(*this) = rhs;
+      return *this; 
+   }
+
+   // specific method for multi-dim
+   /// set maximum number of function calls
+   void SetNCalls(unsigned int calls) { fNCalls = calls; }
+
+   /// maximum number of function calls
+   unsigned int NCalls() const { return fNCalls; }
+
+   /// name of multi-dim integrator
+   std::string  Integrator() const;
+
+   /// type of the integrator (return the enumeration type) 
+   IntegrationMultiDim::Type IntegratorType() const { return (IntegrationMultiDim::Type) fIntegType; }
+
+   /// set multi-dim integrator name 
+   void SetIntegrator(const char * name); 
+
+   /// print all the options 
+   void Print(std::ostream & os = std::cout) const; 
+
+   // static methods for setting and retrieving the default options 
+
+   static void SetDefaultIntegrator(const char * name);
+   static void SetDefaultAbsTolerance(double tol); 
+   static void SetDefaultRelTolerance(double tol); 
+   static void SetDefaultWKSize(unsigned int size);
+   static void SetDefaultNCalls(unsigned int ncall);
+
+   static std::string DefaultIntegrator();
+   static IntegrationMultiDim::Type DefaultIntegratorType();
+   static double DefaultAbsTolerance(); 
+   static double DefaultRelTolerance(); 
+   static unsigned int DefaultWKSize();
+   static unsigned int DefaultNCalls();
+
+   // retrieve specific options 
+   static ROOT::Math::IOptions & Default(const char * name);
+
+   // find specific options - return 0 if not existing 
+   static ROOT::Math::IOptions * FindDefault(const char * name);
+
+   /// print only the specified default options 
+   static void PrintDefault(const char * name = 0, std::ostream & os = std::cout); 
+
+
+private: 
+
+
+};
+
+
+   } // end namespace Math
+
+} // end namespace ROOT
+
+#endif
diff --git a/math/mathcore/inc/Math/Minimizer.h b/math/mathcore/inc/Math/Minimizer.h
index b7c2d21..332b9be 100644
--- a/math/mathcore/inc/Math/Minimizer.h
+++ b/math/mathcore/inc/Math/Minimizer.h
@@ -1,4 +1,4 @@
-// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
 // Author: L. Moneta Fri Sep 22 15:06:47 2006
 
 /**********************************************************************
@@ -17,9 +17,9 @@
 #include "Math/IFunction.h"
 #endif
 
-// #ifndef ROOT_Math_Util
-// #include "Math/Util.h"
-// #endif
+#ifndef ROOT_Math_MinimizerOptions
+#include "Math/MinimizerOptions.h"
+#endif
 
 
 #include <vector> 
@@ -28,10 +28,6 @@
 #include <limits> 
 #include <cmath>
 
-//#define DEBUG
-#ifdef DEBUG
-#include <iostream> 
-#endif
 
 namespace ROOT { 
    
@@ -83,18 +79,14 @@ public:
    */ 
    Minimizer () : 
       fValidError(false),
-#ifndef DEBUG
-      fDebug(0), 
-#else
-      fDebug(3),
-#endif 
-      fStrategy(1),
+      fDebug(MinimizerOptions::DefaultPrintLevel()), 
+      fStrategy(MinimizerOptions::DefaultStrategy()), 
       fStatus(-1),
-      fMaxCalls(0), 
-      fMaxIter(0),
-      fTol(1.E-6), 
-      fPrec(-1),
-      fUp(1.)
+      fMaxCalls(MinimizerOptions::DefaultMaxFunctionCalls()), 
+      fMaxIter(MinimizerOptions::DefaultMaxIterations()), 
+      fTol(MinimizerOptions::DefaultTolerance()), 
+      fPrec(MinimizerOptions::DefaultPrecision()), 
+      fUp(MinimizerOptions::DefaultErrorDef() )
    {} 
 
    /** 
@@ -141,11 +133,6 @@ public:
    int SetVariables(const VariableIterator & begin, const VariableIterator & end) { 
       unsigned int ivar = 0; 
       for ( VariableIterator vitr = begin; vitr != end; ++vitr) { 
-#ifdef DEBUG
-         std::cout << "adding variable " << ivar << "  " << vitr->Name(); 
-         if (vitr->IsDoubleBound() ) std::cout << " bounded to [ " <<  vitr->LowerLimit() << " , " <<  vitr->UpperLimit() << " ] ";
-         std::cout << std::endl; 
-#endif
          bool iret = false; 
          if (vitr->IsFixed() )
             iret = SetFixedVariable(ivar,  vitr->Name(), vitr->Value() ); 
@@ -159,14 +146,8 @@ public:
             iret = SetVariable( ivar, vitr->Name(), vitr->Value(), vitr->StepSize() ); 
 
          if (iret) ivar++; 
-#ifdef DEBUG
-         if (iret) 
-            std::cout << "Added variable " << vitr->Name() << " val = " << vitr->Value() << " step " << vitr->StepSize() 
-                      << std::endl; 
-         else 
-            std::cout << "Failed to Add variable " << vitr->Name() << std::endl; 
-#endif
 
+         // an error message should be eventually be reported in the virtual single SetVariable methods
       }
       return ivar; 
    }
@@ -238,6 +219,26 @@ public:
    */ 
    virtual double CovMatrix(unsigned int i, unsigned int j) const = 0;  
 
+   /** 
+       Fill the passed array with the  covariance matrix elements 
+       if the variable is fixed or const the value is zero. 
+       The array will be filled as cov[i *ndim + j]
+       The ordering of the variables is the same as in errors and parameter value. 
+       This is different from the direct interface of Minuit2 or TMinuit where the 
+       values were obtained only to variable parameters
+   */ 
+   virtual bool GetCovMatrix(double * /*cov*/) const { return false; } 
+
+   /** 
+       Fill the passed array with the Hessian matrix elements 
+       The Hessian matrix is the matrix of the second derivatives 
+       and is the inverse of the covariance matrix
+       If the variable is fixed or const the values for that variables are zero. 
+       The array will be filled as h[i *ndim + j]
+   */ 
+   virtual bool GetHessianMatrix(double * /* h */) const { return false; }
+
+
    ///return status of covariance matrix 
    /// using Minuit convention {0 not calculated 1 approximated 2 made pos def , 3 accurate}
    /// Minimizer who implements covariance matrix calculation will re-implement the method
@@ -315,10 +316,10 @@ public:
    int PrintLevel() const { return fDebug; }
 
    ///  max number of function calls
-   unsigned int MaxFunctionCalls() { return fMaxCalls; } 
+   unsigned int MaxFunctionCalls() const { return fMaxCalls; } 
 
    /// max iterations
-   unsigned int MaxIterations() { return fMaxIter; } 
+   unsigned int MaxIterations() const { return fMaxIter; } 
 
    /// absolute tolerance 
    double Tolerance() const { return  fTol; }
@@ -340,6 +341,19 @@ public:
    ///return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit)
    bool IsValidError() const { return fValidError; }
 
+   /// retrieve the minimizer options (implement derived class if needed)
+   virtual MinimizerOptions  Options() const { 
+      MinimizerOptions opt; 
+      opt.SetPrintLevel(fDebug);
+      opt.SetStrategy(fStrategy);
+      opt.SetMaxFunctionCalls(fMaxCalls);
+      opt.SetMaxIterations(fMaxIter);
+      opt.SetTolerance(fTol);
+      opt.SetPrecision(fPrec);
+      opt.SetErrorDef(fUp);
+      return opt;
+   }
+
    /// set print level
    void SetPrintLevel(int level) { fDebug = level; }
 
@@ -365,7 +379,27 @@ public:
    /// flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit)
    void SetValidError(bool on) { fValidError = on; } 
 
+   /// set all options in one go
+   void SetOptions(const MinimizerOptions & opt) { 
+      fDebug = opt.PrintLevel();
+      fStrategy = opt.Strategy();
+      fMaxCalls = opt.MaxFunctionCalls();
+      fMaxIter = opt.MaxIterations();
+      fTol = opt.Tolerance();
+      fPrec = opt.Precision();
+      fUp = opt.ErrorDef();
+   }
 
+   /// reset the defaut options (defined in MinimizerOptions)
+   void SetDefaultOptions() { 
+      fDebug = MinimizerOptions::DefaultPrintLevel();
+      fStrategy = MinimizerOptions::DefaultStrategy();
+      fMaxCalls = MinimizerOptions::DefaultMaxFunctionCalls();
+      fMaxIter = MinimizerOptions::DefaultMaxIterations();
+      fTol = MinimizerOptions::DefaultTolerance();
+      fPrec = MinimizerOptions::DefaultPrecision();
+      fUp = MinimizerOptions::DefaultErrorDef();
+   }
 
 protected: 
 
diff --git a/math/mathcore/inc/Math/MinimizerOptions.h b/math/mathcore/inc/Math/MinimizerOptions.h
index 5a7edfe..404f18e 100644
--- a/math/mathcore/inc/Math/MinimizerOptions.h
+++ b/math/mathcore/inc/Math/MinimizerOptions.h
@@ -1,4 +1,4 @@
-// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
 // Author: L. Moneta Fri Aug 15 2008
 
 /**********************************************************************
@@ -13,10 +13,15 @@
 
 #include <string>
 
+#include <iostream>
+
 namespace ROOT { 
    
 
-   namespace Math { 
+namespace Math { 
+
+
+class IOptions;      
 
 //_______________________________________________________________________________
 /** 
@@ -49,9 +54,31 @@ public:
    static int DefaultStrategy(); 
    static int DefaultPrintLevel(); 
 
+   /// retrieve extra options - if not existing create a IOptions 
+   static ROOT::Math::IOptions & Default(const char * name);
+
+   // find extra options - return 0 if not existing 
+   static ROOT::Math::IOptions * FindDefault(const char * name);
+
+   /// print all the default options for the name given
+   static void PrintDefault(const char * name = 0, std::ostream & os = std::cout); 
+
+public:
 
    // constructor using the default options 
-   MinimizerOptions();
+   // pass optionally a pointer to the additional options
+   // otehrwise look if they exist for this default minimizer
+   // and in that case they are copied in the constructed instance
+   MinimizerOptions(IOptions * extraOpts = 0);
+
+   // destructor  
+   ~MinimizerOptions();
+
+   // copy constructor 
+   MinimizerOptions(const MinimizerOptions & opt);
+
+   /// assignment operators 
+   MinimizerOptions & operator=(const MinimizerOptions & opt);
 
    /** non-static methods for  retrivieng options */
 
@@ -76,12 +103,18 @@ public:
    /// error definition 
    double ErrorDef() const { return  fErrorDef; }
 
+   /// return extra options (NULL pointer if they are not present)
+   IOptions * ExtraOptions() const { return fExtraOptions; }
+
    /// type of minimizer
    const std::string & MinimizerType() const { return fMinimType; }
 
    /// type of algorithm
    const std::string & MinimizerAlgorithm() const { return fAlgoType; }
 
+   /// print all the options 
+   void Print(std::ostream & os = std::cout) const; 
+
    /** non-static methods for setting options */
 
    /// set print level
@@ -111,6 +144,10 @@ public:
    /// set minimizer algorithm
    void SetMinimizerAlgorithm(const char *type) { fAlgoType = type; }
 
+   /// set extra options (in this case pointer is cloned)
+   void  SetExtraOptions(const IOptions & opt); 
+
+
 private:
 
    int fLevel;               // debug print level 
@@ -119,9 +156,12 @@ private:
    int fStrategy;            // minimizer strategy (used by Minuit)
    double fErrorDef;         // error definition (=1. for getting 1 sigma error for chi2 fits)
    double fTolerance;        // minimize tolerance to reach solution
-   double fPrecision;        // precision of the objective funciton evaluation (value <=0 means left to default)
+   double fPrecision;        // precision of the objective function evaluation (value <=0 means left to default)
    std::string fMinimType;   // Minimizer type (Minuit, Minuit2, etc..
    std::string fAlgoType;    // Minimizer algorithmic specification (Migrad, Minimize, ...)
+
+   // extra options
+   ROOT::Math::IOptions *   fExtraOptions;  // extra options 
      
 };
 
diff --git a/math/mathcore/inc/Math/VirtualIntegrator.h b/math/mathcore/inc/Math/VirtualIntegrator.h
index ad24f00..cb6dc2f 100644
--- a/math/mathcore/inc/Math/VirtualIntegrator.h
+++ b/math/mathcore/inc/Math/VirtualIntegrator.h
@@ -22,6 +22,11 @@
 #include "Math/Error.h"
 #endif
 
+#ifndef ROOT_Math_IntegratorOptions
+#include "Math/IntegratorOptions.h"
+#endif
+
+
 #include <vector>
 
 
@@ -79,6 +84,15 @@ public:
    */
    virtual int Status() const = 0;
 
+   /**
+      return number of function evaluations in calculating the integral 
+      (if integrator do not implement this function returns -1)
+   */
+   virtual int NEval() const { return -1; }
+
+
+
+
 }; 
 
 //___________________________________________________________________
@@ -122,6 +136,24 @@ public:
    /// evaluate Cauchy integral 
    virtual double IntegralCauchy(double a, double b, double c) = 0; 
 
+   ///  get the option used for the integration 
+   /// must be implemented by derived class 
+   virtual ROOT::Math::IntegratorOneDimOptions Options() const = 0; 
+
+   // return type of integrator 
+   virtual ROOT::Math::IntegrationOneDim::Type Type() const { 
+      return Options().IntegratorType();
+   } 
+
+   /// set the options 
+   /// (should be re-implemented by derived classes -if more options than tolerance exist
+   virtual void SetOptions(const ROOT::Math::IntegratorOneDimOptions & opt) {
+      SetRelTolerance(opt.RelTolerance() );
+      SetAbsTolerance(opt.AbsTolerance() );
+   }
+
+
+
 };
 
 //___________________________________________________________________
@@ -150,6 +182,21 @@ public:
    /// setting a multi-dim function
    virtual void SetFunction(const IMultiGenFunction &)  = 0; 
 
+   ///  get the option used for the integration 
+   /// impelement by derived class otherwise return default ones 
+   virtual ROOT::Math::IntegratorMultiDimOptions Options() const = 0;
+
+   // return type of integrator 
+   virtual ROOT::Math::IntegrationMultiDim::Type Type() const { 
+      return Options().IntegratorType();
+   } 
+
+   /// set the options (if needed must be re-implemented by derived classes)
+   virtual void SetOptions(const ROOT::Math::IntegratorMultiDimOptions & opt) {
+      SetRelTolerance(opt.RelTolerance() );
+      SetAbsTolerance(opt.AbsTolerance() );
+   }
+
    
 };
 
diff --git a/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx b/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx
index 6bd9296..d9c8c3e 100644
--- a/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx
+++ b/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx
@@ -12,11 +12,13 @@ namespace Math {
 
 
 
-AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim(double absTol, double relTol, unsigned int size):
+AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim(double absTol, double relTol, unsigned int maxpts, unsigned int size):
    fDim(0), 
+   fMinPts(0), 
+   fMaxPts(maxpts),
+   fSize(size), 
    fAbsTol(absTol),
    fRelTol(relTol),
-   fSize(size), 
    fResult(0), 
    fError(0), fRelError(0),
    fNEval(0),
@@ -26,11 +28,13 @@ AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim(double absTol, double rel
    // constructor - without passing a function
 }
 
-AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim( const IMultiGenFunction &f, double absTol, double relTol, unsigned int size):
+AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim( const IMultiGenFunction &f, double absTol, double relTol, unsigned int maxpts, unsigned int size):
    fDim(f.NDim()), 
+   fMinPts(0), 
+   fMaxPts(maxpts),
+   fSize(size),
    fAbsTol(absTol),
    fRelTol(relTol),
-   fSize(size),
    fResult(0), 
    fError(0), fRelError(0),
    fNEval(0),
@@ -58,7 +62,7 @@ void AdaptiveIntegratorMultiDim::SetRelTolerance(double relTol){ this->fRelTol =
 void AdaptiveIntegratorMultiDim::SetAbsTolerance(double absTol){ this->fAbsTol = absTol; }
 
 
-   double AdaptiveIntegratorMultiDim::DoIntegral(const double* xmin, const double * xmax, bool absValue)
+double AdaptiveIntegratorMultiDim::DoIntegral(const double* xmin, const double * xmax, bool absValue)
 {
    // References:
    //
@@ -73,8 +77,6 @@ void AdaptiveIntegratorMultiDim::SetAbsTolerance(double absTol){ this->fAbsTol =
    bool kFALSE = false;
    bool kTRUE = true;
 
-   unsigned int minpts = 0;
-   unsigned int maxpts = fSize;//specified maximal number of function evaluations
    double eps = fRelTol; //specified relative accuracy
    //output parameters
    fStatus = 0; //report status
@@ -135,6 +137,7 @@ void AdaptiveIntegratorMultiDim::SetAbsTolerance(double absTol){ this->fAbsTol =
 
    double twondm = std::pow(2.0,static_cast<int>(n));
    //unsigned int minpts = Int_t(twondm)+ 2*n*(n+1)+1;
+
    unsigned int ifncls = 0;
    bool  ldv   = kFALSE;
    unsigned int irgnst = 2*n+3;
@@ -142,6 +145,10 @@ void AdaptiveIntegratorMultiDim::SetAbsTolerance(double absTol){ this->fAbsTol =
    unsigned int isbrgn = irgnst;
    unsigned int isbrgs = irgnst;
 
+
+   unsigned int minpts = fMinPts; 
+   unsigned int maxpts = std::max(fMaxPts, irlcls) ;//specified maximal number of function evaluations
+
    if (minpts < 1)      minpts = irlcls;
    if (maxpts < minpts) maxpts = 10*minpts;
 
@@ -149,7 +156,7 @@ void AdaptiveIntegratorMultiDim::SetAbsTolerance(double absTol){ this->fAbsTol =
    // with IWK Length ( >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2).
    // Here, this array is allocated dynamically
 
-   unsigned int iwk = irgnst*(1 +maxpts/irlcls)/2;
+   unsigned int iwk = std::max( fSize, irgnst*(1 +maxpts/irlcls)/2 );
    double *wk = new double[iwk+10];
 
    unsigned int j; 
@@ -352,7 +359,29 @@ double AdaptiveIntegratorMultiDim::Integral(const IMultiGenFunction &f, const do
 
 }
 
+ROOT::Math::IntegratorMultiDimOptions  AdaptiveIntegratorMultiDim::Options() const { 
+   // return the used options
+   ROOT::Math::IntegratorMultiDimOptions opt; 
+   opt.SetAbsTolerance(fAbsTol); 
+   opt.SetRelTolerance(fRelTol); 
+   opt.SetNCalls(fMaxPts); 
+   opt.SetWKSize(fSize); 
+   opt.SetIntegrator("ADAPTIVE");
+   return opt; 
+}
 
+void AdaptiveIntegratorMultiDim::SetOptions(const ROOT::Math::IntegratorMultiDimOptions & opt)
+{
+   //   set integration options
+   if (opt.IntegratorType() != IntegrationMultiDim::kADAPTIVE) {
+      MATH_ERROR_MSG("AdaptiveIntegratorMultiDim::SetOptions","Invalid options");
+      return;
+   }      
+   SetAbsTolerance( opt.AbsTolerance() );
+   SetRelTolerance( opt.RelTolerance() );
+   SetMaxPts( opt.NCalls() );
+   SetSize( opt.WKSize() );
+}
 
 } // namespace Math
 } // namespace ROOT
diff --git a/math/mathcore/src/GenAlgoOptions.cxx b/math/mathcore/src/GenAlgoOptions.cxx
new file mode 100644
index 0000000..97a8c03
--- /dev/null
+++ b/math/mathcore/src/GenAlgoOptions.cxx
@@ -0,0 +1,80 @@
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
+// Author: L. Moneta Nov 2010
+/**********************************************************************
+ *                                                                    *
+ * Copyright (c) 2010  LCG ROOT Math Team, CERN/PH-SFT                *
+ *                                                                    *
+ *                                                                    *
+ **********************************************************************/
+
+// implementation file for static methods of GenAlgoOptions
+// this file contains also the pointer to the static map<algorithm name, options> 
+
+#include "Math/GenAlgoOptions.h"
+#include <cassert>
+
+// for toupper
+#include <algorithm>
+#include <functional>
+#include <ctype.h>   // need to use c version of tolower defined here
+
+namespace ROOT { 
+namespace Math { 
+
+typedef std::map<std::string, ROOT::Math::GenAlgoOptions > OptionsMap; 
+
+namespace GenAlgoOptUtil {
+
+   // map with the generic options for all ROOT::Math numerical algorithm 
+   static OptionsMap gAlgoOptions; 
+ 
+
+   IOptions * DoFindDefault(std::string & algoname, OptionsMap & gOpts) { 
+      // internal function to retrieve the 
+      // default extra options for the given algorithm type 
+      // return zero if not found
+      // store always name in upper case
+      std::transform(algoname.begin(), algoname.end(), algoname.begin(), (int(*)(int)) toupper ); 
+      
+      OptionsMap::iterator pos = gOpts.find(algoname); 
+      if (pos !=  gOpts.end() ) { 
+         return &(pos->second); 
+      }
+      return 0; 
+   }
+}
+   
+   IOptions * GenAlgoOptions::FindDefault(const char * algo) { 
+      // find default options - return 0 if not found
+      std::string algoname(algo);
+      OptionsMap & gOpts = GenAlgoOptUtil::gAlgoOptions; 
+      return GenAlgoOptUtil::DoFindDefault(algoname, gOpts); 
+   }
+
+   IOptions & GenAlgoOptions::Default(const char * algo) { 
+      // create default extra options for the given algorithm type 
+      std::string algoname(algo);
+      OptionsMap & gOpts = GenAlgoOptUtil::gAlgoOptions; 
+      IOptions * opt = GenAlgoOptUtil::DoFindDefault(algoname, gOpts); 
+      if (opt == 0) { 
+         // create new extra options for the given type
+         std::pair<OptionsMap::iterator,bool> ret = gOpts.insert( OptionsMap::value_type(algoname, ROOT::Math::GenAlgoOptions()) );
+         assert(ret.second);
+         opt = &((ret.first)->second);
+      }
+      return *opt;
+   }
+
+   void PrintAllDefault(std::ostream & os) { 
+      const OptionsMap & gOpts = GenAlgoOptUtil::gAlgoOptions; 
+      for (  OptionsMap::const_iterator pos = gOpts.begin(); 
+          pos != gOpts.end(); ++pos) { 
+            os << "Default specific options for algorithm "  << pos->first << " : " << std::endl;
+            (pos->second).Print(os);         
+      }
+   }
+
+   } // end namespace Math
+
+} // end namespace ROOT
+
diff --git a/math/mathcore/src/Integrator.cxx b/math/mathcore/src/Integrator.cxx
index e5c04d5..b01d48b 100644
--- a/math/mathcore/src/Integrator.cxx
+++ b/math/mathcore/src/Integrator.cxx
@@ -26,6 +26,13 @@
 // #define MATH_NO_PLUGIN_MANAGER
 // #endif
 
+#include <algorithm>
+#include <functional>
+#include <ctype.h>   // need to use c version of tolower defined here
+
+
+#include <cassert>
+
 #ifndef MATH_NO_PLUGIN_MANAGER
 
 #include "TROOT.h"
@@ -39,14 +46,13 @@
 
 #endif
 
-#include <cassert>
-#include <algorithm>
+
 
 namespace ROOT {
 namespace Math {
 
 IntegrationOneDim::Type IntegratorOneDim::GetType(const char *name) { 
-   if (name == 0) return IntegrationOneDim::kGAUSS; // default case
+   if (name == 0) return IntegrationOneDim::kDEFAULT;
    std::string typeName(name);
    std::transform(typeName.begin(), typeName.end(), typeName.begin(), (int(*)(int)) toupper );  
    if (typeName == "GAUSS") return IntegrationOneDim::kGAUSS;  
@@ -55,13 +61,23 @@ IntegrationOneDim::Type IntegratorOneDim::GetType(const char *name) {
    if (typeName == "ADAPTIVESINGULAR") return IntegrationOneDim::kADAPTIVESINGULAR;  
    if (typeName == "NONADAPTIVE") return IntegrationOneDim::kNONADAPTIVE;  
    if (!typeName.empty()) MATH_WARN_MSG("IntegratorOneDim::GetType","Invalid type name specified - return default " ); 
-   return IntegrationOneDim::kGAUSS; 
+   return IntegrationOneDim::kDEFAULT; 
 }
 
+std::string IntegratorOneDim::GetName(IntegrationOneDim::Type type) { 
+   if (type == IntegrationOneDim::kDEFAULT) type = GetType(IntegratorOneDimOptions::DefaultIntegrator().c_str() );
+   if (type == IntegrationOneDim::kGAUSS) return "Gauss";
+   if (type == IntegrationOneDim::kLEGENDRE) return "GaussLegendre";
+   if (type == IntegrationOneDim::kADAPTIVE) return "Adaptive";
+   if (type == IntegrationOneDim::kADAPTIVESINGULAR) return "AdaptiveSingular";
+   if (type == IntegrationOneDim::kNONADAPTIVE) return "NonAdaptive";
+   MATH_WARN_MSG("IntegratorOneDim::GetType","Invalid type specified " ); 
+   return std::string("undefined");
+}
    
 
 IntegrationMultiDim::Type IntegratorMultiDim::GetType(const char *name) { 
-   if (name == 0) return IntegrationMultiDim::kADAPTIVE; // default case
+   if (name == 0) return IntegrationMultiDim::kDEFAULT;
    std::string typeName(name); 
    std::transform(typeName.begin(), typeName.end(), typeName.begin(), (int(*)(int)) toupper );  
    if (typeName == "ADAPTIVE") return IntegrationMultiDim::kADAPTIVE;  
@@ -69,9 +85,18 @@ IntegrationMultiDim::Type IntegratorMultiDim::GetType(const char *name) {
    if (typeName == "MISER") return IntegrationMultiDim::kMISER;  
    if (typeName == "PLAIN") return IntegrationMultiDim::kPLAIN;  
    if (!typeName.empty()) MATH_WARN_MSG("IntegratorMultiDim::GetType","Invalid type name specified - return default " ); 
-   return IntegrationMultiDim::kADAPTIVE; 
+   return IntegrationMultiDim::kDEFAULT; 
 }
 
+std::string IntegratorMultiDim::GetName(IntegrationMultiDim::Type type) { 
+   if (type == IntegrationMultiDim::kDEFAULT) type = GetType(IntegratorMultiDimOptions::DefaultIntegrator().c_str() );
+   if (type == IntegrationMultiDim::kADAPTIVE) return "ADAPTIVE";
+   if (type == IntegrationMultiDim::kVEGAS) return "VEGAS";
+   if (type == IntegrationMultiDim::kMISER) return "MISER";
+   if (type == IntegrationMultiDim::kPLAIN) return "PLAIN";
+   MATH_WARN_MSG("IntegratorMultiDim::GetType","Invalid type specified " ); 
+   return std::string("Undefined");
+}
 
 void IntegratorOneDim::SetFunction(const IMultiGenFunction &f, unsigned int icoord , const double * x ) { 
    // set function from a multi-dim function 
@@ -90,6 +115,16 @@ void IntegratorOneDim::SetFunction(const IMultiGenFunction &f, unsigned int icoo
 VirtualIntegratorOneDim * IntegratorOneDim::CreateIntegrator(IntegrationOneDim::Type type , double absTol, double relTol, unsigned int size, int rule) { 
    // create the concrete class for one-dimensional integration. Use the plug-in manager if needed 
 
+   if (type == IntegrationOneDim::kDEFAULT) type = IntegratorOneDimOptions::DefaultIntegratorType();
+   if (absTol <= 0) absTol = IntegratorOneDimOptions::DefaultAbsTolerance(); 
+   if (relTol <= 0) relTol = IntegratorOneDimOptions::DefaultRelTolerance(); 
+   if (size <= 0)  size = IntegratorOneDimOptions::DefaultWKSize(); 
+   if (rule <= 0)  rule = IntegratorOneDimOptions::DefaultNPoints(); 
+   //if (ncall  <= 0) ncall  = IntegratorOneDimOptions::DefaultNCalls(); 
+
+
+   
+
 #ifndef R__HAS_MATHMORE   
    // default type is GAUSS when Mathmore is not built
    if (type == IntegrationOneDim::kADAPTIVE ||  
@@ -99,9 +134,10 @@ VirtualIntegratorOneDim * IntegratorOneDim::CreateIntegrator(IntegrationOneDim::
 #endif
 
    if (type == IntegrationOneDim::kGAUSS)
-      return new GaussIntegrator();
-   if (type == IntegrationOneDim::kLEGENDRE)
-      return new GaussLegendreIntegrator();
+      return new GaussIntegrator(relTol);
+   if (type == IntegrationOneDim::kLEGENDRE) { 
+      return new GaussLegendreIntegrator(rule,relTol);
+   }
 
    VirtualIntegratorOneDim * ig = 0; 
 
@@ -125,16 +161,8 @@ VirtualIntegratorOneDim * IntegratorOneDim::CreateIntegrator(IntegrationOneDim::
       }
       
       // plugin manager requires a string
-      std::string typeName = "Undefined";
-      if (type == IntegrationOneDim::kADAPTIVE) 
-         typeName = "ADAPTIVE";
-      if (type == IntegrationOneDim::kADAPTIVESINGULAR) 
-         typeName = "ADAPTIVESINGULAR";
-      if (type == IntegrationOneDim::kNONADAPTIVE) 
-         typeName = "NONADAPTIVE";
-
+      std::string typeName = GetName(type);
             
-
       ig = reinterpret_cast<ROOT::Math::VirtualIntegratorOneDim *>( h->ExecPlugin(5,typeName.c_str(), rule, absTol, relTol, size ) ); 
       assert(ig != 0);
       
@@ -151,6 +179,12 @@ VirtualIntegratorOneDim * IntegratorOneDim::CreateIntegrator(IntegrationOneDim::
 
 VirtualIntegratorMultiDim * IntegratorMultiDim::CreateIntegrator(IntegrationMultiDim::Type type , double absTol, double relTol, unsigned int ncall) { 
    // create concrete class for multidimensional integration 
+   if (type == IntegrationMultiDim::kDEFAULT) type = GetType(IntegratorMultiDimOptions::DefaultIntegrator().c_str());
+   if (absTol <= 0) absTol = IntegratorMultiDimOptions::DefaultAbsTolerance(); 
+   if (relTol <= 0) relTol = IntegratorMultiDimOptions::DefaultRelTolerance(); 
+   if (ncall  <= 0) ncall  = IntegratorMultiDimOptions::DefaultNCalls(); 
+   unsigned int size = IntegratorMultiDimOptions::DefaultWKSize(); 
+
 
 #ifndef R__HAS_MATHMORE   
    // default type is Adaptive when Mathmore is not built
@@ -159,7 +193,7 @@ VirtualIntegratorMultiDim * IntegratorMultiDim::CreateIntegrator(IntegrationMult
 
    // no need for PM in the adaptive  case using Genz method (class is in MathCore)
    if (type == IntegrationMultiDim::kADAPTIVE)
-      return new AdaptiveIntegratorMultiDim(absTol, relTol, ncall);
+      return new AdaptiveIntegratorMultiDim(absTol, relTol, ncall, size);
       
    VirtualIntegratorMultiDim * ig = 0; 
 
@@ -180,13 +214,7 @@ VirtualIntegratorMultiDim * IntegratorMultiDim::CreateIntegrator(IntegrationMult
          return new AdaptiveIntegratorMultiDim(absTol, relTol, ncall);
       }
 
-
-      std::string typeName = "VEGAS";
-      if (type == IntegrationMultiDim::kMISER) 
-         typeName = "MISER";
-      if (type == IntegrationMultiDim::kPLAIN) 
-         typeName = "PLAIN";
-
+      std::string typeName = GetName(type);
       
       ig = reinterpret_cast<ROOT::Math::VirtualIntegratorMultiDim *>( h->ExecPlugin(4,typeName.c_str(), absTol, relTol, ncall ) ); 
       assert(ig != 0);
diff --git a/math/mathcore/src/IntegratorOptions.cxx b/math/mathcore/src/IntegratorOptions.cxx
new file mode 100644
index 0000000..179c7bc
--- /dev/null
+++ b/math/mathcore/src/IntegratorOptions.cxx
@@ -0,0 +1,382 @@
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
+// Author: L. Moneta Fri Aug 15 2008
+
+/**********************************************************************
+ *                                                                    *
+ * Copyright (c) 2008  LCG ROOT Math Team, CERN/PH-SFT                *
+ *                                                                    *
+ *                                                                    *
+ **********************************************************************/
+
+#include "Math/IntegratorOptions.h"
+#include "Math/Integrator.h"
+#include "Math/IntegratorMultiDim.h"
+#include "Math/GenAlgoOptions.h"
+
+#include "RConfigure.h"
+
+#include <algorithm>
+#include <functional>
+#include <ctype.h>   // need to use c version of tolower defined here
+
+#include <map>
+
+namespace ROOT { 
+   
+namespace Math { 
+
+   // eventually could take values from /etc/system.rootrc
+
+namespace IntegOneDim { 
+   
+#ifdef R__HAS_MATHMORE   
+   static int gDefaultIntegrator = IntegrationOneDim::kADAPTIVESINGULAR;
+#else 
+   static int gDefaultIntegrator = IntegrationOneDim::kGAUSS;
+#endif
+   static double gDefaultAbsTolerance = 1.E-06; 
+   static double gDefaultRelTolerance = 1.E-09; 
+   static unsigned int gDefaultWKSize = 1000;
+   static unsigned int gDefaultNPointsLegendre = 10;  
+   static unsigned int gDefaultNPointsGSLAdaptive = 3;  // corresponds to 31 points
+   static unsigned int gDefaultNPoints = gDefaultNPointsGSLAdaptive;  
+   
+   
+}
+
+namespace IntegMultiDim { 
+
+   static int gDefaultIntegrator = IntegrationMultiDim::kADAPTIVE;  
+   static double gDefaultAbsTolerance = 1.E-06; 
+   static double gDefaultRelTolerance = 1.E-09; 
+   static unsigned int gDefaultWKSize = 100000;
+   static unsigned int gDefaultNCalls = 100000;
+
+
+}
+
+
+// some utility functions
+
+namespace IntegOptionsUtil { 
+
+
+   // traits for the specific methods 1D - ND
+   template<class OptionType> 
+   struct OptionTrait {
+      static int N() { return 0; }
+      static int N(const OptionType & ) { return 0; }
+      static const char * DescriptionOfN() {return 0; } 
+   };
+   template<>
+   struct OptionTrait<IntegratorOneDimOptions> {
+      typedef IntegratorOneDimOptions OptType;
+      static int N() { return OptType::DefaultNPoints(); }
+      static int N(const OptType & opt) { return opt.NPoints(); }
+      static const char * DescriptionOfN() {return  "Rule (Npoints)";} 
+   }; 
+   template<>
+   struct OptionTrait<IntegratorMultiDimOptions> {
+      typedef IntegratorMultiDimOptions OptType;
+      static int N() { return OptType::DefaultNCalls(); }
+      static int N(const OptType & opt) { return opt.NCalls(); }
+      static const char * DescriptionOfN() {return "(max) function calls";} 
+   }; 
+
+   
+   //print  option values (not the default ones) 
+   template <class OptionType>
+   void Print(std::ostream & os,const OptionType & opt) {
+      //print all the options
+      os << std::setw(25) << "Integrator Type"        << " : " << std::setw(15) << opt.Integrator() << std::endl;
+      os << std::setw(25) << "Absolute tolerance"     << " : " << std::setw(15) << opt.AbsTolerance() << std::endl;
+      os << std::setw(25) << "Relative tolerance"     << " : " << std::setw(15) << opt.RelTolerance() << std::endl;
+      os << std::setw(25) << "Workspace size"         << " : " << std::setw(15) << opt.WKSize() << std::endl;
+      typedef  OptionTrait<OptionType> OPT; 
+      os << std::setw(25) << OPT::DescriptionOfN()    << " : " << std::setw(15) << OPT::N(opt) << std::endl;
+      if (opt.ExtraOptions()) { 
+         os << opt.Integrator() << " specific options :"  << std::endl;
+         opt.ExtraOptions()->Print(os);
+      }
+   }
+
+
+   /// print default  options 
+   template <class OptionType>
+   void PrintDefault(const char * name, std::ostream & os) {
+      //print default options
+      std::string integName = (name != 0) ? name : OptionType::DefaultIntegrator();      
+      os << "Default options for numerical integrator "  << integName << " : " << std::endl;
+      os << std::setw(25) << "Absolute tolerance"     << " : " << std::setw(15) << OptionType::DefaultAbsTolerance() << std::endl;
+      os << std::setw(25) << "Relative tolerance"     << " : " <<std::setw(15) << OptionType::DefaultRelTolerance() << std::endl;
+      os << std::setw(25) << "Workspace size"         << " : " << std::setw(15) << OptionType::DefaultWKSize() << std::endl;
+      typedef  OptionTrait<OptionType> OPT; 
+      os << std::setw(25) <<  OPT::DescriptionOfN()   << " : " << std::setw(15) << OPT::N() << std::endl;
+      IOptions * opts = GenAlgoOptions::FindDefault(integName.c_str());
+      if (opts) opts->Print(os);
+   }
+
+}
+
+
+/// constructor (protected) to avoid user creating this class
+BaseIntegratorOptions::BaseIntegratorOptions() :
+   fIntegType(-1),
+   fWKSize(0), fNCalls(0), 
+   fAbsTolerance(0), fRelTolerance(0), 
+   fExtraOptions(0) 
+{} 
+
+BaseIntegratorOptions::BaseIntegratorOptions(const BaseIntegratorOptions & opt) : fExtraOptions(0) {  
+   // copy constructor 
+   (*this) = opt; 
+}
+
+BaseIntegratorOptions & BaseIntegratorOptions::operator=(const BaseIntegratorOptions & opt) {  
+   // assignment operator 
+   if (this == &opt) return *this; // self assignment
+   fWKSize = opt.fWKSize;
+   fNCalls = opt.fNCalls;
+   fAbsTolerance = opt.fAbsTolerance; 
+   fRelTolerance = opt.fRelTolerance; 
+   fIntegType = opt.fIntegType; 
+
+//    std::cout << " copy options for " << fIntegName << std::endl;
+//    std::cout << fExtraOptions << std::endl;
+//    if (fExtraOptions) fExtraOptions->Print(std::cout); 
+
+//    std::cout << opt.fExtraOptions << std::endl;
+//    if (opt.fExtraOptions) (opt.fExtraOptions)->Print(std::cout); 
+
+
+
+   ClearExtra(); 
+   if (opt.fExtraOptions)  fExtraOptions =  (opt.fExtraOptions)->Clone();
+   return *this;
+}
+
+
+void BaseIntegratorOptions::ClearExtra() {  
+   // delete extra options
+   if (fExtraOptions) delete fExtraOptions; 
+   fExtraOptions = 0; 
+}
+
+void BaseIntegratorOptions::SetExtraOptions(const IOptions & opt) {  
+   // delete extra options
+   ClearExtra(); 
+   fExtraOptions = opt.Clone(); 
+}
+
+
+
+// one dim specific  methods
+
+// implementation of non-static methods 
+
+IntegratorOneDimOptions::IntegratorOneDimOptions(IOptions * opts): 
+   BaseIntegratorOptions() 
+{
+   fWKSize       = IntegOneDim::gDefaultWKSize; 
+   fNCalls       = IntegOneDim::gDefaultNPoints; 
+   fAbsTolerance = IntegOneDim::gDefaultAbsTolerance;
+   fRelTolerance = IntegOneDim::gDefaultRelTolerance;
+   fIntegType    = IntegOneDim::gDefaultIntegrator;
+
+   fExtraOptions = opts; // N.B. ownership of pointer is given to the class !
+
+   // check  the default options if opts = 0
+   if (!fExtraOptions) { 
+      std::string igname = DefaultIntegrator();
+      IOptions * gopts = FindDefault( igname.c_str() );
+      if (gopts) fExtraOptions = gopts->Clone();
+   }
+}
+
+void IntegratorOneDimOptions::SetIntegrator(const char * algo ) {   
+   // set the default 1D integrator
+   if (!algo) return; 
+   fIntegType = (int) IntegratorOneDim::GetType(algo);
+}
+
+std::string  IntegratorOneDimOptions::Integrator() const {
+   return  IntegratorOneDim::GetName((IntegratorOneDim::Type) fIntegType);
+}
+
+void IntegratorOneDimOptions::Print(std::ostream & os) const {
+   //print all the options
+   IntegOptionsUtil::Print(os, *this);
+}
+
+// one dim integrator options:  implementation for static methods 
+
+/// print default  options 
+void IntegratorOneDimOptions::PrintDefault(const char * name, std::ostream & os) {
+   //print default options
+   IntegOptionsUtil::PrintDefault<IntegratorOneDimOptions>(name,os);
+}
+
+
+
+void IntegratorOneDimOptions::SetDefaultIntegrator(const char * algo ) {   
+   // set the default 1D integrator
+   if (!algo) return; 
+   IntegOneDim::gDefaultIntegrator = (int) IntegratorOneDim::GetType(algo);
+   if (IntegOneDim::gDefaultIntegrator == IntegrationOneDim::kLEGENDRE) 
+      IntegOneDim::gDefaultNPoints = IntegOneDim::gDefaultNPointsLegendre;  
+   if (IntegOneDim::gDefaultIntegrator == IntegrationOneDim::kADAPTIVE)
+      IntegOneDim::gDefaultNPoints = IntegOneDim::gDefaultNPointsGSLAdaptive;  
+}
+
+
+std::string  IntegratorOneDimOptions::DefaultIntegrator() {
+   // return default integrator name
+   return  IntegratorOneDim::GetName((IntegratorOneDim::Type) IntegOneDim::gDefaultIntegrator);
+}
+
+IntegratorOneDim::Type  IntegratorOneDimOptions::DefaultIntegratorType() {
+   // return default integrator type (enum) 
+   return  (IntegratorOneDim::Type) IntegOneDim::gDefaultIntegrator;
+}
+
+
+void IntegratorOneDimOptions::SetDefaultAbsTolerance(double tol) {
+   // set the default tolerance
+   IntegOneDim::gDefaultAbsTolerance = tol; 
+}
+void IntegratorOneDimOptions::SetDefaultRelTolerance(double tol) {
+   // set the default tolerance
+   IntegOneDim::gDefaultRelTolerance = tol; 
+}
+
+void IntegratorOneDimOptions::SetDefaultWKSize(unsigned int size) {
+   // set the default workspace size 
+   IntegOneDim::gDefaultWKSize = size;
+}
+void IntegratorOneDimOptions::SetDefaultNPoints(unsigned int n) {
+   // set the default number of points for the integration rule
+   IntegOneDim::gDefaultNPoints = n;
+}
+
+
+double IntegratorOneDimOptions::DefaultAbsTolerance()        { return IntegOneDim::gDefaultAbsTolerance; }
+double IntegratorOneDimOptions::DefaultRelTolerance()        { return IntegOneDim::gDefaultRelTolerance; }
+unsigned int IntegratorOneDimOptions::DefaultWKSize()        { return IntegOneDim::gDefaultWKSize; }
+unsigned int IntegratorOneDimOptions::DefaultNPoints()        { return IntegOneDim::gDefaultNPoints; }
+
+
+IOptions & IntegratorOneDimOptions::Default(const char * algo) { 
+   // create default extra options for the given algorithm type 
+   return GenAlgoOptions::Default(algo);
+}
+
+IOptions * IntegratorOneDimOptions::FindDefault(const char * algo) { 
+   // find extra options for the given algorithm type 
+   return GenAlgoOptions::FindDefault(algo);
+}
+
+//////////////////////////////////////////////////////
+//Multi-dim integration options implementation
+/////////////////////////////////////////////////////////
+
+IntegratorMultiDimOptions::IntegratorMultiDimOptions(IOptions * opts): 
+   BaseIntegratorOptions()
+{
+   fWKSize       = IntegMultiDim::gDefaultWKSize; 
+   fNCalls       = IntegMultiDim::gDefaultNCalls; 
+   fAbsTolerance = IntegMultiDim::gDefaultAbsTolerance;
+   fRelTolerance = IntegMultiDim::gDefaultRelTolerance;
+   fIntegType    = IntegMultiDim::gDefaultIntegrator;
+
+   fExtraOptions = opts; // N.B. ownership of pointer is given to the class !
+
+   // check  the default options if opts = 0
+   if (!fExtraOptions) { 
+      IOptions * gopts = FindDefault( DefaultIntegrator().c_str() );
+      if (gopts) fExtraOptions = gopts->Clone();
+   }
+}
+
+void IntegratorMultiDimOptions::SetIntegrator(const char * algo ) {   
+   // set the default integrator
+   if (!algo) return; 
+   fIntegType = (int) IntegratorMultiDim::GetType(algo);
+}
+
+std::string IntegratorMultiDimOptions::Integrator() const {
+   return  IntegratorMultiDim::GetName((IntegratorMultiDim::Type) fIntegType);
+}
+
+void IntegratorMultiDimOptions::Print(std::ostream & os) const {
+   //print all the options
+   IntegOptionsUtil::Print(os, *this);
+}
+
+// multi dim integrator options:  implementation for static methods 
+
+/// print default  options 
+void IntegratorMultiDimOptions::PrintDefault(const char * name, std::ostream & os) {
+   //print default options
+   IntegOptionsUtil::PrintDefault<IntegratorMultiDimOptions>(name,os);
+}
+
+
+void IntegratorMultiDimOptions::SetDefaultIntegrator(const char * algo ) {   
+   // set the default integrator
+   if (!algo) return; 
+   IntegMultiDim::gDefaultIntegrator = (int) IntegratorMultiDim::GetType(algo);
+}
+
+
+std::string  IntegratorMultiDimOptions::DefaultIntegrator() {
+   // return default integrator name 
+   return  IntegratorMultiDim::GetName((IntegratorMultiDim::Type) IntegMultiDim::gDefaultIntegrator);
+}
+
+IntegratorMultiDim::Type  IntegratorMultiDimOptions::DefaultIntegratorType() {
+   // return default integrator type (enum) 
+   return  (IntegratorMultiDim::Type) IntegMultiDim::gDefaultIntegrator;
+}
+
+
+void IntegratorMultiDimOptions::SetDefaultAbsTolerance(double tol) {
+   // set the default tolerance
+   IntegMultiDim::gDefaultAbsTolerance = tol; 
+}
+
+void IntegratorMultiDimOptions::SetDefaultRelTolerance(double tol) {
+   // set the default tolerance
+   IntegMultiDim::gDefaultRelTolerance = tol; 
+}
+
+void IntegratorMultiDimOptions::SetDefaultWKSize(unsigned int size) {
+   // set the default workspace size 
+   IntegMultiDim::gDefaultWKSize = size;
+}
+void IntegratorMultiDimOptions::SetDefaultNCalls(unsigned int ncall) {
+   // set the default (max) function calls
+   IntegMultiDim::gDefaultNCalls = ncall;
+}
+
+
+double IntegratorMultiDimOptions::DefaultAbsTolerance()        { return IntegMultiDim::gDefaultAbsTolerance; }
+double IntegratorMultiDimOptions::DefaultRelTolerance()        { return IntegMultiDim::gDefaultRelTolerance; }
+unsigned int IntegratorMultiDimOptions::DefaultWKSize()        { return IntegMultiDim::gDefaultWKSize; }
+unsigned int IntegratorMultiDimOptions::DefaultNCalls()        { return IntegMultiDim::gDefaultNCalls; }
+
+
+IOptions & IntegratorMultiDimOptions::Default(const char * algo) { 
+   // create default extra options for the given algorithm type 
+   return GenAlgoOptions::Default(algo);
+}
+
+IOptions * IntegratorMultiDimOptions::FindDefault(const char * algo) { 
+   // create default extra options for the given algorithm type 
+   return GenAlgoOptions::FindDefault(algo);
+}
+
+
+} // end namespace Math
+
+} // end namespace ROOT
+
diff --git a/math/mathcore/src/MinimizerOptions.cxx b/math/mathcore/src/MinimizerOptions.cxx
index 85761d0..4d69c6d 100644
--- a/math/mathcore/src/MinimizerOptions.cxx
+++ b/math/mathcore/src/MinimizerOptions.cxx
@@ -1,4 +1,4 @@
-// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $ 
 // Author: L. Moneta Fri Aug 15 2008
 
 /**********************************************************************
@@ -10,104 +10,110 @@
 
 #include "Math/MinimizerOptions.h"
 
+#include "Math/GenAlgoOptions.h"
+
 // case of using ROOT plug-in manager
 #ifndef MATH_NO_PLUGIN_MANAGER
 #include "TEnv.h"
 #endif 
 
+#include <iomanip>
+
 namespace ROOT { 
    
 
 namespace Math { 
 
-   static std::string gDefaultMinimizer = ""; // take from /etc/system.rootrc in ROOT Fitter
-   static std::string gDefaultMinimAlgo = "Migrad";
-   static double gDefaultErrorDef = 1.;
-   static double gDefaultTolerance = 1.E-4; 
-   static double gDefaultPrecision = -1; // value <= 0 means left to minimizer
-   static int  gDefaultMaxCalls = 0; // 0 means leave default values Deaf
-   static int  gDefaultMaxIter  = 0; 
-   static int  gDefaultStrategy  = 1; 
-   static int  gDefaultPrintLevel  = 0; 
-
+   namespace Minim { 
+      static std::string gDefaultMinimizer = ""; // take from /etc/system.rootrc in ROOT Fitter
+      static std::string gDefaultMinimAlgo = "Migrad";
+      static double gDefaultErrorDef = 1.;
+      static double gDefaultTolerance = 1.E-2; 
+      static double gDefaultPrecision = -1; // value <= 0 means left to minimizer
+      static int  gDefaultMaxCalls = 0; // 0 means leave default values Deaf
+      static int  gDefaultMaxIter  = 0; 
+      static int  gDefaultStrategy  = 1; 
+      static int  gDefaultPrintLevel  = 0; 
+   }
 
 
 void MinimizerOptions::SetDefaultMinimizer(const char * type, const char * algo ) {   
    // set the default minimizer type and algorithm
-   if (type) gDefaultMinimizer = std::string(type); 
-   if (algo) gDefaultMinimAlgo = std::string(algo);
+   if (type) Minim::gDefaultMinimizer = std::string(type); 
+   if (algo) Minim::gDefaultMinimAlgo = std::string(algo);
 }
 void MinimizerOptions::SetDefaultErrorDef(double up) {
    // set the default error definition 
-   gDefaultErrorDef = up; 
+   Minim::gDefaultErrorDef = up; 
 }
 void MinimizerOptions::SetDefaultTolerance(double tol) {
    // set the defult tolerance
-   gDefaultTolerance = tol; 
+   Minim::gDefaultTolerance = tol; 
 }
 void MinimizerOptions::SetDefaultPrecision(double prec) {
    // set the defult precision
-   gDefaultPrecision = prec; 
+   Minim::gDefaultPrecision = prec; 
 }
 void MinimizerOptions::SetDefaultMaxFunctionCalls(int maxcall) {
    // set the default maximum number of function calls
-   gDefaultMaxCalls = maxcall; 
+   Minim::gDefaultMaxCalls = maxcall; 
 }
 void MinimizerOptions::SetDefaultMaxIterations(int maxiter) {
    // set the default maximum number of iterations
-   gDefaultMaxIter = maxiter; 
+   Minim::gDefaultMaxIter = maxiter; 
 }
 void MinimizerOptions::SetDefaultStrategy(int stra) {
    // set the default minimization strategy
-   gDefaultStrategy = stra; 
+   Minim::gDefaultStrategy = stra; 
 }
 void MinimizerOptions::SetDefaultPrintLevel(int level) {
    // set the default printing level 
-   gDefaultPrintLevel = level; 
+   Minim::gDefaultPrintLevel = level; 
 }
 
-const std::string & MinimizerOptions::DefaultMinimizerAlgo() { return gDefaultMinimAlgo; }
-double MinimizerOptions::DefaultErrorDef()         { return gDefaultErrorDef; }
-double MinimizerOptions::DefaultTolerance()        { return gDefaultTolerance; }
-double MinimizerOptions::DefaultPrecision()        { return gDefaultPrecision; }
-int    MinimizerOptions::DefaultMaxFunctionCalls() { return gDefaultMaxCalls; }
-int    MinimizerOptions::DefaultMaxIterations()    { return gDefaultMaxIter; }
-int    MinimizerOptions::DefaultStrategy()         { return gDefaultStrategy; }
-int    MinimizerOptions::DefaultPrintLevel()       { return gDefaultPrintLevel; }
+const std::string & MinimizerOptions::DefaultMinimizerAlgo() { return Minim::gDefaultMinimAlgo; }
+double MinimizerOptions::DefaultErrorDef()         { return Minim::gDefaultErrorDef; }
+double MinimizerOptions::DefaultTolerance()        { return Minim::gDefaultTolerance; }
+double MinimizerOptions::DefaultPrecision()        { return Minim::gDefaultPrecision; }
+int    MinimizerOptions::DefaultMaxFunctionCalls() { return Minim::gDefaultMaxCalls; }
+int    MinimizerOptions::DefaultMaxIterations()    { return Minim::gDefaultMaxIter; }
+int    MinimizerOptions::DefaultStrategy()         { return Minim::gDefaultStrategy; }
+int    MinimizerOptions::DefaultPrintLevel()       { return Minim::gDefaultPrintLevel; }
 
 const std::string & MinimizerOptions::DefaultMinimizerType() 
 { 
    // return default minimizer
    // if is "" (no default is set) read from etc/system.rootrc
 
-   if (gDefaultMinimizer.size() == 0) { 
+   if (Minim::gDefaultMinimizer.size() == 0) { 
 #ifndef MATH_NO_PLUGIN_MANAGER
    // use value defined in etc/system.rootrc  (if not found Minuit is used) 
       if (gEnv) 
-         gDefaultMinimizer = gEnv->GetValue("Root.Fitter","Minuit");   
+         Minim::gDefaultMinimizer = gEnv->GetValue("Root.Fitter","Minuit");   
 #else
-      gDefaultMinimizer = "Minuit2";  // in case no PM exists 
+      Minim::gDefaultMinimizer = "Minuit2";  // in case no PM exists 
 #endif
    }
 
-   return gDefaultMinimizer; 
+   return Minim::gDefaultMinimizer; 
 }
 
 
-MinimizerOptions::MinimizerOptions(): 
-   fLevel( gDefaultPrintLevel),
-   fMaxCalls( gDefaultMaxCalls ), 
-   fMaxIter( gDefaultMaxIter ), 
-   fStrategy( gDefaultStrategy ), 
-   fErrorDef(  gDefaultErrorDef ), 
-   fTolerance( gDefaultTolerance ),
-   fPrecision( gDefaultPrecision )
+MinimizerOptions::MinimizerOptions(IOptions * extraOpts): 
+   fLevel( Minim::gDefaultPrintLevel),
+   fMaxCalls( Minim::gDefaultMaxCalls ), 
+   fMaxIter( Minim::gDefaultMaxIter ), 
+   fStrategy( Minim::gDefaultStrategy ), 
+   fErrorDef(  Minim::gDefaultErrorDef ), 
+   fTolerance( Minim::gDefaultTolerance ),
+   fPrecision( Minim::gDefaultPrecision ),
+   fExtraOptions(extraOpts)
 {
    // constructor using  the default options
 
    fMinimType = MinimizerOptions::DefaultMinimizerType();
 
-   fAlgoType =  gDefaultMinimAlgo;
+   fAlgoType =  Minim::gDefaultMinimAlgo;
 
    // case of Fumili2 and TMinuit
    if (fMinimType == "TMinuit") fMinimType = "Minuit";
@@ -117,8 +123,89 @@ MinimizerOptions::MinimizerOptions():
    }   
    else if (fMinimType == "GSLMultiMin" && fAlgoType == "Migrad") 
       fAlgoType = "BFGS2";
+
+   // check if extra options exists (copy them if needed)
+   if (!fExtraOptions) { 
+      IOptions * gopts = FindDefault( fMinimType.c_str() );
+      if (gopts) fExtraOptions = gopts->Clone();
+   }
+}
+
+
+MinimizerOptions::MinimizerOptions(const MinimizerOptions & opt) : fExtraOptions(0) {  
+   // copy constructor 
+   (*this) = opt; 
+}
+
+MinimizerOptions & MinimizerOptions::operator=(const MinimizerOptions & opt) {  
+   // assignment operator 
+   if (this == &opt) return *this; // self assignment
+   fLevel = opt.fLevel;
+   fMaxCalls = opt.fMaxCalls; 
+   fMaxIter = opt.fMaxIter; 
+   fStrategy = opt.fStrategy; 
+   fErrorDef = opt.fErrorDef;
+   fTolerance = opt.fTolerance;
+   fPrecision = opt.fPrecision; 
+   fMinimType = opt.fMinimType; 
+   fAlgoType = opt.fAlgoType; 
+
+   if (fExtraOptions) delete fExtraOptions; 
+   fExtraOptions = 0; 
+   if (opt.fExtraOptions)  fExtraOptions =  (opt.fExtraOptions)->Clone();
+   return *this;
 }
 
+MinimizerOptions::~MinimizerOptions() { 
+   if (fExtraOptions) delete fExtraOptions; 
+}
+
+void MinimizerOptions::SetExtraOptions(const IOptions & opt) {  
+   // set extra options (clone the passed one)
+   if (fExtraOptions) delete fExtraOptions; 
+   fExtraOptions = opt.Clone(); 
+}
+
+void MinimizerOptions::Print(std::ostream & os) const {
+   //print all the options
+   os << std::setw(25) << "Minimizer Type"        << " : " << std::setw(15) << fMinimType << std::endl;
+   os << std::setw(25) << "Minimizer Algorithm"   << " : " << std::setw(15) << fAlgoType << std::endl;
+   os << std::setw(25) << "Strategy"              << " : " << std::setw(15) << fStrategy << std::endl;
+   os << std::setw(25) << "Tolerance"              << " : " << std::setw(15) << fTolerance << std::endl;
+   os << std::setw(25) << "Max func calls"         << " : " << std::setw(15) << fMaxCalls << std::endl;
+   os << std::setw(25) << "Max iterations"         << " : " << std::setw(15) << fMaxIter << std::endl;
+   os << std::setw(25) << "Func Precision"         << " : " << std::setw(15) << fPrecision << std::endl;
+   os << std::setw(25) << "Error definition"       << " : " << std::setw(15) << fErrorDef << std::endl;
+   os << std::setw(25) << "Print Level"            << " : " << std::setw(15) << fLevel << std::endl;
+   
+   if (ExtraOptions()) { 
+      os << fMinimType << " specific options :"  << std::endl;
+      ExtraOptions()->Print(os);
+   }
+}
+
+IOptions & MinimizerOptions::Default(const char * name) { 
+   // create default extra options for the given algorithm type 
+   return GenAlgoOptions::Default(name);
+}
+
+IOptions * MinimizerOptions::FindDefault(const char * name) { 
+   // find extra options for the given algorithm type 
+   return GenAlgoOptions::FindDefault(name);
+}
+
+void MinimizerOptions::PrintDefault(const char * name, std::ostream & os) {
+   //print default options
+   MinimizerOptions tmp;
+   tmp.Print(os);
+   if (!tmp.ExtraOptions() ) {
+      IOptions * opt = FindDefault(name);
+      os << "Specific options for "  << name << std::endl;
+      if (opt) opt->Print(os);
+   }
+}
+
+
 
 
 } // end namespace Math
diff --git a/math/mathcore/inc/Math/AllIntegrationTypes.h b/math/mathcore/inc/Math/AllIntegrationTypes.h
index 9c2fa19..c66a878 100644
--- a/math/mathcore/inc/Math/AllIntegrationTypes.h
+++ b/math/mathcore/inc/Math/AllIntegrationTypes.h
@@ -41,7 +41,7 @@ namespace Math {
 	 </ul>
 	 @ingroup Integration
     */
-     enum Type { kGAUSS, kLEGENDRE, kADAPTIVE, kADAPTIVESINGULAR, kNONADAPTIVE};
+     enum Type { kDEFAULT = -1, kGAUSS, kLEGENDRE, kADAPTIVE, kADAPTIVESINGULAR, kNONADAPTIVE};
 
   }
 
@@ -60,7 +60,7 @@ namespace Math {
 	 @ingroup MCIntegration
     */
 
-     enum Type {kADAPTIVE, kVEGAS, kMISER, kPLAIN};
+     enum Type {kDEFAULT = -1, kADAPTIVE, kVEGAS, kMISER, kPLAIN};
 
   }  
 
diff --git a/math/mathcore/inc/Math/GaussIntegrator.h b/math/mathcore/inc/Math/GaussIntegrator.h
index 2b66c73..ce39ab2 100644
--- a/math/mathcore/inc/Math/GaussIntegrator.h
+++ b/math/mathcore/inc/Math/GaussIntegrator.h
@@ -1,4 +1,4 @@
-// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
 // Authors: David Gonzalez Maline    01/2008 
 
 /**********************************************************************
@@ -202,6 +202,12 @@ public:
    /** This method is not implemented. */
    double IntegralCauchy (double a, double b, double c);
 
+   ///  get the option used for the integration 
+   virtual ROOT::Math::IntegratorOneDimOptions Options() const; 
+
+   // set the options 
+   virtual void SetOptions(const ROOT::Math::IntegratorOneDimOptions & opt);
+
 private:
 
    /**
diff --git a/math/mathcore/src/GaussIntegrator.cxx b/math/mathcore/src/GaussIntegrator.cxx
index 43679fb..d800ae4 100644
--- a/math/mathcore/src/GaussIntegrator.cxx
+++ b/math/mathcore/src/GaussIntegrator.cxx
@@ -1,4 +1,4 @@
-// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
+// @(#)root/mathcore:$Id: root-5.27.06b-updated-mathcore-mathmore.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
 // Authors: David Gonzalez Maline    01/2008 
 
 /**********************************************************************
@@ -179,6 +179,23 @@ double GaussIntegrator::IntegralCauchy (double /*a*/, double /*b*/, double /*c*/
    return -1.0;  
 }
 
+void GaussIntegrator::SetOptions(const ROOT::Math::IntegratorOneDimOptions & opt) {
+   // set options
+   SetRelTolerance(opt.RelTolerance() );
+}
+
+ROOT::Math::IntegratorOneDimOptions  GaussIntegrator::Options() const { 
+   // retrieve options 
+   ROOT::Math::IntegratorOneDimOptions opt; 
+   opt.SetIntegrator("Gauss");
+   //opt.SetAbsTolerance(fEpsilon); 
+   opt.SetRelTolerance(fEpsilon); 
+   opt.SetWKSize(0); 
+   opt.SetNPoints(0); 
+   return opt; 
+}
+
+
 
 //implementation of IntegrandTransform class 
 
