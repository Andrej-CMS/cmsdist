diff --git a/math/mathcore/inc/Math/QuantFuncMathCore.h b/math/mathcore/inc/Math/QuantFuncMathCore.h
index 4a0e9e3..855ea66 100644
--- a/math/mathcore/inc/Math/QuantFuncMathCore.h
+++ b/math/mathcore/inc/Math/QuantFuncMathCore.h
@@ -27,11 +27,6 @@
 #ifndef ROOT_Math_QuantFuncMathCore
 #define ROOT_Math_QuantFuncMathCore
 
-// required for R__HAS_MATHMORE
-#ifndef ROOT_RConfigure
-#include "RConfigure.h"
-#endif
-
 
 namespace ROOT {
 namespace Math {
@@ -206,8 +201,6 @@ namespace Math {
 
 
 
-#ifndef R__HAS_MATHMORE
-
    /**
 
       Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution 
@@ -216,15 +209,14 @@ namespace Math {
       <A HREF="http://mathworld.wolfram.com/Chi-SquaredDistribution.html">
       Mathworld</A>. 
       It is implemented using  chisquared_quantile_c, therefore is not very precise for small z. 
-      It is reccomended to use the MathMore function implemented using GSL
+      It is reccomended to use the MathMore function (ROOT::MathMore::chisquared_quantile )implemented using GSL
 
-      @ingroup QuantFunc_def_in_MathMore
+      @ingroup QuantFunc
 
    */
 
    double chisquared_quantile(double z, double r);  
 
-#endif
 
 
    /**
@@ -310,7 +302,6 @@ namespace Math {
 
 
 
-#ifndef R__HAS_MATHMORE
 
    /**
 
@@ -320,15 +311,16 @@ namespace Math {
       <A HREF="http://mathworld.wolfram.com/GammaDistribution.html">
       Mathworld</A>.
       It is implemented using  chisquared_quantile_c, therefore is not very precise for small z. 
-      It is reccomended to use the MathMore function implemented using GSL
+      For this special cases it is reccomended to use the MathMore function ROOT::MathMore::gamma_quantile
+      implemented using GSL
+
   
-      @ingroup QuantFunc_def_in_MathMore
+      @ingroup QuantFunc
 
    */
 
    double gamma_quantile(double z, double alpha, double theta);
 
-#endif
 
 
    /**
@@ -638,6 +630,6 @@ namespace Math {
 
 
 
-#endif // ROOT_Math_QuantFuncMathMore
+#endif // ROOT_Math_QuantFuncMathCore
 
 #endif // if defined (__CINT__) && !defined(__MAKECINT__)
diff --git a/math/mathcore/src/QuantFuncMathCore.cxx b/math/mathcore/src/QuantFuncMathCore.cxx
index dde8aa2..1412ab1 100644
--- a/math/mathcore/src/QuantFuncMathCore.cxx
+++ b/math/mathcore/src/QuantFuncMathCore.cxx
@@ -64,12 +64,11 @@ namespace Math {
    }
 
 
-#ifndef R__HAS_MATHMORE
    double chisquared_quantile(double z, double r) {
-      // use Cephes (probably large error for z approx 1) 
+      // if possible, should use MathMore function ROOT::Math::chisquared_quantile for z close to zero 
+      // otherwise will always return zero for z  value smaller than eps 
       return 2.* ROOT::Math::Cephes::igami( 0.5 *r, 1. - z); 
    }
-#endif
 
 
    double exponential_quantile_c(double z, double lambda) {
@@ -116,12 +115,11 @@ namespace Math {
 
    }
 
-#ifndef R__HAS_MATHMORE
    double gamma_quantile(double z, double alpha, double theta) {
-      // use gamma_quantile_c (large error for z close to 1)
+      // if possible, should use MathMore function ROOT::Math::gamma_quantile for z close to zero 
+      // otherwise will always return zero for z  value smaller than eps 
       return theta * ROOT::Math::Cephes::igami( alpha, 1.- z); 
    }
-#endif
 
 
 
diff --git a/math/mathmore/Module.mk b/math/mathmore/Module.mk
index e05bbec..5fd4f8c 100644
--- a/math/mathmore/Module.mk
+++ b/math/mathmore/Module.mk
@@ -27,6 +27,7 @@ MATHMOREDO   := $(MATHMOREDS:.cxx=.o)
 MATHMOREDH   := $(MATHMOREDS:.cxx=.h)
 MATHMOREDH1  := $(MODDIRI)/Math/DistFuncMathMore.h \
                 $(MODDIRI)/Math/SpecFuncMathMore.h \
+                $(MODDIRI)/Math/PdfFuncMathMore.h \
                 $(MODDIRI)/Math/Polynomial.h \
                 $(MODDIRI)/Math/Derivator.h \
                 $(MODDIRI)/Math/Interpolator.h \
@@ -36,6 +37,7 @@ MATHMOREDH1  := $(MODDIRI)/Math/DistFuncMathMore.h \
                 $(MODDIRI)/Math/RootFinderAlgorithms.h \
                 $(MODDIRI)/Math/GSLIntegrator.h \
                 $(MODDIRI)/Math/GSLMCIntegrator.h \
+                $(MODDIRI)/Math/MCParameters.h \
                 $(MODDIRI)/Math/GSLMinimizer1D.h \
                 $(MODDIRI)/Math/Chebyshev.h  \
                 $(MODDIRI)/Math/Random.h \
@@ -44,6 +46,7 @@ MATHMOREDH1  := $(MODDIRI)/Math/DistFuncMathMore.h \
                 $(MODDIRI)/Math/GSLMinimizer.h \
                 $(MODDIRI)/Math/GSLNLSMinimizer.h \
                 $(MODDIRI)/Math/GSLSimAnMinimizer.h \
+                $(MODDIRI)/Math/GSLMultiRootFinder.h \
                 $(MODDIRI)/Math/Vavilov.h \
                 $(MODDIRI)/Math/VavilovAccurate.h \
                 $(MODDIRI)/Math/VavilovAccuratePdf.h \
diff --git a/math/mathmore/inc/Math/Chebyshev.h b/math/mathmore/inc/Math/Chebyshev.h
index c47cfeb..35142c3 100644
--- a/math/mathmore/inc/Math/Chebyshev.h
+++ b/math/mathmore/inc/Math/Chebyshev.h
@@ -53,7 +53,8 @@
 #endif
 
 #include <memory>
-#include <stddef.h>
+#include <cstddef>
+
 
 namespace ROOT {
 namespace Math {
diff --git a/math/mathmore/inc/Math/DistFuncMathMore.h b/math/mathmore/inc/Math/DistFuncMathMore.h
index 915a649..82c2658 100644
--- a/math/mathmore/inc/Math/DistFuncMathMore.h
+++ b/math/mathmore/inc/Math/DistFuncMathMore.h
@@ -25,9 +25,9 @@
 #ifndef ROOT_Math_DistFuncMathMore
 #define ROOT_Math_DistFuncMathMore
 
-// #ifndef ROOT_Math_PdfFuncMathMore
-// #include "Math/PdfFuncMathMore.h"
-// #endif
+#ifndef ROOT_Math_PdfFuncMathMore
+#include "Math/PdfFuncMathMore.h"
+#endif
 
 
 // #ifndef ROOT_Math_ProbFuncMathMore
diff --git a/math/mathmore/inc/Math/GSLIntegrator.h b/math/mathmore/inc/Math/GSLIntegrator.h
index 595e157..1c56c37 100644
--- a/math/mathmore/inc/Math/GSLIntegrator.h
+++ b/math/mathmore/inc/Math/GSLIntegrator.h
@@ -340,7 +340,11 @@ namespace Math {
          return the Error Status of the last Integral calculation
        */
       int Status() const;
-      
+            
+      /** 
+          return number of function evaluations in calculating the integral 
+      */
+      int NEval() const { return fNEval; }
       
       // setter for control Parameters  (getters are not needed so far )
       
@@ -362,8 +366,21 @@ namespace Math {
        */
       void SetIntegrationRule(Integration::GKRule );
       
+      /// set the options 
+      virtual void SetOptions(const ROOT::Math::IntegratorOneDimOptions & opt);
+
+      ///  get the option used for the integration 
+      virtual ROOT::Math::IntegratorOneDimOptions Options() const;
       
+      /// get type name
+      IntegrationOneDim::Type GetType() const { return fType; }
       
+      /** 
+          return the name
+      */
+      const char * GetTypeName() const; 
+
+
    protected:
          
       // internal method to check validity of GSL function pointer
@@ -384,6 +401,7 @@ namespace Math {
       double fResult;
       double fError;
       int fStatus;
+      int fNEval; 
       
       // GSLIntegrationAlgorithm * fAlgorithm;
       
diff --git a/math/mathmore/inc/Math/GSLMCIntegrator.h b/math/mathmore/inc/Math/GSLMCIntegrator.h
index 7d5f7b9..d26175b 100644
--- a/math/mathmore/inc/Math/GSLMCIntegrator.h
+++ b/math/mathmore/inc/Math/GSLMCIntegrator.h
@@ -95,21 +95,30 @@ namespace Math {
    class GSLMCIntegrator : public VirtualIntegratorMultiDim {
       
    public:
+
+      typedef MCIntegration::Type Type;
                   
       // constructors
       
-                  
+
+//       /** 
+//           constructor of GSL MCIntegrator using all the default options           
+//       */      
+//       GSLMCIntegrator( );
+
       
-      /** constructor of GSL MCIntegrator. VEGAS MC is set as default integration type 
+       /** constructor of GSL MCIntegrator. VEGAS MC is set as default integration type 
          
-      @param type type of integration. The possible types are defined in the Integration::Type enumeration
-      @param absTol desired absolute Error
+      @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration
+                                        Default is VEGAS 
+      @param absTol desired absolute Error 
       @param relTol desired relative Error
       @param calls maximum number of function calls
-      */
-      
-      explicit 
-      GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 1.E-6, double relTol = 1E-4, unsigned int calls = 500000);
+
+      NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions 
+      */      
+      explicit
+      GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 );
 
       /** constructor of GSL MCIntegrator. VEGAS MC is set as default integration type 
          
@@ -117,12 +126,9 @@ namespace Math {
       @param absTol desired absolute Error
       @param relTol desired relative Error
       @param calls maximum number of function calls
-      */
-      
-      explicit 
+      */ 
       GSLMCIntegrator(const char *  type, double absTol, double relTol, unsigned int calls);
-      
-      
+            
 
       /** 
           destructor 
@@ -199,7 +205,14 @@ public:
          return the Error Status of the last Integral calculation
        */
       int Status() const;
-      
+
+
+      /** 
+          return number of function evaluations in calculating the integral 
+          (This is an fixed by the user)
+      */
+      int NEval() const { return fCalls; }      
+
       
       // setter for control Parameters  (getters are not needed so far )
       
@@ -213,15 +226,13 @@ public:
          set the desired absolute Error
        */
       void SetAbsTolerance(double absTolerance);
-      
+
       /**
-	 to be added later as options for basic MC methods
-       The possible rules are defined in the Integration::GKRule enumeration.
-       The integration rule can be modified only for ADAPTIVE type integrations
+         set the integration options
        */
-      //void SetIntegrationRule(Integration::GKRule );
+      void SetOptions(const ROOT::Math::IntegratorMultiDimOptions & opt);
+      
       
-
       /**
 	 set random number generator
       */
@@ -233,6 +244,12 @@ public:
       void SetType(MCIntegration::Type type);
 
       /**
+	 set integration method using a name instead of an enumeration
+      */
+      void SetTypeName(const char * typeName);
+
+
+      /**
 	 set integration mode for VEGAS method
          The possible MODE are : 
          MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling 
@@ -268,6 +285,28 @@ public:
       */  
       double ChiSqr();
 
+      /** 
+          return the type 
+          (need to be called GetType to avois a conflict with typedef)
+      */
+      MCIntegration::Type GetType() const { return fType; }
+      
+      /** 
+          return the name
+      */
+      const char * GetTypeName() const; 
+
+      /**
+         get the option used for the integration
+      */
+      ROOT::Math::IntegratorMultiDimOptions Options() const; 
+
+      /**
+         get the specific options (for Vegas or Miser) 
+         in term of string-  name 
+      */
+      ROOT::Math::IOptions * ExtraOptions() const; 
+           
 
    protected:
          
@@ -282,14 +321,12 @@ public:
       //type of intergation method   
       MCIntegration::Type fType;
        
-      //mode for VEGAS integration
-      MCIntegration::Mode fMode;
       GSLRngWrapper * fRng;
 
-      double fAbsTol;
-      double fRelTol;
       unsigned int fDim;
       unsigned int fCalls;
+      double fAbsTol;
+      double fRelTol;
       
       // cache Error, Result and Status of integration
       
diff --git a/math/mathmore/inc/Math/GSLMinimizer.h b/math/mathmore/inc/Math/GSLMinimizer.h
index 806d8c9..72f85fa 100644
--- a/math/mathmore/inc/Math/GSLMinimizer.h
+++ b/math/mathmore/inc/Math/GSLMinimizer.h
@@ -167,7 +167,7 @@ public:
    virtual const double *  MinGradient() const; 
 
    /// number of function calls to reach the minimum 
-   virtual unsigned int NCalls() const { return 0; } // not yet ipl.  
+   virtual unsigned int NCalls() const;  
 
    /// this is <= Function().NDim() which is the total 
    /// number of variables (free+ constrained ones) 
diff --git a/math/mathmore/inc/Math/GSLNLSMinimizer.h b/math/mathmore/inc/Math/GSLNLSMinimizer.h
index 8af5a9f..dd66d1a 100644
--- a/math/mathmore/inc/Math/GSLNLSMinimizer.h
+++ b/math/mathmore/inc/Math/GSLNLSMinimizer.h
@@ -230,7 +230,7 @@ public:
    virtual const double *  MinGradient() const; 
 
    /// number of function calls to reach the minimum 
-   virtual unsigned int NCalls() const { return 0; } // not yet ipl.  
+   virtual unsigned int NCalls() const { return (fObjFunc) ? fObjFunc->NCalls() : 0; } 
 
    /// this is <= Function().NDim() which is the total 
    /// number of variables (free+ constrained ones) 
diff --git a/math/mathmore/inc/Math/GSLRndmEngines.h b/math/mathmore/inc/Math/GSLRndmEngines.h
index 3e5422f..fb2613a 100644
--- a/math/mathmore/inc/Math/GSLRndmEngines.h
+++ b/math/mathmore/inc/Math/GSLRndmEngines.h
@@ -230,6 +230,11 @@ namespace Math {
       unsigned int Binomial(double p, unsigned int n) const;
 
       /**
+         Negative Binomial distribution
+      */
+      unsigned int NegativeBinomial(double p, double n) const;
+
+      /**
          Multinomial distribution
       */
       std::vector<unsigned int> Multinomial( unsigned int ntot, const std::vector<double> & p ) const; 
@@ -269,7 +274,8 @@ namespace Math {
 
    //_____________________________________________________________________________________
    /**
-      Ranlux generator (James, Luscher) (defaul luxury)
+      Old Ranlux generator (James, Luscher) (default luxury level, p = 223)
+      (This is eequivalent to TRandom1 with default luxury level)
       see <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html">here</A>
 
       @ingroup Random
@@ -281,27 +287,58 @@ namespace Math {
 
    //_____________________________________________________________________________________
    /**
-      Second generation of Ranlux generator (with  luxury level of 2)
+      Second generation of Ranlux generator for single precision with  luxury level of 1
+      (It throws away 202 values for every 12 used)
+      see <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html">here</A>
+
+      @ingroup Random
+   */
+   class GSLRngRanLuxS1 : public GSLRandomEngine { 
+   public: 
+      GSLRngRanLuxS1(); 
+   };
+   typedef GSLRngRanLuxS1 GSLRngRanLux1; // for backward compatibility
+
+   //_____________________________________________________________________________________
+   /**
+      Second generation of Ranlux generator for Single precision with  luxury level of 2
+      (It throws away 397 value for every 12 used)
+      see <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html">here</A>
+
+      @ingroup Random
+   */
+   class GSLRngRanLuxS2 : public GSLRandomEngine { 
+   public: 
+      GSLRngRanLuxS2(); 
+   };
+   typedef GSLRngRanLuxS2 GSLRngRanLux2; // for backward compatibility
+
+   //_____________________________________________________________________________________
+   /**
+      Double precision (48 bits) version of Second generation of Ranlux generator with  luxury level of 1
+      (It throws away 202 value for every 12 used)
       see <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html">here</A>
 
       @ingroup Random
    */
-   class GSLRngRanLux2 : public GSLRandomEngine { 
+   class GSLRngRanLuxD1 : public GSLRandomEngine { 
    public: 
-      GSLRngRanLux2(); 
+      GSLRngRanLuxD1(); 
    };
 
    //_____________________________________________________________________________________
    /**
-      48 bits version of Second generation of Ranlux generator (with  luxury level of 2)
+      Double precision (48 bits) version of Second generation of Ranlux generator with  luxury level of 2
+      (It throws away 397 value for every 12 used)
       see <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html">here</A>
 
       @ingroup Random
    */
-   class GSLRngRanLux48 : public GSLRandomEngine { 
+   class GSLRngRanLuxD2 : public GSLRandomEngine { 
    public: 
-      GSLRngRanLux48(); 
+      GSLRngRanLuxD2(); 
    };
+   typedef GSLRngRanLuxD2 GSLRngRanLux48; // for backward compatibility
 
 
    //_____________________________________________________________________________________
diff --git a/math/mathmore/inc/Math/LinkDef.h b/math/mathmore/inc/Math/LinkDef.h
index 95a1837..ac89460 100644
--- a/math/mathmore/inc/Math/LinkDef.h
+++ b/math/mathmore/inc/Math/LinkDef.h
@@ -67,10 +67,18 @@
 #pragma link C++ class ROOT::Math::GSLRngMT+;
 #pragma link C++ class ROOT::Math::GSLRngTaus+;
 #pragma link C++ class ROOT::Math::GSLRngRanLux+;
+#pragma link C++ class ROOT::Math::GSLRngRanLuxS1+;
+#pragma link C++ class ROOT::Math::GSLRngRanLuxS2+;
+#pragma link C++ class ROOT::Math::GSLRngRanLuxD1+;
+#pragma link C++ class ROOT::Math::GSLRngRanLuxD2+;
 #pragma link C++ class ROOT::Math::GSLRngGFSR4+;
 #pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngMT>+;
 #pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngTaus>+;
 #pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngRanLux>+;
+#pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS1>+;
+#pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxS2>+;
+#pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD1>+;
+#pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngRanLuxD2>+;
 #pragma link C++ class ROOT::Math::Random<ROOT::Math::GSLRngGFSR4>+;
 
 #pragma link C++ class ROOT::Math::KelvinFunctions+;
@@ -92,7 +100,10 @@
 // #endif
 
 #pragma link C++ class ROOT::Math::GSLMCIntegrator+;
+#pragma link C++ class ROOT::Math::VegasParameters+;
+#pragma link C++ class ROOT::Math::MiserParameters+;
 
-
+#pragma link C++ class ROOT::Math::GSLMultiRootFinder+;
+#pragma link C++ typedef ROOT::Math::MultiRootFinder;
 
 #endif //__CINT__
diff --git a/math/mathmore/inc/Math/LinkDef_Func.h b/math/mathmore/inc/Math/LinkDef_Func.h
index 0f759ad..c0560be 100644
--- a/math/mathmore/inc/Math/LinkDef_Func.h
+++ b/math/mathmore/inc/Math/LinkDef_Func.h
@@ -40,15 +40,23 @@
 #pragma link C++ function ROOT::Math::airy_zero_Bi(unsigned int);
 #pragma link C++ function ROOT::Math::airy_zero_Ai_deriv(unsigned int)
 #pragma link C++ function ROOT::Math::airy_zero_Bi_deriv(unsigned int);
+#pragma link C++ function ROOT::Math::wigner_3j(int,int,int,int,int,int);
+#pragma link C++ function ROOT::Math::wigner_6j(int,int,int,int,int,int);
+#pragma link C++ function ROOT::Math::wigner_9j(int,int,int,int,int,int,int,int,int);
 
 // statistical functions: 
 
+//pdf 
+#pragma link C++ function ROOT::Math::noncentral_chisquared_pdf(double,double,double);
+
+
 // quantiles: inverses of cdf
 
 #pragma link C++ function ROOT::Math::tdistribution_quantile_c(double,double);
 #pragma link C++ function ROOT::Math::tdistribution_quantile(double,double);
 
-#pragma link C++ function ROOT::Math::chisquared_quantile(double,double);
-#pragma link C++ function ROOT::Math::gamma_quantile(double,double,double);
+#pragma link C++ namespace ROOT::MathMore;
+#pragma link C++ function ROOT::MathMore::chisquared_quantile(double,double);
+#pragma link C++ function ROOT::MathMore::gamma_quantile(double,double,double);
 
 #endif
diff --git a/math/mathmore/inc/Math/MCParameters.h b/math/mathmore/inc/Math/MCParameters.h
index b22ca85..9e31d67 100644
--- a/math/mathmore/inc/Math/MCParameters.h
+++ b/math/mathmore/inc/Math/MCParameters.h
@@ -26,35 +26,45 @@
 #ifndef ROOT_Math_MCParameters
 #define ROOT_Math_MCParameters
 
+#include <cstring>   // for size_t
 
 namespace ROOT {
 namespace Math {
 
 
+class IOptions;
 
 /**
    structures collecting parameters 
    for VEGAS multidimensional integration
+   FOr implementation of default parameters see file 
+   mathmore/src/GSLMCIntegrationWorkspace.h
 
    @ingroup MCIntegration
 */
 struct VegasParameters{
-  double sigma;
-  double chisq;
-  double alpha;
-  size_t iterations;
-  
-  VegasParameters():
-    alpha( 1.5),
-    iterations(5)
-  {} 
- 
+   double alpha;
+   size_t iterations; 
+   int stage; 
+   int mode; 
+   int verbose; 
+
+   // constructor of default parameters
+   VegasParameters() { SetDefaultValues(); }
+
+   // construct from GenAlgoOptions
+   // parameter not specified are ignored 
+   VegasParameters(const ROOT::Math::IOptions & opt);
 
-//int stage;
-  //int mode;
-  //int verbose;
+   void SetDefaultValues();
 
+   VegasParameters & operator=(const ROOT::Math::IOptions & opt);
+
+   /// convert to options (return object is managed by the user) 
+   ROOT::Math::IOptions * operator() () const;
 };
+  
+ 
 
 
 /**
@@ -64,21 +74,30 @@ struct VegasParameters{
    @ingroup MCIntegration
 */
 struct MiserParameters{
-  double estimate_frac;
-  size_t min_calls;
-  size_t min_calls_per_bisection;
-  double alpha;
-
-  MiserParameters(unsigned int dim):
-    estimate_frac(0.1),
-    min_calls(16*dim),
-    min_calls_per_bisection(32*min_calls) ,
-    alpha(2.)
-  {}
+   double estimate_frac;
+   size_t min_calls;
+   size_t min_calls_per_bisection;
+   double alpha;
+   double dither; 
+
+   // constructor of default parameters
+   // needs dimension since min_calls = 16 * dim
+   MiserParameters(size_t dim=10) { SetDefaultValues(dim); }
+
+   void SetDefaultValues(size_t dim=10);
+
+   // construct from GenAlgoOptions
+   // parameter not specified are ignored 
+   MiserParameters(const ROOT::Math::IOptions & opt, size_t dim = 10);
+
+   MiserParameters & operator=(const ROOT::Math::IOptions & opt);
+
+   /// convert to options (return object is managed by the user) 
+   ROOT::Math::IOptions * operator() () const;
+
 };
 
 struct PlainParameters{
-
 };
 
 } // namespace Math
diff --git a/math/mathmore/inc/Math/MultiNumGradFunction.h b/math/mathmore/inc/Math/MultiNumGradFunction.h
index 783d011..daa249b 100644
--- a/math/mathmore/inc/Math/MultiNumGradFunction.h
+++ b/math/mathmore/inc/Math/MultiNumGradFunction.h
@@ -61,6 +61,7 @@ public:
    MultiNumGradFunction (const IMultiGenFunction & f) : 
       fFunc(&f), 
       fDim(f.NDim() ),
+      fNCalls(0),
       fOwner(false)
    {}
 
@@ -72,6 +73,7 @@ public:
    template<class FuncType> 
    MultiNumGradFunction (FuncType f, int n) : 
       fDim( n ), 
+      fNCalls(0),
       fOwner(true)
    {
       // create a wrapped function
@@ -90,6 +92,8 @@ public:
 
    unsigned int NDim() const { return fDim; } 
 
+   unsigned int NCalls() const { return fNCalls; }
+
    IMultiGenFunction * Clone() const { 
       if (!fOwner) 
          return new MultiNumGradFunction(*fFunc); 
@@ -114,6 +118,7 @@ private:
 
 
    double DoEval(const double * x) const { 
+      fNCalls++;
       return (*fFunc)(x); 
    }
 
@@ -123,6 +128,7 @@ private:
    // adapat internal function type to IMultiGenFunction needed by derivative calculation
    const IMultiGenFunction * fFunc;  
    unsigned int fDim; 
+   mutable unsigned int fNCalls;
    bool fOwner; 
 
    static double fgEps;          // epsilon used in derivative calculation h ~ eps |x|
diff --git a/math/mathmore/inc/Math/PdfFuncMathMore.h b/math/mathmore/inc/Math/PdfFuncMathMore.h
index bfecc46..b10fbf9 100644
--- a/math/mathmore/inc/Math/PdfFuncMathMore.h
+++ b/math/mathmore/inc/Math/PdfFuncMathMore.h
diff --git a/math/mathmore/inc/Math/Polynomial.h b/math/mathmore/inc/Math/Polynomial.h
index 425cce1..b2d6372 100644
--- a/math/mathmore/inc/Math/Polynomial.h
+++ b/math/mathmore/inc/Math/Polynomial.h
@@ -64,10 +64,10 @@ class Polynomial : public ParamFunction<IParamGradFunction>,
                    public IGradientOneDim  
 {
 
-   typedef  ParamFunction<IParamGradFunction> ParFunc; 
-
-public: 
   
+public: 
+ 
+ typedef  ParamFunction<IParamGradFunction> ParFunc;  
    /**
       Construct a Polynomial function of order n. 
       The number of Parameters is n+1. 
diff --git a/math/mathmore/inc/Math/QuantFuncMathMore.h b/math/mathmore/inc/Math/QuantFuncMathMore.h
index bcfa30a..2654471 100644
--- a/math/mathmore/inc/Math/QuantFuncMathMore.h
+++ b/math/mathmore/inc/Math/QuantFuncMathMore.h
@@ -82,45 +82,6 @@ namespace Math {
   //@{
 
 
-
-
-
-  /**
-
-  Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution 
-  function of the lower tail of the \f$\chi^2\f$ distribution 
-  with \f$r\f$ degrees of freedom (#chisquared_cdf). For detailed description see 
-  <A HREF="http://mathworld.wolfram.com/Chi-SquaredDistribution.html">
-  Mathworld</A>. The implementation used is that of 
-  <A HREF="http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC303">GSL</A>.
-
-  @ingroup QuantFunc
-
-  */
-
-  double chisquared_quantile(double z, double r);
-
-
-
-
-  /**
-
-  Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution 
-  function of the lower tail of the gamma distribution
-  (#gamma_cdf). For detailed description see 
-  <A HREF="http://mathworld.wolfram.com/GammaDistribution.html">
-  Mathworld</A>. The implementation used is that of 
-  <A HREF="http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC300">GSL</A>.
-  
-  @ingroup QuantFunc
-
-  */
-
-  double gamma_quantile(double z, double alpha, double theta);
-
-
-
-
   /**
 
   Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution 
@@ -154,6 +115,7 @@ namespace Math {
 
   double tdistribution_quantile(double z, double r);
 
+
 #ifdef HAVE_OLD_STAT_FUNC
 
   //@}
@@ -182,6 +144,47 @@ namespace Math {
 
 
 } // namespace Math
+
+namespace MathMore {
+
+
+
+  /**
+
+  Re-implementation in MathMore of the Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution 
+  function of the lower tail of the \f$\chi^2\f$ distribution 
+  with \f$r\f$ degrees of freedom (#chisquared_cdf). For detailed description see 
+  <A HREF="http://mathworld.wolfram.com/Chi-SquaredDistribution.html">
+  Mathworld</A>. The implementation used is that of 
+  <A HREF="http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC303">GSL</A>.
+
+  @ingroup QuantFunc
+
+  */
+
+  double chisquared_quantile(double z, double r);
+
+
+
+
+  /**
+
+  Re-implementation in MathMore of the Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution 
+  function of the lower tail of the gamma distribution
+  (#gamma_cdf). For detailed description see 
+  <A HREF="http://mathworld.wolfram.com/GammaDistribution.html">
+  Mathworld</A>. The implementation used is that of 
+  <A HREF="http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC300">GSL</A>.
+  
+  @ingroup QuantFunc
+
+  */
+
+  double gamma_quantile(double z, double alpha, double theta);
+
+
+
+} // end namespace MathMore
 } // namespace ROOT
 
 
diff --git a/math/mathmore/inc/Math/Random.h b/math/mathmore/inc/Math/Random.h
index edd68a4..b330254 100644
--- a/math/mathmore/inc/Math/Random.h
+++ b/math/mathmore/inc/Math/Random.h
@@ -271,6 +271,15 @@ namespace Math {
     }
 
     /**
+       Negative Binomial distribution
+       First parameter is n, second is probability
+       To be consistent with Random::Binomial
+     */
+     unsigned int NegativeBinomial(double n, double prob) { 
+      return fEngine.NegativeBinomial(prob,n);
+    }
+
+    /**
        Multinomial distribution
      */
     std::vector<unsigned int> Multinomial( unsigned int ntot, const std::vector<double> & p ) { 
diff --git a/math/mathmore/inc/Math/SpecFuncMathMore.h b/math/mathmore/inc/Math/SpecFuncMathMore.h
index 7725191..eaace40 100644
--- a/math/mathmore/inc/Math/SpecFuncMathMore.h
+++ b/math/mathmore/inc/Math/SpecFuncMathMore.h
@@ -765,6 +765,56 @@ namespace Math {
 
   double airy_zero_Bi_deriv(unsigned int s);
 
+  /**
+  
+  Calculates the Wigner 3j coupling coefficients
+
+
+  For detailed description see 
+  <A HREF="http://mathworld.wolfram.com/Wigner3j-Symbol.html.html">
+  Mathworld</A>.
+  The implementation used is that of 
+  <A HREF="http://www.gnu.org/software/gsl/manual/html_node/3_002dj-Symbols.html#g_t3_002dj-Symbols">GSL</A>.
+
+  @ingroup SpecFunc
+
+  */
+
+  double wigner_3j(int ja, int jb, int jc, int ma, int mb, int mc);
+
+  /**
+  
+  Calculates the Wigner 6j coupling coefficients
+
+
+  For detailed description see 
+  <A HREF="http://mathworld.wolfram.com/Wigner6j-Symbol.html">
+  Mathworld</A>.
+  The implementation used is that of 
+  <A HREF="http://www.gnu.org/software/gsl/manual/html_node/6_002dj-Symbols.html#g_t6_002dj-Symbols">GSL</A>.
+
+  @ingroup SpecFunc
+
+  */
+
+  double wigner_6j(int ja, int jb, int jc, int jd, int je, int jf);
+
+  /**
+  
+  Calculates the Wigner 9j coupling coefficients
+
+  For detailed description see 
+  <A HREF="http://mathworld.wolfram.com/Wigner9j-Symbol.html">
+  Mathworld</A>.
+  The implementation used is that of 
+  <A HREF="http://www.gnu.org/software/gsl/manual/html_node/9_002dj-Symbols.html#g_t9_002dj-Symbols">GSL</A>.
+
+  @ingroup SpecFunc
+
+  */
+
+   double wigner_9j(int ja, int jb, int jc, int jd, int je, int jf, int jg, int jh, int ji);
+
 
 
 } // namespace Math
diff --git a/math/mathmore/src/GSLIntegrator.cxx b/math/mathmore/src/GSLIntegrator.cxx
index 82119cc..c70202f 100644
--- a/math/mathmore/src/GSLIntegrator.cxx
+++ b/math/mathmore/src/GSLIntegrator.cxx
@@ -37,6 +37,12 @@
 #include "GSLIntegrationWorkspace.h"
 #include "GSLFunctionWrapper.h"
 
+// for toupper
+#include <algorithm>
+#include <functional>
+#include <ctype.h>   // need to use c version of tolower defined here
+
+
 #include <iostream>
 
 
@@ -54,7 +60,7 @@ GSLIntegrator::GSLIntegrator(const Integration::Type type , const Integration::G
    fRelTol(relTol),
    fSize(size),
    fMaxIntervals(size),
-   fResult(0),fError(0),fStatus(-1),
+   fResult(0),fError(0),fStatus(-1),fNEval(-1),
    fFunction(0),
    fWorkspace(0)
 {
@@ -75,7 +81,7 @@ GSLIntegrator::GSLIntegrator(double absTol, double relTol, size_t size) :
    fRelTol(relTol),
    fSize(size),
    fMaxIntervals(size),
-   fResult(0),fError(0),fStatus(-1),
+   fResult(0),fError(0),fStatus(-1),fNEval(-1),
    fFunction(0),
    fWorkspace(0)
 {
@@ -93,7 +99,7 @@ GSLIntegrator::GSLIntegrator(const Integration::Type type , double absTol, doubl
    fRelTol(relTol),
    fSize(size),
    fMaxIntervals(size),
-   fResult(0),fError(0),fStatus(-1),
+   fResult(0),fError(0),fStatus(-1),fNEval(-1),
    fFunction(0),
    fWorkspace(0)
 {
@@ -111,20 +117,25 @@ GSLIntegrator::GSLIntegrator(const Integration::Type type , double absTol, doubl
    fRelTol(relTol),
    fSize(size),
    fMaxIntervals(size),
-   fResult(0),fError(0),fStatus(-1),
+   fResult(0),fError(0),fStatus(-1),fNEval(-1),
    fFunction(0),
    fWorkspace(0)
 {
    //std::cout << type << std::endl; 
 
-   std::string typeName(type); 
-   if (typeName == "NONADAPTIVE")
-      fType =  Integration::kADAPTIVE;
-   else if (typeName == "ADAPTIVESINGULAR")
-      fType =  Integration::kADAPTIVESINGULAR;
-   else 
-      fType =  Integration::kADAPTIVE;  // default
-
+   fType =  Integration::kADAPTIVESINGULAR;  // default
+   if (type != 0) {  // use this dafault
+      std::string typeName(type); 
+      std::transform(typeName.begin(), typeName.end(), typeName.begin(), (int(*)(int)) toupper );  
+      if (typeName == "NONADAPTIVE")
+         fType =  Integration::kNONADAPTIVE;
+      else if (typeName == "ADAPTIVE")
+         fType =  Integration::kADAPTIVE;
+      else { 
+         if (typeName != "ADAPTIVESINGULAR") 
+            MATH_WARN_MSG("GSLIntegrator","Use default type: AdaptiveSingular");
+      }
+   }
 
 
    // constructor with default rule (gauss31) passing the type
@@ -132,7 +143,7 @@ GSLIntegrator::GSLIntegrator(const Integration::Type type , double absTol, doubl
    if (fType !=  Integration::kNONADAPTIVE)
       fWorkspace = new GSLIntegrationWorkspace( fSize);
 
-   SetIntegrationRule((Integration::GKRule) rule);
+   if (rule >= Integration::kGAUSS15 && rule <= Integration::kGAUSS61) SetIntegrationRule((Integration::GKRule) rule);
    
 }
 
@@ -186,9 +197,13 @@ double  GSLIntegrator::Integral(double a, double b) {
    if ( fType == Integration::kNONADAPTIVE) {
       size_t neval = 0; // need to export  this ?
       fStatus = gsl_integration_qng( fFunction->GetFunc(), a, b , fAbsTol, fRelTol, &fResult, &fError, &neval);
+      fNEval = neval;
    }
    else if (fType ==  Integration::kADAPTIVE) {
       fStatus = gsl_integration_qag( fFunction->GetFunc(), a, b , fAbsTol, fRelTol, fMaxIntervals, fRule, fWorkspace->GetWS(), &fResult, &fError);
+      const int npts[6] = {15,21,31,41,51,61}; 
+      assert(fRule>=1 && fRule <=6);
+      fNEval = (fWorkspace->GetWS()->size)*npts[fRule-1];   // get size of workspace (number of iterations)
    }
    else if (fType ==  Integration::kADAPTIVESINGULAR) {
       
@@ -196,6 +211,7 @@ double  GSLIntegrator::Integral(double a, double b) {
       
       
       fStatus = gsl_integration_qags( fFunction->GetFunc(), a, b , fAbsTol, fRelTol, fMaxIntervals, fWorkspace->GetWS(), &fResult, &fError);
+      fNEval = (fWorkspace->GetWS()->size) * 21; //since 21 point rule is used in qags
    }
    else {
       
@@ -216,7 +232,8 @@ double  GSLIntegrator::IntegralCauchy(double a, double b, double c) {
    if (!CheckFunction()) return 0;  
   
    fStatus = gsl_integration_qawc( fFunction->GetFunc(), a, b , c, fAbsTol, fRelTol, fMaxIntervals, fWorkspace->GetWS(), &fResult, &fError);
-  
+   fNEval = (fWorkspace->GetWS()->size) * 15; // 15 point rule is used ?
+
    return fResult;
    
 }
@@ -241,6 +258,7 @@ double  GSLIntegrator::Integral( const std::vector<double> & pts) {
       // remove constness ( should be const in GSL ? )
       double * p = const_cast<double *>(&pts.front() );
       fStatus = gsl_integration_qagp( fFunction->GetFunc(), p, pts.size() , fAbsTol, fRelTol, fMaxIntervals,  fWorkspace->GetWS(), &fResult, &fError);
+      fNEval = (fWorkspace->GetWS()->size) * 15; // 15 point rule is used ?
    }
    else {
       fResult = 0;
@@ -262,6 +280,7 @@ double  GSLIntegrator::Integral( ) {
    if (!fWorkspace) fWorkspace = new GSLIntegrationWorkspace( fSize);
    
    fStatus = gsl_integration_qagi( fFunction->GetFunc(), fAbsTol, fRelTol, fMaxIntervals, fWorkspace->GetWS(), &fResult, &fError);
+   fNEval = (fWorkspace->GetWS()->size) * 15; // 15 point rule is used ?
    
    return fResult;
 }
@@ -277,6 +296,7 @@ double  GSLIntegrator::IntegralUp( double a ) {
    if (!fWorkspace) fWorkspace = new GSLIntegrationWorkspace( fSize);
    
    fStatus = gsl_integration_qagiu( fFunction->GetFunc(), a, fAbsTol, fRelTol, fMaxIntervals, fWorkspace->GetWS(), &fResult, &fError);
+   fNEval = (fWorkspace->GetWS()->size) * 21; // 21 point rule is used ?
    
    return fResult;
 }
@@ -292,6 +312,7 @@ double  GSLIntegrator::IntegralLow( double b ) {
    if (!fWorkspace) fWorkspace = new GSLIntegrationWorkspace( fSize);
    
    fStatus = gsl_integration_qagil( fFunction->GetFunc(), b, fAbsTol, fRelTol, fMaxIntervals, fWorkspace->GetWS(), &fResult, &fError);
+   fNEval = (fWorkspace->GetWS()->size) * 21; // 21 point rule is used ?
    
    return fResult;
 }
@@ -392,6 +413,56 @@ bool GSLIntegrator::CheckFunction() {
    return false; 
 }
 
+void GSLIntegrator::SetOptions(const ROOT::Math::IntegratorOneDimOptions & opt)
+{
+   //   set integration options
+   fType = opt.IntegratorType();
+   if (fType == IntegrationOneDim::kDEFAULT) fType = IntegrationOneDim::kADAPTIVESINGULAR; 
+   if (fType != IntegrationOneDim::kADAPTIVE && 
+       fType != IntegrationOneDim::kADAPTIVESINGULAR && 
+       fType != IntegrationOneDim::kNONADAPTIVE ) {
+      MATH_WARN_MSG("GSLIntegrator::SetOptions","Invalid rule options - use default ADAPTIVESINGULAR");
+      fType = IntegrationOneDim::kADAPTIVESINGULAR; 
+   }
+   SetAbsTolerance( opt.AbsTolerance() );
+   SetRelTolerance( opt.RelTolerance() );
+   fSize = opt.WKSize();
+   fMaxIntervals = fSize; 
+   if (fType == Integration::kADAPTIVE) { 
+      int npts = opt.NPoints();
+      if  ( npts >= Integration::kGAUSS15 && npts <= Integration::kGAUSS61) 
+         fRule = (Integration::GKRule) npts;
+      else { 
+         MATH_WARN_MSG("GSLIntegrator::SetOptions","Invalid rule options - use default GAUSS31");
+         fRule = Integration::kGAUSS31;
+      }
+   }
+}
+
+ROOT::Math::IntegratorOneDimOptions  GSLIntegrator::Options() const { 
+   ROOT::Math::IntegratorOneDimOptions opt; 
+   opt.SetAbsTolerance(fAbsTol); 
+   opt.SetRelTolerance(fRelTol); 
+   opt.SetWKSize(fSize); 
+   opt.SetIntegrator(GetTypeName() );
+
+   if (fType == IntegrationOneDim::kADAPTIVE) 
+      opt.SetNPoints(fRule);       
+   else if (fType == IntegrationOneDim::kADAPTIVESINGULAR) 
+      opt.SetNPoints( Integration::kGAUSS31 ); // fixed rule for adaptive singular
+   else 
+      opt.SetNPoints( 0 ); // not available for the rest
+
+   return opt; 
+}
+
+const char * GSLIntegrator::GetTypeName() const { 
+   if (fType == IntegrationOneDim::kADAPTIVE) return "Adaptive";
+   if (fType == IntegrationOneDim::kADAPTIVESINGULAR) return "AdaptiveSingular";
+   if (fType == IntegrationOneDim::kNONADAPTIVE) return "NonAdaptive";
+   return "Undefined";
+}    
+
 
 } // namespace Math
 } // namespace ROOT
diff --git a/math/mathmore/src/GSLMCIntegrationWorkspace.h b/math/mathmore/src/GSLMCIntegrationWorkspace.h
index d396247..06f0b7e 100644
--- a/math/mathmore/src/GSLMCIntegrationWorkspace.h
+++ b/math/mathmore/src/GSLMCIntegrationWorkspace.h
@@ -50,90 +50,179 @@ namespace Math {
 
    public :
 
-      GSLMCIntegrationWorkspace(unsigned int dim) : 
-         fDim(dim)
-      {}
+      GSLMCIntegrationWorkspace()  {}
 
-      virtual ~GSLMCIntegrationWorkspace() { }
+      virtual ~GSLMCIntegrationWorkspace() { Clear(); }
 
       virtual MCIntegration::Type Type() const = 0;  
 
-      unsigned int NDim() const { return fDim; } 
+      virtual size_t NDim() const { return 0; } 
 
+      /// initialize the workspace creating the GSL pointer if it is not there 
+      virtual bool Init(size_t dim) = 0; 
+
+      /// re-initialize an existing the workspace
+      virtual bool ReInit() = 0; 
+
+      /// free the workspace deleting the GSL pointer 
+      virtual void Clear() {}
+
+      /// retrieve option pointer corresponding to parameters 
+      /// create a new object to be managed by the user 
+      virtual ROOT::Math::IOptions * Options() const = 0;  
 
    private:
 
-      unsigned int fDim;  // workspace dimension (must be equal o functino dimension)
 
    };
-
+   
+   /**
+      workspace for VEGAS
+    */
    class GSLVegasIntegrationWorkspace : public GSLMCIntegrationWorkspace { 
 
    public :
       
-      GSLVegasIntegrationWorkspace(size_t dim) : 
-         GSLMCIntegrationWorkspace (dim)
+      GSLVegasIntegrationWorkspace(size_t dim = 0) : 
+         fWs(0)
       {
+         if (dim > 0) Init(dim);
+      }
+
+      bool Init(size_t dim) { 
          fWs = gsl_monte_vegas_alloc( dim);
+         if (fWs) SetVegasParameters();
+         return (fWs != 0);
       }
-      ~GSLVegasIntegrationWorkspace() {
-         gsl_monte_vegas_free( fWs);
+
+      bool ReInit() { 
+         // according to the code - reinit just reset default GSL values
+         if (!fWs) return false; 
+         int iret = gsl_monte_vegas_init( fWs );
+         SetVegasParameters();
+         return (iret == 0);
+      }
+
+      void Clear() { 
+         if (fWs) gsl_monte_vegas_free( fWs);
+         fWs = 0;
       }
 
       gsl_monte_vegas_state * GetWS() { return fWs; }
-      void SetParameters();
-      void SetParameters(const struct VegasParameters &p);
-      double Sigma() const;
+
+      void SetParameters(const struct VegasParameters &p) { 
+         fParams = p; 
+         if (fWs) SetVegasParameters();
+      }
+
+      size_t NDim() const { return (fWs) ? fWs->dim : 0; } 
+
+      double Result() const {  return (fWs) ? fWs->result : -1;}
+
+      double Sigma() const {  return (fWs) ? fWs->sigma : 0;}
+
+      double Chisq() const {  return (fWs) ? fWs->chisq: -1;}
 
       MCIntegration::Type Type() const { return MCIntegration::kVEGAS; }
+
+      const VegasParameters & Parameters() const { return fParams; }
+      VegasParameters & Parameters()  { return fParams; }
+
+      virtual ROOT::Math::IOptions * Options() const { 
+         return fParams();
+      } 
+
       
    private: 
-      gsl_monte_vegas_state * fWs; 
 
-   };
+      void SetVegasParameters() { 
+         fWs->alpha       = fParams.alpha;
+         fWs->iterations  = fParams.iterations;
+         fWs->stage       = fParams.stage; 
+         fWs->mode        = fParams.mode; 
+         fWs->verbose     = fParams.verbose; 
+      }
 
-   void GSLVegasIntegrationWorkspace::SetParameters(const struct VegasParameters &p)
-   {
-    
-      fWs->alpha = p.alpha;
-      fWs->iterations= p.iterations;
+      
+      gsl_monte_vegas_state * fWs; 
+      VegasParameters fParams;
 
-   }
-   double GSLVegasIntegrationWorkspace::Sigma()const {return fWs->sigma;}
+   };
 
 
+   /**
+      Workspace for MISER 
+    */
    class GSLMiserIntegrationWorkspace : public GSLMCIntegrationWorkspace { 
 
    public :
       
-      GSLMiserIntegrationWorkspace(size_t dim) : 
-         GSLMCIntegrationWorkspace (dim)
+      GSLMiserIntegrationWorkspace(size_t dim = 0) : 
+         fHaveNewParams(false),
+         fWs(0)
       {
+         if (dim > 0) Init(dim);
+      }
+
+
+      bool Init(size_t dim) { 
          fWs = gsl_monte_miser_alloc( dim);
+         // need this to set parameters according to dimension
+         if (!fHaveNewParams) fParams = MiserParameters(dim);
+         if (fWs) SetMiserParameters();
+         return (fWs != 0);
       }
-      ~GSLMiserIntegrationWorkspace() {
-         gsl_monte_miser_free( fWs);
+
+      bool ReInit() { 
+         // according to the code - reinit just reset default GSL values
+         if (!fWs) return false; 
+         int iret = gsl_monte_miser_init( fWs );
+         SetMiserParameters();
+         return (iret == 0);
+      }
+
+      void Clear() { 
+         if (fWs) gsl_monte_miser_free( fWs);
+         fWs = 0;
       }
 
       gsl_monte_miser_state * GetWS() { return fWs; }
-      void SetParameters();
-      void SetParameters(const struct MiserParameters &p);
+
+      void SetParameters(const MiserParameters &p) { 
+         fParams = p;
+         fHaveNewParams = true; 
+         if (fWs) SetMiserParameters();
+      }
+
+      size_t NDim() const { return (fWs) ? fWs->dim : 0; } 
 
       MCIntegration::Type Type() const { return MCIntegration::kMISER; }
-    
+
+
+      const MiserParameters & Parameters() const { return fParams; }
+      MiserParameters & Parameters()  { return fParams; }
+
+      virtual ROOT::Math::IOptions * Options() const { 
+         return fParams();
+      } 
+   
    private: 
-      gsl_monte_miser_state * fWs; 
 
-   };
+      void SetMiserParameters()
+      {
+         fWs->estimate_frac           = fParams.estimate_frac;
+         fWs->min_calls               = fParams.min_calls;
+         fWs->min_calls_per_bisection = fParams.min_calls_per_bisection;
+         fWs->alpha                   = fParams.alpha;
+         fWs->dither                  = fParams.dither;
+      }
+
 
-   void GSLMiserIntegrationWorkspace::SetParameters(const struct MiserParameters &p)
-   {
-      fWs->estimate_frac = p.estimate_frac;
-      fWs->min_calls = p.min_calls;
-      fWs->min_calls_per_bisection = p.min_calls_per_bisection;
-      fWs->alpha = p.alpha;
+      bool fHaveNewParams; 
+      gsl_monte_miser_state * fWs; 
+      MiserParameters fParams;
 
-   }
+   };
 
 
 
@@ -142,25 +231,45 @@ namespace Math {
 
    public :
       
-      GSLPlainIntegrationWorkspace(size_t dim) : 
-         GSLMCIntegrationWorkspace (dim)
-      {
+      GSLPlainIntegrationWorkspace() : 
+         fWs(0)
+      {  }
+
+      bool Init(size_t dim) { 
          fWs = gsl_monte_plain_alloc( dim);
+         // no parameter exists for plain
+         return (fWs != 0);
       }
-      ~GSLPlainIntegrationWorkspace() {
-         gsl_monte_plain_free( fWs);
+
+      bool ReInit() { 
+         if (!fWs) return false; 
+         int iret = gsl_monte_plain_init( fWs );
+         return (iret == GSL_SUCCESS);
+      }
+
+      void Clear() { 
+         if (fWs) gsl_monte_plain_free( fWs);
+         fWs = 0;
       }
 
       gsl_monte_plain_state * GetWS() { return fWs; }
-      //void SetParameters();
+
       //void SetParameters(const struct PlainParameters &p);
 
       MCIntegration::Type Type() const { return MCIntegration::kPLAIN; }
 
+      size_t NDim() const { return (fWs) ? fWs->dim : 0; }    
+
+      virtual ROOT::Math::IOptions * Options() const { 
+         return 0;
+      } 
+
+
    private: 
+
       gsl_monte_plain_state * fWs; 
 
-   
+
    };
 
 
diff --git a/math/mathmore/src/GSLMCIntegrator.cxx b/math/mathmore/src/GSLMCIntegrator.cxx
index 0dba37a..d0b3750 100644
--- a/math/mathmore/src/GSLMCIntegrator.cxx
+++ b/math/mathmore/src/GSLMCIntegrator.cxx
@@ -1,3 +1,26 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Author: Magdalena Slawinska  08/2007
+
+ /**********************************************************************
+  *                                                                    *
+  * Copyright (c) 2007 ROOT Foundation,  CERN/PH-SFT                   *
+  *                                                                    *
+  * This library is free software; you can redistribute it and/or      *
+  * modify it under the terms of the GNU General Public License        *
+  * as published by the Free Software Foundation; either version 2     *
+  * of the License, or (at your option) any later version.             *
+  *                                                                    *
+  * This library is distributed in the hope that it will be useful,    *
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+  * General Public License for more details.                           *
+  *                                                                    *
+  * You should have received a copy of the GNU General Public License  *
+  * along with this library (see file COPYING); if not, write          *
+  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+  * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+  *                                                                    *
+  **********************************************************************/
 //
 // implementation file for class GSLMCIntegrator
 // Author: Magdalena Slawinska
@@ -6,6 +29,7 @@
 
 #include "Math/IFunctionfwd.h"
 #include "Math/IFunction.h"
+#include "Math/Error.h"
 #include <vector>
 
 #include "GSLMonteFunctionWrapper.h"
@@ -14,6 +38,10 @@
 #include "GSLMCIntegrationWorkspace.h"
 #include "GSLRngWrapper.h"
 
+#include <algorithm>
+#include <functional>
+#include <ctype.h>   // need to use c version of tolower defined here
+
 
 #include "gsl/gsl_monte_vegas.h"
 #include "gsl/gsl_monte_miser.h"
@@ -26,60 +54,78 @@ namespace Math {
 
 
                       
-// constructor
-      
-                   
-      
+// constructors
+
+// GSLMCIntegrator::GSLMCIntegrator():
+//    fResult(0),fError(0),fStatus(-1),
+//    fWorkspace(0),
+//    fFunction(0)
+// {
+//    // constructor of GSL MCIntegrator.Vegas MC is set as default integration type
+//    //set random number generator
+//    fRng = new GSLRngWrapper();      
+//    fRng->Allocate();
+//    // use the default options 
+//    ROOT::Math::IntegratorMultiDimOptions opts;  // this create the default options
+//    SetOptions(opts); 
+// }
+
+    
 GSLMCIntegrator::GSLMCIntegrator(MCIntegration::Type type, double absTol, double relTol, unsigned int calls):
    fType(type),
-   fMode(MCIntegration::kIMPORTANCE),
-   fAbsTol(absTol),
-   fRelTol(relTol),
    fDim(0),
-   //fr(r),
-   fCalls(calls),
+   fCalls((calls > 0)  ? calls : IntegratorMultiDimOptions::DefaultNCalls()),
+   fAbsTol((absTol >0) ? absTol : IntegratorMultiDimOptions::DefaultAbsTolerance() ),
+   fRelTol((relTol >0) ? relTol : IntegratorMultiDimOptions::DefaultRelTolerance() ),
    fResult(0),fError(0),fStatus(-1),
    fWorkspace(0),
    fFunction(0)
 {
-   // constructor of GSL MCIntegrator.Vegas MC is set as default integration type
-   //set Workspace according to type
-   
+   // constructor of GSL MCIntegrator using enumeration as type 
+   SetType(type);
    //set random number generator
    fRng = new GSLRngWrapper();      
    fRng->Allocate();
+   // use the default options for the needed extra parameters 
+   // use the default options for the needed extra parameters 
+   if (fType == MCIntegration::kVEGAS) {    
+      IOptions * opts = IntegratorMultiDimOptions::FindDefault("VEGAS");
+      if (opts != 0) SetParameters( VegasParameters(*opts) );
+   }
+   else  if (fType == MCIntegration::kMISER) { 
+      IOptions * opts = IntegratorMultiDimOptions::FindDefault("MISER");
+      if (opts != 0)  SetParameters( MiserParameters(*opts) );
+   }
    
 }
 
 GSLMCIntegrator::GSLMCIntegrator(const char * type, double absTol, double relTol, unsigned int calls):
-   fMode(MCIntegration::kIMPORTANCE),
-   fAbsTol(absTol),
-   fRelTol(relTol),
    fDim(0),
-   //fr(r),
    fCalls(calls),
+   fAbsTol(absTol),
+   fRelTol(relTol),
    fResult(0),fError(0),fStatus(-1),
    fWorkspace(0),
    fFunction(0)
 {
-   // constructor of GSL MCIntegrator. Vegas MC is set as default integration type
-   std::string typeName(type); 
-   if (typeName == "PLAIN")
-      fType =  MCIntegration::kPLAIN;
-   else if (typeName == "MISER")
-      fType =  MCIntegration::kMISER;
-   else 
-      fType =  MCIntegration::kVEGAS;  // default
+   // constructor of GSL MCIntegrator. Vegas MC is set as default integration type if type == 0
+   SetTypeName(type);
    
    //set random number generator
    fRng = new GSLRngWrapper();      
    fRng->Allocate();
-   
+   // use the default options for the needed extra parameters 
+   if (fType == MCIntegration::kVEGAS) {    
+      IOptions * opts = IntegratorMultiDimOptions::FindDefault("VEGAS");
+      if (opts != 0) SetParameters( VegasParameters(*opts) );
+   }
+   else  if (fType == MCIntegration::kMISER) { 
+      IOptions * opts = IntegratorMultiDimOptions::FindDefault("MISER");
+      if (opts != 0)  SetParameters( MiserParameters(*opts) );
+   }
+                             
 }
        
- 
-       //maybe to be added later; for various rules within basic methods
-      //GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, unsigned int size = 1000);
       
       
 GSLMCIntegrator::~GSLMCIntegrator()
@@ -103,8 +149,7 @@ GSLMCIntegrator::GSLMCIntegrator(const GSLMCIntegrator &) :
 GSLMCIntegrator & GSLMCIntegrator::operator=(const GSLMCIntegrator &) { return *this; }
       
    
-         
-         
+                 
               
          
 void GSLMCIntegrator::SetFunction(const IMultiGenFunction &f)
@@ -142,10 +187,6 @@ double GSLMCIntegrator::Integral(const double* a, const double* b)
    {
       GSLVegasIntegrationWorkspace * ws = dynamic_cast<GSLVegasIntegrationWorkspace *>(fWorkspace); 
       assert(ws != 0);
-      if(fMode == MCIntegration::kIMPORTANCE) ws->GetWS()->mode = GSL_VEGAS_MODE_IMPORTANCE;
-      else if(fMode == MCIntegration::kSTRATIFIED) ws->GetWS()->mode = GSL_VEGAS_MODE_STRATIFIED;
-      else if(fMode == MCIntegration::kIMPORTANCE_ONLY) ws->GetWS()->mode = GSL_VEGAS_MODE_IMPORTANCE_ONLY;
-
       fStatus = gsl_monte_vegas_integrate( fFunction->GetFunc(), (double *) a, (double*) b , fDim, fCalls, fr, ws->GetWS(),  &fResult, &fError);
    }
    else if (fType ==  MCIntegration::kMISER) 
@@ -225,57 +266,96 @@ void GSLMCIntegrator::SetGenerator(GSLRngWrapper* r){ this->fRng = r; }
       
 void GSLMCIntegrator::SetType (MCIntegration::Type type)
 {
-      fType=type;
+   // create workspace according to the type 
+   fType=type;
+   if (fWorkspace != 0) { 
+      if (type == fWorkspace->Type() ) return; 
+      delete fWorkspace;  // delete because is a different type 
+      fWorkspace = 0;
+   }
+   //create Workspace according to type
+   if (type == MCIntegration::kPLAIN) { 
+      fWorkspace = new  GSLPlainIntegrationWorkspace();
+   }
+   else if (type == MCIntegration::kMISER) { 
+      fWorkspace = new  GSLMiserIntegrationWorkspace();
+   }
+   else {
+       // default: use  VEGAS
+      if (type != MCIntegration::kVEGAS) { 
+         MATH_WARN_MSG("GSLMCIntegration","Invalid integration type : use Vegas as default");
+         fType =  MCIntegration::kVEGAS; 
+      }
+      fWorkspace = new  GSLVegasIntegrationWorkspace();
+   }
 }
 
-void GSLMCIntegrator::DoInitialize ( )
+void GSLMCIntegrator::SetTypeName(const char * type)
 {
-   //    initialize by setting  integration type 
-
-   
+   // set the integration type using a string
+   std::string typeName = (type!=0) ? type : "VEGAS";
+   if (type == 0) MATH_INFO_MSG("GSLMCIntegration::SetTypeName","use default Vegas integrator method");
+   std::transform(typeName.begin(), typeName.end(), typeName.begin(), (int(*)(int)) toupper ); 
 
-   if (fWorkspace != 0) { 
-      if (fDim == fWorkspace->NDim() && fType == fWorkspace->Type() ) 
-         return; // can use previously existing ws
+   MCIntegration::Type integType =  MCIntegration::kVEGAS;  // default
 
-      // otherwise delete previously existing ws and create a new one
-      delete fWorkspace; 
+   if (typeName == "PLAIN") { 
+      integType =  MCIntegration::kPLAIN;
    }
- 
-   if(fType  ==  ROOT::Math::MCIntegration::kVEGAS)
-   {
-      
-      fWorkspace = new GSLVegasIntegrationWorkspace(fDim);
-	  
+   else if (typeName == "MISER") { 
+      integType =  MCIntegration::kMISER;
    }
-
-   else if (fType ==  ROOT::Math::MCIntegration::kMISER) 
-   {
-
-      fWorkspace = new GSLMiserIntegrationWorkspace(fDim);
+   else if (typeName != "VEGAS")  {
+      MATH_WARN_MSG("GSLMCIntegration::SetTypeName","Invalid integration type : use Vegas as default");
    }
-   else if (fType ==  ROOT::Math::MCIntegration::kPLAIN)   
-   {
 
-      fWorkspace = new GSLPlainIntegrationWorkspace(fDim);
-   }
-   else 
-   {
-      std::cerr << "GSLIntegrator - Error: Unknown integration type" << std::endl;
-      throw std::exception(); 
-   }
-}  
+   // create the fWorkspace object
+   if (integType != fType) SetType(integType);
+}
 
 
 void GSLMCIntegrator::SetMode(MCIntegration::Mode mode)
 {
    //   set integration mode for VEGAS method
    if(fType ==  ROOT::Math::MCIntegration::kVEGAS)
-   {  fMode = mode; }
+   {  
+      GSLVegasIntegrationWorkspace * ws = dynamic_cast<GSLVegasIntegrationWorkspace *>(fWorkspace); 
+      assert(ws != 0);
+      if(mode == MCIntegration::kIMPORTANCE) ws->GetWS()->mode = GSL_VEGAS_MODE_IMPORTANCE;
+      else if(mode == MCIntegration::kSTRATIFIED) ws->GetWS()->mode = GSL_VEGAS_MODE_STRATIFIED;
+      else if(mode == MCIntegration::kIMPORTANCE_ONLY) ws->GetWS()->mode = GSL_VEGAS_MODE_IMPORTANCE_ONLY;
+   }
 
    else std::cerr << "Mode not matching integration type";
 }
 
+void GSLMCIntegrator::SetOptions(const ROOT::Math::IntegratorMultiDimOptions & opt)
+{
+   //   set integration options
+   SetTypeName(opt.Integrator().c_str() );
+   SetAbsTolerance( opt.AbsTolerance() );
+   SetRelTolerance( opt.RelTolerance() );
+   fCalls = opt.NCalls();
+
+   //std::cout << fType << "   " <<  MCIntegration::kVEGAS << std::endl;
+
+   // specific options
+   ROOT::Math::IOptions * extraOpt = opt.ExtraOptions(); 
+   if (extraOpt) { 
+      if (fType ==  MCIntegration::kVEGAS ) { 
+         VegasParameters p(*extraOpt); 
+         SetParameters(p);
+      }
+      else if (fType ==  MCIntegration::kMISER ) { 
+         MiserParameters p(fDim); // if possible pass dimension 
+         p = (*extraOpt); 
+         SetParameters(p);
+      }
+      else {
+         MATH_WARN_MSG("GSLMCIntegrator::SetOptions","Invalid options set for the chosen integration type - ignore them");
+      }
+   }
+}
 
 
 void GSLMCIntegrator::SetParameters(const VegasParameters &p)
@@ -288,7 +368,7 @@ void GSLMCIntegrator::SetParameters(const VegasParameters &p)
       ws->SetParameters(p);
    }
    else 
-      std::cerr << "GSLIntegrator - Error: Parameters not mathing integration type" << std::endl;
+      MATH_ERROR_MSG("GSLIntegrator::SetParameters"," Parameters not matching integration type");
 }
 
 void GSLMCIntegrator::SetParameters(const MiserParameters &p)
@@ -301,10 +381,24 @@ void GSLMCIntegrator::SetParameters(const MiserParameters &p)
       ws->SetParameters(p);
    }
    else
-      std::cerr << "GSLIntegrator - Error: Parameters not mathing integration type" << std::endl;
+      MATH_ERROR_MSG("GSLIntegrator::SetParameters"," Parameters not matching integration type");
 }
 
 	
+void GSLMCIntegrator::DoInitialize ( )
+{
+   //    initialize by setting  integration type 
+  
+   if (fWorkspace == 0) return; 
+   if (fDim == fWorkspace->NDim() && fType == fWorkspace->Type() ) 
+      return; // can use previously existing ws
+
+   // otherwise clear workspace 
+   fWorkspace->Clear(); 
+   // and create a new one
+   fWorkspace->Init(fDim);
+}  
+
 
 
 //----------- methods specific for VEGAS
@@ -359,8 +453,29 @@ bool GSLMCIntegrator::CheckFunction()
    return false; */
 }
       
- 
-    
+const char * GSLMCIntegrator::GetTypeName() const { 
+   if (fType == MCIntegration::kVEGAS) return "VEGAS";
+   if (fType == MCIntegration::kMISER) return "MISER";
+   if (fType == MCIntegration::kPLAIN) return "PLAIN";
+   return "UNDEFINED";
+}    
+
+ROOT::Math::IntegratorMultiDimOptions  GSLMCIntegrator::Options() const { 
+   IOptions * extraOpts = ExtraOptions(); 
+   ROOT::Math::IntegratorMultiDimOptions opt(extraOpts); 
+   opt.SetAbsTolerance(fAbsTol); 
+   opt.SetRelTolerance(fRelTol); 
+   opt.SetNCalls(fCalls); 
+   opt.SetWKSize(0);
+   opt.SetIntegrator(GetTypeName() );
+   return opt; 
+}
+
+ROOT::Math::IOptions *  GSLMCIntegrator::ExtraOptions() const { 
+   if (!fWorkspace) return 0; 
+   return fWorkspace->Options(); 
+}
+
 
 } // namespace Math
 } // namespace ROOT
diff --git a/math/mathmore/src/GSLMinimizer.cxx b/math/mathmore/src/GSLMinimizer.cxx
index c052423..8effb9f 100644
--- a/math/mathmore/src/GSLMinimizer.cxx
+++ b/math/mathmore/src/GSLMinimizer.cxx
@@ -29,12 +29,14 @@
 #include "GSLMultiMinimizer.h"
 
 #include "Math/MultiNumGradFunction.h"
+#include "Math/FitMethodFunction.h"
 
 #include "Math/MinimTransformFunction.h"
 
 #include <cassert>
 
 #include <iostream>
+#include <iomanip>
 #include <cmath>
 #include <algorithm>
 #include <functional>
@@ -59,9 +61,11 @@ GSLMinimizer::GSLMinimizer( ROOT::Math::EGSLMinimizerType type) :
    fNames.reserve(10); 
    fSteps.reserve(10); 
 
-   fLSTolerance = 0.1; // use 10**-4 
-   SetMaxIterations(1000);
-   SetPrintLevel(0);
+   fLSTolerance = 0.1; // line search tolerance (use fixed)
+   int niter = ROOT::Math::MinimizerOptions::DefaultMaxIterations();
+   if (niter <=0 ) niter = 1000; 
+   SetMaxIterations(niter);
+   SetPrintLevel(ROOT::Math::MinimizerOptions::DefaultPrintLevel());
 }
 
 GSLMinimizer::GSLMinimizer( const char *  type) : 
@@ -90,8 +94,10 @@ GSLMinimizer::GSLMinimizer( const char *  type) :
    fSteps.reserve(10); 
 
    fLSTolerance = 0.1; // use 10**-4 
-   SetMaxIterations(1000);
-   SetPrintLevel(0);
+   int niter = ROOT::Math::MinimizerOptions::DefaultMaxIterations();
+   if (niter <=0 ) niter = 1000; 
+   SetMaxIterations(niter);
+   SetPrintLevel(ROOT::Math::MinimizerOptions::DefaultPrintLevel());
 }
 
 
@@ -179,7 +185,7 @@ bool GSLMinimizer::SetVariableValues( const double * x) {
 
 void GSLMinimizer::SetFunction(const ROOT::Math::IMultiGenFunction & func) { 
    // set the function to minimizer 
-   // need to calculate numerical the derivatives since are not supported
+   // need to calculate numerically the derivatives: do via class MultiNumGradFunction
    fObjFunc = new MultiNumGradFunction( func); 
    fDim = fObjFunc->NDim(); 
 }
@@ -191,6 +197,17 @@ void GSLMinimizer::SetFunction(const ROOT::Math::IMultiGradFunction & func) {
    fDim = fObjFunc->NDim(); 
 }
 
+unsigned int GSLMinimizer::NCalls() const {
+   // return numbr of function calls 
+   // if method support 
+   const ROOT::Math::MultiNumGradFunction * fnumgrad = dynamic_cast<const ROOT::Math::MultiNumGradFunction *>(fObjFunc);
+   if (fnumgrad) return fnumgrad->NCalls();
+   const ROOT::Math::FitMethodGradFunction * ffitmethod = dynamic_cast<const ROOT::Math::FitMethodGradFunction *>(fObjFunc);
+   if (ffitmethod) return ffitmethod->NCalls();   
+   // not supported in the other case
+   return 0; 
+}
+
 bool GSLMinimizer::Minimize() { 
    // set initial parameters of the minimizer
 
@@ -276,23 +293,25 @@ bool GSLMinimizer::Minimize() {
          minFound = true; 
       }
 
-      if (debugLevel >=3) { 
-         std::cout << "----------> Iteration " << iter << std::endl; 
+      if (debugLevel >=2) { 
+         std::cout << "----------> Iteration " << std::setw(4) << iter; 
          int pr = std::cout.precision(18);
          std::cout << "            FVAL = " << fGSLMultiMin->Minimum() << std::endl; 
          std::cout.precision(pr);
-         std::cout << "            X Values : "; 
-         const double * xtmp = fGSLMultiMin->X();
-         std::cout << std::endl; 
-         if (trFunc != 0 ) { 
-            xtmp  = trFunc->Transformation(xtmp);  
-         }
-         for (unsigned int i = 0; i < NDim(); ++i) {
-            std::cout << " " << fNames[i] << " = " << xtmp[i];
-         // avoid nan
-         // if (std::isnan(xtmp[i])) status = -11;
-         }
-         std::cout << std::endl; 
+         if (debugLevel >=3) { 
+            std::cout << "            Parameter Values : "; 
+            const double * xtmp = fGSLMultiMin->X();
+            std::cout << std::endl; 
+            if (trFunc != 0 ) { 
+               xtmp  = trFunc->Transformation(xtmp);  
+            }
+            for (unsigned int i = 0; i < NDim(); ++i) {
+               std::cout << " " << fNames[i] << " = " << xtmp[i];
+               // avoid nan
+               // if (std::isnan(xtmp[i])) status = -11;
+            }
+            std::cout << std::endl;
+         } 
       }
 
 
@@ -332,6 +351,8 @@ bool GSLMinimizer::Minimize() {
          std::cout.precision(pr);
 //      std::cout << "Edm   = " << fState.Edm() << std::endl;
          std::cout << "Niterations  = " << iter << std::endl;
+         unsigned int ncalls = NCalls(); 
+         if (ncalls) std::cout << "NCalls     = " << ncalls << std::endl;
          for (unsigned int i = 0; i < fDim; ++i) 
             std::cout << fNames[i] << "\t  = " << fValues[i] << std::endl; 
       }
diff --git a/math/mathmore/src/GSLMinimizer1D.cxx b/math/mathmore/src/GSLMinimizer1D.cxx
index a7de1a2..5ea9fe8 100644
--- a/math/mathmore/src/GSLMinimizer1D.cxx
+++ b/math/mathmore/src/GSLMinimizer1D.cxx
@@ -41,6 +41,7 @@
 #include "gsl/gsl_errno.h"
 
 #include <iostream> 
+#include <cmath>
 
 namespace ROOT { 
 
diff --git a/math/mathmore/src/GSLMultiFit.h b/math/mathmore/src/GSLMultiFit.h
index b88e2eb..33d9dd0 100644
--- a/math/mathmore/src/GSLMultiFit.h
+++ b/math/mathmore/src/GSLMultiFit.h
@@ -54,14 +54,16 @@ public:
 
    /** 
       Default constructor
-      No need to specify the type sofar since only one solver exists so far
+      No need to specify the type so far since only one solver exists so far
    */ 
-   GSLMultiFit () : 
+   GSLMultiFit (const gsl_multifit_fdfsolver_type * type = 0) : 
       fSolver(0), 
       fVec(0),
       fCov(0),
-      fType(gsl_multifit_fdfsolver_lmsder)
-   {}  
+      fType(type)
+   {
+      if (fType == 0) fType = gsl_multifit_fdfsolver_lmsder; // default value 
+   }  
 
    /** 
       Destructor (no operations)
diff --git a/math/mathmore/src/GSLNLSMinimizer.cxx b/math/mathmore/src/GSLNLSMinimizer.cxx
index 639e3e1..e2d7059 100644
--- a/math/mathmore/src/GSLNLSMinimizer.cxx
+++ b/math/mathmore/src/GSLNLSMinimizer.cxx
@@ -116,7 +116,7 @@ private:
 
 // GSLNLSMinimizer implementation
 
-GSLNLSMinimizer::GSLNLSMinimizer( int /* ROOT::Math::EGSLNLSMinimizerType type */ ) : 
+GSLNLSMinimizer::GSLNLSMinimizer( int type ) : 
    fDim(0), 
    fNFree(0),
    fSize(0),
@@ -124,21 +124,31 @@ GSLNLSMinimizer::GSLNLSMinimizer( int /* ROOT::Math::EGSLNLSMinimizerType type *
    fMinVal(0)
 {
    // Constructor implementation : create GSLMultiFit wrapper object
-   fGSLMultiFit = new GSLMultiFit( /*type */ ); 
+   const gsl_multifit_fdfsolver_type * gsl_type = 0; // use default type defined in GSLMultiFit
+   if (type == 1) gsl_type =   gsl_multifit_fdfsolver_lmsder; // scaled lmder version
+   if (type == 2) gsl_type =   gsl_multifit_fdfsolver_lmder; // unscaled version      
+
+   fGSLMultiFit = new GSLMultiFit( gsl_type ); 
    fValues.reserve(10); 
    fNames.reserve(10); 
    fSteps.reserve(10); 
 
    fEdm = -1; 
-   fLSTolerance = 0.0001; 
-   SetMaxIterations(100);
-   SetPrintLevel(1);
+
+   // defult tolerance and max iterations
+   int niter = ROOT::Math::MinimizerOptions::DefaultMaxIterations();
+   if (niter <= 0) niter = 100; 
+   SetMaxIterations(niter); 
+
+   fLSTolerance = ROOT::Math::MinimizerOptions::DefaultTolerance();
+   if (fLSTolerance <=0) fLSTolerance = 0.0001; // default internal value
+
+   SetPrintLevel(ROOT::Math::MinimizerOptions::DefaultPrintLevel());
 }
 
 GSLNLSMinimizer::~GSLNLSMinimizer () { 
    assert(fGSLMultiFit != 0); 
    delete fGSLMultiFit; 
-//   if (fObjFunc) delete fObjFunc; 
 }
 
 bool GSLNLSMinimizer::SetVariable(unsigned int ivar, const std::string & name, double val, double step) { 
@@ -287,7 +297,7 @@ bool GSLNLSMinimizer::Minimize() {
       startValues.resize( fNFree );
    }
 
-
+   if (debugLevel >=1 ) std::cout <<"Minimize using GSLNLSMinimizer "  << std::endl; 
 
 //    // use a global step size = min (step vectors) 
 //    double stepSize = 1; 
@@ -297,16 +307,11 @@ bool GSLNLSMinimizer::Minimize() {
 
    int iret = fGSLMultiFit->Set( fResiduals, &startValues.front() );  
    if (iret) { 
-      std::cout << "GSLNLSMinimizer : Error setting residual functions, iret = " << iret << std::endl;
+      MATH_ERROR_MSGVAL("GSLNLSMinimizer::Minimize","Error setting the residual functions ",iret);
       return false; 
    }
 
-
-   if (debugLevel >=1 ) std::cout <<"Minimize using GSLNLSMinimizer " << fGSLMultiFit->Name() << std::endl; 
-
-
-   //std::cout <<"print Level " << debugLevel << std::endl; 
-   //debugLevel = 3; 
+   if (debugLevel >=1 ) std::cout <<"GSLNLSMinimizer: " << fGSLMultiFit->Name() << " - start iterating......... "  << std::endl; 
 
    // start iteration 
    unsigned  int iter = 0; 
diff --git a/math/mathmore/src/GSLRndmEngines.cxx b/math/mathmore/src/GSLRndmEngines.cxx
index dada365..743f400 100644
--- a/math/mathmore/src/GSLRndmEngines.cxx
+++ b/math/mathmore/src/GSLRndmEngines.cxx
@@ -268,6 +268,12 @@ namespace Math {
       return gsl_ran_binomial(  fRng->Rng(), p, n);
    }
 
+   unsigned int GSLRandomEngine::NegativeBinomial(double p, double n) const
+   { 
+      // Negative Binomial distribution
+      return gsl_ran_negative_binomial(  fRng->Rng(), p, n);
+   }
+
 
    std::vector<unsigned int>  GSLRandomEngine::Multinomial( unsigned int ntot, const std::vector<double> & p ) const
    { 
@@ -290,20 +296,32 @@ namespace Math {
    }
 
 
-
+   // old ranlux - equivalent to TRandom1
    GSLRngRanLux::GSLRngRanLux() : GSLRandomEngine() 
    {
       SetType(new GSLRngWrapper(gsl_rng_ranlux) );
    }
 
-   // second generation of Ranlux (double precision version)
-   GSLRngRanLux2::GSLRngRanLux2() : GSLRandomEngine() 
+   // second generation of Ranlux (single precision version - luxury 1)
+   GSLRngRanLuxS1::GSLRngRanLuxS1() : GSLRandomEngine() 
+   {
+      SetType(new GSLRngWrapper(gsl_rng_ranlxs1) );
+   }
+
+   // second generation of Ranlux (single precision version - luxury 2)
+   GSLRngRanLuxS2::GSLRngRanLuxS2() : GSLRandomEngine() 
    {
       SetType(new GSLRngWrapper(gsl_rng_ranlxs2) );
    }
 
-   // 48 bits version
-   GSLRngRanLux48::GSLRngRanLux48() : GSLRandomEngine() 
+   // double precision  version - luxury 1 
+   GSLRngRanLuxD1::GSLRngRanLuxD1() : GSLRandomEngine() 
+   {
+      SetType(new GSLRngWrapper(gsl_rng_ranlxd1) );
+   }
+   
+   // double precision  version - luxury 2 
+   GSLRngRanLuxD2::GSLRngRanLuxD2() : GSLRandomEngine() 
    {
       SetType(new GSLRngWrapper(gsl_rng_ranlxd2) );
    }
diff --git a/math/mathmore/src/PdfFuncMathMore.cxx b/math/mathmore/src/PdfFuncMathMore.cxx
index 198b6f8..77f075a 100644
--- a/math/mathmore/src/PdfFuncMathMore.cxx
+++ b/math/mathmore/src/PdfFuncMathMore.cxx
diff --git a/math/mathmore/src/QuantFuncMathMore.cxx b/math/mathmore/src/QuantFuncMathMore.cxx
index 3657cb4..5ad8e67 100644
--- a/math/mathmore/src/QuantFuncMathMore.cxx
+++ b/math/mathmore/src/QuantFuncMathMore.cxx
@@ -9,39 +9,38 @@ namespace Math {
 
 
 
+  double tdistribution_quantile_c(double z, double r) {
 
-  double chisquared_quantile(double z, double r) {
-
-    return gsl_cdf_chisq_Pinv(z, r);
+    return gsl_cdf_tdist_Qinv(z, r);
 
   }
 
 
-  double gamma_quantile(double z, double alpha, double theta) {
-
-    return gsl_cdf_gamma_Pinv(z, alpha, theta);
-
-  }
-
 
-  double tdistribution_quantile_c(double z, double r) {
+  double tdistribution_quantile(double z, double r) {
 
-    return gsl_cdf_tdist_Qinv(z, r);
+    return gsl_cdf_tdist_Pinv(z, r);
 
   }
 
+} // namespace Math
 
+namespace MathMore  {
+   // re-impelment some function already existing in MathCore (defined in ROOT::Math namespace)
 
-  double tdistribution_quantile(double z, double r) {
+  double chisquared_quantile(double z, double r) {
 
-    return gsl_cdf_tdist_Pinv(z, r);
+    return gsl_cdf_chisq_Pinv(z, r);
 
   }
 
 
+  double gamma_quantile(double z, double alpha, double theta) {
 
+    return gsl_cdf_gamma_Pinv(z, alpha, theta);
 
+  }
 
+} // namespace MathMore
 
-} // namespace Math
 } // namespace ROOT
diff --git a/math/mathmore/src/SpecFuncMathMore.cxx b/math/mathmore/src/SpecFuncMathMore.cxx
index e5baf99..4272cb5 100644
--- a/math/mathmore/src/SpecFuncMathMore.cxx
+++ b/math/mathmore/src/SpecFuncMathMore.cxx
@@ -26,7 +26,7 @@
 #include "gsl/gsl_sf_expint.h"
 #include "gsl/gsl_sf_zeta.h"
 #include "gsl/gsl_sf_airy.h"
-
+#include "gsl/gsl_sf_coupling.h"
 
 
 namespace ROOT {
@@ -423,7 +423,19 @@ double airy_zero_Bi_deriv(unsigned int s) {
    
 }
 
+// wigner coefficient 
+
+double wigner_3j(int ja, int jb, int jc, int ma, int mb, int mc) {
+   return gsl_sf_coupling_3j(ja,jb,jc,ma,mb,mc);
+}
+
+double wigner_6j(int ja, int jb, int jc, int jd, int je, int jf) { 
+   return gsl_sf_coupling_6j(ja,jb,jc,jd,je,jf);
+}
 
+double wigner_9j(int ja, int jb, int jc, int jd, int je, int jf, int jg, int jh, int ji) { 
+   return gsl_sf_coupling_9j(ja,jb,jc,jd,je,jf,jg,jh,ji);
+}
 
 } // namespace Math
 } // namespace ROOT
commit 6f28fbd9c375d2a77362226fae46cacd77ff43e8
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Mon Sep 12 15:33:03 2011 +0200

    First added.

diff --git a/math/mathmore/inc/Math/GSLMultiRootFinder.h b/math/mathmore/inc/Math/GSLMultiRootFinder.h
new file mode 100644
index 0000000..28eb30b
--- /dev/null
+++ b/math/mathmore/inc/Math/GSLMultiRootFinder.h
@@ -0,0 +1,298 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Author: L. Moneta  03/2011
+
+ /**********************************************************************
+  *                                                                    *
+  * Copyright (c) 2004 ROOT Foundation,  CERN/PH-SFT                   *
+  *                                                                    *
+  * This library is free software; you can redistribute it and/or      *
+  * modify it under the terms of the GNU General Public License        *
+  * as published by the Free Software Foundation; either version 2     *
+  * of the License, or (at your option) any later version.             *
+  *                                                                    *
+  * This library is distributed in the hope that it will be useful,    *
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+  * General Public License for more details.                           *
+  *                                                                    *
+  * You should have received a copy of the GNU General Public License  *
+  * along with this library (see file COPYING); if not, write          *
+  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+  * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+  *                                                                    *
+  **********************************************************************/
+
+// Header file for class GSLMultiRootFinder
+// 
+
+#ifndef ROOT_Math_GSLMultiRootFinder
+#define ROOT_Math_GSLMultiRootFinder
+
+
+
+#ifndef ROOT_Math_IFunction
+#include "Math/IFunction.h"
+#endif
+
+#ifndef ROOT_Math_WrappedFunction
+#include "Math/WrappedFunction.h"
+#endif
+
+#include <vector>
+
+#include <iostream>
+
+namespace ROOT {
+namespace Math {
+
+
+   class GSLMultiRootBaseSolver; 
+
+
+
+//________________________________________________________________________________________________________
+  /**
+     Class for  Multidimensional root finding algorithms bassed on GSL. This class is used to solve a
+     non-linear system of equations:
+
+     f1(x1,....xn) = 0
+     f2(x1,....xn) = 0
+     ..................
+     fn(x1,....xn) = 0
+
+     See the GSL <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html"> online manual</A> for 
+     information on the GSL MultiRoot finding algorithms
+
+     The available GSL algorithms require the derivatives of the supplied functions or not (they are
+     computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the 
+     gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of
+     functions impelmenting the ROOT::Math::IMultiGenFunction interface.  
+     The available algorithms requiring derivatives (see also the GSL  
+     <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html">documentation</A> )
+     are the followings: 
+     <ul>
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridSJ</tt>  with name <it>"HybridSJ"</it>: modified Powell's hybrid
+     method as implemented in HYBRJ in MINPACK  
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridJ</tt>  with name <it>"HybridJ"</it>: unscaled version of the
+     previous algorithm</li>
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kNewton</tt>  with name <it>"Newton"</it>: Newton method </li>
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kGNewton</tt>  with name <it>"GNewton"</it>: modified Newton method </li>
+     </ul>
+     The algorithms without derivatives (see also the GSL  
+     <A HREF="http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html">documentation</A> )
+     are the followings: 
+     <ul>
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridS</tt>  with name <it>"HybridS"</it>: same as HybridSJ but using
+     finate difference approximation for the derivatives</li> 
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kHybrid</tt>  with name <it>"Hybrid"</it>: unscaled version of the
+     previous algorithm</li>
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kDNewton</tt>  with name <it>"DNewton"</it>: discrete Newton algorithm </li>
+         <li><tt>ROOT::Math::GSLMultiRootFinder::kBroyden</tt>  with name <it>"Broyden"</it>: Broyden algorithm </li>
+     </ul>
+
+     @ingroup MultiRoot
+  */
+
+
+ class GSLMultiRootFinder {
+     
+ public: 
+
+   /**
+      enumeration specifying the types of GSL multi root finders
+      requiring the derivatives
+      @ingroup MultiRoot
+   */
+    enum EDerivType { 
+       kHybridSJ, 
+       kHybridJ, 
+       kNewton, 
+       kGNewton
+    };
+    /**
+       enumeration specifying the types of GSL multi root finders
+       which do not require the derivatives
+       @ingroup MultiRoot
+    */
+    enum EType { 
+       kHybridS, 
+       kHybrid, 
+       kDNewton, 
+       kBroyden
+    };
+
+
+
+    /// create a multi-root finder based on an algorithm not requiring function derivative
+    GSLMultiRootFinder(EType type); 
+
+    /// create a multi-root finder based on an algorithm requiring function derivative
+    GSLMultiRootFinder(EDerivType type); 
+
+    /*
+      create a multi-root finder using a string. 
+      The names are those defined in the GSL manuals
+      after having remived the GSL prefix (gsl_multiroot_fsolver).
+      Default algorithm  is "hybrids" (without derivative). 
+    */ 
+    GSLMultiRootFinder(const char * name = 0); 
+
+    /// destructor
+    virtual ~GSLMultiRootFinder(); 
+     
+ private:
+    // usually copying is non trivial, so we make this unaccessible
+    GSLMultiRootFinder(const GSLMultiRootFinder &); 
+    GSLMultiRootFinder & operator = (const GSLMultiRootFinder &); 
+     
+ public: 
+
+    /// set the type for an algorithm without derivatives 
+    void SetType(EType type) { 
+       fType = type; fUseDerivAlgo = false; 
+    }
+
+    /// set the type of algorithm using derivatives 
+    void SetType(EDerivType type) { 
+       fType = type; fUseDerivAlgo = true; 
+    }
+
+    /// set the type using a string
+    void SetType(const char * name);
+
+    /* 
+       add the list of functions f1(x1,..xn),...fn(x1,...xn). The list must contain pointers of  
+       ROOT::Math::IMultiGenFunctions. The method requires the 
+       the begin and end of the list iterator.
+       The list can be any stl container or a simple array of  ROOT::Math::IMultiGenFunctions* or 
+       whatever implementing an iterator.
+       If using a derivative type algorithm the function pointers must implement the 
+       ROOOT::Math::IMultiGradFunction interface
+    */
+    template<class FuncIterator>
+    bool SetFunctionList( FuncIterator begin, FuncIterator end) { 
+       bool ret = true; 
+       for (FuncIterator itr = begin; itr != end; ++itr) { 
+          const ROOT::Math::IMultiGenFunction * f = *itr;          
+          ret &= AddFunction( *f);
+       }
+       return ret;
+    }
+
+    /*
+      add (set) a single function fi(x1,...xn) which is part of the system of 
+       specifying the begin and end of the iterator. 
+       If using a derivative type algorithm the function must implement the 
+       ROOOT::Math::IMultiGradFunction interface
+       Return the current number of function in the list and 0 if failed to add the function
+     */
+    int AddFunction( const ROOT::Math::IMultiGenFunction & func); 
+
+    /// same method as before but using any function implementing 
+    /// the operator(), so can be wrapped in a IMultiGenFunction interface
+    template <class Function> 
+    int AddFunction( Function & f, int ndim) { 
+       // no need to care about lifetime of wfunc. It will be cloned inside AddFunction
+       WrappedMultiFunction<Function &> wfunc(f, ndim); 
+       return AddFunction(wfunc);
+    }
+
+    /**
+       return the number of sunctions set in the class. 
+       The number must be equal to the dimension of the functions
+     */
+    unsigned  int Dim() const { return fFunctions.size(); } 
+
+    /// clear list of functions
+    void Clear(); 
+
+    /// return the root X values solving the system 
+    const double * X() const; 
+
+    /// return the function values f(X) solving the system 
+    /// i.e. they must be close to zero at the solution
+    const double * FVal() const; 
+
+    /// return the last step size 
+    const double * Dx() const; 
+
+
+    /**
+       Find the root starting from the point X;
+       Use the number of iteration and tolerance if given otherwise use 
+       default parameter values which can be defined by 
+       the static method SetDefault...
+    */
+    bool Solve(const double * x,  int maxIter = 0, double absTol = 0, double relTol = 0); 
+
+    /// Return number of iterations
+    int Iterations() const {
+       return fIter; 
+    }
+
+    /// Return the status of last root finding
+    int Status() const { return fStatus; }
+
+    /// Return the algorithm name 
+    const char * Name() const;  
+
+    /* 
+       set print level
+       level = 0  quiet (no messages print) 
+             = 1  print only the result 
+             = 3  max debug. Print result at each iteration
+    */             
+    void SetPrintLevel(int level) { fPrintLevel = level; }
+
+    /// return the print level 
+    int PrintLevel() const { return fPrintLevel; }
+
+
+    //-- static methods to set configurations 
+
+    /// set tolerance (absolute and relative)
+    /// relative tolerance is only use to verify the convergence 
+    /// do it is a minor parameter
+    static void SetDefaultTolerance(double abstol, double reltol = 0 );
+
+    /// set maximum number of iterations
+    static void SetDefaultMaxIterations(int maxiter);
+
+    /// print iteration state
+    void PrintState(std::ostream & os = std::cout);
+
+     
+ protected:
+     
+    // return type given a name
+    std::pair<bool,int> GetType(const char * name); 
+    // clear list of functions 
+    void ClearFunctions(); 
+
+         
+ private: 
+
+    int fIter;           // current numer of iterations
+    int fStatus;         // current status 
+    int fPrintLevel;     // print level 
+
+    // int fMaxIter;        // max number of iterations
+    // double fAbsTolerance;  // absolute tolerance
+    // double fRelTolerance;  // relative tolerance 
+    int fType;            // type of algorithm 
+    bool fUseDerivAlgo; // algorithm using derivative
+     
+    GSLMultiRootBaseSolver * fSolver; 
+    std::vector<ROOT::Math::IMultiGenFunction *> fFunctions;   //! transient Vector of the functions 
+
+
+ }; 
+
+   // use typedef for most sensible name 
+   typedef GSLMultiRootFinder MultiRootFinder; 
+
+} // namespace Math
+} // namespace ROOT
+
+
+#endif /* ROOT_Math_GSLMultiRootFinder */
diff --git a/math/mathmore/inc/Math/MultiRootFinder.h b/math/mathmore/inc/Math/MultiRootFinder.h
new file mode 100644
index 0000000..68a631e
--- /dev/null
+++ b/math/mathmore/inc/Math/MultiRootFinder.h
@@ -0,0 +1,45 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Author: L. Moneta   03/2011 
+
+ /**********************************************************************
+  *                                                                    *
+  * Copyright (c) 2004 ROOT Foundation,  CERN/PH-SFT                   *
+  *                                                                    *
+  * This library is free software; you can redistribute it and/or      *
+  * modify it under the terms of the GNU General Public License        *
+  * as published by the Free Software Foundation; either version 2     *
+  * of the License, or (at your option) any later version.             *
+  *                                                                    *
+  * This library is distributed in the hope that it will be useful,    *
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+  * General Public License for more details.                           *
+  *                                                                    *
+  * You should have received a copy of the GNU General Public License  *
+  * along with this library (see file COPYING); if not, write          *
+  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+  * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+  *                                                                    *
+  **********************************************************************/
+
+// Header file for class MultiRootFinder
+// 
+#ifndef ROOT_Math_MultiRootFinder
+#define ROOT_Math_MultiRootFinder
+
+
+
+#ifndef ROOT_Math_GSLMultiRootFinder
+#include "Math/GSLMultiRootFinder.h"
+#endif
+
+namespace ROOT {
+namespace Math {
+
+   typedef GSLMultiRootFinder MultiRootFinder; 
+
+} // namespace Math
+} // namespace ROOT
+
+
+#endif /* ROOT_Math_MultiRootFinder */
diff --git a/math/mathmore/src/GSLMultiRootFinder.cxx b/math/mathmore/src/GSLMultiRootFinder.cxx
new file mode 100644
index 0000000..6e3dd32
--- /dev/null
+++ b/math/mathmore/src/GSLMultiRootFinder.cxx
@@ -0,0 +1,353 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Authors: L. Moneta, A. Zsenei   08/2005 
+
+ /**********************************************************************
+  *                                                                    *
+  * Copyright (c) 2004 ROOT Foundation,  CERN/PH-SFT                   *
+  *                                                                    *
+  * This library is free software; you can redistribute it and/or      *
+  * modify it under the terms of the GNU General Public License        *
+  * as published by the Free Software Foundation; either version 2     *
+  * of the License, or (at your option) any later version.             *
+  *                                                                    *
+  * This library is distributed in the hope that it will be useful,    *
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+  * General Public License for more details.                           *
+  *                                                                    *
+  * You should have received a copy of the GNU General Public License  *
+  * along with this library (see file COPYING); if not, write          *
+  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+  * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+  *                                                                    *
+  **********************************************************************/
+
+// Implementation file for class GSLMultiRootFinder
+// 
+// Created by: moneta  at Sun Nov 14 11:27:11 2004
+// 
+// Last update: Sun Nov 14 11:27:11 2004
+// 
+
+#include "Math/IFunction.h"
+#include "Math/GSLMultiRootFinder.h"
+#include "GSLMultiRootSolver.h"
+#include "Math/Error.h"
+
+#include "gsl/gsl_multiroots.h"
+#include "gsl/gsl_errno.h"
+#include <cmath>
+#include <iomanip>
+
+#include <algorithm>
+#include <functional>
+#include <ctype.h>   // need to use c version of tolower defined here
+
+
+namespace ROOT {
+namespace Math {
+
+   // default values 
+
+   int gDefaultMaxIter = 100;
+   double gDefaultAbsTolerance = 1.E-6;
+   double gDefaultRelTolerance = 1.E-10;
+
+// impelmentation of static methods 
+void GSLMultiRootFinder::SetDefaultTolerance(double abstol, double reltol ) {
+   // set default tolerance
+      gDefaultAbsTolerance = abstol; 
+      if (reltol > 0) gDefaultRelTolerance = reltol; 
+}
+void GSLMultiRootFinder::SetDefaultMaxIterations(int maxiter) { 
+   // set default max iter
+   gDefaultMaxIter = maxiter;
+}
+
+GSLMultiRootFinder::GSLMultiRootFinder(EType type) : 
+   fIter(0), fStatus(-1), fPrintLevel(0),
+   fType(type), fUseDerivAlgo(false),
+   fSolver(0) 
+{
+   // constructor for non derivative type
+   fFunctions.reserve(2);
+}
+
+GSLMultiRootFinder::GSLMultiRootFinder(EDerivType type) : 
+   fIter(0), fStatus(-1), fPrintLevel(0),
+   fType(type), fUseDerivAlgo(true),
+   fSolver(0) 
+{
+   // constructor for non derivative type
+   fFunctions.reserve(2);
+}
+
+GSLMultiRootFinder::GSLMultiRootFinder(const char * name) : 
+   fIter(0), fStatus(-1), fPrintLevel(0),
+   fType(0), fUseDerivAlgo(false),
+   fSolver(0) 
+{
+   // constructor for a string
+   fFunctions.reserve(2);
+   SetType(name);
+}
+
+GSLMultiRootFinder::~GSLMultiRootFinder() 
+{
+   // delete function wrapper
+   ClearFunctions();
+   if (fSolver) delete fSolver;
+}
+
+GSLMultiRootFinder::GSLMultiRootFinder(const GSLMultiRootFinder &) 
+{
+}
+
+GSLMultiRootFinder & GSLMultiRootFinder::operator = (const GSLMultiRootFinder &rhs) 
+{
+   // dummy operator=
+   if (this == &rhs) return *this;  // time saving self-test
+   
+   return *this;
+}
+
+void GSLMultiRootFinder::SetType(const char * name) {
+   // set type using a string
+   std::pair<bool,int> type = GetType(name);
+   fUseDerivAlgo = type.first; 
+   fType = type.second;
+}
+
+
+int GSLMultiRootFinder::AddFunction(const ROOT::Math::IMultiGenFunction & func) { 
+   // add a new function in the vector
+   ROOT::Math::IMultiGenFunction * f = func.Clone(); 
+   if (!f) return 0;
+   fFunctions.push_back(f);
+   return fFunctions.size();
+}
+
+void GSLMultiRootFinder::ClearFunctions() {
+   // clear the function list
+   for (unsigned int i = 0; i < fFunctions.size(); ++i) {
+      if (fFunctions[i] != 0 ) delete fFunctions[i]; 
+      fFunctions[i] = 0;
+   }
+   fFunctions.clear();
+}
+
+void GSLMultiRootFinder::Clear() {
+   // clear the function list and the solver 
+   ClearFunctions(); 
+   if (fSolver) Clear(); 
+   fSolver = 0; 
+}
+
+
+const double * GSLMultiRootFinder::X() const { 
+   // return x
+   return (fSolver != 0) ? fSolver->X() : 0;
+}
+const double * GSLMultiRootFinder::Dx() const { 
+   // return x
+   return (fSolver != 0) ? fSolver->Dx() : 0; 
+}
+const double * GSLMultiRootFinder::FVal() const { 
+   // return x
+   return (fSolver != 0) ? fSolver->FVal() : 0;
+}
+const char * GSLMultiRootFinder::Name() const {
+   // get GSL name 
+   return (fSolver != 0) ? fSolver->Name().c_str() : ""; 
+}
+
+// bool GSLMultiRootFinder::AddFunction( const ROOT::Math::IMultiGenFunction & func) { 
+//    // clone and add function to the list 
+//    // If using a derivative algorithm the function is checked if it implements
+//    // the gradient interface. If this is not the case the type is set to non-derivatibe algo
+//    ROOT::Math::IGenMultiFunction * f = func.Clone(); 
+//    if (f != 0) return false; 
+//    if (fUseDerivAlgo)  {
+//       bool gradFunc = (dynamic_cast<ROOT::Math::IMultiGradFunction *> (f) != 0 );
+//       if (!gradFunc)  { 
+//          MATH_ERROR_MSG("GSLMultiRootFinder::AddFunction","Function does not provide gradient interface");
+//          MATH_WARN_MSG("GSLMultiRootFinder::AddFunction","clear the function list");         
+//          ClearFunctions(); 
+//          return false; 
+//       }
+//    }
+//    fFunctions.push_back(f);
+//    return true; 
+// }
+
+   const gsl_multiroot_fsolver_type * GetGSLType(GSLMultiRootFinder::EType type) { 
+     //helper functions to find GSL type
+   switch(type)
+      {
+      case ROOT::Math::GSLMultiRootFinder::kHybridS:
+         return gsl_multiroot_fsolver_hybrids;
+      case ROOT::Math::GSLMultiRootFinder::kHybrid:
+         return gsl_multiroot_fsolver_hybrid;
+      case ROOT::Math::GSLMultiRootFinder::kDNewton:
+         return gsl_multiroot_fsolver_dnewton;
+      case ROOT::Math::GSLMultiRootFinder::kBroyden:
+         return gsl_multiroot_fsolver_broyden;
+      default: 
+         return gsl_multiroot_fsolver_hybrids;
+      }
+   return 0;
+}
+
+const gsl_multiroot_fdfsolver_type * GetGSLDerivType(GSLMultiRootFinder::EDerivType type) { 
+//helper functions to find GSL deriv type
+   switch(type)
+   {
+   case ROOT::Math::GSLMultiRootFinder::kHybridSJ :
+      return gsl_multiroot_fdfsolver_hybridsj; 
+   case ROOT::Math::GSLMultiRootFinder::kHybridJ :
+      return gsl_multiroot_fdfsolver_hybridj; 
+   case ROOT::Math::GSLMultiRootFinder::kNewton :
+      return gsl_multiroot_fdfsolver_newton; 
+   case ROOT::Math::GSLMultiRootFinder::kGNewton :
+      return gsl_multiroot_fdfsolver_gnewton; 
+   default:
+      return gsl_multiroot_fdfsolver_hybridsj; 
+   }
+   return 0; // cannot happen
+}
+
+std::pair<bool,int> GSLMultiRootFinder::GetType(const char * name) { 
+   if (name == 0) return std::make_pair<bool,int>(false, -1); 
+   std::string aname = name; 
+   std::transform(aname.begin(), aname.end(), aname.begin(), (int(*)(int)) tolower ); 
+
+   if (aname.find("hybridsj") != std::string::npos) return std::make_pair(true,  kHybridSJ);
+   if (aname.find("hybridj") != std::string::npos) return std::make_pair(true,  kHybridJ); 
+   if (aname.find("hybrids") != std::string::npos) return std::make_pair(false,  kHybridS); 
+   if (aname.find("hybrid") != std::string::npos) return std::make_pair(false,  kHybrid); 
+   if (aname.find("gnewton") != std::string::npos) return std::make_pair(true,  kGNewton);
+   if (aname.find("dnewton") != std::string::npos) return std::make_pair(false,  kDNewton);
+   if (aname.find("newton") != std::string::npos) return std::make_pair(true,  kNewton);
+   if (aname.find("broyden") != std::string::npos) return std::make_pair(false,  kBroyden);
+   MATH_INFO_MSG("GSLMultiRootFinder::GetType","Unknow algorithm - use default one");
+   return std::make_pair(false, -1);   
+} 
+
+bool GSLMultiRootFinder::Solve (const double * x, int maxIter, double absTol, double relTol) 
+{ 
+   fIter = 0;
+   // create the solvers - delete previous existing solver 
+   if (fSolver) delete fSolver; 
+   fSolver = 0; 
+
+   if (fFunctions.size() == 0) {
+      MATH_ERROR_MSG("GSLMultiRootFinder::Solve","Function list is empty");
+      fStatus = -1;
+      return false;
+   }
+
+   if (fUseDerivAlgo) { 
+      EDerivType type = (EDerivType) fType; 
+      if (!fSolver) fSolver = new GSLMultiRootDerivSolver( GetGSLDerivType(type), Dim() );
+   }
+   else { 
+      EType type = (EType) fType; 
+      if (!fSolver) fSolver = new GSLMultiRootSolver( GetGSLType(type), Dim() );
+   }
+
+
+   // first set initial values and function
+   assert(fSolver != 0);
+   bool ret = fSolver->InitSolver( fFunctions, x);
+   if (!ret) { 
+      MATH_ERROR_MSG("GSLMultiRootFinder::Solve","Error initializing the solver");
+      fStatus = -2;
+      return false;
+   }
+
+   if (maxIter == 0) maxIter = gDefaultMaxIter;
+   if (absTol <= 0) absTol = gDefaultAbsTolerance;
+   if (relTol <= 0) relTol = gDefaultRelTolerance;
+
+   if (fPrintLevel >= 1) 
+      std::cout << "GSLMultiRootFinder::Solve:" << Name() << " max iterations " <<   maxIter << " and  tolerance " <<  absTol << std::endl;
+
+   // find the roots by iterating
+   fStatus = 0;
+   int status = 0;
+   int iter = 0; 
+   do { 
+      iter++; 
+      status = fSolver->Iterate();
+
+      if (fPrintLevel >= 2) {
+         std::cout << "GSLMultiRootFinder::Solve - iteration # " <<   iter << " status = " << status << std::endl;
+         PrintState(); 
+      }
+      // act in case of error 
+      if (status == GSL_EBADFUNC) { 
+         MATH_ERROR_MSG("GSLMultiRootFinder::Solve","The iteration encountered a singolar point due to a bad function value");
+         fStatus = status;
+         break;
+      }
+      if (status == GSL_ENOPROG) { 
+         MATH_ERROR_MSG("GSLMultiRootFinder::Solve","The iteration is not making any progress");
+         fStatus = status;
+         break;
+      }
+      if (status != GSL_SUCCESS) { 
+         MATH_ERROR_MSG("GSLMultiRootFinder::Solve","Uknown iteration error - exit");
+         fStatus = status;
+         break;
+      }
+
+      // test also residual
+      status =  fSolver->TestResidual(absTol); 
+
+
+      // should test also the Delta ??
+      int status2 =  fSolver->TestDelta(absTol, relTol); 
+      if (status2 == GSL_SUCCESS) { 
+         MATH_INFO_MSG("GSLMultiRootFinder::Solve","The iteration converged");
+      }
+   }
+   while (status == GSL_CONTINUE && iter < maxIter);
+   if (status == GSL_CONTINUE) { 
+      MATH_INFO_MSGVAL("GSLMultiRootFinder::Solve","exceeded max iterations, reached tolerance is not sufficient",absTol);
+   }
+   if (status == GSL_SUCCESS) { 
+      if (fPrintLevel>=1) {          // print the result
+         MATH_INFO_MSG("GSLMultiRootFinder::Solve","The iteration converged");
+         std::cout << "GSL Algorithm used is :  " << fSolver->Name() << std::endl;
+         std::cout << "Number of iterations  =  " << iter<< std::endl;
+         
+         PrintState(); 
+      }
+   }
+   fIter = iter;
+   fStatus = status; 
+   return  (fStatus == GSL_SUCCESS);
+
+}
+
+void GSLMultiRootFinder::PrintState(std::ostream & os) {    
+   // print current state 
+   if (!fSolver) return;
+   double ndigits = std::log10( double( Dim() ) );
+   int wi = int(ndigits)+1;
+   const double * xtmp = fSolver->X(); 
+   const double * ftmp = fSolver->FVal(); 
+   os << "Root values     = "; 
+   for (unsigned int i = 0; i< Dim(); ++i) 
+      os << "x[" << std::setw(wi) << i << "] = " << std::setw(12) << xtmp[i] << "   ";
+   os << std::endl;
+   os << "Function values = "; 
+   for (unsigned int i = 0; i< Dim(); ++i) 
+      os << "f[" << std::setw(wi) << i << "] = " << std::setw(12) << ftmp[i] << "   ";
+   os << std::endl; 
+}
+
+
+
+} // namespace Math
+} // namespace ROOT
diff --git a/math/mathmore/src/GSLMultiRootFunctionAdapter.h b/math/mathmore/src/GSLMultiRootFunctionAdapter.h
new file mode 100644
index 0000000..800446f
--- /dev/null
+++ b/math/mathmore/src/GSLMultiRootFunctionAdapter.h
@@ -0,0 +1,130 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Authors: L. Moneta, Mar 2011
+
+ /**********************************************************************
+  *                                                                    *
+  * Copyright (c) 2004 ROOT Foundation,  CERN/PH-SFT                   *
+  *                                                                    *
+  * This library is free software; you can redistribute it and/or      *
+  * modify it under the terms of the GNU General Public License        *
+  * as published by the Free Software Foundation; either version 2     *
+  * of the License, or (at your option) any later version.             *
+  *                                                                    *
+  * This library is distributed in the hope that it will be useful,    *
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+  * General Public License for more details.                           *
+  *                                                                    *
+  * You should have received a copy of the GNU General Public License  *
+  * along with this library (see file COPYING); if not, write          *
+  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+  * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+  *                                                                    *
+  **********************************************************************/
+
+// Header file for class GSLMultiMinFunctionAdapter
+//
+// Generic adapter for gsl_multiroot_function signature type  
+// usable for any array of function pointers 
+// implementing operator()(const double *x) and (if needed)
+// Gradient(const double *x, double * g)
+//
+// The class is very similar to GSLMultiFitFunctionAdapter, 
+// but in that case the array is for function references (or value)
+// 
+#ifndef ROOT_Math_GSLMultiRootFunctionAdapter
+#define ROOT_Math_GSLMultiRootFunctionAdapter
+
+#include "gsl/gsl_vector.h"
+#include "gsl/gsl_matrix.h"
+
+#include <cassert>
+
+namespace ROOT {
+namespace Math {
+
+
+
+  /**
+     Class for adapting a C++ functor class to C function pointers used by GSL MultiRoot 
+     Algorithm
+     The templated C++ function class must implement: 
+
+    <em> double operator( const double *  x)</em>
+    and if the derivatives are required: 
+    <em> void Gradient( const double *   x, double * g)</em>
+    and 
+    <em> void FdF( const double *   x, double &f, double * g)</em>
+    
+
+   @ingroup MultiRoot
+  */ 
+     
+
+   // FuncVector must contain a vector of pointers to functions
+   // this same as MultiFit but here need to use pointers where there we used class elements
+
+template<class FuncVector> 
+class GSLMultiRootFunctionAdapter {
+
+   
+
+public: 
+    
+   static int F( const gsl_vector * x, void * p, gsl_vector * f ) { 
+      // p is a pointer to an iterator of functions
+      unsigned int n = f->size;
+      // need to copy iterator otherwise next time the function is called it wont work 
+      FuncVector  & funcVec = *( reinterpret_cast< FuncVector *> (p) );
+      if (n == 0) return -1; 
+      for (unsigned int i = 0; i < n ; ++i) { 
+         gsl_vector_set(f, i, (*funcVec[i])(x->data) );
+      }
+      return 0; 
+   }
+
+    
+   static int Df(  const gsl_vector * x, void * p, gsl_matrix * h) { 
+      
+      // p is a pointer to an iterator of functions
+      unsigned int n = h->size1;
+      unsigned int npar = h->size2;
+      if (n == 0) return -1; 
+      if (npar == 0) return -2; 
+      FuncVector  & funcVec = *( reinterpret_cast< FuncVector *> (p) );
+      for (unsigned int i = 0; i < n ; ++i) { 
+         double * g = (h->data)+i*npar;   //pointer to start  of i-th row
+         assert ( npar == (funcVec[i])->NDim() );
+         (funcVec[i])->Gradient(x->data, g); 
+      }
+      return 0; 
+   }
+
+   /// evaluate derivative and function at the same time 
+   static int FDf(  const gsl_vector * x, void * p,  gsl_vector * f, gsl_matrix * h) { 
+      // should be implemented in the function
+      // p is a pointer to an iterator of functions
+      unsigned int n = h->size1;
+      unsigned int npar = h->size2;
+      if (n == 0) return -1; 
+      if (npar == 0) return -2; 
+      FuncVector  & funcVec = *( reinterpret_cast< FuncVector *> (p) );
+      assert ( f->size == n); 
+      for (unsigned int i = 0; i < n ; ++i) { 
+         assert ( npar == (funcVec[i])->NDim() );
+         double fval = 0; 
+         double * g = (h->data)+i*npar;   //pointer to start  of i-th row
+         (funcVec[i])->FdF(x->data, fval, g); 
+         gsl_vector_set(f, i, fval  );
+      }
+      return 0; 
+   }
+
+};
+
+
+} // namespace Math
+} // namespace ROOT
+
+
+#endif /* ROOT_Math_GSLMultiRootFunctionAdapter */
diff --git a/math/mathmore/src/GSLMultiRootFunctionWrapper.h b/math/mathmore/src/GSLMultiRootFunctionWrapper.h
new file mode 100644
index 0000000..42c7225
--- /dev/null
+++ b/math/mathmore/src/GSLMultiRootFunctionWrapper.h
@@ -0,0 +1,138 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Authors: L. Moneta Dec 2006 
+
+ /**********************************************************************
+  *                                                                    *
+  * Copyright (c) 2004 ROOT Foundation,  CERN/PH-SFT                   *
+  *                                                                    *
+  * This library is free software; you can redistribute it and/or      *
+  * modify it under the terms of the GNU General Public License        *
+  * as published by the Free Software Foundation; either version 2     *
+  * of the License, or (at your option) any later version.             *
+  *                                                                    *
+  * This library is distributed in the hope that it will be useful,    *
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+  * General Public License for more details.                           *
+  *                                                                    *
+  * You should have received a copy of the GNU General Public License  *
+  * along with this library (see file COPYING); if not, write          *
+  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+  * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+  *                                                                    *
+  **********************************************************************/
+
+// Header file for class GSLMultiRootFunctionWrapper
+// 
+// Created by: moneta  at Sat Nov 13 14:54:41 2004
+// 
+// Last update: Sat Nov 13 14:54:41 2004
+// 
+#ifndef ROOT_Math_GSLMultiRootFunctionWrapper
+#define ROOT_Math_GSLMultiRootFunctionWrapper
+
+#include "gsl/gsl_multiroots.h"
+
+#include "GSLMultiRootFunctionAdapter.h"
+
+
+#include <cassert>
+
+namespace ROOT {
+namespace Math {
+
+
+   
+// can re-use same type for multi-fit
+
+   typedef double ( * GSLMultiRootFPointer ) ( const gsl_vector *, void *, gsl_vector *);
+   typedef void   ( * GSLMultiRootDfPointer )   ( const gsl_vector *, void *, gsl_matrix *);
+   typedef void   ( * GSLMultiRootFdfPointer ) ( const gsl_vector *, void *, gsl_vector *, gsl_matrix *);
+
+
+/**
+   wrapper to a multi-dim function without  derivatives for multi roots  
+   algorithm
+
+   @ingroup MultiRoots
+*/
+class GSLMultiRootFunctionWrapper { 
+
+public: 
+
+   GSLMultiRootFunctionWrapper() 
+   {
+      fFunc.f = 0; 
+      fFunc.n = 0; 
+      fFunc.params = 0;
+   }
+
+
+   /// Fill gsl function structure from a C++ function iterator and size and number of residuals
+   template<class FuncVector> 
+   void SetFunctions(const FuncVector & f, unsigned int n ) { 
+      const void * p = &f;
+      assert (p != 0); 
+      fFunc.f   = &GSLMultiRootFunctionAdapter<FuncVector >::F;
+      fFunc.n = n; 
+      fFunc.params =  const_cast<void *>(p); 
+   }
+   
+   gsl_multiroot_function * GetFunctions() { return &fFunc; } 
+
+
+  private: 
+   
+   gsl_multiroot_function fFunc; 
+
+};
+
+
+/**
+   wrapper to a multi-dim function with  derivatives for multi roots  
+   algorithm
+
+   @ingroup MultiRoot
+*/
+
+class GSLMultiRootDerivFunctionWrapper { 
+
+public: 
+
+   GSLMultiRootDerivFunctionWrapper() 
+   {
+      fFunc.f = 0; 
+      fFunc.df = 0; 
+      fFunc.fdf = 0; 
+      fFunc.n = 0; 
+      fFunc.params = 0;
+   }
+
+
+   /// Fill gsl function structure from a C++ function iterator and size and number of residuals
+   template<class FuncVector> 
+   void SetFunctions(const FuncVector & f, unsigned int n  ) { 
+      const void * p = &f;
+      assert (p != 0); 
+      fFunc.f   = &GSLMultiRootFunctionAdapter<FuncVector >::F;
+      fFunc.df  = &GSLMultiRootFunctionAdapter<FuncVector >::Df;
+      fFunc.fdf = &GSLMultiRootFunctionAdapter<FuncVector >::FDf;
+      fFunc.n = n; 
+      fFunc.params =  const_cast<void *>(p); 
+   }
+   
+   gsl_multiroot_function_fdf * GetFunctions() { return &fFunc; } 
+
+
+  private: 
+   
+   gsl_multiroot_function_fdf fFunc; 
+
+};
+
+
+
+} // namespace Math
+} // namespace ROOT
+
+#endif /* ROOT_Math_GSLMultiMinFunctionWrapper */
diff --git a/math/mathmore/src/GSLMultiRootSolver.h b/math/mathmore/src/GSLMultiRootSolver.h
new file mode 100644
index 0000000..c2e8bd7
--- /dev/null
+++ b/math/mathmore/src/GSLMultiRootSolver.h
@@ -0,0 +1,390 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Author: L. Moneta Wed Dec 20 17:26:06 2006
+
+/**********************************************************************
+ *                                                                    *
+ * Copyright (c) 2006  LCG ROOT Math Team, CERN/PH-SFT                *
+ *                                                                    *
+ * This library is free software; you can redistribute it and/or      *
+ * modify it under the terms of the GNU General Public License        *
+ * as published by the Free Software Foundation; either version 2     *
+ * of the License, or (at your option) any later version.             *
+ *                                                                    *
+ * This library is distributed in the hope that it will be useful,    *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+ * General Public License for more details.                           *
+ *                                                                    *
+ * You should have received a copy of the GNU General Public License  *
+ * along with this library (see file COPYING); if not, write          *
+ * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+ * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+ *                                                                    *
+ **********************************************************************/
+
+// Header file for the class GSLMultiRootBaseSolver, 
+//     GSLMultiRootSolver and GSLMultiRootDerivSolver
+
+#ifndef ROOT_Math_GSLMultiRootSolver
+#define ROOT_Math_GSLMultiRootSolver
+
+#include "gsl/gsl_vector.h"
+#include "gsl/gsl_matrix.h"
+#include "gsl/gsl_multiroots.h"
+#include "gsl/gsl_blas.h"
+#include "GSLMultiRootFunctionWrapper.h"
+
+#include "Math/IFunction.h"
+#include "Math/Error.h"
+
+#include <vector>
+#include <string>
+#include <cassert> 
+
+
+namespace ROOT { 
+
+   namespace Math { 
+
+
+/** 
+   GSLMultiRootBaseSolver, internal class for implementing GSL multi-root finders
+   This is the base class for GSLMultiRootSolver (solver not using derivatives) and
+   GSLMUltiRootDerivSolver (solver using derivatives)
+
+   @ingroup MultiRoot
+*/ 
+class GSLMultiRootBaseSolver {
+
+public: 
+
+   /** 
+      virtual Destructor 
+   */ 
+   virtual ~GSLMultiRootBaseSolver ()  {}
+
+
+public: 
+
+
+   /// init the solver with function list and initial values  
+   bool InitSolver(const std::vector<ROOT::Math::IMultiGenFunction*> & funcVec, const double * x) { 
+      // create a vector of the fit contributions
+      // create function wrapper from an iterator of functions
+      unsigned int n = funcVec.size(); 
+      if (n == 0) return false; 
+
+      unsigned int ndim = funcVec[0]->NDim();   // should also be = n
+
+      if (ndim != n) { 
+         MATH_ERROR_MSGVAL("GSLMultiRootSolver::InitSolver","Wrong function dimension",ndim);
+         MATH_ERROR_MSGVAL("GSLMultiRootSolver::InitSolver","Number of functions",n);
+         return false;
+      }
+
+
+      // set function list and initial values in solver 
+      int iret = SetSolver(funcVec,x);
+      return (iret == 0);
+   }
+
+   /// return name 
+   virtual std::string Name() const  = 0;  
+   
+   /// perform an iteration
+   virtual int Iterate() = 0; 
+
+   /// solution values at the current iteration 
+   const double * X() const { 
+      gsl_vector * x = GetRoot(); 
+      return x->data; 
+   }
+
+   /// return function values 
+   const double * FVal() const { 
+      gsl_vector * f = GetF(); 
+      return f->data; 
+   }
+
+   /// return function steps 
+   const double * Dx() const {
+      gsl_vector * dx = GetDx(); 
+      return dx->data; 
+   }
+
+   /// test using abs and relative tolerance
+   ///  |dx| < absTol + relTol*|x| for every component
+   int TestDelta(double absTol, double relTol) const { 
+      gsl_vector * x =  GetRoot(); 
+      gsl_vector * dx =  GetDx(); 
+      if (x == 0 || dx == 0) return -1; 
+      return gsl_multiroot_test_delta(dx, x, absTol, relTol);
+   }
+
+   /// test using abs  tolerance
+   /// Sum |f|_i < absTol 
+   int TestResidual(double absTol) const { 
+      gsl_vector * f =  GetF();       
+      if (f == 0) return -1; 
+      return gsl_multiroot_test_residual(f, absTol);
+   }
+
+
+private: 
+
+   // accessor to be implemented by the derived classes 
+
+   virtual int SetSolver(const std::vector<ROOT::Math::IMultiGenFunction*> & funcVec, const double * x) = 0;
+
+   virtual gsl_vector * GetRoot() const = 0; 
+
+   virtual gsl_vector * GetF() const = 0; 
+
+   virtual gsl_vector * GetDx() const = 0; 
+
+
+}; 
+
+
+/** 
+   GSLMultiRootSolver, internal class for implementing GSL multi-root finders
+   not using derivatives
+
+   @ingroup MultiRoot
+*/ 
+class GSLMultiRootSolver : public GSLMultiRootBaseSolver {
+
+public: 
+
+   /** 
+      Constructor from type and simension of system (number of functions)
+   */ 
+   GSLMultiRootSolver (const gsl_multiroot_fsolver_type * type, int n ) : 
+      fSolver(0), 
+      fVec(0)
+   {
+      CreateSolver(type, n);
+   }  
+
+   /** 
+      Destructor (no operations)
+   */ 
+   virtual ~GSLMultiRootSolver ()  {
+      if (fSolver) gsl_multiroot_fsolver_free(fSolver);
+      if (fVec != 0) gsl_vector_free(fVec); 
+   }  
+
+private:
+   // usually copying is non trivial, so we make this unaccessible
+
+   /** 
+      Copy constructor
+   */ 
+   GSLMultiRootSolver(const GSLMultiRootSolver &) : GSLMultiRootBaseSolver() {} 
+
+   /** 
+      Assignment operator
+   */ 
+   GSLMultiRootSolver & operator = (const GSLMultiRootSolver & rhs)  {
+      if (this == &rhs) return *this;  // time saving self-test
+      return *this;
+   }
+
+
+public: 
+
+
+   void  CreateSolver(const  gsl_multiroot_fsolver_type * type, unsigned int n) { 
+      
+      /// create the solver from the type and size of number of fitting points and number of parameters 
+      if (fSolver) gsl_multiroot_fsolver_free(fSolver);
+      fSolver = gsl_multiroot_fsolver_alloc(type, n);
+
+   }
+
+
+   /// set the solver parameters 
+   virtual int SetSolver(const std::vector<ROOT::Math::IMultiGenFunction*> & funcVec, const double * x) { 
+      // create a vector of the fit contributions
+      // create function wrapper from an iterator of functions
+      assert(fSolver !=0);
+      unsigned int n = funcVec.size();
+
+      fFunctions.SetFunctions(funcVec, funcVec.size() ); 
+      // set initial values and create cached vector 
+      if (fVec != 0) gsl_vector_free(fVec);   
+      fVec = gsl_vector_alloc( n); 
+      std::copy(x,x+n, fVec->data); 
+      // solver should have been already created at this point
+      assert(fSolver != 0); 
+      return gsl_multiroot_fsolver_set(fSolver, fFunctions.GetFunctions(), fVec); 
+   }
+
+   virtual std::string Name() const { 
+      if (fSolver == 0 ) return "undefined";
+      return std::string(gsl_multiroot_fsolver_name(fSolver) ); 
+   }
+   
+   virtual int Iterate() { 
+      if (fSolver == 0) return -1; 
+      return gsl_multiroot_fsolver_iterate(fSolver); 
+   }
+
+   /// solution values at the current iteration 
+   virtual gsl_vector * GetRoot() const { 
+      if (fSolver == 0) return 0; 
+      return  gsl_multiroot_fsolver_root(fSolver);       
+   } 
+
+   /// return function values 
+   virtual gsl_vector * GetF() const { 
+      if (fSolver == 0) return 0; 
+      return  gsl_multiroot_fsolver_f(fSolver);       
+   } 
+
+   /// return function steps 
+   virtual gsl_vector * GetDx() const { 
+      if (fSolver == 0) return 0; 
+      return gsl_multiroot_fsolver_dx(fSolver);       
+   } 
+
+
+private: 
+
+   GSLMultiRootFunctionWrapper fFunctions; 
+   gsl_multiroot_fsolver * fSolver;
+   // cached vector to avoid re-allocating every time a new one
+   mutable gsl_vector * fVec; 
+
+}; 
+
+/** 
+   GSLMultiRootDerivSolver, internal class for implementing GSL multi-root finders
+   using derivatives
+
+   @ingroup MultiRoot
+*/ 
+class GSLMultiRootDerivSolver : public GSLMultiRootBaseSolver {
+
+public: 
+
+   /** 
+      Constructor
+   */ 
+   GSLMultiRootDerivSolver (const gsl_multiroot_fdfsolver_type * type, int n ) : 
+      fDerivSolver(0), 
+      fVec(0)
+   {
+      CreateSolver(type, n);
+   }  
+
+   /** 
+      Destructor (no operations)
+   */ 
+   virtual ~GSLMultiRootDerivSolver ()  {
+      if (fDerivSolver) gsl_multiroot_fdfsolver_free(fDerivSolver);
+      if (fVec != 0) gsl_vector_free(fVec); 
+   }  
+
+private:
+   // usually copying is non trivial, so we make this unaccessible
+
+   /** 
+      Copy constructor
+   */ 
+   GSLMultiRootDerivSolver(const GSLMultiRootDerivSolver &) : GSLMultiRootBaseSolver() {} 
+
+   /** 
+      Assignment operator
+   */ 
+   GSLMultiRootDerivSolver & operator = (const GSLMultiRootDerivSolver & rhs)  {
+      if (this == &rhs) return *this;  // time saving self-test
+      return *this;
+   }
+
+
+public: 
+
+
+   /// create the solver from the type and size of number of fitting points and number of parameters 
+   void  CreateSolver(const gsl_multiroot_fdfsolver_type * type, unsigned int n) { 
+      
+      /// create the solver from the type and size of number of fitting points and number of parameters 
+      if (fDerivSolver) gsl_multiroot_fdfsolver_free(fDerivSolver);
+      fDerivSolver = gsl_multiroot_fdfsolver_alloc(type, n);
+   }
+
+   
+
+   /// set the solver parameters for the case of derivative
+   virtual int SetSolver(const std::vector<ROOT::Math::IMultiGenFunction*> & funcVec, const double * x) { 
+      // create a vector of the fit contributions
+      // need to create a vecctor of gradient functions, convert and store in the class 
+      // the new vector pointer 
+      assert(fDerivSolver !=0);
+      unsigned int n = funcVec.size();
+      fGradFuncVec.reserve( n );
+      for (unsigned int i = 0; i < n; ++i) {
+         ROOT::Math::IMultiGradFunction * func = dynamic_cast<ROOT::Math::IMultiGradFunction *>(funcVec[i] );
+         if (func == 0) { 
+            MATH_ERROR_MSG("GSLMultiRootSolver::SetSolver","Function does not provide gradient interface");
+            return -1;
+         }
+         fGradFuncVec.push_back( func);
+      }
+
+      fDerivFunctions.SetFunctions(fGradFuncVec, funcVec.size() ); 
+      // set initial values 
+      if (fVec != 0) gsl_vector_free(fVec);   
+      fVec = gsl_vector_alloc( n); 
+      std::copy(x,x+n, fVec->data); 
+
+      return gsl_multiroot_fdfsolver_set(fDerivSolver, fDerivFunctions.GetFunctions(), fVec); 
+   }
+
+   virtual std::string Name() const { 
+      if (fDerivSolver == 0 ) return "undefined";
+      return std::string(gsl_multiroot_fdfsolver_name(fDerivSolver) ); 
+   }
+   
+   virtual int Iterate() { 
+      if (fDerivSolver == 0) return -1; 
+      return gsl_multiroot_fdfsolver_iterate(fDerivSolver); 
+   }
+
+   /// solution values at the current iteration 
+   virtual gsl_vector * GetRoot() const { 
+      if (fDerivSolver == 0) return 0; 
+      return gsl_multiroot_fdfsolver_root(fDerivSolver);       
+   } 
+
+   /// return function values 
+   virtual gsl_vector * GetF() const { 
+      if (fDerivSolver == 0) return 0; 
+      return  gsl_multiroot_fdfsolver_f(fDerivSolver);       
+   } 
+
+   /// return function steps 
+   virtual gsl_vector * GetDx() const { 
+      if (fDerivSolver == 0) return 0; 
+      return  gsl_multiroot_fdfsolver_dx(fDerivSolver);       
+   } 
+
+
+
+private: 
+
+   GSLMultiRootDerivFunctionWrapper fDerivFunctions; 
+   gsl_multiroot_fdfsolver * fDerivSolver;
+   // cached vector to avoid re-allocating every time a new one
+   mutable gsl_vector * fVec; 
+   std::vector<ROOT::Math::IMultiGradFunction*> fGradFuncVec; 
+
+}; 
+
+   } // end namespace Math
+
+} // end namespace ROOT
+
+
+#endif /* ROOT_Math_GSLMultiRootSolver */
diff --git a/math/mathmore/src/MCParameters.cxx b/math/mathmore/src/MCParameters.cxx
new file mode 100644
index 0000000..7718933
--- /dev/null
+++ b/math/mathmore/src/MCParameters.cxx
@@ -0,0 +1,139 @@
+// @(#)root/mathmore:$Id: root-5.27.06b-more-updated-mathcore-mathmore.patch,v 1.1 2011/09/12 13:50:11 eulisse Exp $
+// Author: Lorenzo Moneta  11/2010
+
+ /**********************************************************************
+  *                                                                    *
+  * Copyright (c) 2007 ROOT Foundation,  CERN/PH-SFT                   *
+  *                                                                    *
+  * This library is free software; you can redistribute it and/or      *
+  * modify it under the terms of the GNU General Public License        *
+  * as published by the Free Software Foundation; either version 2     *
+  * of the License, or (at your option) any later version.             *
+  *                                                                    *
+  * This library is distributed in the hope that it will be useful,    *
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of     *
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU   *
+  * General Public License for more details.                           *
+  *                                                                    *
+  * You should have received a copy of the GNU General Public License  *
+  * along with this library (see file COPYING); if not, write          *
+  * to the Free Software Foundation, Inc., 59 Temple Place, Suite      *
+  * 330, Boston, MA 02111-1307 USA, or contact the author.             *
+  *                                                                    *
+  **********************************************************************/
+//
+// implementation file for class MCParameters
+// Author: Lorenzo Moneta , Nov 2010
+// 
+//
+
+#include "Math/MCParameters.h"
+#include "Math/GenAlgoOptions.h"
+
+#include "gsl/gsl_monte_vegas.h"
+
+namespace ROOT {
+namespace Math {
+
+
+   /// default VEGAS parameters (copied from gsl/monte/vegas.c) 
+   void VegasParameters::SetDefaultValues() {
+      // init default values
+      alpha        =  1.5;
+      iterations   = 5;
+      stage        = 0; 
+      mode         = GSL_VEGAS_MODE_IMPORTANCE;
+      verbose      = -1;
+   }
+
+   VegasParameters::VegasParameters(const IOptions & opt) { 
+      SetDefaultValues();
+      (*this) = opt;
+   }
+
+   VegasParameters & VegasParameters::operator= (const IOptions & opt) { 
+      // set parameters from IOptions
+      double val = 0; 
+      int ival = 0; 
+      bool ret = false; 
+
+      ret = opt.GetRealValue("alpha",val); 
+      if (ret) alpha = val; 
+      ret = opt.GetIntValue("iterations",ival);
+      if (ret) iterations = ival; 
+      ret = opt.GetIntValue("stage",ival);
+      if (ret) stage = ival; 
+      ret = opt.GetIntValue("mode",ival);
+      if (ret) mode = ival; 
+      ret = opt.GetIntValue("verbose",ival);
+      if (ret) verbose = ival; 
+      return *this;
+   }
+
+   IOptions * VegasParameters::operator() () const { 
+      // convert to options (return object is managed by the user) 
+      GenAlgoOptions * opt = new GenAlgoOptions(); 
+      opt->SetRealValue("alpha",alpha);
+      opt->SetIntValue("iterations",iterations);
+      opt->SetIntValue("stage",stage);
+      opt->SetIntValue("mode",mode);
+      opt->SetIntValue("verbose",verbose);
+      return opt;
+   }
+
+
+
+   /// default MISER parameters (copied from gsl/monte/vegas.c) 
+
+
+   void MiserParameters::SetDefaultValues(size_t dim) {
+      // init default values
+      estimate_frac           = 0.1;
+      min_calls               = (dim>0) ? 16*dim : 160; // use default dim = 10
+      min_calls_per_bisection = 32*min_calls;
+      dither                  = 0;
+      alpha                   = 2.0;
+   }
+
+
+   MiserParameters::MiserParameters(const IOptions & opt, size_t dim) { 
+      SetDefaultValues(dim);
+      (*this) = opt;
+   }
+
+   MiserParameters & MiserParameters::operator= (const IOptions & opt) { 
+      // set parameters from IOptions
+      double val = 0; 
+      int ival = 0; 
+      bool ret = false; 
+
+      ret = opt.GetRealValue("alpha",val); 
+      if (ret) alpha = val; 
+      ret = opt.GetRealValue("dither",val); 
+      if (ret) dither = val; 
+      ret = opt.GetRealValue("estimate_frac",val); 
+      if (ret) estimate_frac = val; 
+      ret = opt.GetIntValue("min_calls",ival); 
+      if (ret) min_calls = ival; 
+      ret = opt.GetIntValue("min_calls_per_bisection",ival); 
+      if (ret) min_calls_per_bisection = ival; 
+      return *this;
+   }
+
+   IOptions * MiserParameters::operator() () const { 
+      // convert to options (return object is managed by the user) 
+      GenAlgoOptions * opt = new GenAlgoOptions(); 
+      opt->SetRealValue("alpha",alpha);
+      opt->SetRealValue("dither",dither);
+      opt->SetRealValue("estimate_frac",estimate_frac);
+      opt->SetIntValue("min_calls",min_calls);
+      opt->SetIntValue("min_calls_per_bisection",min_calls_per_bisection);
+      return opt;
+   }
+
+
+} // namespace Math
+} // namespace ROOT
+
+
+
