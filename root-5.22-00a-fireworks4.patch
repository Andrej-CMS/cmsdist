commit 35d4db90fa2a6d03445747dcca19cb4c8aa9c1f9
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Sat Oct 9 11:15:44 2010 +0200

    ../CMSDIST/root-5.22-00a-fireworks4.patch

diff --git a/graf3d/eve/Module.mk b/graf3d/eve/Module.mk
index d000956..356fbbd 100644
--- a/graf3d/eve/Module.mk
+++ b/graf3d/eve/Module.mk
@@ -33,7 +33,7 @@ EVEH1     := TEveBrowser TEveChunkManager TEveCompound \
              TEveUtil TEveVSD TEveViewer TEveWindow
 
 EVEH2     := TEveArrow TEveBoxSet TEveCalo \
-             TEveDigitSet TEveFrameBox TEveGeoNode TEveGeoShapeExtract \
+             TEveDigitSet TEveFrameBox TEveGeo \
              TEveGridStepper TEveLegoEventHandler \
              TEveLine TEvePointSet TEvePolygonSetProjected TEveQuadSet \
              TEveRGBAPalette TEveScalableStraightLineSet TEveStraightLineSet \
diff --git a/graf3d/eve/inc/LinkDef1.h b/graf3d/eve/inc/LinkDef1.h
index 5280850..a5dd76d 100644
--- a/graf3d/eve/inc/LinkDef1.h
+++ b/graf3d/eve/inc/LinkDef1.h
@@ -95,6 +95,7 @@
 #pragma link C++ class TEveSceneInfo+;
 #pragma link C++ class TEveViewer+;
 #pragma link C++ class TEveViewerList+;
+#pragma link C++ class TEveViewerListEditor+;
 
 // TEvePad
 #pragma link C++ class TEvePad+;
diff --git a/graf3d/eve/inc/LinkDef2.h b/graf3d/eve/inc/LinkDef2.h
index 42595b5..0af238f 100644
--- a/graf3d/eve/inc/LinkDef2.h
+++ b/graf3d/eve/inc/LinkDef2.h
@@ -83,6 +83,9 @@
 // TEveGeoShapeExtract
 #pragma link C++ class TEveGeoShapeExtract+;
 
+// Arbitrary-tesselation TGeoShape.
+#pragma link C++ class TEveGeoPolyShape+;
+
 // TEvePolygonSetProjected
 #pragma link C++ class TEvePolygonSetProjected+;
 #pragma link C++ class TEvePolygonSetProjectedEditor+;
diff --git a/graf3d/eve/inc/TEveCaloData.h b/graf3d/eve/inc/TEveCaloData.h
index f3d1b46..6b2948b 100644
--- a/graf3d/eve/inc/TEveCaloData.h
+++ b/graf3d/eve/inc/TEveCaloData.h
@@ -25,10 +25,10 @@ class TEveCaloData: public TEveRefBackPtr
 public:
    struct SliceInfo_t
    {
-      TString  fName;
-      Float_t  fThreshold;
-      Int_t    fID;
-      Color_t  fColor;
+      TString  fName;      // Name of the slice, eg. ECAL, HCAL.
+      Float_t  fThreshold; // Only display towers with higher energy.
+      Int_t    fID;        // Unique identification of the slice.
+      Color_t  fColor;     // Color used to draw this longitudinal slice.
       TH2F    *fHist;
 
       SliceInfo_t(): fName(""), fThreshold(0), fID(-1), fColor(Color_t(4)), fHist(0){}
@@ -141,6 +141,8 @@ protected:
 
    TAxis*       fEtaAxis;
    TAxis*       fPhiAxis;
+   
+   Bool_t       fWrapTwoPi;
 
    Float_t      fMaxValEt; // cached
    Float_t      fMaxValE;  // cached
@@ -185,6 +187,9 @@ public:
 
    virtual Float_t GetEps()      const { return fEps; }
    virtual void    SetEps(Float_t eps) { fEps=eps; }
+   
+   Bool_t   GetWrapTwoPi() const { return fWrapTwoPi; }
+   void     SetWrapTwoPi(Bool_t w) { fWrapTwoPi=w; }
 
    static  Float_t EtaToTheta(Float_t eta);
 
diff --git a/graf3d/eve/inc/TEveCaloLegoGL.h b/graf3d/eve/inc/TEveCaloLegoGL.h
index b2c3261..73d8c0c 100644
--- a/graf3d/eve/inc/TEveCaloLegoGL.h
+++ b/graf3d/eve/inc/TEveCaloLegoGL.h
@@ -13,7 +13,6 @@
 #define ROOT_TEveCaloLegoGL
 
 #include "TGLObject.h"
-#include "TGLIncludes.h"
 #include "TGLAxisPainter.h"
 
 #include "TEveCaloData.h"
@@ -96,17 +95,18 @@ public:
 //______________________________________________________________________________
 inline void TEveCaloLegoGL::WrapTwoPi(Float_t &min, Float_t &max) const
 {
-   //   static const Float_t pi  = TMath::Pi() + 1e-6;
-   if (fM->GetPhiMax()>TMath::Pi() && max<=fM->GetPhiMin())
+   if (fM->GetData()->GetWrapTwoPi())
    {
-      min += TMath::TwoPi();
-      max += TMath::TwoPi();
+      if (fM->GetPhiMax()>TMath::Pi() && max<=fM->GetPhiMin())
+      {
+         min += TMath::TwoPi();
+         max += TMath::TwoPi();
+      }
+      else if (fM->GetPhiMin()<-TMath::Pi() && min>=fM->GetPhiMax())
+      {
+         min -= TMath::TwoPi();
+         max -= TMath::TwoPi();
+      }
    }
-   else if (fM->GetPhiMin()<-TMath::Pi() && min>=fM->GetPhiMax())
-   {
-      min -= TMath::TwoPi();
-      max -= TMath::TwoPi();
-   }
-
 }
 #endif
diff --git a/graf3d/eve/inc/TEveGeoNode.h b/graf3d/eve/inc/TEveGeoNode.h
index e1a55c1..a939a42 100644
--- a/graf3d/eve/inc/TEveGeoNode.h
+++ b/graf3d/eve/inc/TEveGeoNode.h
@@ -13,15 +13,17 @@
 #define ROOT_TEveGeoNode
 
 #include "TEveElement.h"
-#include "TEveTrans.h"
-#include "TEveProjectionBases.h"
 
 class TGeoVolume;
 class TGeoNode;
 class TGeoHMatrix;
 class TGeoManager;
 
-class TGeoShape;
+// Added here to ease transition - forward declaration should be used.
+// This include will be removed for 5.24.
+#include <TEveGeoShape.h>
+// class TGeoShape;
+
 class TEveGeoShapeExtract;
 
 //----------------------------------------------------------------
@@ -36,7 +38,10 @@ class TEveGeoNode : public TEveElement,
 
 protected:
    TGeoNode *fNode;
-   TEveGeoShapeExtract* DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeExtract* parent = 0, Int_t level = 0);
+   TEveGeoShapeExtract* DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeExtract* parent=0, Bool_t leafs_only=kFALSE);
+
+   static Int_t                  fgCSGExportNSeg;  //!
+   static std::list<TGeoShape*>  fgTemporaryStore; //!
 
 public:
    TEveGeoNode(TGeoNode* node);
@@ -50,6 +55,9 @@ public:
 
    virtual void   ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent);
 
+   virtual void   ExpandIntoListTrees();
+   virtual void   ExpandIntoListTreesRecursively();
+
    virtual Bool_t CanEditElement() const { return kFALSE; }
 
    virtual void   AddStamp(UChar_t bits);
@@ -64,10 +72,15 @@ public:
    void UpdateNode(TGeoNode* node);
    void UpdateVolume(TGeoVolume* volume);
 
-   void Save(const char* file, const char* name="Extract");
+   void Save(const char* file, const char* name="Extract", Bool_t leafs_only=kFALSE);
+   void SaveExtract(const char* file, const char* name, Bool_t leafs_only);
+   void WriteExtract(const char* name, Bool_t leafs_only);
 
    virtual void Draw(Option_t* option="");
 
+   static Int_t GetCSGExportNSeg();
+   static void  SetCSGExportNSeg(Int_t nseg);
+
    ClassDef(TEveGeoNode, 1); // Wrapper for TGeoNode that allows it to be shown in GUI and controlled as a TEveElement.
 };
 
@@ -116,52 +129,4 @@ public:
    ClassDef(TEveGeoTopNode, 1); // Top-level TEveGeoNode with a pointer to TGeoManager and controls for steering of TGeoPainter.
 };
 
-
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-class TEveGeoShape : public TEveElement,
-                     public TNamed,
-                     public TEveProjectable
-{
-   TEveGeoShape(const TEveGeoShape&);            // Not implemented
-   TEveGeoShape& operator=(const TEveGeoShape&); // Not implemented
-
-protected:
-   Color_t           fColor;
-   Int_t             fNSegments;
-   TGeoShape*        fShape;
-
-   static TGeoManager* fgGeoMangeur;
-
-   static TEveGeoShape* SubImportShapeExtract(TEveGeoShapeExtract* gse, TEveElement* parent);
-   TEveGeoShapeExtract* DumpShapeTree(TEveGeoShape* geon, TEveGeoShapeExtract* parent = 0);
-
-public:
-   TEveGeoShape(const char* name="TEveGeoShape", const char* title=0);
-   virtual ~TEveGeoShape();
-
-   virtual Bool_t  CanEditMainColor()        const { return kTRUE; }
-   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
-
-   Color_t     GetColor()      const { return fColor; }
-   Int_t       GetNSegments()  const { return fNSegments; }
-   void        SetNSegments(Int_t s) { fNSegments = s; }
-   TGeoShape*  GetShape()            { return fShape; }
-   void        SetShape(TGeoShape* s);
-
-   virtual void Paint(Option_t* option="");
-
-   void Save(const char* file, const char* name="Extract");
-   static TEveGeoShape* ImportShapeExtract(TEveGeoShapeExtract* gse, TEveElement* parent=0);
-
-   // GeoProjectable
-   virtual TBuffer3D*   MakeBuffer3D();
-   virtual TClass*      ProjectedClass() const;
-
-   static TGeoManager*  GetGeoMangeur();
-
-   ClassDef(TEveGeoShape, 1); // Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).
-};
-
 #endif
diff --git a/graf3d/eve/inc/TEveGeoPolyShape.h b/graf3d/eve/inc/TEveGeoPolyShape.h
new file mode 100644
index 0000000..268e119
--- /dev/null
+++ b/graf3d/eve/inc/TEveGeoPolyShape.h
@@ -0,0 +1,47 @@
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveGeoPolyShape
+#define ROOT_TEveGeoPolyShape
+
+#include "TGeoBBox.h"
+#include "TAttBBox.h"
+
+class TBuffer3D;
+class TGLFaceSet;
+
+class TEveGeoPolyShape : public TGeoBBox
+{
+   friend class TEveGeoPolyShapeGL;
+
+private:
+   TEveGeoPolyShape(const TEveGeoPolyShape&);            // Not implemented
+   TEveGeoPolyShape& operator=(const TEveGeoPolyShape&); // Not implemented
+
+protected:
+   std::vector<Double_t> fVertices;
+   std::vector<Int_t>    fPolyDesc;
+   UInt_t                fNbPols;
+
+   virtual void FillBuffer3D(TBuffer3D& buffer, Int_t reqSections, Bool_t localFrame) const;
+
+public:
+   TEveGeoPolyShape();
+   virtual ~TEveGeoPolyShape() {}
+
+   void SetFromFaceSet(TGLFaceSet* fs);
+
+   virtual const TBuffer3D& GetBuffer3D(Int_t reqSections, Bool_t localFrame) const;
+   virtual       TBuffer3D* MakeBuffer3D() const;
+
+   ClassDef(TEveGeoPolyShape, 1); // A shape with arbitrary tesselation for visualization of CSG shapes.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveGeoShape.h b/graf3d/eve/inc/TEveGeoShape.h
new file mode 100644
index 0000000..ee1d0d6
--- /dev/null
+++ b/graf3d/eve/inc/TEveGeoShape.h
@@ -0,0 +1,67 @@
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveGeoShape
+#define ROOT_TEveGeoShape
+
+#include "TEveElement.h"
+#include "TEveProjectionBases.h"
+
+class TGeoShape;
+class TEveGeoShapeExtract;
+
+class TEveGeoShape : public TEveElement,
+                     public TNamed,
+                     public TEveProjectable
+{
+   TEveGeoShape(const TEveGeoShape&);            // Not implemented
+   TEveGeoShape& operator=(const TEveGeoShape&); // Not implemented
+
+protected:
+   Color_t           fColor;
+   Int_t             fNSegments;
+   TGeoShape*        fShape;
+
+   static TGeoManager* fgGeoMangeur;
+
+   static TEveGeoShape* SubImportShapeExtract(TEveGeoShapeExtract* gse, TEveElement* parent);
+   TEveGeoShapeExtract* DumpShapeTree(TEveGeoShape* geon, TEveGeoShapeExtract* parent=0);
+
+public:
+   TEveGeoShape(const char* name="TEveGeoShape", const char* title=0);
+   virtual ~TEveGeoShape();
+
+   virtual Bool_t  CanEditMainColor()        const { return kTRUE; }
+   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+
+   Color_t     GetColor()      const { return fColor; }
+   Int_t       GetNSegments()  const { return fNSegments; }
+   void        SetNSegments(Int_t s) { fNSegments = s; }
+   TGeoShape*  GetShape()            { return fShape; }
+   void        SetShape(TGeoShape* s);
+
+   virtual void Paint(Option_t* option="");
+
+   void Save(const char* file, const char* name="Extract");
+   void SaveExtract(const char* file, const char* name);
+   void WriteExtract(const char* name);
+
+   static TEveGeoShape* ImportShapeExtract(TEveGeoShapeExtract* gse, TEveElement* parent=0);
+
+   // GeoProjectable
+   virtual TBuffer3D*   MakeBuffer3D();
+   virtual TClass*      ProjectedClass() const;
+
+   static TGeoManager*  GetGeoMangeur();
+
+   ClassDef(TEveGeoShape, 1); // Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEvePolygonSetProjected.h b/graf3d/eve/inc/TEvePolygonSetProjected.h
index d6e7405..b3c000c 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjected.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjected.h
@@ -23,12 +23,6 @@
 
 class TBuffer3D;
 
-namespace std
-{
-template<typename _Tp> class allocator;
-template<typename _Tp, typename _Alloc > class list;
-}
-
 class TEveVector;
 
 class TEvePolygonSetProjected :  public TEveElementList,
diff --git a/graf3d/eve/inc/TEveProjectionAxes.h b/graf3d/eve/inc/TEveProjectionAxes.h
index b485fe2..7dea40b 100644
--- a/graf3d/eve/inc/TEveProjectionAxes.h
+++ b/graf3d/eve/inc/TEveProjectionAxes.h
@@ -2,12 +2,12 @@
 // Author: Matevz Tadel 2007
 
 /*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
+* Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+* All rights reserved.                                                  *
+*                                                                       *
+* For the licensing terms see $ROOTSYS/LICENSE.                         *
+* For the list of contributors see $ROOTSYS/README/CREDITS.             *
+*************************************************************************/
 
 #ifndef ROOT_TEveProjectionAxes
 #define ROOT_TEveProjectionAxes
diff --git a/graf3d/eve/inc/TEveViewer.h b/graf3d/eve/inc/TEveViewer.h
index 4263ceb..4c8dbbc 100644
--- a/graf3d/eve/inc/TEveViewer.h
+++ b/graf3d/eve/inc/TEveViewer.h
@@ -35,8 +35,12 @@ private:
    TEveViewer& operator=(const TEveViewer&); // Not implemented
 
 protected:
-   TGLViewer *fGLViewer;
-   TGFrame   *fGLViewerFrame;
+   TGLViewer    *fGLViewer;
+   TGFrame      *fGLViewerFrame;
+
+   static Bool_t fgInitInternal;
+   static Bool_t fgRecreateGlOnDockOps;
+   static void   InitInternal();
 
 public:
    TEveViewer(const char* n="TEveViewer", const char* t="");
@@ -79,7 +83,10 @@ private:
    TEveViewerList& operator=(const TEveViewerList&); // Not implemented
 
 protected:
-   Bool_t       fShowTooltip;
+   Bool_t        fShowTooltip;
+
+   Float_t       fBrightness;
+   Bool_t        fUseLightColorSet;
 
 public:
    TEveViewerList(const char* n="TEveViewerList", const char* t="");
@@ -106,8 +113,14 @@ public:
 
    // --------------------------------
 
-   Bool_t GetShowTooltip()   const { return fShowTooltip; }
-   void   SetShowTooltip(Bool_t x) { fShowTooltip = x; }
+   Bool_t  GetShowTooltip()     const { return fShowTooltip; }
+   void    SetShowTooltip(Bool_t x)   { fShowTooltip = x; }
+
+   Float_t GetColorBrightness() const { return fBrightness; }
+   void    SetColorBrightness(Float_t b);
+  
+   Bool_t  UseLightColorSet()   const { return fUseLightColorSet; }
+   void    SwitchColorSet();
 
    ClassDef(TEveViewerList, 0); // List of Viewers providing common operations on TEveViewer collections.
 };
diff --git a/graf3d/eve/inc/TEveViewerListEditor.h b/graf3d/eve/inc/TEveViewerListEditor.h
new file mode 100644
index 0000000..18edb9d
--- /dev/null
+++ b/graf3d/eve/inc/TEveViewerListEditor.h
@@ -0,0 +1,45 @@
+// Authors: Matevz Tadel & Alja Mrak-Tadel: 2006, 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveViewerListEditor
+#define ROOT_TEveViewerListEditor
+
+#include "TGedFrame.h"
+
+class TEveGValuator;
+class TEveViewerList;
+
+class TEveViewerListEditor : public TGedFrame
+{
+private:
+   TEveViewerListEditor(const TEveViewerListEditor&);            // Not implemented
+   TEveViewerListEditor& operator=(const TEveViewerListEditor&); // Not implemented
+
+protected:
+   TEveViewerList            *fM; // Model object.
+
+   TEveGValuator             *fBrightness;
+   TGTextButton              *fColorSet;
+
+public:
+   TEveViewerListEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30,
+         UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());
+   virtual ~TEveViewerListEditor() {}
+
+   virtual void SetModel(TObject* obj);
+
+   // Declare callback/slot methods
+   void DoBrightness();
+   void SwitchColorSet();
+
+   ClassDef(TEveViewerListEditor, 0); // GUI editor for TEveViewerList.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveWindow.h b/graf3d/eve/inc/TEveWindow.h
index 0191bd9..1ea6038 100644
--- a/graf3d/eve/inc/TEveWindow.h
+++ b/graf3d/eve/inc/TEveWindow.h
@@ -133,6 +133,9 @@ public:
    void SomeWindowClosed(TEveWindow* w);
    void MainFrameClosed();
 
+   TEveWindow* GetOriginalSlot() const { return fOriginalSlot; }
+   TEveWindow* GetOriginalContainer() const { return fOriginalContainer; }
+
    ClassDef(TEveCompositeFrameInMainFrame, 0); // Eve-composite-frame that is contained in one tab of a TGTab.
 };
 
@@ -370,6 +373,7 @@ public:
    virtual TGFrame*        GetGUIFrame();
 
    virtual Bool_t          CanMakeNewSlots() const { return kTRUE; }
+   virtual TEveWindowSlot* NewSlotWithWeight(Float_t w);
    virtual TEveWindowSlot* NewSlot(); // *MENU*
 
    void FlipOrientation(); // *MENU*
diff --git a/graf3d/eve/inc/TEveWindowManager.h b/graf3d/eve/inc/TEveWindowManager.h
index 4031d9f..c98ed9a 100644
--- a/graf3d/eve/inc/TEveWindowManager.h
+++ b/graf3d/eve/inc/TEveWindowManager.h
@@ -38,6 +38,8 @@ public:
    void SelectWindow(TEveWindow* w);
    void DeleteWindow(TEveWindow* w);
 
+   void WindowDocked(TEveWindow* window); // *SIGNAL*
+   void WindowUndocked (TEveWindow* window); // *SIGNAL*
    void WindowSelected(TEveWindow* window); // *SIGNAL*
    void WindowDeleted (TEveWindow* window); // *SIGNAL*
 
diff --git a/graf3d/eve/src/TEveCaloData.cxx b/graf3d/eve/src/TEveCaloData.cxx
index 642a029..a2bd125 100644
--- a/graf3d/eve/src/TEveCaloData.cxx
+++ b/graf3d/eve/src/TEveCaloData.cxx
@@ -90,6 +90,8 @@ TEveCaloData::TEveCaloData():
    fEtaAxis(0),
    fPhiAxis(0),
 
+   fWrapTwoPi(kTRUE),
+
    fMaxValEt(0),
    fMaxValE(0),
 
@@ -587,16 +589,26 @@ void TEveCaloDataHist::GetCellList(Float_t eta, Float_t etaD,
    TH2   *h0  = fSliceInfos[0].fHist;
    Int_t  bin = 0;
 
+   Bool_t accept;
    for (Int_t ieta = 1; ieta <= nEta; ++ieta)
    {
       if (fEtaAxis->GetBinLowEdge(ieta) >= etaMin && fEtaAxis->GetBinUpEdge(ieta) <= etaMax)
       {
          for (Int_t iphi = 1; iphi <= nPhi; ++iphi)
          {
-            if (TEveUtil::IsU1IntervalContainedByMinMax
-                (phiMin, phiMax, fPhiAxis->GetBinLowEdge(iphi), fPhiAxis->GetBinUpEdge(iphi)))
+            if (fWrapTwoPi )
+            {
+               accept = TEveUtil::IsU1IntervalContainedByMinMax
+                  (phiMin, phiMax, fPhiAxis->GetBinLowEdge(iphi), fPhiAxis->GetBinUpEdge(iphi));
+            }         
+            else
+            {
+               accept = fPhiAxis->GetBinLowEdge(iphi) >= phiMin &&  fPhiAxis->GetBinUpEdge(iphi) <= phiMax &&
+                  fPhiAxis->GetBinLowEdge(iphi) >= phiMin &&  fPhiAxis->GetBinUpEdge(iphi) <= phiMax;
+            }
+         
+            if (accept)
             {
-
                bin = h0->GetBin(ieta, iphi);
                for (Int_t s = 0; s < nSlices; ++s)
                {
diff --git a/graf3d/eve/src/TEveCaloLegoGL.cxx b/graf3d/eve/src/TEveCaloLegoGL.cxx
index 66c7dd0..dee8ae4 100644
--- a/graf3d/eve/src/TEveCaloLegoGL.cxx
+++ b/graf3d/eve/src/TEveCaloLegoGL.cxx
@@ -13,6 +13,7 @@
 #include "TH2.h"
 #include "THLimitsFinder.h"
 
+#include "TGLIncludes.h"
 #include "TGLRnrCtx.h"
 #include "TGLSelectRecord.h"
 #include "TGLScene.h"
diff --git a/graf3d/eve/src/TEveCaloVizEditor.cxx b/graf3d/eve/src/TEveCaloVizEditor.cxx
index 4feb502..65a2baa 100644
--- a/graf3d/eve/src/TEveCaloVizEditor.cxx
+++ b/graf3d/eve/src/TEveCaloVizEditor.cxx
@@ -255,9 +255,16 @@ void TEveCaloVizEditor::SetModel(TObject* obj)
       fM->GetData()->GetPhiLimits(min, max);
       fPhi->SetLimits(min, max, 101, TGNumberFormat::kNESRealTwo);
       fPhi->SetValue(fM->fPhi);
-      fPhi->SetToolTip("Center angle in radians");
-
-      fPhiOffset->SetLimits(1e-3, TMath::Pi(), 101, TGNumberFormat::kNESRealTwo);
+      if ( fM->GetData()->GetWrapTwoPi())
+      {
+         fPhi->SetToolTip("Center angle in radians");
+         fPhiOffset->SetLimits(1e-3, TMath::Pi(), 101, TGNumberFormat::kNESRealTwo);
+      }
+      else
+      {
+         Float_t d = (max-min)*0.5;
+         fPhiOffset->SetLimits(1e-3, d, 101, TGNumberFormat::kNESRealTwo);
+      }
       fPhiOffset->SetValue(fM->fPhiOffset);
       fPhiOffset->SetToolTip("Phi range in radians");
 
diff --git a/graf3d/eve/src/TEveGeoNode.cxx b/graf3d/eve/src/TEveGeoNode.cxx
index 7492a47..b60cc2f 100644
--- a/graf3d/eve/src/TEveGeoNode.cxx
+++ b/graf3d/eve/src/TEveGeoNode.cxx
@@ -10,10 +10,15 @@
  *************************************************************************/
 
 #include "TEveGeoNode.h"
+#include "TEveTrans.h"
 #include "TEveManager.h"
 #include "TEvePolygonSetProjected.h"
 
 #include "TEveGeoShapeExtract.h"
+#include "TEvePad.h"
+#include "TEveGeoPolyShape.h"
+#include "TGLScenePad.h"
+#include "TGLFaceSet.h"
 
 #include "TROOT.h"
 #include "TPad.h"
@@ -26,6 +31,7 @@
 #include "TGeoVolume.h"
 #include "TGeoNode.h"
 #include "TGeoShapeAssembly.h"
+#include "TGeoCompositeShape.h"
 #include "TGeoManager.h"
 #include "TGeoMatrix.h"
 #include "TVirtualGeoPainter.h"
@@ -41,6 +47,25 @@
 
 ClassImp(TEveGeoNode);
 
+Int_t                 TEveGeoNode::fgCSGExportNSeg = 64;
+std::list<TGeoShape*> TEveGeoNode::fgTemporaryStore;
+
+//______________________________________________________________________________
+Int_t TEveGeoNode::GetCSGExportNSeg()
+{
+   // Returns number of segments used for CSG export.
+
+   return fgCSGExportNSeg;
+}
+
+//______________________________________________________________________________
+void TEveGeoNode::SetCSGExportNSeg(Int_t nseg)
+{
+   // Sets number of segments used for CSG export.
+
+   fgCSGExportNSeg = nseg;
+}
+
 //______________________________________________________________________________
 TEveGeoNode::TEveGeoNode(TGeoNode* node) :
    TEveElement(),
@@ -109,6 +134,32 @@ void TEveGeoNode::ExpandIntoListTree(TGListTree* ltree,
    TEveElement::ExpandIntoListTree(ltree, parent);
 }
 
+//______________________________________________________________________________
+void TEveGeoNode::ExpandIntoListTrees()
+{
+   // Expand children into all list-trees.
+
+   for (sLTI_i i = fItems.begin(); i != fItems.end(); ++i)
+   {
+      ExpandIntoListTree(i->fTree, i->fItem);
+   }
+}
+
+//______________________________________________________________________________
+void TEveGeoNode::ExpandIntoListTreesRecursively()
+{
+   // Expand children into all list-trees recursively.
+   // This is useful if one wants to export extracted shapes.
+
+   ExpandIntoListTrees();
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      TEveGeoNode *egn = dynamic_cast<TEveGeoNode*>(*i);
+      if (egn)
+         egn->ExpandIntoListTreesRecursively();
+   }
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
@@ -197,7 +248,6 @@ void TEveGeoNode::UpdateNode(TGeoNode* node)
    for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i) {
       ((TEveGeoNode*)(*i))->UpdateNode(node);
    }
-
 }
 
 //______________________________________________________________________________
@@ -237,21 +287,47 @@ void TEveGeoNode::Draw(Option_t* option)
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveGeoNode::Save(const char* file, const char* name)
+void TEveGeoNode::Save(const char* file, const char* name, Bool_t leafs_only)
 {
    // Save TEveGeoShapeExtract tree starting at this node.
+   // This function is obsolete, use SaveExtract() instead.
+
+   Warning("Save()", "This function is deprecated, use SaveExtract() instead.");
+   SaveExtract(file, name, leafs_only);
+}
+
+//______________________________________________________________________________
+void TEveGeoNode::SaveExtract(const char* file, const char* name, Bool_t leafs_only)
+{
+   // Save the shape tree as TEveGeoShapeExtract.
+   // File is always recreated.
 
-   TEveGeoShapeExtract* gse = DumpShapeTree(this, 0, 0);
+   TEveGeoShapeExtract* gse = DumpShapeTree(this, 0, leafs_only);
 
    TFile f(file, "RECREATE");
    gse->Write(name);
    f.Close();
+
+   for (std::list<TGeoShape*>::iterator i = fgTemporaryStore.begin(); i != fgTemporaryStore.end(); ++i)
+      delete *i;
+   fgTemporaryStore.clear();
+}
+
+//______________________________________________________________________________
+void TEveGeoNode::WriteExtract(const char* name, Bool_t leafs_only)
+{
+   // Write the shape tree as TEveGeoShapeExtract to current directory.
+
+   TEveGeoShapeExtract* gse = DumpShapeTree(this, 0, leafs_only);
+   gse->Write(name);
 }
 
 /******************************************************************************/
 
 //______________________________________________________________________________
-TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeExtract* parent, Int_t level)
+TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode*         geon,
+                                                TEveGeoShapeExtract* parent,
+                                                Bool_t               leafs_only)
 {
    // Export the node hierarchy into tree of TEveGeoShapeExtract objects.
 
@@ -275,6 +351,48 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeE
          return 0;
       }
       tshape  = tvolume->GetShape();
+      if (tshape->IsComposite())
+      {
+         TEvePad pad;
+         TEvePadHolder gpad(kFALSE, &pad);
+         pad.GetListOfPrimitives()->Add(tshape);
+         TGLScenePad scene_pad(&pad);
+         pad.SetViewer3D(&scene_pad);
+
+         TEveGeoManagerHolder gmgr(tvolume->GetGeoManager());
+         gGeoManager->SetPaintVolume(tvolume);
+         Int_t nseg = gGeoManager->GetNsegments();
+         gGeoManager->SetNsegments(fgCSGExportNSeg);
+
+         Bool_t had_null_transform = kFALSE;
+         if (tshape->GetTransform() == 0) {
+            had_null_transform = kTRUE;
+            tshape->SetTransform(gGeoIdentity);
+         }
+
+         scene_pad.BeginScene();
+         dynamic_cast<TGeoCompositeShape*>(tshape)->PaintComposite();
+         scene_pad.EndScene();
+
+         if (had_null_transform) {
+            tshape->SetTransform(0);
+         }
+
+         gGeoManager->SetNsegments(nseg);
+
+         pad.SetViewer3D(0);
+
+         TGLFaceSet* fs = dynamic_cast<TGLFaceSet*>(scene_pad.FindLogical(tvolume));
+         if (!fs) {
+            Warning(eh, "Failed extracting CSG tesselation TEveGeoNode '%s'; skipping its sub-tree.\n", geon->GetName());
+            return 0;
+         }
+
+         TEveGeoPolyShape* egps = new TEveGeoPolyShape();
+         egps->SetFromFaceSet(fs);
+         tshape = egps;
+         fgTemporaryStore.push_back(egps);
+      }
    }
 
    // transformation
@@ -302,18 +420,17 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeE
       rgba[2] = c->GetBlue();
    }
    gse->SetRGBA(rgba);
-   Bool_t rnr = geon->GetRnrSelf();
-   if (level > gGeoManager->GetVisLevel())
-      rnr = kFALSE;
-   gse->SetRnrSelf(rnr);
-   gse->SetRnrElements(geon->GetRnrChildren());
-
-   if (dynamic_cast<TGeoShapeAssembly*>(tshape)) {
-      Info(eh, "TGeoShapeAssembly name='%s' encountered in traversal. This is not supported.", tshape->GetName());
-      tshape = 0;
+   Bool_t rnr     = tnode->IsVisible();
+   Bool_t rnr_els = tnode->IsVisDaughters();
+   if (tvolume) {
+      rnr     = rnr     && tvolume->IsVisible();
+      rnr_els = rnr_els && tvolume->IsVisDaughters();
    }
-   gse->SetShape(tshape);
-   ++level;
+   gse->SetRnrSelf    (rnr);
+   gse->SetRnrElements(rnr_els);
+
+   gse->SetShape((leafs_only && geon->HasChildren()) ? 0 : tshape);
+
    if (geon->HasChildren())
    {
       TList* ele = new TList();
@@ -324,7 +441,7 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode* geon, TEveGeoShapeE
       while (i != geon->EndChildren())
       {
          TEveGeoNode* l = dynamic_cast<TEveGeoNode*>(*i);
-         DumpShapeTree(l, gse, level+1);
+         DumpShapeTree(l, gse, leafs_only);
          ++i;
       }
    }
@@ -460,272 +577,3 @@ void TEveGeoTopNode::NodeVisChanged(TGeoNode* node)
    printf("%s node %s %p\n", eh.Data(), node->GetName(), (void*)node);
    UpdateNode(node);
 }
-
-
-//==============================================================================
-//==============================================================================
-// TEveGeoShape
-//==============================================================================
-
-//______________________________________________________________________________
-//
-// Wrapper for TGeoShape with absolute positioning and color
-// attributes allowing display of extracted TGeoShape's (without an
-// active TGeoManager) and simplified geometries (needed for NLT
-// projections).
-//
-// TGeoCompositeShapes are currently NOT supported. This is planned
-// for ROOT-5.24.
-
-namespace
-{
-TGeoManager* init_geo_mangeur()
-{
-   // Create a phony geo manager that
-   TGeoManager* old = gGeoManager;
-   gGeoManager = 0;
-   TGeoManager* mgr = new TGeoManager();
-   mgr->SetNameTitle("TEveGeoShape::fgGeoMangeur",
-                     "Static geo manager used for wrapped TGeoShapes.");
-   gGeoManager = old;
-   return mgr;
-}
-}
-
-ClassImp(TEveGeoShape);
-
-TGeoManager* TEveGeoShape::fgGeoMangeur = init_geo_mangeur();
-
-//______________________________________________________________________________
-TGeoManager* TEveGeoShape::GetGeoMangeur()
-{
-   // Return static geo-manager that is used intenally to make shapes
-   // lead a happy life.
-   // Set gGeoManager to this object when creating TGeoShapes to be
-   // passed into TEveGeoShapes.
-
-   return fgGeoMangeur;
-}
-
-//______________________________________________________________________________
-TEveGeoShape::TEveGeoShape(const char* name, const char* title) :
-   TEveElement   (fColor),
-   TNamed        (name, title),
-   fColor        (0),
-   fNSegments    (0),
-   fShape        (0)
-{
-   // Constructor.
-
-   InitMainTrans();
-}
-
-//______________________________________________________________________________
-TEveGeoShape::~TEveGeoShape()
-{
-   // Destructor.
-
-   SetShape(0);
-}
-
-//______________________________________________________________________________
-void TEveGeoShape::SetShape(TGeoShape* s)
-{
-   // Set TGeoShape shown by this object.
-
-   TEveGeoManagerHolder gmgr(fgGeoMangeur);
-
-   if (fShape) {
-      fShape->SetUniqueID(fShape->GetUniqueID() - 1);
-      if (fShape->GetUniqueID() == 0)
-         delete fShape;
-   }
-   fShape = s;
-   if (fShape) {
-      fShape->SetUniqueID(fShape->GetUniqueID() + 1);
-   }
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEveGeoShape::Paint(Option_t* /*option*/)
-{
-   // Paint object.
-
-   static const TEveException eh("TEveGeoShape::Paint ");
-
-   if (fShape == 0)
-      return;
-
-   TEveGeoManagerHolder gmgr(fgGeoMangeur, fNSegments);
-
-   TBuffer3D& buff = (TBuffer3D&) fShape->GetBuffer3D
-      (TBuffer3D::kCore, kFALSE);
-
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   RefMainTrans().SetBuffer3D(buff);
-   buff.fLocalFrame   = kTRUE; // Always enforce local frame (no geo manager).
-
-
-   Int_t sections = TBuffer3D::kBoundingBox | TBuffer3D::kShapeSpecific;
-   if (fNSegments > 2)
-      sections |= TBuffer3D::kRawSizes | TBuffer3D::kRaw;
-   fShape->GetBuffer3D(sections, kTRUE);
-
-   Int_t reqSec = gPad->GetViewer3D()->AddObject(buff);
-
-   if (reqSec != TBuffer3D::kNone) {
-      // This shouldn't happen, but I suspect it does sometimes.
-      if (reqSec & TBuffer3D::kCore)
-         Warning(eh, "Core section required again for shape='%s'. This shouldn't happen.", GetName());
-      fShape->GetBuffer3D(reqSec, kTRUE);
-      reqSec = gPad->GetViewer3D()->AddObject(buff);
-   }
-
-   if (reqSec != TBuffer3D::kNone)
-      Warning(eh, "Extra section required: reqSec=%d, shape=%s.", reqSec, GetName());
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEveGeoShape::Save(const char* file, const char* name)
-{
-   // Save the shape tree as TEveGeoShapeExtract.
-   // File is always recreated.
-
-   TEveGeoShapeExtract* gse = DumpShapeTree(this, 0);
-
-   TFile f(file, "RECREATE");
-   gse->Write(name);
-   f.Close();
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-TEveGeoShapeExtract* TEveGeoShape::DumpShapeTree(TEveGeoShape* gsre,
-                                                 TEveGeoShapeExtract* parent)
-{
-   // Export this shape and its descendants into a geoshape-extract.
-
-   TEveGeoShapeExtract* she = new TEveGeoShapeExtract(gsre->GetName(), gsre->GetTitle());
-   she->SetTrans(gsre->RefMainTrans().Array());
-   Int_t ci = gsre->GetColor();
-   TColor* c = gROOT->GetColor(ci);
-   Float_t rgba[4] = {1, 0, 0, 1 - gsre->GetMainTransparency()/100.};
-   if (c)
-   {
-      rgba[0] = c->GetRed();
-      rgba[1] = c->GetGreen();
-      rgba[2] = c->GetBlue();
-   }
-   she->SetRGBA(rgba);
-   she->SetRnrSelf(gsre->GetRnrSelf());
-   she->SetRnrElements(gsre->GetRnrChildren());
-   she->SetShape(gsre->GetShape());
-   if (gsre->HasChildren())
-   {
-      TList* ele = new TList();
-      she->SetElements(ele);
-      she->GetElements()->SetOwner(true);
-      TEveElement::List_i i = gsre->BeginChildren();
-      while (i != gsre->EndChildren()) {
-         TEveGeoShape* l = dynamic_cast<TEveGeoShape*>(*i);
-         DumpShapeTree(l, she);
-         i++;
-      }
-   }
-   if (parent)
-      parent->GetElements()->Add(she);
-
-   return she;
-}
-
-//______________________________________________________________________________
-TEveGeoShape* TEveGeoShape::ImportShapeExtract(TEveGeoShapeExtract* gse,
-                                               TEveElement*         parent)
-{
-   // Import a shape extract 'gse' under element 'parent'.
-
-   TEveGeoManagerHolder gmgr(fgGeoMangeur);
-   TEveManager::TRedrawDisabler redrawOff(gEve);
-   TEveGeoShape* gsre = SubImportShapeExtract(gse, parent);
-   gsre->ElementChanged();
-   return gsre;
-}
-
-
-//______________________________________________________________________________
-TEveGeoShape* TEveGeoShape::SubImportShapeExtract(TEveGeoShapeExtract* gse,
-                                                  TEveElement*         parent)
-{
-   // Recursive version for importing a shape extract tree.
-
-   TEveGeoShape* gsre = new TEveGeoShape(gse->GetName(), gse->GetTitle());
-   gsre->RefMainTrans().SetFromArray(gse->GetTrans());
-   const Float_t* rgba = gse->GetRGBA();
-   gsre->SetMainColorRGB(rgba[0], rgba[1], rgba[2]);
-   gsre->SetMainAlpha(rgba[3]);
-   gsre->SetRnrSelf(gse->GetRnrSelf());
-   gsre->SetRnrChildren(gse->GetRnrElements());
-   gsre->SetShape(gse->GetShape());
-
-   if (parent)
-      parent->AddElement(gsre);
-
-   if (gse->HasElements())
-   {
-      TIter next(gse->GetElements());
-      TEveGeoShapeExtract* chld;
-      while ((chld = (TEveGeoShapeExtract*) next()) != 0)
-         SubImportShapeExtract(chld, gsre);
-   }
-
-   return gsre;
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-TClass* TEveGeoShape::ProjectedClass() const
-{
-   // Return class for projected objects, TEvePolygonSetProjected.
-   // Virtual from TEveProjectable.
-
-   return TEvePolygonSetProjected::Class();
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-TBuffer3D* TEveGeoShape::MakeBuffer3D()
-{
-   // Create a TBuffer3D suitable for presentation of the shape.
-   // Transformation matrix is also applied.
-
-   if (fShape == 0) return 0;
-
-   if (dynamic_cast<TGeoShapeAssembly*>(fShape)) {
-      // !!!! TGeoShapeAssembly makes a bad TBuffer3D
-      return 0;
-   }
-
-   TEveGeoManagerHolder gmgr(fgGeoMangeur, fNSegments);
-
-   TBuffer3D* buff  = fShape->MakeBuffer3D();
-   TEveTrans& mx    = RefMainTrans();
-   if (mx.GetUseTrans())
-   {
-      Int_t n = buff->NbPnts();
-      Double_t* pnts = buff->fPnts;
-      for(Int_t k = 0; k < n; ++k)
-      {
-         mx.MultiplyIP(&pnts[3*k]);
-      }
-   }
-   return buff;
-}
diff --git a/graf3d/eve/src/TEveGeoPolyShape.cxx b/graf3d/eve/src/TEveGeoPolyShape.cxx
new file mode 100644
index 0000000..ca6c215
--- /dev/null
+++ b/graf3d/eve/src/TEveGeoPolyShape.cxx
@@ -0,0 +1,122 @@
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveGeoPolyShape.h"
+#include "TGLFaceSet.h"
+
+#include "TVirtualPad.h"
+#include "TBuffer3D.h"
+#include "TBuffer3DTypes.h"
+
+//______________________________________________________________________________
+// Description of TEveGeoPolyShape
+//
+
+ClassImp(TEveGeoPolyShape);
+
+//______________________________________________________________________________
+TEveGeoPolyShape::TEveGeoPolyShape() :
+   TGeoBBox(),
+   fNbPols(0)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+void TEveGeoPolyShape::SetFromFaceSet(TGLFaceSet* fs)
+{
+   // Set data-members from a face-set.
+
+   fVertices = fs->GetVertices();
+   fPolyDesc = fs->GetPolyDesc();
+   fNbPols   = fs->GetNbPols();
+}
+
+//______________________________________________________________________________
+void TEveGeoPolyShape::FillBuffer3D(TBuffer3D& b, Int_t reqSections, Bool_t) const
+{
+   // Fill the passed buffer 3D.
+
+   if (reqSections & TBuffer3D::kCore)
+   {
+      // If writing core section all others will be invalid
+      b.ClearSectionsValid();
+
+      b.fID = const_cast<TEveGeoPolyShape*>(this);
+      b.fColor = 0;
+      b.fTransparency = 0;
+      b.fLocalFrame = kFALSE;
+      b.fReflection = kTRUE;
+
+      b.SetSectionsValid(TBuffer3D::kCore);
+   }
+
+   if (reqSections & TBuffer3D::kRawSizes || reqSections & TBuffer3D::kRaw)
+   {
+      UInt_t nvrt = fVertices.size() / 3;
+      UInt_t nseg = 0;
+
+      const Int_t *pd = &fPolyDesc[0];
+      for (UInt_t i = 0; i < fNbPols; ++i)
+      {
+         nseg += pd[0];
+         pd   += pd[0] + 1;
+      }
+
+      b.SetRawSizes(nvrt, 3*nvrt, nseg, 3*nseg, fNbPols, fNbPols+fPolyDesc.size());
+
+      memcpy(b.fPnts, &fVertices[0], sizeof(Double_t)*fVertices.size());
+
+      Int_t si = 0, pi = 0, ns = 0;
+
+      pd = &fPolyDesc[0];
+      for (UInt_t i = 0; i < fNbPols; ++i)
+      {
+         UInt_t nv = pd[0]; ++pd;
+         b.fPols[pi++] = 0;
+         b.fPols[pi++] = nv;
+         for (UInt_t j = 0; j < nv; ++j)
+         {
+            b.fSegs[si++] = 0;
+            b.fSegs[si++] = pd[j];
+            b.fSegs[si++] = (j != nv - 1) ? pd[j+1] : pd[0];
+
+            b.fPols[pi++] = ns++;
+         }
+         pd += nv;
+      }
+
+      b.SetSectionsValid(TBuffer3D::kRawSizes | TBuffer3D::kRaw);
+   }
+}
+
+//______________________________________________________________________________
+const TBuffer3D& TEveGeoPolyShape::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const
+{
+   // Fill static buffer 3D.
+
+   static TBuffer3D buf(TBuffer3DTypes::kGeneric);
+
+   FillBuffer3D(buf, reqSections, localFrame);
+
+   return buf;
+}
+
+//______________________________________________________________________________
+TBuffer3D* TEveGeoPolyShape::MakeBuffer3D() const
+{
+   // Create buffer 3D and fill it with point/segment/poly data.
+
+   TBuffer3D* buf = new TBuffer3D(TBuffer3DTypes::kGeneric);
+
+   FillBuffer3D(*buf, TBuffer3D::kCore | TBuffer3D::kRawSizes | TBuffer3D::kRaw, kFALSE);
+
+   return buf;
+}
diff --git a/graf3d/eve/src/TEveGeoShape.cxx b/graf3d/eve/src/TEveGeoShape.cxx
new file mode 100644
index 0000000..12814ec
--- /dev/null
+++ b/graf3d/eve/src/TEveGeoShape.cxx
@@ -0,0 +1,325 @@
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveGeoShape.h"
+#include "TEveTrans.h"
+#include "TEveManager.h"
+#include "TEvePolygonSetProjected.h"
+
+#include "TEveGeoShapeExtract.h"
+#include "TEvePad.h"
+#include "TEveGeoPolyShape.h"
+#include "TGLScenePad.h"
+#include "TGLFaceSet.h"
+
+#include "TROOT.h"
+#include "TPad.h"
+#include "TBuffer3D.h"
+#include "TVirtualViewer3D.h"
+#include "TColor.h"
+#include "TFile.h"
+
+#include "TGeoShape.h"
+#include "TGeoVolume.h"
+#include "TGeoNode.h"
+#include "TGeoShapeAssembly.h"
+#include "TGeoCompositeShape.h"
+#include "TGeoManager.h"
+#include "TGeoMatrix.h"
+#include "TVirtualGeoPainter.h"
+
+namespace
+{
+TGeoManager* init_geo_mangeur()
+{
+   // Create a phony geo manager that can be used for storing free
+   // shapes. Otherwise shapes register themselves to current
+   // geo-manager (or even create one).
+
+   TGeoManager* old = gGeoManager;
+   gGeoManager = 0;
+   TGeoManager* mgr = new TGeoManager();
+   mgr->SetNameTitle("TEveGeoShape::fgGeoMangeur",
+                     "Static geo manager used for wrapped TGeoShapes.");
+   gGeoManager = old;
+   return mgr;
+}
+}
+
+//==============================================================================
+//==============================================================================
+// TEveGeoShape
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Wrapper for TGeoShape with absolute positioning and color
+// attributes allowing display of extracted TGeoShape's (without an
+// active TGeoManager) and simplified geometries (needed for NLT
+// projections).
+//
+// TGeoCompositeShapes and TGeoAssemblies are supported.
+
+ClassImp(TEveGeoShape);
+
+TGeoManager* TEveGeoShape::fgGeoMangeur = init_geo_mangeur();
+
+//______________________________________________________________________________
+TGeoManager* TEveGeoShape::GetGeoMangeur()
+{
+   // Return static geo-manager that is used intenally to make shapes
+   // lead a happy life.
+   // Set gGeoManager to this object when creating TGeoShapes to be
+   // passed into TEveGeoShapes.
+
+   return fgGeoMangeur;
+}
+
+//______________________________________________________________________________
+TEveGeoShape::TEveGeoShape(const char* name, const char* title) :
+   TEveElement   (fColor),
+   TNamed        (name, title),
+   fColor        (0),
+   fNSegments    (0),
+   fShape        (0)
+{
+   // Constructor.
+
+   InitMainTrans();
+}
+
+//______________________________________________________________________________
+TEveGeoShape::~TEveGeoShape()
+{
+   // Destructor.
+
+   SetShape(0);
+}
+
+//______________________________________________________________________________
+void TEveGeoShape::SetShape(TGeoShape* s)
+{
+   // Set TGeoShape shown by this object.
+
+   TEveGeoManagerHolder gmgr(fgGeoMangeur);
+
+   if (fShape) {
+      fShape->SetUniqueID(fShape->GetUniqueID() - 1);
+      if (fShape->GetUniqueID() == 0)
+         delete fShape;
+   }
+   fShape = s;
+   if (fShape) {
+      fShape->SetUniqueID(fShape->GetUniqueID() + 1);
+   }
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEveGeoShape::Paint(Option_t* /*option*/)
+{
+   // Paint object.
+
+   static const TEveException eh("TEveGeoShape::Paint ");
+
+   if (fShape == 0)
+      return;
+
+   TEveGeoManagerHolder gmgr(fgGeoMangeur, fNSegments);
+
+   TBuffer3D& buff = (TBuffer3D&) fShape->GetBuffer3D
+      (TBuffer3D::kCore, kFALSE);
+
+   buff.fID           = this;
+   buff.fColor        = GetMainColor();
+   buff.fTransparency = GetMainTransparency();
+   RefMainTrans().SetBuffer3D(buff);
+   buff.fLocalFrame   = kTRUE; // Always enforce local frame (no geo manager).
+
+   Int_t sections = TBuffer3D::kBoundingBox | TBuffer3D::kShapeSpecific;
+   if (fNSegments > 2)
+      sections |= TBuffer3D::kRawSizes | TBuffer3D::kRaw;
+   fShape->GetBuffer3D(sections, kTRUE);
+
+   Int_t reqSec = gPad->GetViewer3D()->AddObject(buff);
+
+   if (reqSec != TBuffer3D::kNone) {
+      // This shouldn't happen, but I suspect it does sometimes.
+      if (reqSec & TBuffer3D::kCore)
+         Warning(eh, "Core section required again for shape='%s'. This shouldn't happen.", GetName());
+      fShape->GetBuffer3D(reqSec, kTRUE);
+      reqSec = gPad->GetViewer3D()->AddObject(buff);
+   }
+
+   if (reqSec != TBuffer3D::kNone)
+      Warning(eh, "Extra section required: reqSec=%d, shape=%s.", reqSec, GetName());
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEveGeoShape::Save(const char* file, const char* name)
+{
+   // Save the shape tree as TEveGeoShapeExtract.
+   // File is always recreated.
+   // This function is obsolete, use SaveExtractInstead().
+
+   Warning("Save()", "This function is deprecated, use SaveExtract() instead.");
+   SaveExtract(file, name);
+}
+
+//______________________________________________________________________________
+void TEveGeoShape::SaveExtract(const char* file, const char* name)
+{
+   // Save the shape tree as TEveGeoShapeExtract.
+   // File is always recreated.
+
+   TEveGeoShapeExtract* gse = DumpShapeTree(this, 0);
+
+   TFile f(file, "RECREATE");
+   gse->Write(name);
+   f.Close();
+}
+
+//______________________________________________________________________________
+void TEveGeoShape::WriteExtract(const char* name)
+{
+   // Write the shape tree as TEveGeoShapeExtract to current directory.
+
+   TEveGeoShapeExtract* gse = DumpShapeTree(this, 0);
+   gse->Write(name);
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+TEveGeoShapeExtract* TEveGeoShape::DumpShapeTree(TEveGeoShape* gsre,
+                                                 TEveGeoShapeExtract* parent)
+{
+   // Export this shape and its descendants into a geoshape-extract.
+
+   TEveGeoShapeExtract* she = new TEveGeoShapeExtract(gsre->GetName(), gsre->GetTitle());
+   she->SetTrans(gsre->RefMainTrans().Array());
+   Int_t ci = gsre->GetColor();
+   TColor* c = gROOT->GetColor(ci);
+   Float_t rgba[4] = {1, 0, 0, 1 - gsre->GetMainTransparency()/100.};
+   if (c)
+   {
+      rgba[0] = c->GetRed();
+      rgba[1] = c->GetGreen();
+      rgba[2] = c->GetBlue();
+   }
+   she->SetRGBA(rgba);
+   she->SetRnrSelf(gsre->GetRnrSelf());
+   she->SetRnrElements(gsre->GetRnrChildren());
+   she->SetShape(gsre->GetShape());
+   if (gsre->HasChildren())
+   {
+      TList* ele = new TList();
+      she->SetElements(ele);
+      she->GetElements()->SetOwner(true);
+      TEveElement::List_i i = gsre->BeginChildren();
+      while (i != gsre->EndChildren()) {
+         TEveGeoShape* l = dynamic_cast<TEveGeoShape*>(*i);
+         DumpShapeTree(l, she);
+         i++;
+      }
+   }
+   if (parent)
+      parent->GetElements()->Add(she);
+
+   return she;
+}
+
+//______________________________________________________________________________
+TEveGeoShape* TEveGeoShape::ImportShapeExtract(TEveGeoShapeExtract* gse,
+                                               TEveElement*         parent)
+{
+   // Import a shape extract 'gse' under element 'parent'.
+
+   TEveGeoManagerHolder gmgr(fgGeoMangeur);
+   TEveManager::TRedrawDisabler redrawOff(gEve);
+   TEveGeoShape* gsre = SubImportShapeExtract(gse, parent);
+   gsre->ElementChanged();
+   return gsre;
+}
+
+
+//______________________________________________________________________________
+TEveGeoShape* TEveGeoShape::SubImportShapeExtract(TEveGeoShapeExtract* gse,
+                                                  TEveElement*         parent)
+{
+   // Recursive version for importing a shape extract tree.
+
+   TEveGeoShape* gsre = new TEveGeoShape(gse->GetName(), gse->GetTitle());
+   gsre->RefMainTrans().SetFromArray(gse->GetTrans());
+   const Float_t* rgba = gse->GetRGBA();
+   gsre->SetMainColorRGB(rgba[0], rgba[1], rgba[2]);
+   gsre->SetMainAlpha(rgba[3]);
+   gsre->SetRnrSelf(gse->GetRnrSelf());
+   gsre->SetRnrChildren(gse->GetRnrElements());
+   gsre->SetShape(gse->GetShape());
+
+   if (parent)
+      parent->AddElement(gsre);
+
+   if (gse->HasElements())
+   {
+      TIter next(gse->GetElements());
+      TEveGeoShapeExtract* chld;
+      while ((chld = (TEveGeoShapeExtract*) next()) != 0)
+         SubImportShapeExtract(chld, gsre);
+   }
+
+   return gsre;
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+TClass* TEveGeoShape::ProjectedClass() const
+{
+   // Return class for projected objects, TEvePolygonSetProjected.
+   // Virtual from TEveProjectable.
+
+   return TEvePolygonSetProjected::Class();
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+TBuffer3D* TEveGeoShape::MakeBuffer3D()
+{
+   // Create a TBuffer3D suitable for presentation of the shape.
+   // Transformation matrix is also applied.
+
+   if (fShape == 0) return 0;
+
+   if (dynamic_cast<TGeoShapeAssembly*>(fShape)) {
+      // !!!! TGeoShapeAssembly makes a bad TBuffer3D
+      return 0;
+   }
+
+   TEveGeoManagerHolder gmgr(fgGeoMangeur, fNSegments);
+
+   TBuffer3D* buff  = fShape->MakeBuffer3D();
+   TEveTrans& mx    = RefMainTrans();
+   if (mx.GetUseTrans())
+   {
+      Int_t n = buff->NbPnts();
+      Double_t* pnts = buff->fPnts;
+      for(Int_t k = 0; k < n; ++k)
+      {
+         mx.MultiplyIP(&pnts[3*k]);
+      }
+   }
+   return buff;
+}
diff --git a/graf3d/eve/src/TEveGeoShapeExtract.cxx b/graf3d/eve/src/TEveGeoShapeExtract.cxx
index 9c86976..ad6b898 100644
--- a/graf3d/eve/src/TEveGeoShapeExtract.cxx
+++ b/graf3d/eve/src/TEveGeoShapeExtract.cxx
@@ -11,6 +11,7 @@
 
 #include "TEveGeoShapeExtract.h"
 #include "TEveGeoNode.h"
+#include "TEveGeoShape.h"
 
 #include "TList.h"
 #include "TGeoManager.h"
diff --git a/graf3d/eve/src/TEveManager.cxx b/graf3d/eve/src/TEveManager.cxx
index c86d0a4..1bc94ae 100644
--- a/graf3d/eve/src/TEveManager.cxx
+++ b/graf3d/eve/src/TEveManager.cxx
@@ -253,8 +253,7 @@ TCanvas* TEveManager::AddCanvasTab(const char* name)
 
    fBrowser->StartEmbedding(1, -1);
    TCanvas* c = new TCanvas;
-   fBrowser->StopEmbedding();
-   fBrowser->SetTabTitle(name, 1, -1);
+   fBrowser->StopEmbedding(name);
 
    return c;
 }
diff --git a/graf3d/eve/src/TEvePolygonSetProjected.cxx b/graf3d/eve/src/TEvePolygonSetProjected.cxx
index 72dc746..17dbea0 100644
--- a/graf3d/eve/src/TEvePolygonSetProjected.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjected.cxx
@@ -11,7 +11,7 @@
 
 #include "TEvePolygonSetProjected.h"
 #include "TEveVSDStructs.h"
-#include "TEveGeoNode.h"
+#include "TEveGeoShape.h"
 #include "TEveProjectionManager.h"
 
 #include "TBuffer3D.h"
diff --git a/graf3d/eve/src/TEveProjectionAxes.cxx b/graf3d/eve/src/TEveProjectionAxes.cxx
index 788fc04..a9c0bd6 100644
--- a/graf3d/eve/src/TEveProjectionAxes.cxx
+++ b/graf3d/eve/src/TEveProjectionAxes.cxx
@@ -2,12 +2,12 @@
 // Author: Matevz Tadel 2007
 
 /*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
+* Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+* All rights reserved.                                                  *
+*                                                                       *
+* For the licensing terms see $ROOTSYS/LICENSE.                         *
+* For the list of contributors see $ROOTSYS/README/CREDITS.             *
+*************************************************************************/
 
 #include "TEveProjectionAxes.h"
 #include "TEveProjectionManager.h"
diff --git a/graf3d/eve/src/TEveUtil.cxx b/graf3d/eve/src/TEveUtil.cxx
index 2e795a0..5e8d25b 100644
--- a/graf3d/eve/src/TEveUtil.cxx
+++ b/graf3d/eve/src/TEveUtil.cxx
@@ -277,17 +277,18 @@ Color_t* TEveUtil::FindColorVar(TObject* obj, const char* varname)
    return (Color_t*) (((char*)obj) + off);
 }
 
+//______________________________________________________________________________
 void TEveUtil::SetColorBrightness(Float_t value, Bool_t full_redraw)
 {
    // Tweak all ROOT colors to become brighter (if value > 0) or
    // darker (value < 0). Reasonable values for the value argument are
-   // from -0.5 to 0.5 (error will be printed otherwise).
+   // from -2.5 to 2.5 (error will be printed otherwise).
    // If value is zero, the original colors are restored.
    //
    // You should call TEveManager::FullRedraw3D() afterwards or set
    // the argument full_redraw to true (default is false).
 
-   if (value < -0.5 || value > 0.5)
+   if (value < -2.5 || value > 2.5)
    {
       Error("TEveUtil::SetColorBrightness", "value '%f' out of range [-0.5, 0.5].", value);
       return;
@@ -323,13 +324,17 @@ void TEveUtil::SetColorBrightness(Float_t value, Bool_t full_redraw)
          {
             cdef->Copy(*croot);
          }
+
          Float_t r, g, b;
          croot->GetRGB(r, g, b);
-         if (r < 0.01 && g < 0.01 && b < 0.01) continue; // skip black
-         if (r > 0.99 && g > 0.99 && b > 0.99) continue; // skip white
-         r = TMath::Min(r + value, 1.0f);
-         g = TMath::Min(g + value, 1.0f);
-         b = TMath::Min(b + value, 1.0f);
+         r = TMath::Power( r, (2.5 - value)/2.5);
+         g = TMath::Power(g, (2.5 - value)/2.5);
+         b = TMath::Power(b, (2.5 - value)/2.5);
+
+         r = TMath::Min(r, 1.0f);
+         g = TMath::Min(g, 1.0f);
+         b = TMath::Min(b, 1.0f);
+
          croot->SetRGB(r, g, b);
       }
       else
diff --git a/graf3d/eve/src/TEveViewer.cxx b/graf3d/eve/src/TEveViewer.cxx
index e950854..dc952a2 100644
--- a/graf3d/eve/src/TEveViewer.cxx
+++ b/graf3d/eve/src/TEveViewer.cxx
@@ -24,6 +24,36 @@
 #include "TGLLogicalShape.h"  // For handling OnMouseIdle signal
 #include "TGLEventHandler.h"
 
+#include "TSystem.h"
+namespace
+{
+TString gSystem_GetFromPipe(const char *command)
+{
+   // Execute command and return output in TString.
+
+   TString out;
+
+   FILE *pipe = gSystem->OpenPipe(command, "r");
+   if (!pipe) {
+      SysError("GetFromPipe", "cannot run command \"%s\"", command);
+      return out;
+   }
+
+   TString line;
+   while (line.Gets(pipe)) {
+      if (out != "")
+         out += "\n";
+      out += line;
+   }
+
+   Int_t r = gSystem->ClosePipe(pipe);
+   if (r) {
+      Error("GetFromPipe", "command \"%s\" returned %d", command, r);
+   }
+   return out;
+}
+}
+
 //==============================================================================
 //==============================================================================
 // TEveViewer
@@ -42,6 +72,9 @@
 
 ClassImp(TEveViewer);
 
+Bool_t TEveViewer::fgInitInternal        = kFALSE;
+Bool_t TEveViewer::fgRecreateGlOnDockOps = kFALSE;
+
 //______________________________________________________________________________
 TEveViewer::TEveViewer(const char* n, const char* t) :
    TEveWindowFrame(0, n, t),
@@ -56,6 +89,11 @@ TEveViewer::TEveViewer(const char* n, const char* t) :
 
    SetChildClass(TEveSceneInfo::Class());
    fGUIFrame->SetCleanup(kNoCleanup); // the gl-viewer's frame deleted elsewhere.
+
+   if (!fgInitInternal)
+   {
+      InitInternal();
+   }
 }
 
 //______________________________________________________________________________
@@ -72,27 +110,45 @@ TEveViewer::~TEveViewer()
 /******************************************************************************/
 
 //______________________________________________________________________________
+void TEveViewer::InitInternal()
+{
+   // Initialize static data-members according to running conditions.
+
+   // Determine if display is running on a mac.
+   // This is also works for ssh connection mac->linux.
+#ifndef WIN32
+   TString s = gSystem_GetFromPipe("xdpyinfo");
+   if (s.Index("Apple-WM") != kNPOS)
+   {
+      fgRecreateGlOnDockOps = kTRUE;
+   }
+#endif
+
+   fgInitInternal = kTRUE;
+}
+
+//______________________________________________________________________________
 void TEveViewer::PreUndock()
 {
    // Virtual function called before a window is undocked.
    // On mac we have to force recreation of gl-context.
 
    TEveWindowFrame::PreUndock();
-#ifdef R__MACOSX
-   fGLViewer->DestroyGLWidget();
-#endif
+   if (fgRecreateGlOnDockOps) {
+      fGLViewer->DestroyGLWidget();
+   }
 }
 
 //______________________________________________________________________________
 void TEveViewer::PostDock()
 {
-   // Virtual function called before a window is undocked.
+   // Virtual function called after a window is docked.
    // On mac we have to force recreation of gl-context.
 
-#ifdef R__MACOSX
-   fGLViewer->CreateGLWidget();
-#endif
-   TEveWindowFrame::PreUndock();
+   if (fgRecreateGlOnDockOps) {
+      fGLViewer->CreateGLWidget();
+   }
+   TEveWindowFrame::PostDock();
 }
 
 /******************************************************************************/
@@ -253,7 +309,10 @@ ClassImp(TEveViewerList);
 //______________________________________________________________________________
 TEveViewerList::TEveViewerList(const char* n, const char* t) :
    TEveElementList(n, t),
-   fShowTooltip   (kTRUE)
+   fShowTooltip   (kTRUE),
+
+   fBrightness(0),
+  fUseLightColorSet(kFALSE)
 {
    // Constructor.
 
@@ -457,3 +516,29 @@ void TEveViewerList::OnClicked(TObject *obj, UInt_t button, UInt_t state)
       el = 0;
    gEve->GetSelection()->UserPickedElement(el, state & kKeyControlMask);
 }
+
+//______________________________________________________________________________
+void TEveViewerList::SetColorBrightness(Float_t b)
+{
+   // Set color brightness.
+
+   TEveUtil::SetColorBrightness(b, 1);
+}
+
+//______________________________________________________________________________
+void TEveViewerList::SwitchColorSet()
+{
+   // Switch background color.
+
+   fUseLightColorSet = ! fUseLightColorSet;
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {  
+      TGLViewer* glv = ((TEveViewer*)*i)->GetGLViewer();
+      if ( fUseLightColorSet)
+         glv->UseLightColorSet();
+      else 
+         glv->UseDarkColorSet();
+
+      glv->RequestDraw(TGLRnrCtx::kLODHigh);
+   }
+}
diff --git a/graf3d/eve/src/TEveViewerListEditor.cxx b/graf3d/eve/src/TEveViewerListEditor.cxx
new file mode 100644
index 0000000..54c5a6a
--- /dev/null
+++ b/graf3d/eve/src/TEveViewerListEditor.cxx
@@ -0,0 +1,80 @@
+// Authors: Matevz Tadel & Alja Mrak-Tadel: 2006, 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveViewerListEditor.h"
+#include "TEveViewer.h"
+#include "TEveGValuators.h"
+
+//______________________________________________________________________________
+// GUI editor for TEveViewerList.
+//
+
+ClassImp(TEveViewerListEditor);
+
+//______________________________________________________________________________
+TEveViewerListEditor::TEveViewerListEditor(const TGWindow *p, Int_t width, Int_t height,
+             UInt_t options, Pixel_t back) :
+   TGedFrame(p, width, height, options | kVerticalFrame, back),
+   fM(0),
+
+   fBrightness(0),
+   fColorSet(0)
+{
+   // Constructor.
+
+   MakeTitle("TEveViewerList");
+
+   Int_t labelW = 63;
+   fBrightness = new TEveGValuator(this, "Brightness:", 90, 0);
+   fBrightness->SetLabelWidth(labelW);
+   fBrightness->SetNELength(4);
+   fBrightness->Build();
+   fBrightness->SetLimits(-2, 2 ,  41 , TGNumberFormat::kNESRealTwo);
+   fBrightness->Connect("ValueSet(Double_t)", "TEveViewerListEditor", this, "DoBrightness()");
+   AddFrame(fBrightness, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
+
+   fColorSet =  new TGTextButton(this , "Switch ColorSet");
+   fColorSet->Connect("Clicked()", "TEveViewerListEditor", this, "SwitchColorSet()");
+   AddFrame(fColorSet, new TGLayoutHints(kLHintsLeft, 2, 1, 4, 4));
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEveViewerListEditor::SetModel(TObject* obj)
+{
+   // Set model object.
+
+   fM = dynamic_cast<TEveViewerList*>(obj);
+
+   fBrightness->SetValue(fM->GetColorBrightness());
+}
+
+/******************************************************************************/
+
+// Implements callback/slot methods
+
+//______________________________________________________________________________
+void TEveViewerListEditor::DoBrightness()
+{
+   // Slot for brightness.
+
+   fColorSet->SetText(fM->UseLightColorSet()?"DarkColorSet": "Light ColorSet");
+   fM->SetColorBrightness(fBrightness->GetValue());
+}
+
+//______________________________________________________________________________
+void TEveViewerListEditor::SwitchColorSet()
+{
+   // Slot for color set.
+
+   fColorSet->SetText(fM->UseLightColorSet()? "Light ColorSet":"Dark ColorSet");
+   fM->SwitchColorSet();
+}
diff --git a/graf3d/eve/src/TEveWindow.cxx b/graf3d/eve/src/TEveWindow.cxx
index 71fa931..9d3675d 100644
--- a/graf3d/eve/src/TEveWindow.cxx
+++ b/graf3d/eve/src/TEveWindow.cxx
@@ -485,18 +485,32 @@ void TEveCompositeFrameInMainFrame::MainFrameClosed()
 
    if (fEveWindow != 0)
    {
+      TEveWindow* swapCandidate = 0;
       if (fOriginalSlot)
       {
-         TEveWindow::SwapWindows(fEveWindow, fOriginalSlot);
+         // if use pack, show hidden slot
+         TEveCompositeFrameInPack* packFrame = dynamic_cast<TEveCompositeFrameInPack*>(fOriginalSlot->GetEveFrame());
+         if (packFrame) {
+            TGPack* pack = (TGPack*)(packFrame->GetParent());
+            pack->ShowFrame(packFrame);
+         }
+         swapCandidate = fOriginalSlot;
       }
       else if (fOriginalContainer)
       {
-         TEveWindow::SwapWindows(fEveWindow, fOriginalContainer->NewSlot());
+         swapCandidate = fOriginalContainer->NewSlot();
       }
       else if (gEve->GetWindowManager()->HasDefaultContainer())
       {
-         TEveWindow::SwapWindows(fEveWindow, gEve->GetWindowManager()->GetDefaultContainer()->NewSlot());
+         swapCandidate =  gEve->GetWindowManager()->GetDefaultContainer()->NewSlot();
       }
+
+      if( swapCandidate )
+      {
+         TEveWindow::SwapWindows(fEveWindow, swapCandidate);
+         gEve->GetWindowManager()->WindowDocked(fEveWindow );
+      }
+
    }
 
    fMainFrame->DontCallClose();
@@ -730,7 +744,7 @@ void TEveWindow::PreUndock()
 //______________________________________________________________________________
 void TEveWindow::PostDock()
 {
-   // Virtual function called before a window is undocked.
+   // Virtual function called after a window is docked.
 
    for (List_ci i=fChildren.begin(); i!=fChildren.end(); ++i)
    {
@@ -803,12 +817,21 @@ void TEveWindow::UndockWindow()
    if (return_cont && ! return_cont->CanMakeNewSlots())
       return_cont = 0;
 
+   // hide slot if in pack
+   TEveCompositeFrameInPack* packFrame = dynamic_cast<TEveCompositeFrameInPack*>(fEveFrame);
+   if (packFrame) {
+      TGPack* pack = (TGPack*)(packFrame->GetParent());
+      pack->HideFrame(fEveFrame);
+   }
+
    TEveWindowSlot* ew_slot = TEveWindow::CreateWindowMainFrame(0);
 
    TEveWindow::SwapWindows(ew_slot, this);
 
    ((TEveCompositeFrameInMainFrame*) fEveFrame)->
       SetOriginalSlotAndContainer(ew_slot, return_cont);
+
+   gEve->GetWindowManager()->WindowUndocked(this );
 }
 
 //______________________________________________________________________________
@@ -829,6 +852,8 @@ void TEveWindow::UndockWindowDestroySlot()
       SetOriginalSlotAndContainer(0, return_cont);
 
    ew_slot->DestroyWindowAndSlot();
+
+   gEve->GetWindowManager()->WindowUndocked(this);
 }
 
 //______________________________________________________________________________
@@ -1347,12 +1372,20 @@ TEveWindowSlot* TEveWindowPack::NewSlot()
 {
    // Create a new frame-slot at the last position of the pack.
 
+   return NewSlotWithWeight(1.f);
+}
+
+//______________________________________________________________________________
+TEveWindowSlot* TEveWindowPack::NewSlotWithWeight(Float_t w)
+{
+   // Create a new weighted frame-slot at the last position of the pack.
+
    TEveCompositeFrame* slot = new TEveCompositeFrameInPack(fPack, this, fPack);
 
    TEveWindowSlot* ew_slot = TEveWindow::CreateDefaultWindowSlot();
    ew_slot->PopulateEmptyFrame(slot);
 
-   fPack->AddFrame(slot);
+   fPack->AddFrameWithWeight(slot, 0, w);
    slot->MapWindow();
 
    fPack->Layout();
diff --git a/graf3d/eve/src/TEveWindowManager.cxx b/graf3d/eve/src/TEveWindowManager.cxx
index 1eefcf5..1478d6e 100644
--- a/graf3d/eve/src/TEveWindowManager.cxx
+++ b/graf3d/eve/src/TEveWindowManager.cxx
@@ -87,6 +87,22 @@ void TEveWindowManager::DeleteWindow(TEveWindow* window)
 }
 
 //______________________________________________________________________________
+void TEveWindowManager::WindowDocked(TEveWindow* window)
+{
+   // Emit the "WindowDocked(TEveWindow*)" signal.
+
+   Emit("WindowDocked(TEveWindow*)", (Long_t)window);
+}
+
+//______________________________________________________________________________
+void TEveWindowManager::WindowUndocked(TEveWindow* window)
+{
+   // Emit the "WindowUndocked(TEveWindow*)" signal.
+
+   Emit("WindowUndocked(TEveWindow*)", (Long_t)window);
+}
+
+//______________________________________________________________________________
 void TEveWindowManager::WindowSelected(TEveWindow* window)
 {
    // Emit the "WindowSelected(TEveWindow*)" signal.
@@ -97,7 +113,7 @@ void TEveWindowManager::WindowSelected(TEveWindow* window)
 //______________________________________________________________________________
 void TEveWindowManager::WindowDeleted(TEveWindow* window)
 {
-   // Emit the "WindowSelected(TEveWindow*)" signal.
+   // Emit the "WindowDeleted(TEveWindow*)" signal.
 
    Emit("WindowDeleted(TEveWindow*)", (Long_t)window);
 }
diff --git a/graf3d/gl/inc/LinkDef.h b/graf3d/gl/inc/LinkDef.h
index 79a7459..1020123 100644
--- a/graf3d/gl/inc/LinkDef.h
+++ b/graf3d/gl/inc/LinkDef.h
@@ -96,7 +96,8 @@
 #pragma link C++ class TGLSphere;
 #pragma link C++ class TGLText;
 #pragma link C++ class TGLAxis;
-#pragma link C++ class TGLAxisPainter;
+#pragma link C++ class TGLAxisPainter+;
+#pragma link C++ class TGLAxisPainterBox+;
 
 #pragma link C++ class TGLSelectionBuffer;
 #pragma link C++ class TGLPlotCoordinates;
@@ -117,8 +118,9 @@
 #pragma link C++ class TGLContextIdentity;
 #pragma link C++ class TGLFormat;
 #pragma link C++ class TGLAdapter;
-#pragma link C++ class TF2GL;
-#pragma link C++ class TH2GL;
+#pragma link C++ class TF2GL+;
+#pragma link C++ class TH2GL+;
+#pragma link C++ class TH3GL+;
 #pragma link C++ class TGLParametricEquationGL;
 #pragma link C++ class TGLEmbeddedViewer;
 #pragma link C++ class TGLEventHandler;
diff --git a/graf3d/gl/inc/TF2GL.h b/graf3d/gl/inc/TF2GL.h
index 733b411f..12fa141 100644
--- a/graf3d/gl/inc/TF2GL.h
+++ b/graf3d/gl/inc/TF2GL.h
@@ -47,7 +47,7 @@ public:
    // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
    // virtual void ProcessSelection(UInt_t* ptr, TGLViewer*, TGLScene*);
 
-   ClassDef(TF2GL, 0) // GL renderer for TF2 and TF3.
+   ClassDef(TF2GL, 0); // GL renderer for TF2 and TF3.
 };
 
 #endif
diff --git a/graf3d/gl/inc/TGLAxisPainter.h b/graf3d/gl/inc/TGLAxisPainter.h
index 85dd79f..25677f8 100644
--- a/graf3d/gl/inc/TGLAxisPainter.h
+++ b/graf3d/gl/inc/TGLAxisPainter.h
@@ -17,8 +17,14 @@
 
 class TAttAxis;
 class TAxis;
+class TH1;
 class TGLRnrCtx;
 
+
+//==============================================================================
+// TGLAxisPainter
+//==============================================================================
+
 class TGLAxisPainter
 {
 public:
@@ -47,7 +53,7 @@ private:
 
 protected:
    TAttAxis        *fAttAxis;    // Model.
-   TGLFont::EMode   fFontMode;   // Later in AttAxis
+   TGLFont::EMode   fFontMode;   // To be put into TAttAxis
    LabVec_t         fLabVec;     // List of Labels position-value pairs
    TMVec_t          fTMVec;      // List of tick-mark position-value pairs
 
@@ -108,7 +114,7 @@ public:
    void SetTextFormat(Double_t min, Double_t max, Double_t binWidth);
 
    // Renderers.
-   void RnrText( const char* txt, const TGLVector3 &pos, const TGLFont::ETextAlign_e align, const TGLFont &font) const;
+   void RnrText (const char* txt, const TGLVector3 &pos, const TGLFont::ETextAlign_e align, const TGLFont &font) const;
    void RnrTitle(const char* title, TGLVector3 &pos, TGLFont::ETextAlign_e align) const;
    void RnrLabels() const;
    void RnrLines() const;
@@ -118,4 +124,27 @@ public:
    ClassDef(TGLAxisPainter, 0); // GL axis painter.
 };
 
+
+//==============================================================================
+// TGLAxisPainterBox
+//==============================================================================
+
+class TGLAxisPainterBox : public TGLAxisPainter
+{
+protected:
+   TGLVector3          fAxisTitlePos[3];
+   TAxis*              fAxis[3];
+
+public:
+   TGLAxisPainterBox();
+   virtual ~TGLAxisPainterBox();
+
+   void SetAxis3DTitlePos(TGLRnrCtx &rnrCtx);
+   void DrawAxis3D(TGLRnrCtx &rnrCtx);
+
+   void PlotStandard(TGLRnrCtx &rnrCtx, const TH1* histo, const TGLBoundingBox& bbox);
+
+   ClassDef(TGLAxisPainterBox, 0); // Painter of GL axes for a 3D box.
+};
+
 #endif
diff --git a/graf3d/gl/inc/TGLClip.h b/graf3d/gl/inc/TGLClip.h
index 82c513e..3da512a 100644
--- a/graf3d/gl/inc/TGLClip.h
+++ b/graf3d/gl/inc/TGLClip.h
@@ -34,9 +34,12 @@ public:
    enum EMode { kOutside, // Clip away what's outside
                 kInside   // Clip away what's inside
    };
-private:
+
+protected:
    EMode  fMode;
    UInt_t fTimeStamp;
+   Bool_t fValid;
+
 public:
    TGLClip(const TGLLogicalShape & logical, const TGLMatrix & transform, const float color[4]);
    virtual ~TGLClip();
@@ -51,6 +54,9 @@ public:
    UInt_t TimeStamp() const { return fTimeStamp; }
    void   IncTimeStamp()    { ++fTimeStamp; }
 
+   Bool_t IsValid() const { return fValid;   }
+   void   Invalidate()    { fValid = kFALSE; }
+
    virtual void Draw(TGLRnrCtx & rnrCtx) const;
    virtual void PlaneSet(TGLPlaneSet_t & set) const = 0;
 
@@ -130,6 +136,8 @@ protected:
    Bool_t                 fShowManip;
    TGLManipSet           *fManip;
 
+   TGLBoundingBox         fLastBBox;
+
 public:
    TGLClipSet();
    virtual ~TGLClipSet();
@@ -148,6 +156,11 @@ public:
 
    // Clipping
    void  SetupClips(const TGLBoundingBox& sceneBBox);
+   void  SetupCurrentClip(const TGLBoundingBox& sceneBBox);
+   void  SetupCurrentClipIfInvalid(const TGLBoundingBox& sceneBBox);
+
+   void  InvalidateClips();
+   void  InvalidateCurrentClip();
 
    void  GetClipState(EClipType type, Double_t data[6]) const;
    void  SetClipState(EClipType type, const Double_t data[6]);
diff --git a/graf3d/gl/inc/TGLFaceSet.h b/graf3d/gl/inc/TGLFaceSet.h
index 627e803..95644aa 100644
--- a/graf3d/gl/inc/TGLFaceSet.h
+++ b/graf3d/gl/inc/TGLFaceSet.h
@@ -37,6 +37,12 @@ public:
 
    void SetFromMesh(const RootCsg::TBaseMesh *m);
 
+   std::vector<Double_t>& GetVertices() { return fVertices; }
+   std::vector<Double_t>& GetNormals()  { return fNormals;  }
+   std::vector<Int_t>&    GetPolyDesc() { return fPolyDesc; }
+   UInt_t                 GetNbPols()   { return fNbPols;   }
+
+
 private:
    void GLDrawPolys()const;
    Int_t CheckPoints(const Int_t *source, Int_t *dest)const;
diff --git a/graf3d/gl/inc/TGLFontManager.h b/graf3d/gl/inc/TGLFontManager.h
index df524bf..34c636d 100644
--- a/graf3d/gl/inc/TGLFontManager.h
+++ b/graf3d/gl/inc/TGLFontManager.h
@@ -143,7 +143,8 @@ public:
    static TObjArray*        GetFontFileArray();
    static FontSizeVec_t*    GetFontSizeArray();
 
-   static Int_t             GetFontSize(Float_t ds, Int_t min = -1, Int_t max = -1);
+   static Int_t             GetFontSize(Float_t ds);
+   static Int_t             GetFontSize(Float_t ds, Int_t min, Int_t max);
    static const char*       GetFontNameFromId(Int_t);
 
    void   ClearFontTrash();
diff --git a/graf3d/gl/inc/TGLOverlay.h b/graf3d/gl/inc/TGLOverlay.h
index 577cc97..77b3bc1 100644
--- a/graf3d/gl/inc/TGLOverlay.h
+++ b/graf3d/gl/inc/TGLOverlay.h
@@ -21,12 +21,18 @@ class TGLOvlSelectRecord;
 
 class TGLOverlayElement
 {
+public:
+   enum ERole { kUser, kViewer, kAnnotation, kAll };
+
 private:
    TGLOverlayElement(const TGLOverlayElement&);            // Not implemented
    TGLOverlayElement& operator=(const TGLOverlayElement&); // Not implemented
 
+protected:
+   ERole   fRole;
+    
 public:
-   TGLOverlayElement() {}
+   TGLOverlayElement(ERole r = kUser):fRole(r) {}
    virtual ~TGLOverlayElement() {}
 
    virtual Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
@@ -37,6 +43,9 @@ public:
 
    virtual void Render(TGLRnrCtx& rnrCtx) = 0;
 
+   ERole   GetRole() const { return fRole; }
+   void    SetRole(ERole r) { fRole = r; }
+
    ClassDef(TGLOverlayElement, 0) // Base class for GL overlay elements.
 };
 
diff --git a/graf3d/gl/inc/TGLParametricEquationGL.h b/graf3d/gl/inc/TGLParametricEquationGL.h
index 418f842..42c11c4 100644
--- a/graf3d/gl/inc/TGLParametricEquationGL.h
+++ b/graf3d/gl/inc/TGLParametricEquationGL.h
@@ -48,7 +48,7 @@ public:
    // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
    // virtual void ProcessSelection(UInt_t* ptr, TGLViewer*, TGLScene*);
 
-   ClassDef(TGLParametricEquationGL, 0) // GL renderer for TGLParametricEquation
+   ClassDef(TGLParametricEquationGL, 0); // GL renderer for TGLParametricEquation
 };
 
 #endif
diff --git a/graf3d/gl/inc/TGLRnrCtx.h b/graf3d/gl/inc/TGLRnrCtx.h
index 87785e1..0e8e932 100644
--- a/graf3d/gl/inc/TGLRnrCtx.h
+++ b/graf3d/gl/inc/TGLRnrCtx.h
@@ -31,6 +31,11 @@ class TGLRect;
 
 class GLUquadric;
 
+namespace std
+{
+   template<typename _Tp> class allocator;
+   template<typename _Tp, typename _Alc> class list;
+}
 
 /**************************************************************************/
 // TGLRnrCtx
@@ -80,6 +85,8 @@ private:
    TGLRnrCtx(const TGLRnrCtx&);            // Not implemented
    TGLRnrCtx& operator=(const TGLRnrCtx&); // Not implemented
 
+   typedef std::list<TGLColorSet*, std::allocator<TGLColorSet*> > lpTGLColorSet_t;
+
 protected:
    TGLViewerBase  *fViewer;
    TGLCamera      *fCamera;
@@ -113,7 +120,7 @@ protected:
    TGLRect        *fPickRectangle;
    TGLSelectBuffer*fSelectBuffer;
 
-   void           *fColorSetStack;
+   lpTGLColorSet_t*fColorSetStack;
 
    UInt_t          fEventKeySym;
 
@@ -209,6 +216,8 @@ public:
    TGLColorSet* ChangeBaseColorSet(TGLColorSet* set);
    TGLColorSet* GetBaseColorSet();
 
+   void         ColorOrForeground(Color_t col);
+
    UInt_t GetEventKeySym()   const { return fEventKeySym; }
    void   SetEventKeySym(UInt_t k) { fEventKeySym = k; }
 
diff --git a/graf3d/gl/inc/TGLUtil.h b/graf3d/gl/inc/TGLUtil.h
index 4a1a7c5..42ade38 100644
--- a/graf3d/gl/inc/TGLUtil.h
+++ b/graf3d/gl/inc/TGLUtil.h
@@ -141,7 +141,7 @@ public:
 
    void Dump() const;
 
-   ClassDef(TGLVertex3,0) // GL 3 component vertex helper/wrapper class
+   ClassDef(TGLVertex3,0); // GL 3 component vertex helper/wrapper class
 };
 
 //______________________________________________________________________________
@@ -267,7 +267,7 @@ public:
    Double_t Mag() const;
    void     Normalise();
 
-   ClassDef(TGLVector3,0) // GL 3 component vector helper/wrapper class
+   ClassDef(TGLVector3,0); // GL 3 component vector helper/wrapper class
 };
 
 // Inline for TGLVertex3 requiring full TGLVector definition
@@ -415,7 +415,7 @@ public:
    // Debug
    void Draw() const;
 
-   ClassDef(TGLLine3,0) // GL line wrapper class
+   ClassDef(TGLLine3,0); // GL line wrapper class
 };
 
 //////////////////////////////////////////////////////////////////////////
@@ -471,7 +471,7 @@ public:
    Double_t Aspect() const;
    EOverlap Overlap(const TGLRect & other) const;
 
-   ClassDef(TGLRect,0) // GL rect helper/wrapper class
+   ClassDef(TGLRect,0); // GL rect helper/wrapper class
 };
 
 //______________________________________________________________________________
@@ -576,7 +576,7 @@ public:
    TGLPlane(Double_t eq[4]);
    TGLPlane(const TGLVector3 & norm, const TGLVertex3 & point);
    TGLPlane(const TGLVertex3 & p1, const TGLVertex3 & p2, const TGLVertex3 & p3);
-   virtual ~TGLPlane(); // ClassDef introduces virtual fns
+   virtual ~TGLPlane();
 
    // Manipulators
    void Set(const TGLPlane & other);
@@ -602,104 +602,19 @@ public:
 
    void Dump() const;
 
-   ClassDef(TGLPlane,0) // GL plane helper/wrapper class
+   ClassDef(TGLPlane,0); // GL plane helper/wrapper class
 };
 
 typedef std::vector<TGLPlane>                 TGLPlaneSet_t;
 typedef std::vector<TGLPlane>::iterator       TGLPlaneSet_i;
 typedef std::vector<TGLPlane>::const_iterator TGLPlaneSet_ci;
 
-//______________________________________________________________________________
-inline void TGLPlane::Set(const TGLPlane & other)
-{
-   fVals[0] = other.fVals[0];
-   fVals[1] = other.fVals[1];
-   fVals[2] = other.fVals[2];
-   fVals[3] = other.fVals[3];
-}
-
-//______________________________________________________________________________
-inline void TGLPlane::Set(Double_t a, Double_t b, Double_t c, Double_t d)
-{
-   fVals[0] = a;
-   fVals[1] = b;
-   fVals[2] = c;
-   fVals[3] = d;
-   Normalise();
-}
-
-//______________________________________________________________________________
-inline void TGLPlane::Set(Double_t eq[4])
-{
-   fVals[0] = eq[0];
-   fVals[1] = eq[1];
-   fVals[2] = eq[2];
-   fVals[3] = eq[3];
-   Normalise();
-}
-
-//______________________________________________________________________________
-inline void TGLPlane::Set(const TGLVector3 & norm, const TGLVertex3 & point)
-{
-   // Set plane from a normal vector and in-plane point pair
-   fVals[0] = norm[0];
-   fVals[1] = norm[1];
-   fVals[2] = norm[2];
-   fVals[3] = -(fVals[0]*point[0] + fVals[1]*point[1] + fVals[2]*point[2]);
-   Normalise();
-}
-
-//______________________________________________________________________________
-inline void TGLPlane::Set(const TGLVertex3 & p1, const TGLVertex3 & p2, const TGLVertex3 & p3)
-{
-   TGLVector3 norm = Cross(p2 - p1, p3 - p1);
-   Set(norm, p2);
-}
-
-//______________________________________________________________________________
-inline void TGLPlane::Negate()
-{
-   fVals[0] = -fVals[0];
-   fVals[1] = -fVals[1];
-   fVals[2] = -fVals[2];
-   fVals[3] = -fVals[3];
-}
-
-//______________________________________________________________________________
-inline void TGLPlane::Normalise()
-{
-   Double_t mag = sqrt( fVals[0]*fVals[0] + fVals[1]*fVals[1] + fVals[2]*fVals[2] );
-
-   if ( mag == 0.0 ) {
-      Error("TGLPlane::Normalise", "trying to normalise plane with zero magnitude normal");
-      return;
-   }
-
-   fVals[0] /= mag;
-   fVals[1] /= mag;
-   fVals[2] /= mag;
-   fVals[3] /= mag;
-}
-
-//______________________________________________________________________________
-inline Double_t TGLPlane::DistanceTo(const TGLVertex3 & vertex) const
-{
-   return (fVals[0]*vertex[0] + fVals[1]*vertex[1] + fVals[2]*vertex[2] + fVals[3]);
-}
-
-//______________________________________________________________________________
-inline TGLVertex3 TGLPlane::NearestOn(const TGLVertex3 & point) const
-{
-   TGLVector3 o = Norm() * (Dot(Norm(), TGLVector3(point[0], point[1], point[2])) + D() / Dot(Norm(), Norm()));
-   TGLVertex3 v = point - o;
-   return v;
-}
-
 // Some free functions for planes
 std::pair<Bool_t, TGLLine3>   Intersection(const TGLPlane & p1, const TGLPlane & p2);
 std::pair<Bool_t, TGLVertex3> Intersection(const TGLPlane & p1, const TGLPlane & p2, const TGLPlane & p3);
 std::pair<Bool_t, TGLVertex3> Intersection(const TGLPlane & plane, const TGLLine3 & line, Bool_t extend);
 
+
 //////////////////////////////////////////////////////////////////////////
 //                                                                      //
 // TGLMatrix                                                            //
@@ -733,7 +648,7 @@ public:
    TGLMatrix(const TGLVertex3 & origin, const TGLVector3 & zAxis);
    TGLMatrix(const Double_t vals[16]);
    TGLMatrix(const TGLMatrix & other);
-   virtual ~TGLMatrix(); // ClassDef introduces virtual fns
+   virtual ~TGLMatrix();
 
    // Operators
    TGLMatrix & operator =(const TGLMatrix & rhs);
@@ -787,7 +702,7 @@ public:
 
    void Dump() const;
 
-   ClassDef(TGLMatrix,0) // GL matrix helper/wrapper class
+   ClassDef(TGLMatrix,0); // GL matrix helper/wrapper class
 };
 
 //______________________________________________________________________________
@@ -897,13 +812,16 @@ inline void TGLMatrix::GetBaseVec(Int_t b, Double_t* x) const
 // TGLColor
 //
 // Encapsulate color in preferred GL format - UChar_t RGBA array.
+// Color index is also cached for easier interfacing with the
+// traditional ROOT graphics.
 //
 //////////////////////////////////////////////////////////////////////////
 
 class TGLColor
 {
 protected:
-   UChar_t fRGBA[4];
+   UChar_t         fRGBA[4];
+   mutable Short_t fIndex;
 
 public:
    TGLColor();
@@ -1113,7 +1031,7 @@ public:
                           const TGLVertex3 & pos,
                                 Bool_t       center = kFALSE);
 
-   ClassDef(TGLUtil,0) // Wrapper class for misc GL pieces
+   ClassDef(TGLUtil,0); // Wrapper class for misc GL pieces
 };
 
 /**************************************************************************/
@@ -1192,7 +1110,7 @@ private:
    TGLSelectionBuffer(const TGLSelectionBuffer &);
    TGLSelectionBuffer &operator = (const TGLSelectionBuffer &);
 
-   ClassDef(TGLSelectionBuffer, 0)//Holds color buffer content for selection
+   ClassDef(TGLSelectionBuffer, 0); //Holds color buffer content for selection
 };
 
 template<class T>
diff --git a/graf3d/gl/inc/TGLViewer.h b/graf3d/gl/inc/TGLViewer.h
index 9ee562c..338efbb 100644
--- a/graf3d/gl/inc/TGLViewer.h
+++ b/graf3d/gl/inc/TGLViewer.h
@@ -89,6 +89,7 @@ protected:
    TGLLightSet         *fLightSet;             //!
    // Clipping
    TGLClipSet          *fClipSet;              //!
+   Bool_t               fClipAutoUpdate;       //!
    // Selected physical
    TGLSelectRecord      fCurrentSelRec;        //! select record in use as selected
    TGLSelectRecord      fSelRec;               //! select record from last select (should go to context)
@@ -225,6 +226,8 @@ public:
 
    TGLLightSet* GetLightSet() const { return fLightSet; }
    TGLClipSet * GetClipSet()  const { return fClipSet; }
+   Bool_t GetClipAutoUpdate() const   { return fClipAutoUpdate; }
+   void   SetClipAutoUpdate(Bool_t x) { fClipAutoUpdate = x; }
 
    // External GUI component interface
    TGLCamera & CurrentCamera() const { return *fCurrentCamera; }
diff --git a/graf3d/gl/inc/TGLViewerBase.h b/graf3d/gl/inc/TGLViewerBase.h
index 9e5f015..01159b1 100644
--- a/graf3d/gl/inc/TGLViewerBase.h
+++ b/graf3d/gl/inc/TGLViewerBase.h
@@ -16,6 +16,7 @@
 
 #include "TGLLockable.h"
 #include <TGLBoundingBox.h>
+#include "TGLOverlay.h"
 
 #include <list>
 #include <vector>
@@ -91,6 +92,7 @@ public:
    virtual void AddOverlayElement(TGLOverlayElement* el);
    virtual void RemoveOverlayElement(TGLOverlayElement* el);
    virtual void DeleteOverlayAnnotations();
+   virtual void DeleteOverlayElements(TGLOverlayElement::ERole r);
 
    TGLClip* Clip()         const { return fClip; }
    void     SetClip(TGLClip *p)  { fClip = p;    }
diff --git a/graf3d/gl/inc/TH2GL.h b/graf3d/gl/inc/TH2GL.h
index b5e6fd1..84cb3d8 100644
--- a/graf3d/gl/inc/TH2GL.h
+++ b/graf3d/gl/inc/TH2GL.h
@@ -13,9 +13,12 @@
 #define ROOT_TH2GL
 
 #include <TGLObject.h>
+#include <TGLUtil.h>
+#include <TGLAxisPainter.h>
 
 class TGLRnrCtx;
-class TH1;
+class TH2;
+class TAxis;
 
 #include "TGLPlotPainter.h"
 
@@ -26,7 +29,7 @@ private:
    TH2GL& operator=(const TH2GL&); // Not implemented
 
 protected:
-   TH1                *fM; // fModel dynamic-casted to TH2
+   TH2                *fM; // Model object dynamic-casted to TH2.
 
    TGLPlotPainter     *fPlotPainter;
    TGLPlotCoordinates  fCoord;
@@ -45,7 +48,7 @@ public:
    // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
    // virtual void ProcessSelection(UInt_t* ptr, TGLViewer*, TGLScene*);
 
-   ClassDef(TH2GL, 0) // GL renderer for TH2 and TH3.
+   ClassDef(TH2GL, 0); // GL renderer for TH2 and TH3.
 }; // endclass TH2GL
 
 #endif
diff --git a/graf3d/gl/inc/TH3GL.h b/graf3d/gl/inc/TH3GL.h
new file mode 100644
index 0000000..bc3c181
--- /dev/null
+++ b/graf3d/gl/inc/TH3GL.h
@@ -0,0 +1,53 @@
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TH3GL
+#define ROOT_TH3GL
+
+#include "TGLObject.h"
+#include <TGLUtil.h>
+#include <TGLAxisPainter.h>
+#include "TGLPlotPainter.h"
+
+class TGLRnrCtx;
+class TH3;
+class TAxis;
+
+class TH3;
+
+class TH3GL : public TGLObject
+{
+private:
+   TH3GL(const TH3GL&);            // Not implemented
+   TH3GL& operator=(const TH3GL&); // Not implemented
+
+protected:
+   TH3                *fM;  // Model object dynamic-casted to TH2.
+
+   TGLPlotPainter     *fPlotPainter;
+   TGLPlotCoordinates  fCoord;
+
+public:
+   TH3GL();
+   virtual ~TH3GL();
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void DirectDraw(TGLRnrCtx & rnrCtx) const;
+
+   // To support two-level selection
+   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+
+   ClassDef(TH3GL, 0); // GL renderer class for TH3.
+};
+
+#endif
diff --git a/graf3d/gl/src/TF2GL.cxx b/graf3d/gl/src/TF2GL.cxx
index 6305f75..25579f2 100644
--- a/graf3d/gl/src/TF2GL.cxx
+++ b/graf3d/gl/src/TF2GL.cxx
@@ -18,7 +18,7 @@
 
 #include "TGLSurfacePainter.h"
 #include "TGLTF3Painter.h"
-#include "TGLAxis.h"
+#include "TGLAxisPainter.h"
 
 #include "TGLRnrCtx.h"
 
@@ -29,8 +29,9 @@
 // GL renderer for TF2.
 // TGLPlotPainter is used internally.
 
-ClassImp(TF2GL)
+ClassImp(TF2GL);
 
+//______________________________________________________________________________
 TF2GL::TF2GL() : TGLObject(), fM(0), fH(0)
 {
    // Constructor.
@@ -38,6 +39,7 @@ TF2GL::TF2GL() : TGLObject(), fM(0), fH(0)
    fDLCache = kFALSE; // Disable display list.
 }
 
+//______________________________________________________________________________
 TF2GL::~TF2GL()
 {
    // Destructor.
@@ -48,14 +50,19 @@ TF2GL::~TF2GL()
 
 /**************************************************************************/
 
+//______________________________________________________________________________
 Bool_t TF2GL::SetModel(TObject* obj, const Option_t* opt)
 {
    // Set model object.
 
+   TString option(opt);
+   option.ToLower();
+
    if(SetModelCheckClass(obj, TF2::Class()))
    {
       fM = dynamic_cast<TF2*>(obj);
       fH = (TH2*) fM->CreateHistogram();
+      fH->GetZaxis()->SetLimits(fH->GetMinimum(), fH->GetMaximum());
 
       if (dynamic_cast<TF3*>(fM))
          fPlotPainter = new TGLTF3Painter((TF3*)fM, fH, 0, &fCoord);
@@ -67,8 +74,6 @@ Bool_t TF2GL::SetModel(TObject* obj, const Option_t* opt)
       fCoord.SetYLog(gPad->GetLogy());
       fCoord.SetZLog(gPad->GetLogz());
 
-      TString option(opt);
-
       if (option.Index("sph") != kNPOS)
          fCoord.SetCoordType(kGLSpherical);
       else if (option.Index("pol") != kNPOS)
@@ -84,6 +89,7 @@ Bool_t TF2GL::SetModel(TObject* obj, const Option_t* opt)
    return kFALSE;
 }
 
+//______________________________________________________________________________
 void TF2GL::SetBBox()
 {
    // Setup bounding-box.
@@ -91,9 +97,8 @@ void TF2GL::SetBBox()
    fBoundingBox.Set(fPlotPainter->RefBackBox().Get3DBox());
 }
 
-/**************************************************************************/
-
-void TF2GL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
+//______________________________________________________________________________
+void TF2GL::DirectDraw(TGLRnrCtx & rnrCtx) const
 {
    // Render the object.
 
@@ -108,17 +113,10 @@ void TF2GL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
    fPlotPainter->DrawPlot();
 
    glDisable(GL_CULL_FACE);
-
-   TGLAxis ap;
-   const Rgl::Range_t & xr = fCoord.GetXRange();
-   ap.PaintGLAxis(fBoundingBox[0].CArr(), fBoundingBox[1].CArr(),
-                  xr.first, xr.second, 205);
-   const Rgl::Range_t & yr = fCoord.GetXRange();
-   ap.PaintGLAxis(fBoundingBox[0].CArr(), fBoundingBox[3].CArr(),
-                  yr.first, yr.second, 205);
-   const Rgl::Range_t & zr = fCoord.GetXRange();
-   ap.PaintGLAxis(fBoundingBox[0].CArr(), fBoundingBox[4].CArr(),
-                  zr.first, zr.second, 205);
-
    glPopAttrib();
+
+   // Axes
+   TGLAxisPainterBox axe_painter;
+   axe_painter.SetFontMode(TGLFont::kPixmap);
+   axe_painter.PlotStandard(rnrCtx, fH, fBoundingBox);
 }
diff --git a/graf3d/gl/src/TGLAnnotation.cxx b/graf3d/gl/src/TGLAnnotation.cxx
index 2ed9b18..0a5bbbc 100644
--- a/graf3d/gl/src/TGLAnnotation.cxx
+++ b/graf3d/gl/src/TGLAnnotation.cxx
@@ -37,7 +37,7 @@ ClassImp(TGLAnnotation);
 
 //______________________________________________________________________________
 TGLAnnotation::TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref) :
-   TGLOverlayElement(),
+   TGLOverlayElement(TGLOverlayElement::kAnnotation),
    fMainFrame(0), fTextEdit(0),
    fParent(0),
    fText(text),
diff --git a/graf3d/gl/src/TGLAxisPainter.cxx b/graf3d/gl/src/TGLAxisPainter.cxx
index 3e5280b..cc17c2e 100644
--- a/graf3d/gl/src/TGLAxisPainter.cxx
+++ b/graf3d/gl/src/TGLAxisPainter.cxx
@@ -19,16 +19,20 @@
 
 #include "TAttAxis.h"
 #include "TAxis.h"
+#include "TH1.h"
 #include "THLimitsFinder.h"
 
 #include "TMath.h"
 #include "TPRegexp.h"
 
+//==============================================================================
+// TGLAxisPainterBox
+//==============================================================================
+
 //______________________________________________________________________________
 //
 // Utility class to paint axis in GL.
 
-
 ClassImp(TGLAxisPainter);
 
 //______________________________________________________________________________
@@ -243,7 +247,7 @@ void TGLAxisPainter::SetLabelFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t
 {
    // Set label font derived from TAttAxis.
 
-   fLabelPixelFontSize = TGLFontManager::GetFontSize(fontSize, 10, 128);
+   fLabelPixelFontSize = TGLFontManager::GetFontSize(fontSize);
    fLabel3DFontSize = size3d;
    if (fLabelFont.GetMode() == TGLFont::kUndef)
    {
@@ -283,11 +287,12 @@ void TGLAxisPainter::RnrLabels() const
 }
 
 //______________________________________________________________________________
-void TGLAxisPainter::SetTitleFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t fontSize, Double_t size3d)
+void TGLAxisPainter::SetTitleFont(TGLRnrCtx &rnrCtx, const char* fontName,
+                                  Int_t fontSize, Double_t size3d)
 {
    // Set title font derived from TAttAxis.
 
-   fTitlePixelFontSize = TGLFontManager::GetFontSize(fontSize, 10, 128);
+   fTitlePixelFontSize = TGLFontManager::GetFontSize(fontSize);
    fTitle3DFontSize = size3d;
 
    if (fTitleFont.GetMode() == TGLFont::kUndef)
@@ -428,35 +433,32 @@ void TGLAxisPainter::PaintAxis(TGLRnrCtx &rnrCtx, TAxis* ax)
    // Set font.
 
    // First projected axis length needed if use realtive font size.
-   const char* labFontName = TGLFontManager::GetFontNameFromId(fAttAxis->GetLabelFont());
+   const char* labFontName   = TGLFontManager::GetFontNameFromId(fAttAxis->GetLabelFont());
    const char* titleFontName = TGLFontManager::GetFontNameFromId(fAttAxis->GetTitleFont());
 
    if (fFontMode == TGLFont::kPolygon || fFontMode == TGLFont::kTexture)
    {
       // get sensible pixel resolution relative to projected axis length
       // in pixmap for this is given explicitly
-      Double_t len = 0;
-      GLdouble mm[16];
-      GLdouble pm[16];
+      GLdouble mm[16], pm[16];
       GLint    vp[4];
       glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
       glGetDoublev(GL_PROJECTION_MATRIX, pm);
       glGetIntegerv(GL_VIEWPORT, vp);
 
-      GLdouble dn[3];
-      GLdouble up[3];
+      GLdouble dn[3], up[3];
       gluProject(fDir.X()*min, fDir.Y()*min, fDir.Z()*min, mm, pm, vp, &dn[0], &dn[1], &dn[2]);
       gluProject(fDir.X()*max, fDir.Y()*max, fDir.Z()*max, mm, pm, vp, &up[0], &up[1], &up[2]);
-      len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0])
-                        + (up[1] - dn[1]) * (up[1] - dn[1])
-                        + (up[2] - dn[2]) * (up[2] - dn[2]));
+      Double_t len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0]) +
+                                 (up[1] - dn[1]) * (up[1] - dn[1]) +
+                                 (up[2] - dn[2]) * (up[2] - dn[2]));
 
       fLabelPixelFontSize = TMath::CeilNint(len*fAttAxis->GetLabelSize());
       fTitlePixelFontSize = TMath::CeilNint(len*fAttAxis->GetTitleSize());
    }
 
-   SetLabelFont(rnrCtx, labFontName, fLabelPixelFontSize,   (max -min)*fAttAxis->GetLabelSize());
-   SetTitleFont(rnrCtx, titleFontName, fTitlePixelFontSize, (max -min)*fAttAxis->GetTitleSize());
+   SetLabelFont(rnrCtx, labFontName,   fLabelPixelFontSize, (max - min)*fAttAxis->GetLabelSize());
+   SetTitleFont(rnrCtx, titleFontName, fTitlePixelFontSize, (max - min)*fAttAxis->GetTitleSize());
 
    //______________________________________________________________________________
    // Draw.
@@ -468,3 +470,206 @@ void TGLAxisPainter::PaintAxis(TGLRnrCtx &rnrCtx, TAxis* ax)
    if (ax->GetTitle())
       RnrTitle(ax->GetTitle(), fTitlePos, fLabelAlign);
 }
+
+
+//==============================================================================
+// TGLAxisPainterBox
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Painter class for axes encompassing a 3D box.
+
+ClassImp(TGLAxisPainterBox);
+
+//______________________________________________________________________________
+TGLAxisPainterBox::TGLAxisPainterBox() :
+   TGLAxisPainter()
+{
+   // Constructor.
+
+   fAxis[0] = fAxis[1] = fAxis[2] = 0;
+}
+
+//______________________________________________________________________________
+TGLAxisPainterBox::~TGLAxisPainterBox()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TGLAxisPainterBox::SetAxis3DTitlePos(TGLRnrCtx &rnrCtx)
+{
+   // Get position of axes and titles from projected corners.
+
+   Double_t x0 =  fAxis[0]->GetXmin();
+   Double_t x1 =  fAxis[0]->GetXmax();
+
+   Double_t y0 =  fAxis[1]->GetXmin();
+   Double_t y1 =  fAxis[1]->GetXmax();
+ 
+   Double_t z0 =  fAxis[2]->GetXmin();
+   Double_t z1 =  fAxis[2]->GetXmax();
+
+   // project corner points
+   const GLdouble *pm = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
+   GLdouble mm[16];
+   GLint    vp[4];
+   glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
+   glGetIntegerv(GL_VIEWPORT, vp);
+   GLdouble projX[4], projY[4], projZ[4];
+   GLdouble cornerX[4];
+   GLdouble cornerY[4];
+   cornerX[0] = x0; cornerY[0] = y0;
+   cornerX[1] = x1; cornerY[1] = y0;
+   cornerX[2] = x1; cornerY[2] = y1;
+   cornerX[3] = x0; cornerY[3] = y1;
+   gluProject(cornerX[0], cornerY[0], z0, mm, pm, vp, &projX[0], &projY[0], &projZ[0]);
+   gluProject(cornerX[1], cornerY[1], z0, mm, pm, vp, &projX[1], &projY[1], &projZ[1]);
+   gluProject(cornerX[2], cornerY[2], z0, mm, pm, vp, &projX[2], &projY[2], &projZ[2]);
+   gluProject(cornerX[3], cornerY[3], z0, mm, pm, vp, &projX[3], &projY[3], &projZ[3]);
+
+
+   // Z axis location (left most corner)
+   //
+   Int_t idxLeft = 0;
+   Float_t xt = projX[0];
+   for (Int_t i = 1; i < 4; ++i) {
+      if (projX[i] < xt) {
+         xt  = projX[i];
+         idxLeft = i;
+      }
+   }
+   fAxisTitlePos[2].Set(cornerX[idxLeft], cornerY[idxLeft], z1);
+
+
+   // XY axis location (closest to eye) first
+   //
+   Float_t zt = 1.f;
+   Float_t zMin = 0.f;
+   Int_t idxFront = 0;
+   for (Int_t i = 0; i < 4; ++i) {
+      if (projZ[i] < zt) {
+         zt  = projZ[i];
+         idxFront = i;
+      }
+      if (projZ[i] > zMin) zMin = projZ[i];
+   }
+   Int_t xyIdx = idxFront;
+   if (zMin - zt < 1e-2) xyIdx = 0; // avoid flipping in front view
+
+
+   switch (xyIdx) {
+      case 0:
+         fAxisTitlePos[0].Set(x1, y0, z0);
+         fAxisTitlePos[1].Set(x0, y1, z0);
+         break;
+      case 1:
+         fAxisTitlePos[0].Set(x1, y0, z0);
+         fAxisTitlePos[1].Set(x0, y1, z0);
+         break;
+      case 2:
+         fAxisTitlePos[0].Set(x0, y1, z0);
+         fAxisTitlePos[1].Set(x1, y0, z0);
+         break;
+      case 3:
+         fAxisTitlePos[0].Set(x1, y1, z0);
+         fAxisTitlePos[1].Set(x0, y0, z0);
+         break;
+   }
+}
+
+//______________________________________________________________________________
+void TGLAxisPainterBox::DrawAxis3D(TGLRnrCtx &rnrCtx)
+{
+   // Draw XYZ axis with bitmap font.
+
+   // set font size first depending on size of projected axis
+   TGLMatrix mm;
+   GLdouble pm[16];
+   GLint    vp[4];
+   glGetDoublev(GL_MODELVIEW_MATRIX, mm.Arr());
+   glGetDoublev(GL_PROJECTION_MATRIX, pm);
+   glGetIntegerv(GL_VIEWPORT, vp);
+
+   // determine bitmap font size from lenght of projected vertical
+   GLdouble dn[3];
+   GLdouble up[3];
+   gluProject(fAxisTitlePos[2].X(), fAxisTitlePos[2].Y(), fAxis[2]->GetXmin(), mm.Arr(), pm, vp, &dn[0], &dn[1], &dn[2]);
+   gluProject(fAxisTitlePos[2].X(), fAxisTitlePos[2].Y(), fAxis[2]->GetXmax(), mm.Arr(), pm, vp, &up[0], &up[1], &up[2]);
+   Double_t len = TMath::Sqrt((up[0] - dn[0]) * (up[0] - dn[0]) +
+                              (up[1] - dn[1]) * (up[1] - dn[1]) +
+                              (up[2] - dn[2]) * (up[2] - dn[2]));
+   SetLabelPixelFontSize(TMath::CeilNint(len*fAxis[2]->GetLabelSize()));
+   SetTitlePixelFontSize(TMath::CeilNint(len*fAxis[2]->GetTitleSize()));
+
+ 
+   // Z axis
+   //  
+   // tickmark vector = 10 pixels left
+   fAxis[2]->SetTickLength(1.); // leave this relative factor neutral
+   TGLVertex3 worldRef(fAxisTitlePos[2].X(), fAxisTitlePos[2].Y(), fAxisTitlePos[2].Z());
+   RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -10, 0, &mm);
+   SetTMNDim(1);
+   RefDir().Set(0., 0., 1.);
+   SetLabelAlign(TGLFont::kRight);
+   glPushMatrix();  
+   glTranslatef(fAxisTitlePos[2].X(), fAxisTitlePos[2].Y(), 0);
+   RefTitlePos().Set(RefTMOff(0).X(), RefTMOff(0).Y(),fAxisTitlePos[2].Z());
+   PaintAxis(rnrCtx, fAxis[2]);
+   glPopMatrix();
+
+   // XY Axis
+   //
+   SetTMNDim(2);
+   RefTMOff(1).Set(0, 0, fAxis[2]->GetXmin()- fAxis[2]->GetXmax());
+   SetLabelAlign(TGLFont::kCenterUp);
+   // X
+   glPushMatrix();
+   RefDir().Set(1, 0, 0);
+   Float_t yOff = fAxis[0]->GetXmax() - fAxis[0]->GetXmin();
+   yOff *= 0.5f;
+   if (fAxisTitlePos[0].Y() < fAxis[1]->GetXmax()) yOff = -yOff;
+   RefTMOff(0).Set(0, yOff, 0);
+   glTranslatef(0, fAxisTitlePos[0].Y(), fAxisTitlePos[0].Z());
+   RefTitlePos().Set(fAxisTitlePos[0].X(), yOff*1.5*fAxis[0]->GetTickLength(), 0);
+   PaintAxis(rnrCtx, fAxis[0]);
+   glPopMatrix();
+
+   // Y
+   glPushMatrix();
+   RefDir().Set(0, 1, 0);
+   Float_t xOff = fAxis[1]->GetXmax() - fAxis[1]->GetXmin();
+   if (fAxisTitlePos[1].X() < fAxis[0]->GetXmax()) xOff = -xOff;
+   RefTMOff(0).Set(xOff, 0, 0);
+   glTranslatef(fAxisTitlePos[1].X(), 0, fAxisTitlePos[1].Z());
+   RefTitlePos().Set(xOff*1.5*fAxis[1]->GetTickLength(), fAxisTitlePos[1].Y(), 0);
+   PaintAxis(rnrCtx, fAxis[1]);
+   glPopMatrix();
+}
+
+//______________________________________________________________________________
+void TGLAxisPainterBox::PlotStandard(      TGLRnrCtx      &rnrCtx,
+                                     const TH1            *histo,
+                                     const TGLBoundingBox &bbox)
+{
+   //
+
+   fAxis[0] = histo->GetXaxis();
+   fAxis[1] = histo->GetYaxis();
+   fAxis[2] = histo->GetZaxis();
+   // fAxis[2]->SetTitle("Z");
+   // fAxis[2]->SetLabelSize(0.04);
+   // fAxis[2]->SetTitleSize(0.05);
+
+   Double_t sx = (bbox.XMax() - bbox.XMin()) / (fAxis[0]->GetXmax() - fAxis[0]->GetXmin());
+   Double_t sy = (bbox.YMax() - bbox.YMin()) / (fAxis[1]->GetXmax() - fAxis[1]->GetXmin());
+   Double_t sz = (bbox.ZMax() - bbox.ZMin()) / (fAxis[2]->GetXmax() - fAxis[2]->GetXmin());
+
+   // draw
+   glPushMatrix();
+   glScaled(sx, sy, sz);
+   SetAxis3DTitlePos(rnrCtx);
+   DrawAxis3D(rnrCtx);
+   glPopMatrix();
+}
diff --git a/graf3d/gl/src/TGLCameraOverlay.cxx b/graf3d/gl/src/TGLCameraOverlay.cxx
index 09844b6..d4dbe2a 100644
--- a/graf3d/gl/src/TGLCameraOverlay.cxx
+++ b/graf3d/gl/src/TGLCameraOverlay.cxx
@@ -103,7 +103,7 @@ void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx)
 
       TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
       TGLFont font;
-      Int_t fs = TGLFontManager::GetFontSize((vp.Width()+vp.Height())*0.01, 10, 128);
+      Int_t fs = TGLFontManager::GetFontSize((vp.Width()+vp.Height())*0.01);
       rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
       Float_t bb[6];
       const char* txt = Form("(%f, %f, %f)", v[0], v[1], v[2]);
diff --git a/graf3d/gl/src/TGLClip.cxx b/graf3d/gl/src/TGLClip.cxx
index 2ba1039..7a96ac8 100644
--- a/graf3d/gl/src/TGLClip.cxx
+++ b/graf3d/gl/src/TGLClip.cxx
@@ -89,7 +89,8 @@ ClassImp(TGLClip);
 TGLClip::TGLClip(const TGLLogicalShape & logical, const TGLMatrix & transform, const float color[4]) :
    TGLPhysicalShape(0, logical, transform, kTRUE, color),
    fMode      (kInside),
-   fTimeStamp (1)
+   fTimeStamp (1),
+   fValid     (kFALSE)
 {
    // Construct a stand-alone physical clipping object.
 
@@ -157,6 +158,7 @@ TGLClipPlane::TGLClipPlane() :
 
    TGLPlane plane(0.0, -1.0, 0.0, 0.0);
    Set(plane);
+   fValid = kFALSE;
 }
 
 //______________________________________________________________________________
@@ -174,6 +176,7 @@ void TGLClipPlane::Setup(const TGLBoundingBox & bbox)
    TGLClipPlaneLogical* cpl = (TGLClipPlaneLogical*) GetLogical();
    cpl->Resize(extents);
    IncTimeStamp();
+   fValid = kTRUE;
 }
 
 //______________________________________________________________________________
@@ -186,12 +189,13 @@ void TGLClipPlane::Set(const TGLPlane& plane)
    TGLVertex3 newCenter = plane.NearestOn(oldCenter);
    SetTransform(TGLMatrix(newCenter, plane.Norm()));
    IncTimeStamp();
+   fValid = kTRUE;
 }
 
 //______________________________________________________________________________
 void TGLClipPlane::PlaneSet(TGLPlaneSet_t& set) const
 {
-   // Return set of planes (actually a single) describing this clip plane.
+   // Return set of planes (actually a single one) describing this clip plane.
 
    set.resize(1);
    set[0] = BoundingBox().GetNearPlane();
@@ -238,6 +242,7 @@ void TGLClipBox::Setup(const TGLBoundingBox& bbox)
    cbl->Resize(center - halfLengths, center + halfLengths);
 
    IncTimeStamp();
+   fValid = kTRUE;
 }
 
 //______________________________________________________________________________
@@ -329,7 +334,7 @@ void TGLClipSet::Render(TGLRnrCtx& rnrCtx)
 {
    // Render clip-shape and manipulator.
 
-   if (fCurrentClip == 0) return;
+   if (!fCurrentClip) return;
 
    rnrCtx.SetShapeLOD(TGLRnrCtx::kLODHigh);
    rnrCtx.SetDrawPass(TGLRnrCtx::kPassFill);
@@ -348,20 +353,59 @@ void TGLClipSet::FillPlaneSet(TGLPlaneSet_t& set) const
 {
    // Forward request to fill the plane-set to the current clip.
 
-   if (fCurrentClip != 0)
+   if (fCurrentClip)
       fCurrentClip->PlaneSet(set);
 }
 
 //______________________________________________________________________________
 void TGLClipSet::SetupClips(const TGLBoundingBox& sceneBBox)
 {
-   // Setup clipping objects for current scene bounding box.
+   // Setup clipping objects for given scene bounding box.
 
+   fLastBBox = sceneBBox;
    fClipPlane->Setup(sceneBBox);
    fClipBox  ->Setup(sceneBBox);
 }
 
 //______________________________________________________________________________
+void TGLClipSet::SetupCurrentClip(const TGLBoundingBox& sceneBBox)
+{
+   // Setup current clipping object for given scene bounding box.
+
+   fLastBBox = sceneBBox;
+   if (fCurrentClip)
+      fCurrentClip->Setup(sceneBBox);
+}
+
+//______________________________________________________________________________
+void TGLClipSet::SetupCurrentClipIfInvalid(const TGLBoundingBox& sceneBBox)
+{
+   // Setup current clipping object for given scene bounding box.
+
+   fLastBBox = sceneBBox;
+   if (fCurrentClip && ! fCurrentClip->IsValid())
+      fCurrentClip->Setup(sceneBBox);
+}
+
+//______________________________________________________________________________
+void TGLClipSet::InvalidateClips()
+{
+   // Invalidate clip objects.
+
+   fClipPlane->Invalidate();
+   fClipBox  ->Invalidate();
+}
+
+//______________________________________________________________________________
+void TGLClipSet::InvalidateCurrentClip()
+{
+   // Invalidate current clip object.
+
+   if (fCurrentClip)
+      fCurrentClip->Invalidate();
+}
+
+//______________________________________________________________________________
 void TGLClipSet::GetClipState(EClipType type, Double_t data[6]) const
 {
    // Get state of clip object 'type' into data vector:
@@ -377,6 +421,8 @@ void TGLClipSet::GetClipState(EClipType type, Double_t data[6]) const
 
       case kClipPlane:
       {
+         if (!fClipPlane->IsValid())
+            fClipPlane->Setup(fLastBBox);
          TGLPlaneSet_t planes;
          fClipPlane->PlaneSet(planes);
          data[0] = planes[0].A();
@@ -387,6 +433,8 @@ void TGLClipSet::GetClipState(EClipType type, Double_t data[6]) const
       }
       case kClipBox:
       {
+         if (!fClipBox->IsValid())
+            fClipBox->Setup(fLastBBox);
          const TGLBoundingBox & box = fClipBox->BoundingBox();
          TGLVector3 ext = box.Extents();
          data[0] = box.Center().X();
diff --git a/graf3d/gl/src/TGLFontManager.cxx b/graf3d/gl/src/TGLFontManager.cxx
index 97a7305..c4a5d4c 100644
--- a/graf3d/gl/src/TGLFontManager.cxx
+++ b/graf3d/gl/src/TGLFontManager.cxx
@@ -12,6 +12,7 @@
 #include "RConfigure.h"
 #include "TGLFontManager.h"
 
+#include "TMath.h"
 #include "TSystem.h"
 #include "TEnv.h"
 #include "TObjString.h"
@@ -410,29 +411,26 @@ TGLFontManager::FontSizeVec_t* TGLFontManager::GetFontSizeArray()
 }
 
 //______________________________________________________________________________
-Int_t TGLFontManager::GetFontSize(Float_t ds, Int_t min, Int_t max)
+Int_t TGLFontManager::GetFontSize(Float_t ds)
 {
    // Get availabe font size.
 
    if (fgStaticInitDone == kFALSE) InitStatics();
 
-   Int_t  nums = fgFontSizeArray.size();
-   Int_t i = 0;
-   while (i<nums)
-   {
-      if (ds<=fgFontSizeArray[i]) break;
-      i++;
-   }
-
-   Int_t fs =  fgFontSizeArray[i];
-
-   if (min>0 && fs<min)
-      fs = min;
+   Int_t idx = TMath::BinarySearch(fgFontSizeArray.size(), &fgFontSizeArray[0],
+                                   TMath::CeilNint(ds));
+   if (idx < 0) idx = 0;
+   return fgFontSizeArray[idx];
+}
 
-   if (max>0 && fs>max)
-      fs = max;
+//______________________________________________________________________________
+Int_t TGLFontManager::GetFontSize(Float_t ds, Int_t min, Int_t max)
+{
+   // Get availabe font size.
 
-   return fs;
+   if (ds < min) ds = min;
+   if (ds > max) ds = max;
+   return GetFontSize(ds);
 }
 
 //______________________________________________________________________________
@@ -477,7 +475,7 @@ void TGLFontManager::InitStatics()
       fgFontSizeArray.push_back(i);
    for (Int_t i = 24; i <= 64; i+=4)
       fgFontSizeArray.push_back(i);
-   for (Int_t i = 72; i <= 120; i+=8)
+   for (Int_t i = 72; i <= 128; i+=8)
       fgFontSizeArray.push_back(i);
 
    fgStaticInitDone = kTRUE;
diff --git a/graf3d/gl/src/TGLManipSet.cxx b/graf3d/gl/src/TGLManipSet.cxx
index 2a3be4a..04feb43 100644
--- a/graf3d/gl/src/TGLManipSet.cxx
+++ b/graf3d/gl/src/TGLManipSet.cxx
@@ -35,6 +35,7 @@
 ClassImp(TGLManipSet);
 
 TGLManipSet::TGLManipSet() :
+   TGLOverlayElement(kViewer),
    fType     (kTrans),
    fDrawBBox (kFALSE)
 {
diff --git a/graf3d/gl/src/TGLParametricEquationGL.cxx b/graf3d/gl/src/TGLParametricEquationGL.cxx
index a542fa7..a543aab 100644
--- a/graf3d/gl/src/TGLParametricEquationGL.cxx
+++ b/graf3d/gl/src/TGLParametricEquationGL.cxx
@@ -16,10 +16,8 @@
 
 #include "TGLSurfacePainter.h"
 #include "TGLTF3Painter.h"
-#include "TGLAxis.h"
 
 #include "TGLRnrCtx.h"
-
 #include "TGLIncludes.h"
 
 //______________________________________________________________________
@@ -27,7 +25,7 @@
 // GL-renderer wrapper for TGLParametricEquation.
 // This allows rendering of parametric-equations in standard GL viewer.
 
-ClassImp(TGLParametricEquationGL)
+ClassImp(TGLParametricEquationGL);
 
 //______________________________________________________________________________
 TGLParametricEquationGL::TGLParametricEquationGL() : TGLObject(), fM(0)
@@ -71,7 +69,7 @@ void TGLParametricEquationGL::SetBBox()
 }
 
 //______________________________________________________________________________
-void TGLParametricEquationGL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
+void TGLParametricEquationGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
 {
    // Render the object.
 
diff --git a/graf3d/gl/src/TGLRnrCtx.cxx b/graf3d/gl/src/TGLRnrCtx.cxx
index 1a9557a..d1a2979 100644
--- a/graf3d/gl/src/TGLRnrCtx.cxx
+++ b/graf3d/gl/src/TGLRnrCtx.cxx
@@ -28,10 +28,6 @@
 #include <algorithm>
 #include <cassert>
 
-typedef std::list<TGLColorSet*>           lpTGLColorSet_t;
-typedef std::list<TGLColorSet*>::iterator lpTGLColorSet_i;
-
-
 //______________________________________________________________________
 //
 // The TGLRnrCtx class aggregates data for a given redering context as
@@ -97,7 +93,7 @@ TGLRnrCtx::TGLRnrCtx(TGLViewerBase* viewer) :
 
    
    fColorSetStack = new lpTGLColorSet_t;
-   static_cast<lpTGLColorSet_t*>(fColorSetStack)->push_back(0);
+   fColorSetStack->push_back(0);
 
    fSelectBuffer = new TGLSelectBuffer;
    fQuadric = gluNewQuadric();
@@ -121,7 +117,7 @@ TGLRnrCtx::~TGLRnrCtx()
    gluDeleteQuadric(fQuadric);
    delete fPickRectangle;
    delete fSelectBuffer;
-   delete static_cast<lpTGLColorSet_t*>(fColorSetStack);
+   delete fColorSetStack;
 }
 
 //______________________________________________________________________
@@ -264,14 +260,15 @@ void TGLRnrCtx::PushColorSet()
 {
    // Create copy of current color-set on the top of the stack.
 
-   lpTGLColorSet_t& css = * static_cast<lpTGLColorSet_t*>(fColorSetStack);
-   css.push_back(new TGLColorSet(*css.back()));
+   fColorSetStack->push_back(new TGLColorSet(*fColorSetStack->back()));
 }
 
 //______________________________________________________________________________
 TGLColorSet& TGLRnrCtx::ColorSet()
 {
-   return * static_cast<lpTGLColorSet_t*>(fColorSetStack)->back();
+   // Return reference to current color-set (top of hte stack).
+
+   return * fColorSetStack->back();
 }
 
 //______________________________________________________________________________
@@ -280,12 +277,10 @@ void TGLRnrCtx::PopColorSet()
    // Pops the top-most color-set.
    // If only one entry is available, error is printed and the entry remains.
 
-   lpTGLColorSet_t& css = * static_cast<lpTGLColorSet_t*>(fColorSetStack);
-
-   if (css.size() >= 2)
+   if (fColorSetStack->size() >= 2)
    {
-      delete css.back();
-      css.pop_back();
+      delete fColorSetStack->back();
+      fColorSetStack->pop_back();
    }
    else
    {
@@ -299,9 +294,8 @@ TGLColorSet* TGLRnrCtx::ChangeBaseColorSet(TGLColorSet* set)
    // Change the default/bottom color-set.
    // Returns the previous color-set.
 
-   lpTGLColorSet_t& css = * static_cast<lpTGLColorSet_t*>(fColorSetStack);
-   TGLColorSet* old = css.front();
-   css.front() = set;
+   TGLColorSet* old = fColorSetStack->front();
+   fColorSetStack->front() = set;
    return old;
 }
 
@@ -310,9 +304,20 @@ TGLColorSet* TGLRnrCtx::GetBaseColorSet()
 {
    // Returns the current base color-set.
 
-   return static_cast<lpTGLColorSet_t*>(fColorSetStack)->front();
+   return fColorSetStack->front();
 }
 
+//______________________________________________________________________________
+void TGLRnrCtx::ColorOrForeground(Color_t col)
+{
+   // Set col if it is different from background, otherwise use
+   // current foreground color.
+
+   if (fColorSetStack->back()->Background().GetColorIndex() == col)
+      TGLUtil::Color(fColorSetStack->back()->Foreground());
+   else
+      TGLUtil::Color(col);
+}
 
 /**************************************************************************/
 // Display-list state
diff --git a/graf3d/gl/src/TGLSAViewer.cxx b/graf3d/gl/src/TGLSAViewer.cxx
index 6c47308..6e005ac 100644
--- a/graf3d/gl/src/TGLSAViewer.cxx
+++ b/graf3d/gl/src/TGLSAViewer.cxx
@@ -76,8 +76,8 @@ DIRECT SCENE INTERACTIONS\n\n\
    SELECT a shape with Shift+Left mouse button click.\n\n\
    SELECT the viewer with Shift+Left mouse button click on a free space.\n\n\
    MOVE a selected shape using Shift+Mid mouse drag.\n\n\
-   Invoke the CONTEXT menu with Shift+Right mouse click.\n\n\
-   Secondary selection and direct render object interaction is initiated\n\
+   Invoke the CONTEXT menu with Shift+Right mouse click.\n\n"
+   "Secondary selection and direct render object interaction is initiated\n\
    by Alt+Left mouse click (Mod1, actually). Only few classes support this option.\n\n\
 CAMERA\n\n\
    The \"Camera\" menu is used to select the different projections from \n\
@@ -107,8 +107,8 @@ SCENE CLIPPING\n\n\
    In the Scene-Clipping tabs select a 'Clip Type': None, Plane, Box\n\n\
    For 'Plane' and 'Box' the lower pane shows the relevant parameters:\n\n\
 \tPlane: Equation coefficients of form aX + bY + cZ + d = 0\n\
-\tBox: Center X/Y/Z and Length X/Y/Z\n\n\
-   For Box checking the 'Show / Edit' checkbox shows the clip box (in light blue)\n\
+\tBox: Center X/Y/Z and Length X/Y/Z\n\n"
+   "For Box checking the 'Show / Edit' checkbox shows the clip box (in light blue)\n\
    in viewer. It also attaches the current manipulator to the box - enabling\n\
    direct editing in viewer.\n\n\
 MANIPULATORS\n\n\
diff --git a/graf3d/gl/src/TGLSceneBase.cxx b/graf3d/gl/src/TGLSceneBase.cxx
index f9af3b5..e3b5afd 100644
--- a/graf3d/gl/src/TGLSceneBase.cxx
+++ b/graf3d/gl/src/TGLSceneBase.cxx
@@ -109,8 +109,8 @@ void TGLSceneBase::RemoveViewer(TGLViewerBase* viewer)
 
    if (fViewers.empty() && fAutoDestruct)
    {
-      Info("TGLSceneBase::RemoveViewer", "scene '%s' not used - autodestructing.",
-           GetName());
+      if (gDebug > 0)
+         Info("TGLSceneBase::RemoveViewer", "scene '%s' not used - autodestructing.", GetName());
       delete this;
    }
 }
diff --git a/graf3d/gl/src/TGLScenePad.cxx b/graf3d/gl/src/TGLScenePad.cxx
index a00f232..5be4719 100644
--- a/graf3d/gl/src/TGLScenePad.cxx
+++ b/graf3d/gl/src/TGLScenePad.cxx
@@ -31,8 +31,10 @@
 #include "TList.h"
 #include "TMath.h"
 
-#include "TH2.h"         // Preliminary support for GL plot painters
-#include "TH3.h"         // Preliminary support for GL plot painters
+// Preliminary support for GL plot painters
+#include "TH3.h"
+#include "TH3GL.h"
+#include "TH2.h"
 #include "TH2GL.h"
 #include "TF2.h"
 #include "TF2GL.h"
@@ -72,7 +74,6 @@ TGLScenePad::TGLScenePad(TVirtualPad* pad) :
 // Histo import and Sub-pad traversal
 /******************************************************************************/
 
-
 //______________________________________________________________________________
 void TGLScenePad::AddHistoPhysical(TGLLogicalShape* log)
 {
@@ -122,7 +123,6 @@ void TGLScenePad::AddHistoPhysical(TGLLogicalShape* log)
    // phys->BoundingBox().Dump();
 }
 
-
 //______________________________________________________________________________
 void TGLScenePad::SubPadPaint(TVirtualPad* pad)
 {
@@ -153,13 +153,24 @@ void TGLScenePad::ObjectPaint(TObject* obj, Option_t* opt)
    // Special handling of 2D/3D histograms to activate Timur's
    // histo-painters.
 
-   if (obj->InheritsFrom(TAtt3D::Class()) && !obj->InheritsFrom(TH3::Class()))
+   if (obj->InheritsFrom(TH3::Class()))
+   {
+      // TH3 in principle inherits from TAtt3D, but it gets painted
+      // via the histo-painters - which we need to bypass.
+      // printf("histo 3d\n");
+      TGLObject* log = new TH3GL();
+      log->SetModel(obj, opt);
+      log->SetBBox();
+      AdoptLogical(*log);
+      AddHistoPhysical(log);
+   }
+   else if (obj->InheritsFrom(TAtt3D::Class()))
    {
       //Since TH3's derived from TAtt3D, it should be checked here.
       //printf("normal-painting %s / %s\n", obj->GetName(), obj->ClassName());
       obj->Paint(opt);
    }
-   else if (obj->InheritsFrom(TH2::Class()) || obj->InheritsFrom(TH3::Class()))
+   else if (obj->InheritsFrom(TH2::Class()))
    {
       // printf("histo 2d\n");
       TGLObject* log = new TH2GL();
@@ -199,7 +210,6 @@ void TGLScenePad::ObjectPaint(TObject* obj, Option_t* opt)
    }
 }
 
-
 //______________________________________________________________________________
 void TGLScenePad::PadPaintFromViewer(TGLViewer* viewer)
 {
@@ -214,7 +224,6 @@ void TGLScenePad::PadPaintFromViewer(TGLViewer* viewer)
    fSmartRefresh = sr;
 }
 
-
 //______________________________________________________________________________
 void TGLScenePad::PadPaint(TVirtualPad* pad)
 {
@@ -235,10 +244,9 @@ void TGLScenePad::PadPaint(TVirtualPad* pad)
 }
 
 
-/******************************************************************************/
+//==============================================================================
 // VV3D
-/******************************************************************************/
-
+//==============================================================================
 
 //______________________________________________________________________________
 void TGLScenePad::BeginScene()
@@ -294,7 +302,6 @@ void TGLScenePad::BeginScene()
    }
 }
 
-
 //______________________________________________________________________________
 void TGLScenePad::EndScene()
 {
@@ -314,7 +321,6 @@ void TGLScenePad::EndScene()
    }
 }
 
-
 //______________________________________________________________________________
 Int_t TGLScenePad::AddObject(const TBuffer3D& buffer, Bool_t* addChildren)
 {
@@ -328,7 +334,6 @@ Int_t TGLScenePad::AddObject(const TBuffer3D& buffer, Bool_t* addChildren)
    return sections;
 }
 
-
 //______________________________________________________________________________
 Int_t TGLScenePad::AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t* addChildren)
 {
@@ -469,7 +474,6 @@ Int_t TGLScenePad::AddObject(UInt_t physicalID, const TBuffer3D& buffer, Bool_t*
    return TBuffer3D::kNone;
 }
 
-
 //______________________________________________________________________________
 Bool_t TGLScenePad::OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren)
 {
@@ -495,7 +499,6 @@ Bool_t TGLScenePad::OpenComposite(const TBuffer3D& buffer, Bool_t* addChildren)
    }
 }
 
-
 //______________________________________________________________________________
 void TGLScenePad::CloseComposite()
 {
@@ -517,7 +520,6 @@ void TGLScenePad::CloseComposite()
    }
 }
 
-
 //______________________________________________________________________________
 void TGLScenePad::AddCompositeOp(UInt_t operation)
 {
@@ -531,7 +533,6 @@ void TGLScenePad::AddCompositeOp(UInt_t operation)
 
 // Protected methods
 
-
 //______________________________________________________________________________
 Int_t TGLScenePad::ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeRaw) const
 {
@@ -604,7 +605,6 @@ Int_t TGLScenePad::ValidateObjectBuffer(const TBuffer3D& buffer, Bool_t includeR
    }
 }
 
-
 //______________________________________________________________________________
 TGLLogicalShape* TGLScenePad::CreateNewLogical(const TBuffer3D& buffer) const
 {
@@ -678,7 +678,6 @@ TGLLogicalShape* TGLScenePad::CreateNewLogical(const TBuffer3D& buffer) const
    return newLogical;
 }
 
-
 //______________________________________________________________________________
 TGLPhysicalShape*
 TGLScenePad::CreateNewPhysical(UInt_t ID, const TBuffer3D& buffer,
@@ -698,7 +697,6 @@ TGLScenePad::CreateNewPhysical(UInt_t ID, const TBuffer3D& buffer,
                                buffer.fReflection, rgba);
 }
 
-
 //______________________________________________________________________________
 RootCsg::TBaseMesh* TGLScenePad::BuildComposite()
 {
@@ -725,7 +723,6 @@ RootCsg::TBaseMesh* TGLScenePad::BuildComposite()
    } else return fCSTokens[fCSLevel++].second;
 }
 
-
 //______________________________________________________________________________
 TGLLogicalShape* TGLScenePad::AttemptDirectRenderer(TObject* id)
 {
diff --git a/graf3d/gl/src/TGLUtil.cxx b/graf3d/gl/src/TGLUtil.cxx
index eaaaa3e..aa1c82d 100644
--- a/graf3d/gl/src/TGLUtil.cxx
+++ b/graf3d/gl/src/TGLUtil.cxx
@@ -47,7 +47,7 @@
 // required.                                                            //
 //////////////////////////////////////////////////////////////////////////
 
-ClassImp(TGLVertex3)
+ClassImp(TGLVertex3);
 
 //______________________________________________________________________________
 TGLVertex3::TGLVertex3()
@@ -137,7 +137,7 @@ void TGLVertex3::Dump() const
 // minimum required.                                                    //
 //////////////////////////////////////////////////////////////////////////
 
-ClassImp(TGLVector3)
+ClassImp(TGLVector3);
 
 //______________________________________________________________________________
 TGLVector3::TGLVector3() :
@@ -182,7 +182,7 @@ TGLVector3::~TGLVector3()
 // pair.                                                                //
 //////////////////////////////////////////////////////////////////////////
 
-ClassImp(TGLLine3)
+ClassImp(TGLLine3);
 
 //______________________________________________________________________________
 TGLLine3::TGLLine3(const TGLVertex3 & start, const TGLVertex3 & end) :
@@ -239,7 +239,7 @@ void TGLLine3::Draw() const
 // Viewport (pixel base) 2D rectangle class                             //
 //////////////////////////////////////////////////////////////////////////
 
-ClassImp(TGLRect)
+ClassImp(TGLRect);
 
 //______________________________________________________________________________
 TGLRect::TGLRect() :
@@ -302,7 +302,7 @@ EOverlap TGLRect::Overlap(const TGLRect & other) const
 // required.                                                            //
 //////////////////////////////////////////////////////////////////////////
 
-ClassImp(TGLPlane)
+ClassImp(TGLPlane);
 
 //______________________________________________________________________________
 TGLPlane::TGLPlane()
@@ -358,13 +358,117 @@ TGLPlane::~TGLPlane()
 }
 
 //______________________________________________________________________________
+void TGLPlane::Normalise()
+{
+   // Normalise the plane.
+
+   Double_t mag = sqrt(fVals[0]*fVals[0] + fVals[1]*fVals[1] + fVals[2]*fVals[2]);
+
+   if (mag == 0.0 ) {
+      Error("TGLPlane::Normalise", "trying to normalise plane with zero magnitude normal");
+      return;
+   }
+   mag = 1.0 / mag;
+   fVals[0] *= mag;
+   fVals[1] *= mag;
+   fVals[2] *= mag;
+   fVals[3] *= mag;
+}
+
+//______________________________________________________________________________
 void TGLPlane::Dump() const
 {
    // Output plane equation to std::out
+
    std::cout.precision(6);
    std::cout << "Plane : " << fVals[0] << "x + " << fVals[1] << "y + " << fVals[2] << "z + " << fVals[3] << std::endl;
 }
 
+//______________________________________________________________________________
+void TGLPlane::Set(const TGLPlane & other)
+{
+   // Assign from other.
+
+   fVals[0] = other.fVals[0];
+   fVals[1] = other.fVals[1];
+   fVals[2] = other.fVals[2];
+   fVals[3] = other.fVals[3];
+}
+
+//______________________________________________________________________________
+void TGLPlane::Set(Double_t a, Double_t b, Double_t c, Double_t d)
+{
+   // Set by values.
+
+   fVals[0] = a;
+   fVals[1] = b;
+   fVals[2] = c;
+   fVals[3] = d;
+   Normalise();
+}
+
+//______________________________________________________________________________
+void TGLPlane::Set(Double_t eq[4])
+{
+   // Set by array values.
+
+   fVals[0] = eq[0];
+   fVals[1] = eq[1];
+   fVals[2] = eq[2];
+   fVals[3] = eq[3];
+   Normalise();
+}
+
+//______________________________________________________________________________
+void TGLPlane::Set(const TGLVector3 & norm, const TGLVertex3 & point)
+{
+   // Set plane from a normal vector and in-plane point pair
+
+   fVals[0] = norm[0];
+   fVals[1] = norm[1];
+   fVals[2] = norm[2];
+   fVals[3] = -(fVals[0]*point[0] + fVals[1]*point[1] + fVals[2]*point[2]);
+   Normalise();
+}
+
+//______________________________________________________________________________
+void TGLPlane::Set(const TGLVertex3 & p1, const TGLVertex3 & p2, const TGLVertex3 & p3)
+{
+   // Set plane by three points.
+
+   TGLVector3 norm = Cross(p2 - p1, p3 - p1);
+   Set(norm, p2);
+}
+
+//______________________________________________________________________________
+void TGLPlane::Negate()
+{
+   // Negate the plane.
+
+   fVals[0] = -fVals[0];
+   fVals[1] = -fVals[1];
+   fVals[2] = -fVals[2];
+   fVals[3] = -fVals[3];
+}
+
+//______________________________________________________________________________
+Double_t TGLPlane::DistanceTo(const TGLVertex3 & vertex) const
+{
+   // Distance from plane to vertex.
+
+   return (fVals[0]*vertex[0] + fVals[1]*vertex[1] + fVals[2]*vertex[2] + fVals[3]);
+}
+
+//______________________________________________________________________________
+TGLVertex3 TGLPlane::NearestOn(const TGLVertex3 & point) const
+{
+   // Return nearest point on plane.
+
+   TGLVector3 o = Norm() * (Dot(Norm(), TGLVector3(point[0], point[1], point[2])) + D() / Dot(Norm(), Norm()));
+   TGLVertex3 v = point - o;
+   return v;
+}
+
 // Some free functions for plane intersections
 
 //______________________________________________________________________________
@@ -453,7 +557,7 @@ std::pair<Bool_t, TGLVertex3> Intersection(const TGLPlane & plane, const TGLLine
 // required.                                                            //
 //////////////////////////////////////////////////////////////////////////
 
-ClassImp(TGLMatrix)
+ClassImp(TGLMatrix);
 
 //______________________________________________________________________________
 TGLMatrix::TGLMatrix()
@@ -976,6 +1080,8 @@ void TGLMatrix::Dump() const
 //
 // Class encapsulating color information in preferred GL format - an
 // array of four unsigned bytes.
+// Color index is also cached for easier interfacing with the
+// traditional ROOT graphics.
 //
 
 ClassImp(TGLColor);
@@ -987,6 +1093,7 @@ TGLColor::TGLColor()
 
    fRGBA[0] = fRGBA[1] = fRGBA[2] = 0;
    fRGBA[3] = 255;
+   fIndex   = -1;
 }
 
 //______________________________________________________________________________
@@ -1028,6 +1135,7 @@ TGLColor& TGLColor::operator=(const TGLColor& c)
    fRGBA[1] = c.fRGBA[1];
    fRGBA[2] = c.fRGBA[2];
    fRGBA[3] = c.fRGBA[3];
+   fIndex   = c.fIndex;
    return *this;
 }
 
@@ -1036,7 +1144,9 @@ Color_t TGLColor::GetColorIndex() const
 {
    // Returns color-index representing the color.
 
-   return TColor::GetColor(fRGBA[0], fRGBA[1], fRGBA[2]);
+   if (fIndex == -1)
+      fIndex = TColor::GetColor(fRGBA[0], fRGBA[1], fRGBA[2]);
+   return fIndex;
 }
 
 //______________________________________________________________________________
@@ -1056,6 +1166,7 @@ void TGLColor::SetColor(Int_t r, Int_t g, Int_t b, Int_t a)
    fRGBA[1] = g;
    fRGBA[2] = b;
    fRGBA[3] = a;
+   fIndex   = -1;
 }
 
 //______________________________________________________________________________
@@ -1067,6 +1178,7 @@ void TGLColor::SetColor(Float_t r, Float_t g, Float_t b, Float_t a)
    fRGBA[1] = (UChar_t)(255*g);
    fRGBA[2] = (UChar_t)(255*b);
    fRGBA[3] = (UChar_t)(255*a);
+   fIndex   = -1;
 }
 
 //______________________________________________________________________________
@@ -1081,6 +1193,7 @@ void TGLColor::SetColor(Color_t color_index)
       fRGBA[0] = (UChar_t)(255*c->GetRed());
       fRGBA[1] = (UChar_t)(255*c->GetGreen());
       fRGBA[2] = (UChar_t)(255*c->GetBlue());
+      fIndex   = color_index;
    }
    else
    {
@@ -1088,6 +1201,7 @@ void TGLColor::SetColor(Color_t color_index)
       fRGBA[0] = 255;
       fRGBA[1] = 0;
       fRGBA[2] = 255;
+      fIndex   = -1;
    }
 }
 
@@ -1106,6 +1220,7 @@ void TGLColor::SetColor(Color_t color_index, Char_t transparency)
       fRGBA[1] = (UChar_t)(255*c->GetGreen());
       fRGBA[2] = (UChar_t)(255*c->GetBlue());
       fRGBA[3] = alpha;
+      fIndex   = color_index;
    }
    else
    {
@@ -1114,6 +1229,7 @@ void TGLColor::SetColor(Color_t color_index, Char_t transparency)
       fRGBA[1] = 0;
       fRGBA[2] = 255;
       fRGBA[3] = alpha;
+      fIndex   = -1;
       return;
    }
 }
@@ -2166,7 +2282,7 @@ TGLDisableGuard::~TGLDisableGuard()
    glEnable(GLenum(fCap));
 }
 
-ClassImp(TGLSelectionBuffer)
+ClassImp(TGLSelectionBuffer);
 
 //______________________________________________________________________________
 TGLSelectionBuffer::TGLSelectionBuffer()
diff --git a/graf3d/gl/src/TGLViewer.cxx b/graf3d/gl/src/TGLViewer.cxx
index 3f4149a..d100526 100644
--- a/graf3d/gl/src/TGLViewer.cxx
+++ b/graf3d/gl/src/TGLViewer.cxx
@@ -110,6 +110,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad, Int_t x, Int_t y,
 
    fLightSet          (0),
    fClipSet           (0),
+   fClipAutoUpdate    (kTRUE),
    fSelectedPShapeRef (0),
    fCurrentOvlElm     (0),
 
@@ -165,6 +166,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad) :
 
    fLightSet          (0),
    fClipSet           (0),
+   fClipAutoUpdate    (kTRUE),
    fSelectedPShapeRef (0),
    fCurrentOvlElm     (0),
 
@@ -217,16 +219,25 @@ void TGLViewer::InitSecondaryObjects()
    // Common initialization.
 
    fLightSet = new TGLLightSet;
-   fClipSet  = new TGLClipSet;  fOverlay.push_back(fClipSet);
+   fClipSet  = new TGLClipSet;
+   AddOverlayElement(fClipSet);
 
-   fSelectedPShapeRef = new TGLManipSet; fOverlay.push_back(fSelectedPShapeRef);
+   fSelectedPShapeRef = new TGLManipSet;
    fSelectedPShapeRef->SetDrawBBox(kTRUE);
+   AddOverlayElement(fSelectedPShapeRef);
 
    fLightColorSet.StdLightBackground();
-   if (fgUseDefaultColorSetForNewViewers)
+   if (fgUseDefaultColorSetForNewViewers) {
       fRnrCtx->ChangeBaseColorSet(&fgDefaultColorSet);
-   else
-      fRnrCtx->ChangeBaseColorSet(&fDarkColorSet);
+   } else {
+      if (fPad) {
+         fRnrCtx->ChangeBaseColorSet(&fLightColorSet);
+         fLightColorSet.Background().SetColor(fPad->GetFillColor());
+         fLightColorSet.Foreground().SetColor(fPad->GetLineColor());
+      } else {
+         fRnrCtx->ChangeBaseColorSet(&fDarkColorSet);
+      }
+   }
 
    fCameraOverlay = new TGLCameraOverlay(kFALSE, kFALSE);
    AddOverlayElement(fCameraOverlay);
@@ -240,9 +251,7 @@ TGLViewer::~TGLViewer()
    // Destroy viewer object.
 
    delete fLightSet;
-   delete fClipSet;
-   delete fSelectedPShapeRef;
-   delete fCameraOverlay;
+   // fClipSet, fSelectedPShapeRef and fCameraOverlay deleted via overlay.
 
    delete fContextMenu;
    delete fRedrawTimer;
@@ -459,7 +468,11 @@ void TGLViewer::PreRender()
 
    // Setup lighting
    fLightSet->StdSetupLights(fOverallBoundingBox, *fCamera, fDebugMode);
-   fClipSet->SetupClips(fOverallBoundingBox);
+   // Setup clip object.
+   if (fClipAutoUpdate)
+      fClipSet->SetupCurrentClip(fOverallBoundingBox);
+   else
+      fClipSet->SetupCurrentClipIfInvalid(fOverallBoundingBox);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/gl/src/TGLViewerBase.cxx b/graf3d/gl/src/TGLViewerBase.cxx
index 93801e2..607faa4 100644
--- a/graf3d/gl/src/TGLViewerBase.cxx
+++ b/graf3d/gl/src/TGLViewerBase.cxx
@@ -72,6 +72,8 @@ TGLViewerBase::~TGLViewerBase()
       delete *i;
    }
 
+   DeleteOverlayElements(TGLOverlayElement::kAll);
+
    delete fRnrCtx;
 }
 
@@ -203,18 +205,26 @@ void TGLViewerBase::DeleteOverlayAnnotations()
 {
    // Delete overlay elements that are annotations.
 
-   OverlayElmVec_t goners;
-   for (OverlayElmVec_i i = fOverlay.begin(); i != fOverlay.end(); ++i)
-   {
-      if (dynamic_cast<TGLAnnotation*>(*i))
-         goners.push_back(*i);
-   }
-   if ( ! goners.empty())
+   DeleteOverlayElements(TGLOverlayElement::kAnnotation);
+}
+
+//______________________________________________________________________
+void TGLViewerBase::DeleteOverlayElements(TGLOverlayElement::ERole role)
+{
+   // Delete overlay elements.
+
+   OverlayElmVec_t ovl;
+   fOverlay.swap(ovl);
+
+   for (OverlayElmVec_i i = ovl.begin(); i != ovl.end(); ++i)
    {
-      for (OverlayElmVec_i i = goners.begin(); i != goners.end(); ++i)
+      if (role == TGLOverlayElement::kAll || (*i)->GetRole() == role)
          delete *i;
-      Changed();
+      else
+         fOverlay.push_back(*i);
    }
+
+   Changed();
 }
 
 /**************************************************************************/
diff --git a/graf3d/gl/src/TH2GL.cxx b/graf3d/gl/src/TH2GL.cxx
index 1088e9c..5ab7818 100644
--- a/graf3d/gl/src/TH2GL.cxx
+++ b/graf3d/gl/src/TH2GL.cxx
@@ -11,36 +11,38 @@
 
 #include "TH2GL.h"
 #include "TH2.h"
-#include "TH3.h"
 #include "TVirtualPad.h"
+#include "TAxis.h"
+#include "TMath.h"
 
 #include "TGLSurfacePainter.h"
 #include "TGLHistPainter.h"
 #include "TGLLegoPainter.h"
 #include "TGLBoxPainter.h"
 #include "TGLTF3Painter.h"
-#include "TGLAxis.h"
+#include "TGLAxisPainter.h"
+#include "TGLCamera.h"
 
 #include "TGLRnrCtx.h"
 
 #include "TGLIncludes.h"
 
 //______________________________________________________________________________
-// TH2GL
 //
 // Rendering of TH2 and derived classes.
 // Interface to plot-painters also used for gl-in-pad.
 
-ClassImp(TH2GL)
+ClassImp(TH2GL);
 
-TH2GL::TH2GL() : TGLObject(), fM(0), fPlotPainter(0)
+//______________________________________________________________________________
+TH2GL::TH2GL() :
+TGLObject(), fM(0), fPlotPainter(0)
 {
    // Constructor.
 
    fDLCache = kFALSE; // Disable display list.
 }
 
-
 //______________________________________________________________________________
 TH2GL::~TH2GL()
 {
@@ -49,15 +51,15 @@ TH2GL::~TH2GL()
    delete fPlotPainter;
 }
 
-
 //______________________________________________________________________________
 Bool_t TH2GL::SetModel(TObject* obj, const Option_t* opt)
 {
    // Set model object.
+
    TString option(opt);
    option.ToLower();
 
-   if(SetModelCheckClass(obj, TH2::Class()))
+   if (SetModelCheckClass(obj, TH2::Class()))
    {
       fM = dynamic_cast<TH2*>(obj);
 
@@ -82,23 +84,10 @@ Bool_t TH2GL::SetModel(TObject* obj, const Option_t* opt)
       fPlotPainter->AddOption(option);
       fPlotPainter->InitGeometry();
       return kTRUE;
-   } else if (SetModelCheckClass(obj, TH3::Class())) {
-      fM = dynamic_cast<TH3 *>(obj);
-
-      if (option.Index("iso") != kNPOS)
-         fPlotPainter = new TGLIsoPainter(fM, 0, &fCoord);
-      else if (option.Index("box") != kNPOS)
-         fPlotPainter = new TGLBoxPainter(fM, 0, &fCoord);
-
-      fPlotPainter->AddOption(option);
-      fPlotPainter->InitGeometry();
-      return kTRUE;
    }
-
    return kFALSE;
 }
 
-
 //______________________________________________________________________________
 void TH2GL::SetBBox()
 {
@@ -107,9 +96,8 @@ void TH2GL::SetBBox()
    fBoundingBox.Set(fPlotPainter->RefBackBox().Get3DBox());
 }
 
-
 //______________________________________________________________________________
-void TH2GL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
+void TH2GL::DirectDraw(TGLRnrCtx & rnrCtx) const
 {
    // Render the object.
 
@@ -124,17 +112,10 @@ void TH2GL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
    fPlotPainter->DrawPlot();
 
    glDisable(GL_CULL_FACE);
-
-   TGLAxis ap;
-   const Rgl::Range_t & xr = fCoord.GetXRange();
-   ap.PaintGLAxis(fBoundingBox[0].CArr(), fBoundingBox[1].CArr(),
-                  xr.first, xr.second, 205);
-   const Rgl::Range_t & yr = fCoord.GetXRange();
-   ap.PaintGLAxis(fBoundingBox[0].CArr(), fBoundingBox[3].CArr(),
-                  yr.first, yr.second, 205);
-   const Rgl::Range_t & zr = fCoord.GetXRange();
-   ap.PaintGLAxis(fBoundingBox[0].CArr(), fBoundingBox[4].CArr(),
-                  zr.first, zr.second, 205);
-
    glPopAttrib();
+
+   // Axes
+   TGLAxisPainterBox axe_painter;
+   axe_painter.SetFontMode(TGLFont::kPixmap);
+   axe_painter.PlotStandard(rnrCtx, fM, fBoundingBox);
 }
diff --git a/graf3d/gl/src/TH3GL.cxx b/graf3d/gl/src/TH3GL.cxx
new file mode 100644
index 0000000..471473d
--- /dev/null
+++ b/graf3d/gl/src/TH3GL.cxx
@@ -0,0 +1,107 @@
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TH3GL.h"
+#include "TH3.h"
+#include "TVirtualPad.h"
+#include "TAxis.h"
+#include "TMath.h"
+
+#include "TGLSurfacePainter.h"
+#include "TGLHistPainter.h"
+#include "TGLLegoPainter.h"
+#include "TGLBoxPainter.h"
+#include "TGLTF3Painter.h"
+#include "TGLAxisPainter.h"
+#include "TGLCamera.h"
+
+#include "TGLRnrCtx.h"
+#include "TGLIncludes.h"
+
+//______________________________________________________________________________
+// OpenGL renderer class for TH3.
+//
+
+ClassImp(TH3GL);
+
+//______________________________________________________________________________
+TH3GL::TH3GL() :
+   TGLObject(), fM(0), fPlotPainter(0)
+{
+   // Constructor.
+
+   fDLCache = kFALSE; // Disable display list.
+}
+
+//______________________________________________________________________________
+TH3GL::~TH3GL()
+{
+   // Destructor.
+
+   delete fPlotPainter;
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+Bool_t TH3GL::SetModel(TObject* obj, const Option_t* opt)
+{
+   // Set model object.
+
+   TString option(opt);
+   option.ToLower();
+
+   if (SetModelCheckClass(obj, TH3::Class())) {
+      fM = dynamic_cast<TH3*>(obj);
+      if (option.Index("iso") != kNPOS)
+         fPlotPainter = new TGLIsoPainter(fM, 0, &fCoord);
+      else if (option.Index("box") != kNPOS)
+         fPlotPainter = new TGLBoxPainter(fM, 0, &fCoord);
+
+      fPlotPainter->AddOption(option);
+      fPlotPainter->InitGeometry();
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TH3GL::SetBBox()
+{
+   // Set bounding box.
+
+   fBoundingBox.Set(fPlotPainter->RefBackBox().Get3DBox());
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TH3GL::DirectDraw(TGLRnrCtx & rnrCtx) const
+{
+   // Render with OpenGL.
+
+   fPlotPainter->RefBackBox().FindFrontPoint();
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LIGHTING_BIT);
+
+   glEnable(GL_NORMALIZE);
+   glDisable(GL_COLOR_MATERIAL);
+
+   fPlotPainter->InitGL();
+   fPlotPainter->DrawPlot();
+
+   glDisable(GL_CULL_FACE);
+   glPopAttrib();
+
+   // Axes
+   TGLAxisPainterBox axe_painter;
+   axe_painter.SetFontMode(TGLFont::kPixmap);
+   axe_painter.PlotStandard(rnrCtx, fM, fBoundingBox);
+}
diff --git a/gui/gui/inc/LinkDef1.h b/gui/gui/inc/LinkDef1.h
index dcf0220..4fc3ade 100644
--- a/gui/gui/inc/LinkDef1.h
+++ b/gui/gui/inc/LinkDef1.h
@@ -110,5 +110,6 @@
 #pragma link C++ class TGNumberEntry;
 #pragma link C++ class TGNumberEntryLayout;
 #pragma link C++ class TGPack;
+#pragma link C++ class TGFrameElementPack;
 
 #endif
diff --git a/gui/gui/inc/TGFileBrowser.h b/gui/gui/inc/TGFileBrowser.h
index a45cd15..56a4d14 100644
--- a/gui/gui/inc/TGFileBrowser.h
+++ b/gui/gui/inc/TGFileBrowser.h
@@ -91,6 +91,7 @@ public:
    void        GetObjPicture(const TGPicture **pic, TObject *obj);
    void        GotoDir(const char *path);
    void        Selected(char *);
+   void        Update();
 
    ClassDef(TGFileBrowser, 0) // File browser.
 };
diff --git a/gui/gui/inc/TGPack.h b/gui/gui/inc/TGPack.h
index c3e3297..42bcea7 100644
--- a/gui/gui/inc/TGPack.h
+++ b/gui/gui/inc/TGPack.h
@@ -13,6 +13,28 @@
 #define ROOT_TGPack
 
 #include "TGFrame.h"
+#include "TGLayout.h"
+
+class TGSplitter;
+
+
+class  TGFrameElementPack : public TGFrameElement
+{
+private:
+   TGFrameElementPack(const TGFrameElementPack&);            // Not implemented
+   TGFrameElementPack& operator=(const TGFrameElementPack&); // Not implemented
+
+public:
+   Float_t fWeight;               // relative weight
+   TGFrameElementPack* fSplitFE; //! cached varaible for optimisation
+
+   TGFrameElementPack(TGFrame *frame, TGLayoutHints* lh = 0, Float_t weight = 1):
+      TGFrameElement(frame, lh), fWeight(weight), fSplitFE(0) { }
+
+   ClassDef(TGFrameElementPack, 0); // Class used in TGPack.
+};
+
+//==============================================================================
 
 class TGPack : public TGCompositeFrame
 {
@@ -27,6 +49,9 @@ protected:
 
    Int_t          fDragOverflow;  //!
 
+   Float_t        fWeightSum;     // total sum of sub  frame weights
+   Int_t          fNVisible;      //  number of visible frames
+
    Int_t          GetFrameLength(const TGFrame* f) const { return fVertical ? f->GetHeight() : f->GetWidth(); }
    Int_t          GetLength()                      const { return GetFrameLength(this); }
    Int_t          GetAvailableLength()             const;
@@ -34,18 +59,15 @@ protected:
    void           SetFrameLength  (TGFrame* f, Int_t len);
    void           SetFramePosition(TGFrame* f, Int_t pos);
 
-   Int_t          NumberOfRealFrames() const;
-   Int_t          LengthOfRealFrames() const;
+   void           FindFrames(TGFrame* splitter, TGFrameElementPack*& f0, TGFrameElementPack*& f1) const;
 
-   void           ResizeExistingFrames(Int_t amount);
-   void           ExpandExistingFrames(Int_t amount);
-   void           ShrinkExistingFrames(Int_t amount);
+   void           CheckSplitterVisibility();
+   void           ResizeExistingFrames();
    void           RefitFramesToPack();
 
-   void           FindFrames(TGFrame* splitter, TGFrame*& f0, TGFrame*& f1);
+   void           AddFrameInternal(TGFrame *f, TGLayoutHints* l = 0, Float_t weight = 1);
+   void           RemoveFrameInternal(TGFrame *f);
 
-   void           AddFrameInternal(TGFrame *f, TGLayoutHints* l = 0);
-   Int_t          RemoveFrameInternal(TGFrame *f);
 
 public:
    TGPack(const TGWindow *p = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = 0,
@@ -53,7 +75,9 @@ public:
    TGPack(TGClient *c, Window_t id, const TGWindow *parent = 0);
    virtual ~TGPack();
 
-   virtual void   AddFrame(TGFrame *f, TGLayoutHints *l = 0);
+   virtual void   AddFrameWithWeight(TGFrame *f, TGLayoutHints* l, Float_t w);
+   virtual void   AddFrame(TGFrame *f, TGLayoutHints* l=0);
+
    virtual void   DeleteFrame(TGFrame *f);
    virtual void   RemoveFrame(TGFrame *f);
    virtual void   ShowFrame(TGFrame *f);
@@ -61,11 +85,16 @@ public:
 
    using          TGCompositeFrame::Resize;
    virtual void   Resize(UInt_t w = 0, UInt_t h = 0);
+
+   using          TGCompositeFrame::MapSubwindows;
+   virtual void   MapSubwindows();
+
    virtual void   MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0);
    virtual void   Layout();
 
-   void           EqualizeFrames();
+   virtual void Dump() const;
 
+   void EqualizeFrames();
    void HandleSplitterStart();
    void HandleSplitterResize(Int_t delta);
 
@@ -75,8 +104,8 @@ public:
    void   SetVertical(Bool_t x);
 
    // For now assume this is always true. Lenght of splitter = 4 pixels.
-   // Bool_t GetUseSplitters() const { return fUseSplitters; }
-   // void SetUseSplitters(Bool_t x) { fUseSplitters = x; }
+   Bool_t GetUseSplitters() const { return fUseSplitters; }
+   void SetUseSplitters(Bool_t x) { fUseSplitters = x; }
 
    ClassDef(TGPack, 0); // Horizontal or vertical stack of frames.
 };
diff --git a/gui/gui/src/TGDoubleSlider.cxx b/gui/gui/src/TGDoubleSlider.cxx
index 3702efc..c1214c1 100644
--- a/gui/gui/src/TGDoubleSlider.cxx
+++ b/gui/gui/src/TGDoubleSlider.cxx
@@ -278,7 +278,7 @@ void TGDoubleVSlider::DoRedraw()
       for (int i = 0; i <= lines; i++) {
          int y = i * fScale + (i * remain) / lines;
          gVirtualX->DrawLine(fId, GetBlackGC()(), fWidth/2+8, y+7, fWidth/2+10, y+7);
-         if ((fScaleType && kDoubleScaleBoth))
+         if ((fScaleType & kDoubleScaleBoth))
             gVirtualX->DrawLine(fId, GetBlackGC()(), fWidth/2-9, y+7, fWidth/2-11, y+7);
       }
    }
@@ -468,7 +468,7 @@ void TGDoubleHSlider::DoRedraw()
       for (int i = 0; i <= lines; i++) {
          int x = i * fScale + (i * remain) / lines;
          gVirtualX->DrawLine(fId, GetBlackGC()(), x+7, fHeight/2+8, x+7, fHeight/2+10);
-         if ((fScaleType && kDoubleScaleBoth))
+         if ((fScaleType & kDoubleScaleBoth))
             gVirtualX->DrawLine(fId, GetBlackGC()(), x+7, fHeight/2-9, x+7, fHeight/2-11);
       }
    }
diff --git a/gui/gui/src/TGFileBrowser.cxx b/gui/gui/src/TGFileBrowser.cxx
index a039fd3..6d857c1 100644
--- a/gui/gui/src/TGFileBrowser.cxx
+++ b/gui/gui/src/TGFileBrowser.cxx
@@ -174,7 +174,7 @@ void TGFileBrowser::CreateBrowser()
    AddFrame(fBotFrame, new TGLayoutHints(kLHintsLeft | kLHintsTop |
             kLHintsExpandX, 2, 2, 2, 2));
 
-   fContextMenu = new TContextMenu("FileBrowserContextMenu") ;
+   fContextMenu = new TContextMenu("FileBrowserContextMenu");
    fFilter      = 0;
    fGroupSize   = 1000;
    fListLevel   = 0;
@@ -486,6 +486,7 @@ void TGFileBrowser::Refresh(Bool_t /*force*/)
 {
    // Refresh content of the list tree.
 
+   TTimer::SingleShot(200, "TGFileBrowser", this, "Update()");
    return; // disable refresh for the time being...
    TCursorSwitcher cursorSwitcher(this, fListTree);
    static UInt_t prev = 0;
@@ -501,6 +502,27 @@ void TGFileBrowser::Refresh(Bool_t /*force*/)
    }
 }
 
+//______________________________________________________________________________
+void TGFileBrowser::Update()
+{
+   // Update content of the list tree.
+
+   TGListTreeItem *item = fCurrentDir;
+   if (!item) item = fRootDir;
+   //fListTree->DeleteChildren(item);
+   TGListTreeItem *curr = fListTree->GetSelected(); // GetCurrent() ??
+   if (curr) {
+      TObject *obj = (TObject *) curr->GetUserData();
+      if (obj && obj->InheritsFrom("TObjString")) {
+         TString fullpath = FullPathName(curr);
+         if (gSystem->AccessPathName(fullpath.Data())) {
+            fListTree->DeleteItem(curr);
+         }
+      }
+   }
+   DoubleClicked(item, 1);
+}
+
 /**************************************************************************/
 // Other
 /**************************************************************************/
@@ -707,7 +729,7 @@ void TGFileBrowser::Clicked(TGListTreeItem *item, Int_t btn, Int_t x, Int_t y)
    CheckRemote(item);
    if (item && btn == kButton3) {
       TObject *obj = (TObject *) item->GetUserData();
-      if (obj) {
+      if (obj && !obj->InheritsFrom("TObjString")) {
          if (obj->InheritsFrom("TKey") && (obj->IsA() != TClass::Class())) {
             Chdir(item);
             const char *clname = (const char *)gROOT->ProcessLine(TString::Format("((TKey *)0x%lx)->GetClassName();", obj));
@@ -724,7 +746,7 @@ void TGFileBrowser::Clicked(TGListTreeItem *item, Int_t btn, Int_t x, Int_t y)
              obj->InheritsFrom("TBranch")) {
             Chdir(item);
          }
-         fContextMenu->Popup(x, y, obj);
+         fContextMenu->Popup(x, y, obj, fBrowser);
       }
       else {
          fListTree->GetPathnameFromItem(item, path);
@@ -735,13 +757,13 @@ void TGFileBrowser::Clicked(TGListTreeItem *item, Int_t btn, Int_t x, Int_t y)
                fCurrentDir = item;
                if (fDir) delete fDir;
                fDir = new TSystemDirectory(item->GetText(), fullpath.Data());
-               fContextMenu->Popup(x, y, fDir);
+               fContextMenu->Popup(x, y, fDir, fBrowser);
             }
             else {
                fCurrentDir = item->GetParent();
                if (fFile) delete fFile;
                fFile = new TSystemFile(item->GetText(), fullpath.Data());
-               fContextMenu->Popup(x, y, fFile);
+               fContextMenu->Popup(x, y, fFile, fBrowser);
             }
          }
       }
@@ -946,7 +968,7 @@ void TGFileBrowser::DoubleClicked(TGListTreeItem *item, Int_t /*btn*/)
          TSystemFile *file;
          TString fname;
          // directories first
-         fListTree->DeleteChildren(item);
+         //fListTree->DeleteChildren(item);
          while ((file=(TSystemFile*)next())) {
             fname = file->GetName();
             if (file->IsDirectory()) {
diff --git a/gui/gui/src/TGPack.cxx b/gui/gui/src/TGPack.cxx
index b19aa6e..3e1b493 100644
--- a/gui/gui/src/TGPack.cxx
+++ b/gui/gui/src/TGPack.cxx
@@ -11,9 +11,7 @@
 
 #include "TGPack.h"
 #include "TGSplitter.h"
-
-#include <algorithm>
-#include <vector>
+#include "TMath.h"
 
 //______________________________________________________________________________
 //
@@ -34,7 +32,9 @@ TGPack::TGPack(const TGWindow *p, UInt_t w, UInt_t h, UInt_t options, Pixel_t ba
    fVertical     (kTRUE),
    fUseSplitters (kTRUE),
    fSplitterLen  (4),
-   fDragOverflow (0)
+   fDragOverflow (0),
+   fWeightSum(0),
+   fNVisible(0)
 {
    // Constructor.
 
@@ -68,8 +68,8 @@ Int_t TGPack::GetAvailableLength() const
    // Return length of entire frame without splitters.
 
    Int_t len = fVertical ? GetHeight() : GetWidth();
-   if (fUseSplitters)
-      len -= fSplitterLen * (fList->GetSize() - 1) / 2;
+   len -= fSplitterLen * (fNVisible - 1);
+
    return len;
 }
 
@@ -96,143 +96,89 @@ void TGPack::SetFramePosition(TGFrame* f, Int_t pos)
 }
 
 //______________________________________________________________________________
-Int_t TGPack::NumberOfRealFrames() const
-{
-   // Returns number of frames in pack excluding the splitters.
-
-   if (fUseSplitters)
-      return (fList->GetSize() + 1) / 2;
-   else
-      return  fList->GetSize();
-}
-
-//______________________________________________________________________________
-Int_t TGPack::LengthOfRealFrames() const
+void TGPack::CheckSplitterVisibility()
 {
-   // Returns length of frames in pack excluding the splitters.
+   // Check if splitter of first visible frame is hidden.
+   // Check if the next following visible splitter is visible.
 
-   Int_t l = 0;
-
-   TGFrameElement *el;
+   TGFrameElementPack *el;
    TIter next(fList);
-
-   while ((el = (TGFrameElement *) next()))
+   Int_t rvf = 0;
+   while ((el = (TGFrameElementPack*) next()))
    {
-      l += GetFrameLength(el->fFrame);
-
-      if (fUseSplitters)
-         next();
+      if (el->fState && el->fSplitFE)
+      {
+         if (rvf)
+         {
+            // unmap first slider if necessary
+            if ( el->fSplitFE->fState == 0 ) { 
+               el->fSplitFE->fState = 1;
+               el->fSplitFE->fFrame->MapWindow();
+            }
+         }
+         else
+         {
+            // show slider in next visible frame
+            if (el->fSplitFE->fState) {
+               el->fSplitFE->fState = 0;
+               el->fSplitFE->fFrame->UnmapWindow();
+            }
+         }
+         ++rvf;
+      }
    }
-
-   return l;
 }
 
 //______________________________________________________________________________
-void TGPack::ResizeExistingFrames(Int_t amount)
+void TGPack::ResizeExistingFrames()
 {
    // Resize (shrink or expand) existing frames by amount in total.
 
-   if (amount > 0)
-      ExpandExistingFrames(amount);
-   else if (amount < 0)
-      ShrinkExistingFrames(-amount);
-
-   RefitFramesToPack();
-}
-
-//______________________________________________________________________________
-void TGPack::ExpandExistingFrames(Int_t amount)
-{
-   // Expand existing frames by amount in total.
-
    if (fList->IsEmpty())
       return;
 
-   Int_t length    = LengthOfRealFrames();
-   Int_t remainder = amount;
+   // get unitsize
+   Int_t nflen  = GetAvailableLength();
+   Float_t unit = Float_t(nflen)/fWeightSum;
 
-   std::vector<TGFrame*> frame_vec;
+   // set frame sizes
+   Int_t sumFrames = 0;
+   Int_t frameLength = 0;
    {
-      TGFrameElement *el;
+      TGFrameElementPack *el;
       TIter next(fList);
-      while ((el = (TGFrameElement *) next()))
+      while ((el = (TGFrameElementPack*) next()))
       {
-         Int_t l = GetFrameLength(el->fFrame);
-         Int_t d = (l * amount) / length;
-         SetFrameLength(el->fFrame, l + d);
-         remainder -= d;
-
-         frame_vec.push_back(el->fFrame);
-
-         if (fUseSplitters)
-            next();
-      }
-   }
-
-   std::random_shuffle(frame_vec.begin(), frame_vec.end());
-
-   while (remainder > 0)
-   {
-      std::vector<TGFrame*>::iterator fi = frame_vec.begin();
-      while (fi != frame_vec.end() && remainder > 0)
-      {
-         Int_t l = GetFrameLength(*fi);
-         if (l > 0)
+         if (el->fState && el->fWeight)
          {
-            SetFrameLength(*fi, l + 1);
-            --remainder;
+            frameLength = TMath::Nint( unit*(el->fWeight));
+            SetFrameLength(el->fFrame, frameLength);
+            sumFrames += frameLength;
          }
-         ++fi;
       }
    }
-}
-
-//______________________________________________________________________________
-void TGPack::ShrinkExistingFrames(Int_t amount)
-{
-   // Shrink existing frames by amount in total.
-
-   Int_t length    = LengthOfRealFrames();
-   Int_t remainder = amount;
 
-   std::vector<TGFrame*> frame_vec;
+   // redistribute the remain
    {
+      // printf("available %d total %d \n", nflen, sumFrames);
+      Int_t remain =  nflen-sumFrames;
+      Int_t step = TMath::Sign(1, remain);
+      TGFrameElementPack *el;
       TIter next(fList);
-      TGFrameElement *el;
-      while ((el = (TGFrameElement *) next()))
+      while ((el = (TGFrameElementPack*) next()) && remain)
       {
-         Int_t l = GetFrameLength(el->fFrame);
-         Int_t d = (l * amount) / length;
-         SetFrameLength(el->fFrame, l - d);
-         remainder -= d;
-
-         frame_vec.push_back(el->fFrame);
-
-         if (fUseSplitters)
-            next();
-      }
-   }
-
-   std::random_shuffle(frame_vec.begin(), frame_vec.end());
-
-   Bool_t all_one = kFALSE;
-   while (remainder > 0 && ! all_one)
-   {
-      all_one = kTRUE;
-
-      std::vector<TGFrame*>::iterator fi = frame_vec.begin();
-      while (fi != frame_vec.end() && remainder > 0)
-      {
-         Int_t l = GetFrameLength(*fi);
-         if (l > 1)
+         if (el->fState &&  el->fWeight)
          {
-            all_one = kFALSE;
-            SetFrameLength(*fi, l - 1);
-            --remainder;
+            Int_t l = GetFrameLength(el->fFrame) + step;
+            if (l > 0)
+            {
+               SetFrameLength(el->fFrame, l);
+               remain -= step;
+            }
          }
-         ++fi;
       }
    }
+   RefitFramesToPack();
 }
 
 //______________________________________________________________________________
@@ -253,103 +199,116 @@ void TGPack::RefitFramesToPack()
 }
 
 //______________________________________________________________________________
-void TGPack::FindFrames(TGFrame* splitter, TGFrame*& f0, TGFrame*& f1)
+void TGPack::FindFrames(TGFrame* splitter, TGFrameElementPack*& f0, TGFrameElementPack*& f1) const
 {
    // Find frames around splitter and return them f0 (previous) and f1 (next).
 
-   TGFrameElement *el;
+   TGFrameElementPack *el;
    TIter next(fList);
 
-   while ((el = (TGFrameElement *) next()))
+   while ((el = (TGFrameElementPack *) next()))
    {
       if (el->fFrame == splitter)
          break;
-      f0 = el->fFrame;
+      f0 = el;
    }
-   el = (TGFrameElement *) next();
-   f1 = el->fFrame;
+   f1 = (TGFrameElementPack *) next();
 }
 
+
 //------------------------------------------------------------------------------
 
 //______________________________________________________________________________
-void TGPack::AddFrameInternal(TGFrame* f, TGLayoutHints* l)
+void TGPack::AddFrameInternal(TGFrame* f, TGLayoutHints* l, Float_t weight)
 {
    // Add frame f at the end.
    // LayoutHints are ignored in TGPack.
 
-   Int_t n     = NumberOfRealFrames();
-   Int_t nflen = (GetLength() - (fUseSplitters ? fSplitterLen*n : 0)) / (n + 1);
-
-   // printf("New frame, n=%d, new_frame_len=%d\n", n, nflen);
+   // add splitter
+   TGFrameElementPack *sf = 0;
+   if (fUseSplitters) {
+      TGSplitter* s = 0;
+      if (fVertical)
+         s = new TGHSplitter(this, GetWidth(), fSplitterLen, kTRUE);
+      else
+         s = new TGVSplitter(this, fSplitterLen, GetHeight(), kTRUE);
+      s->Connect("Moved(Int_t)",  "TGPack", this, "HandleSplitterResize(Int_t)");
+      s->Connect("DragStarted()", "TGPack", this, "HandleSplitterStart()");
+
+      sf = new TGFrameElementPack(s, l ? l : fgDefaultHints, 0);
+      fList->Add(sf);
+      // in case of recusive cleanup, propagate cleanup setting to all
+      // child composite frames
+      if (fMustCleanup == kDeepCleanup)
+         s->SetCleanup(kDeepCleanup);
+      s->MapWindow();
+   }
 
-   if (n > 0)
-   {
-      ShrinkExistingFrames(nflen);
+   // instread TGCopositeFrame::AddFrame
+   TGFrameElementPack *el = new TGFrameElementPack(f, l ? l : fgDefaultHints, weight);
+   el->fSplitFE = sf;
+   fList->Add(el);
 
-      if (fUseSplitters) {
-         nflen -= fSplitterLen;
-         TGSplitter* s = 0;
-         if (fVertical)
-            s = new TGHSplitter(this, GetWidth(), fSplitterLen, kTRUE);
-         else
-            s = new TGVSplitter(this, fSplitterLen, GetHeight(), kTRUE);
-         s->Connect("Moved(Int_t)",  "TGPack", this, "HandleSplitterResize(Int_t)");
-         s->Connect("DragStarted()", "TGPack", this, "HandleSplitterStart()");
-         TGCompositeFrame::AddFrame(s);
-         s->MapWindow();
-      }
-   }
-   SetFrameLength(f, nflen);
-   TGCompositeFrame::AddFrame(f, l);
+   // in case of recusive cleanup, propagate cleanup setting to all
+   // child composite frames
+   if (fMustCleanup == kDeepCleanup)
+      f->SetCleanup(kDeepCleanup);
    f->MapWindow();
+
+   fNVisible ++;
+   fWeightSum += weight;
+
+   CheckSplitterVisibility();
+   ResizeExistingFrames();
 }
 
 //______________________________________________________________________________
-void TGPack::AddFrame(TGFrame* f, TGLayoutHints* l)
+void TGPack::AddFrameWithWeight(TGFrame* f, TGLayoutHints *l, Float_t weight)
 {
-   // Add frame f at the end.
+   // Add frame f at the end with given weight.
    // LayoutHints are ignored in TGPack.
 
-   AddFrameInternal(f, l);
+   AddFrameInternal(f, l, weight);
+   Layout();
+}
 
+//______________________________________________________________________________
+void TGPack::AddFrame(TGFrame* f, TGLayoutHints *l)
+{
+   // Add frame f at the end with default weight.
+   // LayoutHints are ignored in TGPack.
+
+   AddFrameInternal(f, l, 1);
    Layout();
 }
 
 //______________________________________________________________________________
-Int_t TGPack::RemoveFrameInternal(TGFrame* f)
+void TGPack::RemoveFrameInternal(TGFrame* f)
 {
    // Remove frame f.
 
-   TGFrameElement *el = FindFrameElement(f);
-
-   if (!el) return 0;
+   TGFrameElementPack *el = (TGFrameElementPack*)FindFrameElement(f);
 
-   Int_t space_freed = 0;
+   if (!el || el->fState == 0 ) return;
 
-   if (fUseSplitters && NumberOfRealFrames() > 1)
+   if (fUseSplitters )
    {
-      TGFrameElement *splitter_el = 0;
-      if (el == fList->First())
-         splitter_el = (TGFrameElement*) fList->After(el);
-      else
-         splitter_el = (TGFrameElement*) fList->Before(el);
-      TGFrame* splitter = splitter_el->fFrame;
-      space_freed += fSplitterLen;
+      TGFrame* splitter = el->fSplitFE->fFrame;
       splitter->UnmapWindow();
       TGCompositeFrame::RemoveFrame(splitter);
       // This is needed so that splitter window gets destroyed on server.
       splitter->ReparentWindow(fClient->GetDefaultRoot());
       delete splitter;
    }
-
-   space_freed += GetFrameLength(f);
    f->UnmapWindow();
    TGCompositeFrame::RemoveFrame(f);
 
-   // printf("Removed frame, n=%d, space_freed=%d\n", NumberOfRealFrames(), space_freed);
 
-   return space_freed;
+   fNVisible --;
+   fWeightSum -= el->fWeight;
+
+   CheckSplitterVisibility();
+   ResizeExistingFrames();
 }
 
 //______________________________________________________________________________
@@ -358,13 +317,9 @@ void TGPack::DeleteFrame(TGFrame* f)
    // Remove frame f and refit existing frames to pack size.
    // Frame is deleted.
 
-   Int_t space_freed = RemoveFrameInternal(f);
-   if (space_freed)
-   {
-      delete f;
-      ResizeExistingFrames(space_freed);
-      Layout();
-   }
+   RemoveFrameInternal(f);
+   delete f;
+   Layout();
 }
 
 //______________________________________________________________________________
@@ -373,35 +328,115 @@ void TGPack::RemoveFrame(TGFrame* f)
    // Remove frame f and refit existing frames to pack size.
    // Frame is not deleted.
 
-   Int_t space_freed = RemoveFrameInternal(f);
-   if (space_freed)
+   RemoveFrameInternal(f);
+   Layout();
+}
+
+//______________________________________________________________________________
+void TGPack::Dump() const
+{
+   // Print sub frame info.
+
+   printf("--------------------------------------------------------------\n");
+   Int_t cnt = 0;
+   TGFrameElementPack *el;
+   TIter next(fList);
+   while ((el = (TGFrameElementPack *) next()))
    {
-      ResizeExistingFrames(space_freed);
-      Layout();
+      printf("idx[%d] visible(%d) %s  \n",cnt, el->fState, el->fFrame->GetName());
+      cnt++;
    }
+   printf("--------------------------------------------------------------\n");
 }
 
 //______________________________________________________________________________
-void TGPack::ShowFrame(TGFrame* /*f*/)
+void TGPack::ShowFrame(TGFrame* f)
 {
+   // Show sub frame.
    // Virtual from TGCompositeFrame.
-   // This operation not supported by pack.
 
-   Error("ShowFrame", "not yet supported.");
+   TGFrameElementPack *el = (TGFrameElementPack*)FindFrameElement(f);
+   if (el)
+   {
+      //show
+      el->fState = 1;
+      el->fFrame->MapWindow();
+
+      // show splitter
+      if (fUseSplitters)
+      {
+         el->fSplitFE->fFrame->MapWindow();
+         el->fSplitFE->fState = 1;
+      }
+
+      // Dump();
+      fNVisible++;
+      fWeightSum += el->fWeight;
+
+      CheckSplitterVisibility();
+      ResizeExistingFrames();
+      Layout();
+   }
 }
 
 //______________________________________________________________________________
-void TGPack::HideFrame(TGFrame* /*f*/)
+void TGPack::HideFrame(TGFrame* f)
 {
+   // Hide sub frame.
    // Virtual from TGCompositeFrame.
-   // This operation not supported by pack.
 
-   Error("HideFrame", "not yet supported.");
+   TGFrameElementPack *el = (TGFrameElementPack*) FindFrameElement(f);
+   if (el)
+   {
+      // hide real frame
+      el->fState = 0;
+      el->fFrame->UnmapWindow();
+
+      // hide splitter
+      if (fUseSplitters)
+      {
+         el->fSplitFE->fFrame->UnmapWindow();
+         el->fSplitFE->fState = 0;
+      }
+
+      // Dump();
+      fNVisible--;
+      fWeightSum -= el->fWeight;
+
+      CheckSplitterVisibility();
+      ResizeExistingFrames();
+      Layout();
+   }
 }
 
 //------------------------------------------------------------------------------
 
 //______________________________________________________________________________
+void TGPack::MapSubwindows()
+{
+   // Virtual method of TGcompositeFrame.
+   // Map all sub windows that are part of the composite frame.
+
+   if (!fMapSubwindows) {
+      return;
+   }
+
+   if (!fList) return;
+
+   TGFrameElement *el;
+   TIter next(fList);
+
+   while ((el = (TGFrameElement *) next())) {
+      if (el->fFrame && el->fState) {
+         el->fFrame->MapWindow();
+         el->fFrame->MapSubwindows();
+         TGFrameElement *fe = el->fFrame->GetFrameElement();
+         if (fe) fe->fState |= kIsVisible;
+      }
+   }
+}
+
+//______________________________________________________________________________
 void TGPack::Resize(UInt_t w, UInt_t h)
 {
    // Resize the pack.
@@ -409,13 +444,11 @@ void TGPack::Resize(UInt_t w, UInt_t h)
 
    if (w == fWidth && h == fHeight) return;
 
-   Int_t delta = fVertical ? h - GetHeight() : w - GetWidth();
-
    fWidth  = w;
    fHeight = h;
    TGWindow::Resize(fWidth, fHeight);
 
-   ResizeExistingFrames(delta);
+   ResizeExistingFrames();
 
    Layout();
 }
@@ -442,9 +475,12 @@ void TGPack::Layout()
 
    while ((el = (TGFrameElement *) next()))
    {
-      SetFramePosition(el->fFrame, pos);
-      pos += GetFrameLength(el->fFrame);
-      el->fFrame->Layout();
+      if (el->fState)
+      {
+         SetFramePosition(el->fFrame, pos);
+         pos += GetFrameLength(el->fFrame);
+         el->fFrame->Layout();
+      }
    }
 }
 
@@ -456,25 +492,19 @@ void TGPack::EqualizeFrames()
    if (fList->IsEmpty())
       return;
 
-   Int_t length = GetAvailableLength();
-   Int_t nf     = NumberOfRealFrames();
-   Int_t lpf    = (Int_t) (((Double_t) length) / nf);
-   Int_t extra  = length - nf*lpf;
-
-   TGFrameElement *el;
+   fWeightSum = 0;
+   TGFrameElementPack *el;
    TIter next(fList);
-
-   while ((el = (TGFrameElement *) next()))
+   while ((el = (TGFrameElementPack *) next()))
    {
-      SetFrameLength(el->fFrame, lpf + extra);
-      extra = 0;
-
-      if (fUseSplitters)
-         next();
+      el->fWeight = 1;
+      if (el->fState)
+         fWeightSum ++;
    }
-}
 
-//------------------------------------------------------------------------------
+   ResizeExistingFrames();
+   Layout();
+}
 
 //______________________________________________________________________________
 void TGPack::HandleSplitterStart()
@@ -489,13 +519,14 @@ void TGPack::HandleSplitterResize(Int_t delta)
 {
    // Handle resize events from splitters.
 
-   Int_t min_dec = - (GetAvailableLength() + NumberOfRealFrames());
+   Int_t available = GetAvailableLength();
+   Int_t min_dec = - (available + fNVisible*2 -1);
    if (delta <  min_dec)
       delta = min_dec;
 
    TGSplitter *s = dynamic_cast<TGSplitter*>((TGFrame*) gTQSender);
 
-   TGFrame *f0=0, *f1=0;
+   TGFrameElementPack *f0=0, *f1=0;
    FindFrames(s, f0, f1);
 
    if (fDragOverflow < 0)
@@ -519,28 +550,34 @@ void TGPack::HandleSplitterResize(Int_t delta)
       }
    }
 
+   Int_t l0 = GetFrameLength(f0->fFrame);
+   Int_t l1 = GetFrameLength(f1->fFrame);
    if (delta < 0)
    {
-      Int_t l = GetFrameLength(f0);
-      if (l - 1 < -delta)
+      if (l0 - 1 < -delta)
       {
-         fDragOverflow += delta + l - 1;
-         delta = -l + 1;
+         fDragOverflow += delta + l0 - 1;
+         delta = -l0 + 1;
       }
-      SetFrameLength(f0, l + delta);
-      SetFrameLength(f1, GetFrameLength(f1) - delta);
    }
    else
    {
-      Int_t l = GetFrameLength(f1);
-      if (l - 1 < delta)
+      if (l1 - 1 < delta)
       {
-         fDragOverflow += delta - l + 1;
-         delta = l - 1;
+         fDragOverflow += delta - l1 + 1;
+         delta = l1 - 1;
       }
-      SetFrameLength(f0, GetFrameLength(f0) + delta);
-      SetFrameLength(f1, l - delta);
    }
+   l0 += delta;
+   l1 -= delta;
+   SetFrameLength(f0->fFrame, l0);
+   SetFrameLength(f1->fFrame, l1);
+   Float_t weightDelta = Float_t(delta)/available;
+   weightDelta *= fWeightSum;
+   f0->fWeight += weightDelta;
+   f1->fWeight -= weightDelta;
+
+   ResizeExistingFrames();
    Layout();
 }
 
diff --git a/gui/guihtml/inc/TGHtmlBrowser.h b/gui/guihtml/inc/TGHtmlBrowser.h
index d78dfab..7d184b3 100644
--- a/gui/guihtml/inc/TGHtmlBrowser.h
+++ b/gui/guihtml/inc/TGHtmlBrowser.h
@@ -59,11 +59,11 @@ public:
                  UInt_t w = 900, UInt_t h = 600);
    virtual ~TGHtmlBrowser() { ; }
 
-   virtual void      CloseWindow();
    virtual Bool_t    ProcessMessage(Long_t msg, Long_t parm1, Long_t);
    void              Selected(const char *txt);
    void              URLChanged();
    void              Back();
+   Bool_t            CheckAnchors(const char *);
    void              Forward();
    void              Reload();
    void              Stop();
diff --git a/gui/guihtml/src/TGHtmlBrowser.cxx b/gui/guihtml/src/TGHtmlBrowser.cxx
index ce882ca..159f185 100644
--- a/gui/guihtml/src/TGHtmlBrowser.cxx
+++ b/gui/guihtml/src/TGHtmlBrowser.cxx
@@ -221,21 +221,56 @@ TGHtmlBrowser::TGHtmlBrowser(const char *filename, const TGWindow *p, UInt_t w,
    fHtml->Connect("MouseOver(const char *)", "TGHtmlBrowser", this, "MouseOver(const char *)");
    fHtml->Connect("MouseDown(const char *)", "TGHtmlBrowser", this, "MouseDown(const char *)");
 
-   Selected(filename);
-
    MapSubwindows();
    Resize(GetDefaultSize());
    MapWindow();
    Resize(w, h);
+
+   if (filename)
+      Selected(filename);
 }
 
 //______________________________________________________________________________
-void TGHtmlBrowser::CloseWindow()
+Ssiz_t ReadSize(const char *url)
 {
-   // Close TGHtmlBrowser window.
+   // Read (open) remote files.
+
+   char buf[4096];
+   TUrl fUrl(url);
+
+   // Give full URL so Apache's virtual hosts solution works.
+   TString msg = "HEAD ";
+   msg += fUrl.GetProtocol();
+   msg += "://";
+   msg += fUrl.GetHost();
+   msg += ":";
+   msg += fUrl.GetPort();
+   msg += "/";
+   msg += fUrl.GetFile();
+   msg += " HTTP/1.0";
+   msg += "\r\n";
+   msg += "User-Agent: ROOT-TWebFile/1.1";
+   msg += "\r\n\r\n";
 
-   Cleanup();
-   DeleteWindow();
+   TString uri(url);
+   if (!uri.BeginsWith("http://"))
+      return 0;
+   TSocket s(fUrl.GetHost(), fUrl.GetPort());
+   if (!s.IsValid())
+      return 0;
+   if (s.SendRaw(msg.Data(), msg.Length()) == -1)
+      return 0;
+   if (s.RecvRaw(buf, 4096) == -1) {
+      return 0;
+   }
+   TString reply(buf);
+   Ssiz_t idx = reply.Index("Content-length:", 0, TString::kIgnoreCase);
+   if (idx > 0) {
+      idx += 15;
+      TString slen = reply(idx, reply.Length() - idx);
+      return (Ssiz_t)atol(slen.Data());
+   }
+   return 0;
 }
 
 //______________________________________________________________________________
@@ -246,6 +281,9 @@ static char *ReadRemote(const char *url)
    static char *buf = 0;
    TUrl fUrl(url);
 
+   Ssiz_t size = ReadSize(url);
+   if (size <= 0) size = 1024*1024;
+
    TString msg = "GET ";
    msg += fUrl.GetProtocol();
    msg += "://";
@@ -264,7 +302,6 @@ static char *ReadRemote(const char *url)
       return 0;
    if (s.SendRaw(msg.Data(), msg.Length()) == -1)
       return 0;
-   Int_t size = 1024*1024;
    buf = (char *)calloc(size, sizeof(char));
    if (s.RecvRaw(buf, size) == -1) {
       free(buf);
@@ -281,14 +318,19 @@ void TGHtmlBrowser::Selected(const char *uri)
    char *buf = 0;
    FILE *f;
 
+   if (CheckAnchors(uri))
+      return;
+
    TString surl(gSystem->UnixPathName(uri));
-   if (!surl.BeginsWith("http://") && !surl.BeginsWith("file://")) {
+   if (!surl.BeginsWith("http://") && !surl.BeginsWith("ftp://") &&
+       !surl.BeginsWith("file://")) {
       if (surl.BeginsWith("file:"))
          surl.ReplaceAll("file:", "file://");
       else
          surl.Prepend("file://");
    }
    if (surl.EndsWith(".root")) {
+      // in case of root file, just open it and refresh browsers
       gVirtualX->SetCursor(fHtml->GetId(), gVirtualX->CreateCursor(kWatch));
       gROOT->ProcessLine(Form("TFile::Open(\"%s\");", surl.Data()));
       Clicked((char *)surl.Data());
@@ -298,7 +340,32 @@ void TGHtmlBrowser::Selected(const char *uri)
    }
    gVirtualX->SetCursor(fHtml->GetId(), gVirtualX->CreateCursor(kWatch));
    TUrl url(surl.Data());
+   if (surl.EndsWith(".pdf", TString::kIgnoreCase)) {
+      // special case: open pdf files with external viewer
+      // works only on Windows for the time being...
+      if (!gVirtualX->InheritsFrom("TGX11")) {
+         TString cmd = TString::Format("explorer %s", surl.Data());
+         gSystem->Exec(cmd.Data());
+      }
+      gVirtualX->SetCursor(fHtml->GetId(), gVirtualX->CreateCursor(kPointer));
+      return;
+   }
+   if (surl.EndsWith(".gif") || surl.EndsWith(".jpg") || surl.EndsWith(".png")) {
+      // special case: single picture
+      fHtml->Clear();
+      char imgHtml[1024];
+      sprintf(imgHtml, "<IMG src=\"%s\"> ", surl.Data());
+      fHtml->ParseText(imgHtml);
+      fHtml->SetBaseUri(url.GetUrl());
+      fURL->SetText(surl.Data());
+      if (!fComboBox->FindEntry(surl.Data()))
+         fComboBox->AddEntry(surl.Data(), fComboBox->GetNumberOfEntries()+1);
+      fHtml->Layout();
+      gVirtualX->SetCursor(fHtml->GetId(), gVirtualX->CreateCursor(kPointer));
+      return;
+   }
    if ((!strcmp(url.GetProtocol(), "http"))) {
+      // standard web page
       buf = ReadRemote(url.GetUrl());
       if (buf) {
          fHtml->Clear();
@@ -320,6 +387,7 @@ void TGHtmlBrowser::Selected(const char *uri)
       }
    }
    else {
+      // local file
       f = fopen(url.GetFile(), "r");
       if (f) {
          TString fpath = url.GetUrl();
@@ -347,8 +415,15 @@ void TGHtmlBrowser::Selected(const char *uri)
          }
       }
    }
+   // restore cursor
    gVirtualX->SetCursor(fHtml->GetId(), gVirtualX->CreateCursor(kPointer));
    fHtml->Layout();
+   Ssiz_t idx = surl.Last('#');
+   if (idx > 0) {
+      idx +=1; // skip #
+      TString anchor = surl(idx, surl.Length() - idx);
+      fHtml->GotoAnchor(anchor.Data());
+   }
    SetWindowName(Form("%s - RHTML",surl.Data()));
 }
 
@@ -385,6 +460,46 @@ void TGHtmlBrowser::Back()
 }
 
 //______________________________________________________________________________
+Bool_t TGHtmlBrowser::CheckAnchors(const char *uri)
+{
+   // Check if we just change position in the page (using anchor)
+   // and return kTRUE if any anchor has been found and followed.
+
+   TString surl(gSystem->UnixPathName(uri));
+
+   if (!fHtml->GetBaseUri())
+      return kFALSE;
+   TString actual = fHtml->GetBaseUri();
+   Ssiz_t idx = surl.Last('#');
+   Ssiz_t idy = actual.Last('#');
+   TString short1(surl.Data());
+   TString short2(actual.Data());
+   if (idx > 0)
+      short1 = surl(0, idx);
+   if (idy > 0)
+      short2 = actual(0, idy);
+
+   if (short1 == short2) {
+      if (idx > 0) {
+         idx +=1; // skip #
+         TString anchor = surl(idx, surl.Length() - idx);
+         fHtml->GotoAnchor(anchor.Data());
+      }
+      else {
+         fHtml->ScrollToPosition(TGLongPosition(0, 0));
+      }
+      fHtml->SetBaseUri(surl.Data());
+      if (!fComboBox->FindEntry(surl.Data()))
+         fComboBox->AddEntry(surl.Data(), fComboBox->GetNumberOfEntries()+1);
+      fURL->SetText(surl.Data());
+      fComboBox->Select(fComboBox->GetNumberOfEntries(), kFALSE);
+      SetWindowName(Form("%s - RHTML",surl.Data()));
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
 void TGHtmlBrowser::Forward()
 {
    // Handle "Forward" navigation button.
diff --git a/tutorials/eve/MultiView.C b/tutorials/eve/MultiView.C
new file mode 100644
index 0000000..e8857e0
--- /dev/null
+++ b/tutorials/eve/MultiView.C
@@ -0,0 +1,147 @@
+#include <TEveManager.h>
+
+#include <TEveViewer.h>
+#include <TGLViewer.h>
+
+#include <TEveScene.h>
+
+#include <TEveProjectionManager.h>
+#include <TEveProjectionAxes.h>
+
+#include <TEveBrowser.h>
+#include <TEveWindow.h>
+
+// MultiView
+//
+// Structure encapsulating standard views: 3D, r-phi and rho-z.
+// Includes scenes and projection managers.
+//
+// Should be used in compiled mode.
+
+struct MultiView
+{
+   TEveProjectionManager *fRPhiMgr;
+   TEveProjectionManager *fRhoZMgr;
+
+   TEveViewer            *f3DView;
+   TEveViewer            *fRPhiView;
+   TEveViewer            *fRhoZView;
+
+   TEveScene             *fRPhiGeomScene;
+   TEveScene             *fRhoZGeomScene;
+   TEveScene             *fRPhiEventScene;
+   TEveScene             *fRhoZEventScene;
+
+   //-------------------------------------------------------------------------
+
+   MultiView()
+   {
+      // Constructor --- creates required scenes, projection managers
+      // and GL viewers.
+
+      // Scenes
+      //========
+
+      fRPhiGeomScene  = gEve->SpawnNewScene("RPhi Geometry",
+                                            "Scene holding projected geometry for the RPhi view.");
+      fRhoZGeomScene  = gEve->SpawnNewScene("RhoZ Geometry",
+                                            "Scene holding projected geometry for the RhoZ view.");
+      fRPhiEventScene = gEve->SpawnNewScene("RPhi Event Data",
+                                            "Scene holding projected event-data for the RPhi view.");
+      fRhoZEventScene = gEve->SpawnNewScene("RhoZ Event Data",
+                                            "Scene holding projected event-data for the RhoZ view.");
+
+
+      // Projection managers
+      //=====================
+
+      fRPhiMgr = new TEveProjectionManager();
+      fRPhiMgr->SetProjection(TEveProjection::kPT_RPhi);
+      gEve->AddToListTree(fRPhiMgr, kFALSE);
+      {
+         TEveProjectionAxes* a = new TEveProjectionAxes(fRPhiMgr);
+         a->SetMainColor(kWhite);
+         a->SetTitle("R-Phi");
+         a->SetTitleSize(0.05);
+         a->SetTitleFont(102);
+         a->SetLabelSize(0.025);
+         a->SetLabelFont(102);
+         fRPhiGeomScene->AddElement(a);
+      }
+
+      fRhoZMgr = new TEveProjectionManager();
+      fRhoZMgr->SetProjection(TEveProjection::kPT_RhoZ);
+      gEve->AddToListTree(fRhoZMgr, kFALSE);
+      {
+         TEveProjectionAxes* a = new TEveProjectionAxes(fRhoZMgr);
+         a->SetMainColor(kWhite);
+         a->SetTitle("Rho-Z");
+         a->SetTitleSize(0.05);
+         a->SetTitleFont(102);
+         a->SetLabelSize(0.025);
+         a->SetLabelFont(102);
+         fRhoZGeomScene->AddElement(a);
+      }
+
+
+      // Viewers
+      //=========
+
+      TEveWindowSlot *slot = 0;
+      TEveWindowPack *pack = 0;
+
+      slot = TEveWindow::CreateWindowInTab(gEve->GetBrowser()->GetTabRight());
+      pack = slot->MakePack();
+      pack->SetElementName("Multi View");
+      pack->SetHorizontal();
+      pack->SetShowTitleBar(kFALSE);
+      pack->NewSlot()->MakeCurrent();
+      f3DView = gEve->SpawnNewViewer("3D View", "");
+      f3DView->AddScene(gEve->GetGlobalScene());
+      f3DView->AddScene(gEve->GetEventScene());
+
+      pack = pack->NewSlot()->MakePack();
+      pack->SetShowTitleBar(kFALSE);
+      pack->NewSlot()->MakeCurrent();
+      fRPhiView = gEve->SpawnNewViewer("RPhi View", "");
+      fRPhiView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
+      fRPhiView->AddScene(fRPhiGeomScene);
+      fRPhiView->AddScene(fRPhiEventScene);
+
+      pack->NewSlot()->MakeCurrent();
+      fRhoZView = gEve->SpawnNewViewer("RhoZ View", "");
+      fRhoZView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
+      fRhoZView->AddScene(fRhoZGeomScene);
+      fRhoZView->AddScene(fRhoZEventScene);
+   }
+
+   void ImportGeomRPhi(TEveElement* el)
+   { 
+      fRPhiMgr->ImportElements(el, fRPhiGeomScene);
+   }
+
+   void ImportGeomRhoZ(TEveElement* el)
+   { 
+      fRhoZMgr->ImportElements(el, fRhoZGeomScene);
+   }
+
+   void ImportEventRPhi(TEveElement* el)
+   { 
+      fRPhiMgr->ImportElements(el, fRPhiEventScene);
+   }
+
+   void ImportEventRhoZ(TEveElement* el)
+   { 
+      fRhoZMgr->ImportElements(el, fRhoZEventScene);
+   }
+
+   void DestroyEventRPhi()
+   {
+      fRPhiEventScene->DestroyElements();
+   }
+
+   void DestroyEventRhoZ()
+   {
+      fRhoZEventScene->DestroyElements();
+   }
+};
diff --git a/tutorials/eve/SplitGLView.C b/tutorials/eve/SplitGLView.C
index 0bca271..ff909f4 100644
--- a/tutorials/eve/SplitGLView.C
+++ b/tutorials/eve/SplitGLView.C
@@ -698,6 +698,7 @@ SplitGLView::SplitGLView(const TGWindow *p, UInt_t w, UInt_t h, Bool_t embed) :
 
    // create eve pad (our geometry container)
    fPad = new TEvePad();
+   fPad->SetFillColor(kBlack);
 
    // create the split frames
    fSplitFrame = new TGSplitFrame(this, 800, 600);
diff --git a/tutorials/eve/advanced/assembly.C b/tutorials/eve/advanced/assembly.C
new file mode 100644
index 0000000..c6eb505
--- /dev/null
+++ b/tutorials/eve/advanced/assembly.C
@@ -0,0 +1,108 @@
+// Geometry detector assembly example
+// Author: Andrei Gheata
+//
+// Modified to save the assebly as shape-extract.
+// 1. Run root assembly.C
+//    This will produce assembly.root containing the extract.
+// 2. Display the assebly as:
+//    root show_extract.C("assembly.root")
+
+
+void assembly()
+{
+//--- Definition of a simple geometry
+   gSystem->Load("libGeom");
+   TGeoManager *geom = new TGeoManager("Assemblies",
+      "Geometry using assemblies");
+   Int_t i;
+   //--- define some materials
+   TGeoMaterial *matVacuum = new TGeoMaterial("Vacuum", 0,0,0);
+   TGeoMaterial *matAl = new TGeoMaterial("Al", 26.98,13,2.7);
+//   //--- define some media
+   TGeoMedium *Vacuum = new TGeoMedium("Vacuum",1, matVacuum);
+   TGeoMedium *Al = new TGeoMedium("Aluminium",2, matAl);
+
+   //--- make the top container volume
+   TGeoVolume *top = geom->MakeBox("TOP", Vacuum, 1000., 1000., 100.);
+   geom->SetTopVolume(top);
+
+   // Make the elementary assembly of the whole structure
+   TGeoVolume *tplate = new TGeoVolumeAssembly("TOOTHPLATE");
+
+   Int_t ntooth = 5;
+   Double_t xplate = 25;
+   Double_t yplate = 50;
+   Double_t xtooth = 10;
+   Double_t ytooth = 0.5*yplate/ntooth;
+   Double_t dshift = 2.*xplate + xtooth;
+   Double_t xt,yt;
+
+   TGeoVolume *plate = geom->MakeBox("PLATE", Al, xplate,yplate,1);
+   plate->SetLineColor(kBlue);
+   TGeoVolume *tooth = geom->MakeBox("TOOTH", Al, xtooth,ytooth,1);
+   tooth->SetLineColor(kBlue);
+   tplate->AddNode(plate,1);
+   for (i=0; i<ntooth; i++) {
+      xt = xplate+xtooth;
+      yt = -yplate + (4*i+1)*ytooth;
+      tplate->AddNode(tooth, i+1, new TGeoTranslation(xt,yt,0));
+      xt = -xplate-xtooth;
+      yt = -yplate + (4*i+3)*ytooth;
+      tplate->AddNode(tooth, ntooth+i+1, new TGeoTranslation(xt,yt,0));
+   }
+
+   TGeoRotation *rot1 = new TGeoRotation();
+   rot1->RotateX(90);
+   TGeoRotation *rot;
+   // Make a hexagone cell out of 6 toothplates. These can zip togeather
+   // without generating overlaps (they are self-contained)
+   TGeoVolume *cell = new TGeoVolumeAssembly("CELL");
+   for (i=0; i<6; i++) {
+      Double_t phi =  60.*i;
+      Double_t phirad = phi*TMath::DegToRad();
+      Double_t xp = dshift*TMath::Sin(phirad);
+      Double_t yp = -dshift*TMath::Cos(phirad);
+      rot = new TGeoRotation(*rot1);
+      rot->RotateZ(phi);
+      cell->AddNode(tplate,i+1,new TGeoCombiTrans(xp,yp,0,rot));
+   }
+
+   // Make a row as an assembly of cells, then combine rows in a honeycomb
+   // structure. This again works without any need to define rows as
+   // "overlapping"
+   TGeoVolume *row = new TGeoVolumeAssembly("ROW");
+   Int_t ncells = 5;
+   for (i=0; i<ncells; i++) {
+      Double_t ycell = (2*i+1)*(dshift+10);
+      row->AddNode(cell, ncells+i+1, new TGeoTranslation(0,ycell,0));
+      row->AddNode(cell,ncells-i,new TGeoTranslation(0,-ycell,0));
+   }
+
+   Double_t dxrow = 3.*(dshift+10.)*TMath::Tan(30.*TMath::DegToRad());
+   Double_t dyrow = dshift+10.;
+   Int_t nrows = 5;
+   for (i=0; i<nrows; i++) {
+      Double_t xrow = 0.5*(2*i+1)*dxrow;
+      Double_t yrow = 0.5*dyrow;
+      if ((i%2)==0) yrow = -yrow;
+      top->AddNode(row, nrows+i+1, new TGeoTranslation(xrow,yrow,0));
+      top->AddNode(row, nrows-i, new TGeoTranslation(-xrow,-yrow,0));
+   }
+
+   //--- close the geometry
+   geom->CloseGeometry();
+
+   TEveManager::Create();
+
+   TGeoNode* node = gGeoManager->GetTopNode();
+   TEveGeoTopNode* en = new TEveGeoTopNode(gGeoManager, node);
+   en->SetVisLevel(4);
+   en->GetNode()->GetVolume()->SetVisibility(kFALSE);
+
+   gEve->AddGlobalElement(en);
+
+   gEve->Redraw3D(kTRUE);
+
+   en->ExpandIntoListTreesRecursively();
+   en->Save("assembly.root", "Assembly");
+}
diff --git a/tutorials/eve/advanced/csgdemo.C b/tutorials/eve/advanced/csgdemo.C
new file mode 100644
index 0000000..65caea1
--- /dev/null
+++ b/tutorials/eve/advanced/csgdemo.C
@@ -0,0 +1,68 @@
+// Combinatorial Solid Geometry example
+// Author: Andrei Gheata
+//
+// Stripped down to demonstrate EVE shape-extracts.
+// 1. Run root csgdemo.C
+//    This will produce csg.root containing the extract.
+// 2. Display the assebly as:
+//    root show_extract.C("csg.root")
+
+//______________________________________________________________________________
+void csgdemo ()
+{
+  gSystem->Load("libGeom");
+
+   TCanvas *c = new TCanvas("composite shape", "A * B - C");
+   c->Iconify();
+
+   if (gGeoManager) delete gGeoManager;
+
+   new TGeoManager("xtru", "poza12");
+   TGeoMaterial *mat = new TGeoMaterial("Al", 26.98,13,2.7);
+   TGeoMedium   *med = new TGeoMedium("MED",1,mat);
+   TGeoVolume   *top = gGeoManager->MakeBox("TOP",med,100,100,100);
+   gGeoManager->SetTopVolume(top);
+
+   // define shape components with names
+   TGeoBBox   *box  = new TGeoBBox("box", 20., 20., 20.);
+   TGeoBBox   *box1 = new TGeoBBox("box1", 5., 5., 5.);
+   TGeoSphere *sph  = new TGeoSphere("sph", 5., 25.);
+   TGeoSphere *sph1 = new TGeoSphere("sph1", 1., 15.);
+   // create the composite shape based on a Boolean expression
+   TGeoTranslation *tr  = new TGeoTranslation(0., 30., 0.);
+   TGeoTranslation *tr1 = new TGeoTranslation(0., 40., 0.);
+   TGeoTranslation *tr2 = new TGeoTranslation(0., 30., 0.);
+   TGeoTranslation *tr3 = new TGeoTranslation(0., 30., 0.);
+   tr->SetName("tr");
+   tr1->SetName("tr1");
+   tr2->SetName("tr2");
+   tr3->SetName("tr3");
+   // register all used transformations
+   tr->RegisterYourself();
+   tr1->RegisterYourself();
+   tr2->RegisterYourself();
+   tr3->RegisterYourself();
+
+   TGeoCompositeShape *cs = new TGeoCompositeShape("mir", "(sph * box) + (sph1:tr - box1:tr1)");
+
+   TGeoVolume *vol = new TGeoVolume("COMP4", cs);
+   vol->SetLineColor(kMagenta);
+   top->AddNode(vol,1);
+   gGeoManager->CloseGeometry();
+   gGeoManager->SetNsegments(80);
+   top->Draw();
+
+   TEveManager::Create();
+
+   TGeoNode* node = gGeoManager->GetTopNode();
+   TEveGeoTopNode* en = new TEveGeoTopNode(gGeoManager, node);
+   en->SetVisLevel(4);
+   en->GetNode()->GetVolume()->SetVisibility(kFALSE);
+
+   gEve->AddGlobalElement(en);
+
+   gEve->Redraw3D(kTRUE);
+
+   en->ExpandIntoListTreesRecursively();
+   en->Save("csg.root", "CSG Demo");
+}
diff --git a/tutorials/eve/advanced/show_extract.C b/tutorials/eve/advanced/show_extract.C
new file mode 100644
index 0000000..ca45601
--- /dev/null
+++ b/tutorials/eve/advanced/show_extract.C
@@ -0,0 +1,22 @@
+void show_extract(const char* file)
+{
+  TEveManager::Create();
+
+  TFile::Open(file);
+
+  TIter next(gDirectory->GetListOfKeys());
+  TKey* key;
+  TString xxx("TEveGeoShapeExtract");
+
+  while ((key = (TKey*) next()))
+  {
+    if (xxx == key->GetClassName())
+    {
+      TEveGeoShapeExtract* gse = (TEveGeoShapeExtract*) key->ReadObj();
+      TEveGeoShape* gs = TEveGeoShape::ImportShapeExtract(gse, 0);
+      gEve->AddGlobalElement(gs);
+    }
+  }
+
+  gEve->Redraw3D(kTRUE);
+}
diff --git a/tutorials/eve/alice_esd.C b/tutorials/eve/alice_esd.C
index 01d9d6e..84f9406 100644
--- a/tutorials/eve/alice_esd.C
+++ b/tutorials/eve/alice_esd.C
@@ -130,18 +130,9 @@ TEveTrackList *gTrackList = 0;
 
 TEveGeoShape *gGeomGentle = 0;
 
-TEveProjectionManager *gRPhiMgr = 0;
-TEveProjectionManager *gRhoZMgr = 0;
-
-TEveViewer *g3DView   = 0;
-TEveViewer *gRPhiView = 0;
-TEveViewer *gRhoZView = 0;
-
-TEveScene *gRPhiGeomScene  = 0;
-TEveScene *gRhoZGeomScene  = 0;
-TEveScene *gRPhiEventScene = 0;
-TEveScene *gRhoZEventScene = 0;
-
+// Implemented in MultiView.C
+class MultiView;
+MultiView* gMultiView = 0;
 
 /******************************************************************************/
 // Initialization and steering functions
@@ -158,6 +149,14 @@ void alice_esd()
    // 4. Spawn simple GUI.
    // 5. Load first event.
 
+   const TString weh("alice_esd()");
+
+   if (gROOT->LoadMacro("MultiView.C+") != 0)
+   {
+      Error(weh, "Failed loading MultiView.C in compiled mode.");
+      return;
+   }
+
    TFile::SetCacheFileDir(".");
 
    if (!alice_esd_loadlib("aliesd"))
@@ -237,82 +236,13 @@ void alice_esd()
    }
 
 
-   // Scenes
-   //========
-
-   gRPhiGeomScene  = gEve->SpawnNewScene("RPhi Geometry",
-                                         "Scene holding projected geometry for the RPhi view.");
-   gRhoZGeomScene  = gEve->SpawnNewScene("RhoZ Geometry",
-                                         "Scene holding projected geometry for the RhoZ view.");
-   gRPhiEventScene = gEve->SpawnNewScene("RPhi Event Data",
-                                         "Scene holding projected geometry for the RPhi view.");
-   gRhoZEventScene = gEve->SpawnNewScene("RhoZ Event Data",
-                                         "Scene holding projected geometry for the RhoZ view.");
-
-
-   // Projection managers
+   // Standard multi-view
    //=====================
 
-   gRPhiMgr = new TEveProjectionManager();
-   gRPhiMgr->SetProjection(TEveProjection::kPT_RPhi);
-   gEve->AddToListTree(gRPhiMgr, kFALSE);
-   {
-      TEveProjectionAxes* a = new TEveProjectionAxes(gRPhiMgr);
-      a->SetMainColor(kWhite);
-      a->SetTitle("R-Phi");
-      a->SetTitleSize(0.05);
-      a->SetTitleFont(102);
-      a->SetLabelSize(0.025);
-      a->SetLabelFont(102);
-      gRPhiGeomScene->AddElement(a);
-   }
-   gRPhiMgr->ImportElements(gGeomGentle, gRPhiGeomScene);
-
-   gRhoZMgr = new TEveProjectionManager();
-   gRhoZMgr->SetProjection(TEveProjection::kPT_RhoZ);
-   gEve->AddToListTree(gRhoZMgr, kFALSE);
-   {
-      TEveProjectionAxes* a = new TEveProjectionAxes(gRhoZMgr);
-      a->SetMainColor(kWhite);
-      a->SetTitle("Rho-Z");
-      a->SetTitleSize(0.05);
-      a->SetTitleFont(102);
-      a->SetLabelSize(0.025);
-      a->SetLabelFont(102);
-      gRhoZGeomScene->AddElement(a);
-   }
-   gRhoZMgr->ImportElements(gGeomGentle, gRhoZGeomScene);
-
+   gMultiView = new MultiView;
 
-   // Viewers
-   //=========
-
-   TEveWindowSlot *slot = 0;
-   TEveWindowPack *pack = 0;
-
-   slot = TEveWindow::CreateWindowInTab(gEve->GetBrowser()->GetTabRight());
-   pack = slot->MakePack();
-   pack->SetElementName("Multi View");
-   pack->SetHorizontal();
-   pack->SetShowTitleBar(kFALSE);
-   pack->NewSlot()->MakeCurrent();
-   g3DView = gEve->SpawnNewViewer("3D View", "");
-   g3DView->AddScene(gEve->GetGlobalScene());
-   g3DView->AddScene(gEve->GetEventScene());
-
-   pack = pack->NewSlot()->MakePack();
-   pack->SetShowTitleBar(kFALSE);
-   pack->NewSlot()->MakeCurrent();
-   gRPhiView = gEve->SpawnNewViewer("RPhi View", "");
-   gRPhiView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
-   gRPhiView->AddScene(gRPhiGeomScene);
-   gRPhiView->AddScene(gRPhiEventScene);
-
-   pack->NewSlot()->MakeCurrent();
-   gRhoZView = gEve->SpawnNewViewer("RhoZ View", "");
-   gRhoZView->GetGLViewer()->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
-   gRhoZView->AddScene(gRhoZGeomScene);
-   gRhoZView->AddScene(gRhoZEventScene);
+   gMultiView->ImportGeomRPhi(gGeomGentle);
+   gMultiView->ImportGeomRhoZ(gGeomGentle);
 
 
    // HTML summary view
@@ -326,6 +256,7 @@ void alice_esd()
    fgHtml->MapSubwindows();
    wf->SetElementName("Summary");
 
+
    // Final stuff
    //=============
 
@@ -380,16 +311,11 @@ void load_event()
 
    TEveElement* top = gEve->GetCurrentEvent();
 
-   if (gRPhiMgr && top)
-   {
-      gRPhiEventScene->DestroyElements();
-      gRPhiMgr->ImportElements(top, gRPhiEventScene);
-   }
-   if (gRhoZMgr && top)
-   {
-      gRhoZEventScene->DestroyElements();
-      gRhoZMgr->ImportElements(top, gRhoZEventScene);
-   }
+   gMultiView->DestroyEventRPhi();
+   gMultiView->ImportEventRPhi(top);
+
+   gMultiView->DestroyEventRhoZ();
+   gMultiView->ImportEventRhoZ(top);
 
    update_html_summary();
 
@@ -521,7 +447,7 @@ void alice_esd_read()
 
       TEveTrack* track = esd_make_track(trkProp, n, at, tp);
       track->SetAttLineAttMarker(gTrackList);
-      gEve->AddElement(track, gTrackList);
+      gTrackList->AddElement(track);
 
       // This needs further investigation. Clusters not shown.
       // if (frnd)
diff --git a/tutorials/eve/geom_cms_playback.C b/tutorials/eve/geom_cms_playback.C
new file mode 100644
index 0000000..4a93f6d
--- /dev/null
+++ b/tutorials/eve/geom_cms_playback.C
@@ -0,0 +1,4 @@
+void geom_cms_playback()
+{
+   TRecorder r("http://mtadel.home.cern.ch/mtadel/geom_cms_recording.root");
+}
diff --git a/tutorials/eve/pack.C b/tutorials/eve/pack.C
index 2cb73a3..0905d40 100644
--- a/tutorials/eve/pack.C
+++ b/tutorials/eve/pack.C
@@ -19,9 +19,9 @@ void pack()
    b = new TGTextButton(hp, "Ailaaha");  hp->AddFrame(b);
 
    vp = new TGPack(hp, hp->GetWidth(), hp->GetHeight());
-   b = new TGTextButton(vp, "Blaaaaa");  vp->AddFrame(b);
-   b = new TGTextButton(vp, "Blooooo");  vp->AddFrame(b);
-   b = new TGTextButton(vp, "Bleeeee");  vp->AddFrame(b);
+   b = new TGTextButton(vp, "Blaaaaa");  vp->AddFrameWithWeight(b, 0, 5);
+   b = new TGTextButton(vp, "Blooooo");  vp->AddFrameWithWeight(b, 0, 3);
+   b = new TGTextButton(vp, "Bleeeee");  vp->AddFrameWithWeight(b, 0, 5);
    hp->AddFrame(vp, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));
 
    b = new TGTextButton(hp, "Cilnouk");  hp->AddFrame(b);
diff --git a/tutorials/eve/pythia_display.C b/tutorials/eve/pythia_display.C
new file mode 100644
index 0000000..f6a48db
--- /dev/null
+++ b/tutorials/eve/pythia_display.C
@@ -0,0 +1,276 @@
+//
+// Demo showing H -> ZZ -> 4 mu generated by Pythia.
+// Requires libPythia6.
+
+//==============================================================================
+// Constants.
+//------------------------------------------------------------------------------
+
+const Double_t kR_min = 240;
+const Double_t kR_max = 250;
+const Double_t kZ_d   = 300;
+
+// Solenoid field along z, in Tesla.
+const Double_t kMagField = 4;
+
+// Color for Higgs, Zs and muons
+const Color_t  kColors[3] = { kRed, kGreen, kYellow };
+
+//==============================================================================
+// Global variables.
+//------------------------------------------------------------------------------
+
+class TPythia6;
+TPythia6   *g_pythia = 0;
+
+// Implemented in MultiView.C
+class MultiView;
+MultiView* gMultiView = 0;
+
+TEveTrackList *gTrackList = 0;
+
+//==============================================================================
+// Forward decalarations of CINT functions.
+//------------------------------------------------------------------------------
+
+void pythia_next_event();
+void pythia_make_gui();
+
+//==============================================================================
+// Main - pythia_display()
+//------------------------------------------------------------------------------
+
+void pythia_display()
+{
+   const TString weh("pythia_display()");
+
+   if (g_pythia != 0)
+   {
+      Warning(weh, "Already initialized.");
+      return;
+   }
+#ifndef G__WIN32 // libPythia6 is a static library on Windoze
+   if (gSystem->Load("libPythia6") < 0)
+   {
+      Error(weh, "Could not load 'libPythia6', make sure it is available!");
+      return;
+   }
+#endif
+   gSystem->Load("libEGPythia6");
+
+   if (gROOT->LoadMacro("MultiView.C+") != 0)
+   {
+      Error(weh, "Failed loading MultiView.C in compiled mode.");
+      return;
+   }
+
+   //========================================================================
+   //========================================================================
+
+   // Create an instance of the Pythia event generator ... 
+   g_pythia = new TPythia6; 
+   TPythia6& P = * g_pythia;
+
+   P.SetMSEL(0);           // full user controll;
+   P.SetMSUB(102, 1);      // g + g -> H0
+   //P.SetMSUB(123, 1);    // f + f' -> f + f' + H0
+   //P.SetMSUB(124, 1);    // f + f' -> f" + f"' + H0
+
+   P.SetPMAS(6,  1, 175);  // mass of TOP
+   P.SetPMAS(25, 1, 180);  // mass of Higgs
+
+
+   P.SetCKIN(1, 170.0);    // range of allowed mass
+   P.SetCKIN(2, 190.0);
+
+   P.SetMSTP(61, 0);   // switch off ISR
+   P.SetMSTP(71, 0);   // switch off FSR
+   P.SetMSTP(81, 0);   // switch off multiple interactions
+
+   P.SetMSTP(111, 0);  // Switch off fragmentation
+
+   // Force h0 -> ZZ
+   for (Int_t i = 210; i <= 288; ++i)
+      P.SetMDME(i, 1, 0);
+   P.SetMDME(225, 1, 1);
+
+   // Force Z -> mumu
+   for (Int_t i = 174; i <= 189; ++i)
+      P.SetMDME(i, 1, 0);
+   P.SetMDME(184, 1, 1);
+
+
+   P.Initialize("cms", "p", "p", 14000);
+
+   //========================================================================
+   // Create views and containers.
+   //========================================================================
+
+   TEveManager::Create();
+
+   TEveElementList *fake_geom = new TEveElementList("Geometry");
+
+   TEveGeoShape *b;
+
+   b = new TEveGeoShape("Barell 1");
+   b->SetShape(new TGeoTube(kR_min, kR_max, kZ_d));
+   b->SetMainColor(kCyan);
+   b->SetMainTransparency(80);
+   fake_geom->AddElement(b);
+
+   b = new TEveGeoShape("Barell 2");
+   b->SetShape(new TGeoTube(2*kR_min, 2*kR_max, 2*kZ_d));
+   b->SetMainColor(kPink-3);
+   b->SetMainTransparency(80);
+   fake_geom->AddElement(b);
+
+   gEve->AddGlobalElement(fake_geom);
+
+
+   gMultiView = new MultiView;
+
+   gMultiView->ImportGeomRPhi(fake_geom);
+   gMultiView->ImportGeomRhoZ(fake_geom);
+
+   gEve->GetBrowser()->GetTabRight()->SetTab(1);
+
+   gTrackList = new TEveTrackList("Pythia Tracks"); 
+   gTrackList->SetMainColor(kYellow);
+   gTrackList->SetMarkerColor(kRed);
+   gTrackList->SetMarkerStyle(4);
+   gTrackList->SetMarkerSize(0.5);
+   gEve->AddElement(gTrackList);
+
+   TEveTrackPropagator* trkProp = gTrackList->GetPropagator();
+   trkProp->SetMagField(kMagField);
+   trkProp->SetMaxR(2*kR_max);
+   trkProp->SetMaxZ(2*kZ_d);
+
+   //========================================================================
+   //========================================================================
+
+   pythia_make_gui();
+   pythia_next_event();
+
+   gEve->Redraw3D(kTRUE);
+}
+
+
+//==============================================================================
+// Next event
+//------------------------------------------------------------------------------
+
+void pythia_next_event()
+{
+   gTrackList->DestroyElements();
+
+   TPythia6& P = * g_pythia;
+
+   P.GenerateEvent();
+
+   int nh = P.GetMSTU(72);
+
+   // printf("N = %d, Nhard = %d :: NumSec = %d, separators (%d,%d,%d,%d)\n",
+   //    P.GetN(), nh, P.GetMSTU(70), P.GetMSTU(71), P.GetMSTU(72), P.GetMSTU(73), P.GetMSTU(74));
+   //                          2->2                 hard                  postfrag              final
+
+   TEveTrackPropagator *trkProp = gTrackList->GetPropagator();
+   TClonesArray        &MC      = * (TClonesArray*) P.GetListOfParticles();
+   for (Int_t i = 0; i < 7; ++i)
+   {
+      TMCParticle& p = * MC[nh+i];
+      TParticle pb(p.GetKF(), p.GetKS(), 0, 0,
+                   p.GetFirstChild()-nh-1, p.GetLastChild()-nh-1,
+                   p.GetPx(), p.GetPy(), p.GetPz(), p.GetEnergy(),
+                   p.GetVx(), p.GetVy(), p.GetVz(), p.GetTime());
+
+      TEveTrack* track = new TEveTrack(&pb, i, trkProp);
+      track->SetName(Form("%s [%d]", pb.GetName(), i));
+      track->SetStdTitle();
+      track->SetAttLineAttMarker(gTrackList);
+      if (i == 0)
+         track->SetLineColor(kColors[0]);
+      else if (i <= 2)
+         track->SetLineColor(kColors[1]);
+
+      gTrackList->AddElement(track);
+      
+      /*
+        printf("%d - %d %d %d %d %d %d\n", i,
+        p.GetKF(), p.GetKS(), 0, 0,
+        p.GetFirstChild()-nh-1, p.GetLastChild()-nh-1);
+        printf("%d - %f %f %f %f\n", i,
+        p.GetPx(), p.GetPy(), p.GetPz(), p.GetEnergy(),
+        printf("%d - %f %f %f %f\n", i,
+        p.GetVx(), p.GetVy(), p.GetVz(), p.GetTime());
+      */
+   }
+
+   gTrackList->MakeTracks();
+
+
+   TEveElement* top = gEve->GetCurrentEvent();
+
+   gMultiView->DestroyEventRPhi();
+   gMultiView->ImportEventRPhi(top);
+
+   gMultiView->DestroyEventRhoZ();
+   gMultiView->ImportEventRhoZ(top);
+
+   gEve->Redraw3D();
+}
+
+
+//==============================================================================
+// GUI stuff
+//------------------------------------------------------------------------------
+class EvNavHandler
+{
+public:
+   void Fwd()
+   {
+      pythia_next_event();
+   }
+   void Bck()
+   {}
+};
+
+//______________________________________________________________________________
+void pythia_make_gui()
+{
+   // Create minimal GUI for event navigation.
+
+   TEveBrowser* browser = gEve->GetBrowser();
+   browser->StartEmbedding(TRootBrowser::kLeft);
+
+   TGMainFrame* frmMain = new TGMainFrame(gClient->GetRoot(), 1000, 600);
+   frmMain->SetWindowName("XX GUI");
+   frmMain->SetCleanup(kDeepCleanup);
+
+   TGHorizontalFrame* hf = new TGHorizontalFrame(frmMain);
+   {
+      
+      TString icondir( Form("%s/icons/", gSystem->Getenv("ROOTSYS")) );
+      TGPictureButton* b = 0;
+      EvNavHandler    *fh = new EvNavHandler;
+
+      b = new TGPictureButton(hf, gClient->GetPicture(icondir + "GoBack.gif"));
+      b->SetEnabled(kFALSE);
+      b->SetToolTipText("Go to previous event - not supported.");
+      hf->AddFrame(b);
+      b->Connect("Clicked()", "EvNavHandler", fh, "Bck()");
+
+      b = new TGPictureButton(hf, gClient->GetPicture(icondir + "GoForward.gif"));
+      b->SetToolTipText("Generate new event.");
+      hf->AddFrame(b);
+      b->Connect("Clicked()", "EvNavHandler", fh, "Fwd()");
+   }
+   frmMain->AddFrame(hf);
+
+   frmMain->MapSubwindows();
+   frmMain->Resize();
+   frmMain->MapWindow();
+
+   browser->StopEmbedding();
+   browser->SetTabTitle("Event Control", 0);
+}
diff --git a/tutorials/eve/test_compound.C b/tutorials/eve/test_compound.C
index c18331e..1379f1a 100644
--- a/tutorials/eve/test_compound.C
+++ b/tutorials/eve/test_compound.C
@@ -52,7 +52,7 @@ void test_compound()
    TEveScene  *scene  = gEve->SpawnNewScene("Projected Event");
    viewer->AddScene(scene);
    {
-      TGLViewer* v = viewer->GetDefaultGLViewer();
+      TGLViewer* v = viewer->GetGLViewer();
       v->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
    }
 
diff --git a/tutorials/eve/test_windows.C b/tutorials/eve/test_windows.C
index ca035df..9993790 100644
--- a/tutorials/eve/test_windows.C
+++ b/tutorials/eve/test_windows.C
@@ -137,6 +137,7 @@ void DetailTest()
 
 void TabsTest()
 {
+   TRandom r(0);
    TEveWindowSlot  *slot  = 0;
    TEveWindowFrame *frame = 0;
    TEveViewer *v = 0;
@@ -149,16 +150,17 @@ void TabsTest()
    // horizontal text views
    slot = tab1->NewSlot();
    TEveWindowPack* pack1 = slot->MakePack();
-   pack1->SetShowTitleBar(kFALSE);
    for(int i = 0; i<4;++i)
    {
-      slot = pack1->NewSlot();
+      Int_t weight = r.Uniform(3, 7);
+      slot = pack1->NewSlotWithWeight(weight);
       frame = slot->MakeFrame();
+      frame->SetElementName(Form("FrameInPack %d", i));
       TGCompositeFrame* cf = frame->GetGUICompositeFrame();
       TGTextView* text_view =  new TGTextView(cf, 200, 400);
       cf->AddFrame(text_view,  new TGLayoutHints(kLHintsLeft|kLHintsExpandX|kLHintsExpandY));
 
-      for(Int_t l =0; l<3; l++)
+      for(Int_t l =0; l<weight; l++)
       {
          text_view->AddLine(Form("slot[%d] add line %d here ", i, l));
       }
