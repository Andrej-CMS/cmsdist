commit 2dd1c40583ef677affc49ccf5559f9da7cb6a11c
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Sat Oct 9 11:15:45 2010 +0200

    ../CMSDIST/root-5.22-00d-fireworks6.patch

diff --git a/graf3d/eve/inc/LinkDef1.h b/graf3d/eve/inc/LinkDef1.h
index aaa528d..e893391 100644
--- a/graf3d/eve/inc/LinkDef1.h
+++ b/graf3d/eve/inc/LinkDef1.h
@@ -67,6 +67,7 @@
 #pragma link C++ class TEveElement::TEveListTreeInfo+;
 #pragma link C++ class TEveElementObjectPtr+;
 #pragma link C++ class TEveElementList+;
+#pragma link C++ class TEveElementListProjected+;
 #pragma link C++ class TEveElementEditor+;
 
 #pragma link C++ class std::list<TEveElement*>;
@@ -140,6 +141,7 @@
 #pragma link C++ typedef TEveProjection::vPreScale_i;
 #pragma link C++ class TEveRhoZProjection+;
 #pragma link C++ class TEveRPhiProjection+;
+#pragma link C++ class TEve3DProjection+;
 
 #pragma link C++ class TEveProjectionManager+;
 #pragma link C++ class TEveProjectionManagerEditor+;
diff --git a/graf3d/eve/inc/LinkDef2.h b/graf3d/eve/inc/LinkDef2.h
index f4aeb62..fa572a5 100644
--- a/graf3d/eve/inc/LinkDef2.h
+++ b/graf3d/eve/inc/LinkDef2.h
@@ -17,9 +17,6 @@
 // LinkDef2.h - Visualization elements and helper classes.
 //==============================================================================
 
-//______________________________________________________________________________
-// Visualization elements
-
 // TEveTrack
 #pragma link C++ class TEveTrack+;
 #pragma link C++ class TEveTrackGL+;
@@ -79,6 +76,7 @@
 #pragma link C++ class TEveGeoNodeEditor+;
 #pragma link C++ class TEveGeoTopNodeEditor+;
 #pragma link C++ class TEveGeoShape+;
+#pragma link C++ class TEveGeoShapeProjected+;
 
 // TEveGeoShapeExtract
 #pragma link C++ class TEveGeoShapeExtract+;
diff --git a/graf3d/eve/inc/TEveArrow.h b/graf3d/eve/inc/TEveArrow.h
index eb7c233..817ad30 100644
--- a/graf3d/eve/inc/TEveArrow.h
+++ b/graf3d/eve/inc/TEveArrow.h
@@ -40,6 +40,8 @@ protected:
    TEveVector  fOrigin;
    TEveVector  fVector;
 
+   Int_t       fDrawQuality; // Number of segments of circles.
+
 public:
    TEveArrow(Float_t xVec=0, Float_t yVec=0, Float_t zVec=1,
              Float_t xOrg=0, Float_t yOrg=0, Float_t zOrg=0);
@@ -56,6 +58,9 @@ public:
    TEveVector GetVector() { return fVector; }
    TEveVector GetOrigin() { return fOrigin; }
 
+   Int_t GetDrawQuality() const  { return fDrawQuality; }
+   void  SetDrawQuality(Int_t q) { fDrawQuality = q; }
+
    virtual void ComputeBBox();
    virtual void Paint(Option_t* option="");
 
diff --git a/graf3d/eve/inc/TEveCalo.h b/graf3d/eve/inc/TEveCalo.h
index 9c3330d..bcbcf89 100644
--- a/graf3d/eve/inc/TEveCalo.h
+++ b/graf3d/eve/inc/TEveCalo.h
@@ -36,7 +36,8 @@ private:
    TEveCaloViz& operator=(const TEveCaloViz&); // Not implemented
 
 protected:
-   TEveCaloData* fData;  // event data reference
+   TEveCaloData* fData;           // event data reference
+   Bool_t        fCellIdCacheOK;  // data cell ids cache state
 
    Double_t      fEtaMin;
    Double_t      fEtaMax;
@@ -58,7 +59,6 @@ protected:
    Bool_t            fValueIsColor;   // Interpret signal value as RGBA color.
    TEveRGBAPalette*  fPalette;        // Pointer to signal-color palette.
 
-   Bool_t            fCellIdCacheOK;  // Flag cell ids cache state
 
    void AssignCaloVizParameters(TEveCaloViz* cv);
 
@@ -71,11 +71,21 @@ public:
 
    virtual ~TEveCaloViz();
 
-   TEveCaloData* GetData() const { return fData; }
-   virtual void  SetData(TEveCaloData* d);
-   virtual void  DataChanged();
+   virtual TEveElement* ForwardSelection();
+   virtual TEveElement* ForwardEdit();
+
+   virtual void Paint(Option_t* option="");
 
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
    virtual Float_t GetValToHeight() const;
+   virtual void    CellSelectionChanged() {}
+
+   TEveCaloData* GetData() const { return fData; }
+   void    SetData(TEveCaloData* d);
+   void    DataChanged();   Float_t GetMaxVal() const;
+
+   void    AssertCellIdCache() const;
+   void    InvalidateCellIdCache() { fCellIdCacheOK=kFALSE; ResetBBox(); };
 
    Float_t GetDataSliceThreshold(Int_t slice) const;
    void    SetDataSliceThreshold(Int_t slice, Float_t val);
@@ -88,7 +98,7 @@ public:
    void    SetEndCapPos   (Float_t z) { fEndCapPos = z; ResetBBox(); }
 
    Bool_t  GetPlotEt() const { return fPlotEt; }
-   virtual void    SetPlotEt(Bool_t x);
+   void    SetPlotEt(Bool_t x);
 
    void    SetMaxTowerH(Float_t x) { fMaxTowerH = x; }
    Float_t GetMaxTowerH() const    { return fMaxTowerH; }
@@ -97,17 +107,18 @@ public:
    void    SetMaxValAbs(Float_t x) { fMaxValAbs = x; }
    Float_t GetMaxValAbs() const    { return fMaxValAbs; }
 
-   Float_t GetMaxVal() const;
-
    Float_t GetTransitionEta() const;
    Float_t GetTransitionTheta() const;
 
    TEveRGBAPalette* GetPalette() const { return fPalette; }
    void             SetPalette(TEveRGBAPalette* p);
+
    TEveRGBAPalette* AssertPalette();
+   Bool_t  GetValueIsColor()   const { return fValueIsColor;}
+   void    SetValueIsColor(Bool_t x) { fValueIsColor = x;}
 
-   Bool_t GetValueIsColor()   const { return fValueIsColor;}
-   void   SetValueIsColor(Bool_t x) { fValueIsColor = x;}
+   Bool_t  GetAutoRange()   const { return fAutoRange; }
+   void    SetAutoRange(Bool_t x) { fAutoRange = x; }
 
    void    SetEta(Float_t l, Float_t u);
    Float_t GetEta()    const { return 0.5f*(fEtaMin+fEtaMax); }
@@ -115,22 +126,15 @@ public:
    Float_t GetEtaMax() const { return fEtaMax; }
    Float_t GetEtaRng() const { return fEtaMax-fEtaMin; }
 
-   virtual void SetPhi(Float_t phi)    { SetPhiWithRng(phi, fPhiOffset); }
-   virtual void SetPhiRng(Float_t rng) { SetPhiWithRng(fPhi, rng); }
-   virtual void SetPhiWithRng(Float_t x, Float_t r);
+   void    SetPhi(Float_t phi)    { SetPhiWithRng(phi, fPhiOffset); }
+   void    SetPhiRng(Float_t rng) { SetPhiWithRng(fPhi, rng); }
+   void    SetPhiWithRng(Float_t x, Float_t r);
    Float_t GetPhi()    const { return fPhi; }
    Float_t GetPhiMin() const { return fPhi-fPhiOffset; }
    Float_t GetPhiMax() const { return fPhi+fPhiOffset; }
    Float_t GetPhiRng() const { return 2.0f*fPhiOffset; }
 
-   Bool_t  GetAutoRange()   const { return fAutoRange; }
-   void    SetAutoRange(Bool_t x) { fAutoRange = x; }
-
-   void InvalidateCellIdCache() { fCellIdCacheOK=kFALSE; ResetBBox(); }
-
-   virtual void Paint(Option_t* option="");
-
-   virtual TClass* ProjectedClass() const;
+   Bool_t  CellInEtaPhiRng (TEveCaloData::CellData_t&) const;
 
    ClassDef(TEveCaloViz, 0); // Base-class for visualization of calorimeter eventdata.
 };
@@ -147,6 +151,7 @@ private:
 
 protected:
    TEveCaloData::vCellId_t fCellList;
+   TEveCaloData::vCellId_t fCellListSelected;
 
    Bool_t    fRnrEndCapFrame;
    Bool_t    fRnrBarrelFrame;
@@ -167,7 +172,7 @@ public:
    void SetRnrFrame(Bool_t e, Bool_t b)         { fRnrEndCapFrame = e; fRnrBarrelFrame = b; }
    void GetRnrFrame(Bool_t &e, Bool_t &b) const { e = fRnrEndCapFrame; b = fRnrBarrelFrame; }
 
-   virtual void SetFrameTransparency(UChar_t x) { fFrameTransparency = x; }
+   void    SetFrameTransparency(UChar_t x) { fFrameTransparency = x; }
    UChar_t GetFrameTransparency() const { return fFrameTransparency; }
 
    ClassDef(TEveCalo3D, 0); // Class for 3D visualization of calorimeter event data.
@@ -180,6 +185,10 @@ class TEveCalo2D : public TEveCaloViz,
                    public TEveProjected
 {
    friend class TEveCalo2DGL;
+
+   typedef std::vector<TEveCaloData::vCellId_t*>           vBinCells_t;
+   typedef std::vector<TEveCaloData::vCellId_t*>::iterator vBinCells_i;
+
 private:
    TEveCalo2D(const TEveCalo2D&);            // Not implemented
    TEveCalo2D& operator=(const TEveCalo2D&); // Not implemented
@@ -188,20 +197,29 @@ private:
 
 protected:
    std::vector<TEveCaloData::vCellId_t*>   fCellLists;
-   std::vector<Int_t>                      fBinIds;
+
+   std::vector<TEveCaloData::vCellId_t*>   fCellListsSelected;
+   std::vector<Int_t>                      fBinIdsSelected;
+
+   Float_t                                 fMaxESumBin;
+   Float_t                                 fMaxEtSumBin;
 
    virtual void BuildCellIdCache();
 
+   virtual void SetDepthLocal(Float_t x) { fDepth = x; }
+
 public:
    TEveCalo2D(const char* n="TEveCalo2D", const char* t="");
    virtual ~TEveCalo2D();
 
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
    virtual void UpdateProjection();
-   virtual void SetDepth(Float_t x){fDepth = x;}
-
    virtual void ComputeBBox();
 
+   virtual void CellSelectionChanged();
+
+   virtual Float_t GetValToHeight() const;
+
    ClassDef(TEveCalo2D, 0); // Class for visualization of projected calorimeter event data.
 };
 /**************************************************************************/
@@ -214,7 +232,7 @@ class TEveCaloLego : public TEveCaloViz
 
 public:
    enum EProjection_e { kAuto, k3D, k2D };
-   enum E2DMode_e     { kValColor, kValSize };
+   enum E2DMode_e     { kValColor, kValSize, kValSizeOutline };
    enum EBoxMode_e    { kNone, kFrontBack, kBack};
 
 private:
@@ -224,8 +242,6 @@ private:
 protected:
    TEveCaloData::vCellId_t fCellList;
 
-   Bool_t                  fTopViewUseMaxColor;
-   Color_t                 fTopViewTowerColor;
    Color_t                 fFontColor;
    Color_t                 fGridColor;
    Color_t                 fPlaneColor;
@@ -245,7 +261,6 @@ protected:
    Bool_t                  fDrawHPlane;
    Float_t                 fHPlaneVal;
 
-   Int_t                   fTowerPicked;
    Int_t                   fBinStep;
 
    Int_t                   fDrawNumberCellPixels;
@@ -255,17 +270,11 @@ protected:
 
 public:
    TEveCaloLego(TEveCaloData* data=0, const char* n="TEveCaloLego", const char* t="");
-
    virtual ~TEveCaloLego(){}
 
+   virtual void ComputeBBox();
    virtual void  SetData(TEveCaloData* d);
 
-   Bool_t   GetTopViewUseMaxColor() const { return fTopViewUseMaxColor; }
-   void     SetTopViewUseMaxColor(Bool_t x) { fTopViewUseMaxColor = x; }
-
-   Color_t  GetTopViewTowerColor() const { return fTopViewTowerColor; }
-   void     SetTopViewTowerColor(Color_t x) { fTopViewTowerColor = x; }
-
    Color_t  GetFontColor() const { return fFontColor; }
    void     SetFontColor(Color_t ci) { fFontColor=ci; }
 
@@ -305,15 +314,10 @@ public:
    Float_t  GetHPlaneVal() const { return fHPlaneVal; }
    void     SetHPlaneVal(Float_t s) { fHPlaneVal = s;}
 
-   Int_t    GetTowerPicked() const { return fTowerPicked; }
-   void     SetTowerPicked(Int_t p) { fTowerPicked = p;}
-
    Int_t    GetDrawNumberCellPixels() { return fDrawNumberCellPixels; }
    void     SetDrawNumberCellPixels(Int_t x) { fDrawNumberCellPixels = x; }
    Int_t    GetCellPixelFontSize() { return fCellPixelFontSize; }
    void     SetCellPixelFontSize(Int_t x) { fCellPixelFontSize = x; }
-   
-   virtual void ComputeBBox();
 
    ClassDef(TEveCaloLego, 0);  // Class for visualization of calorimeter histogram data.
 };
diff --git a/graf3d/eve/inc/TEveCalo2DGL.h b/graf3d/eve/inc/TEveCalo2DGL.h
index 73ee88f..bc9faac 100644
--- a/graf3d/eve/inc/TEveCalo2DGL.h
+++ b/graf3d/eve/inc/TEveCalo2DGL.h
@@ -14,6 +14,7 @@
 
 #include "TGLObject.h"
 #include "TEveCaloData.h"
+#include "TEveCalo.h"
 
 class TGLViewer;
 class TGLScene;
@@ -32,10 +33,14 @@ protected:
 
    void      MakeRhoZCell(Float_t thetaMin, Float_t thetaMax, Float_t& offset, Bool_t isBarrel, Bool_t phiPlus, Float_t towerH) const;
 
-   Float_t   MakeRPhiCell(Float_t phiMin, Float_t phiMax, Float_t towerH, Float_t offset) const;
+   void      MakeRPhiCell(Float_t phiMin, Float_t phiMax, Float_t towerH, Float_t offset) const;
 
-   void      DrawRPhi(TGLRnrCtx & rnrCtx) const;
-   void      DrawRhoZ(TGLRnrCtx & rnrCtx) const;
+   void      DrawRPhi(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t&) const;
+   void      DrawRPhiHighlighted(TGLRnrCtx & rnrCtx) const;
+   void      DrawRhoZ(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t&) const;
+   void      DrawRhoZHighlighted(TGLRnrCtx & rnrCtx) const;
+
+   Bool_t    IsRPhi() const;
 
 public:
    TEveCalo2DGL();
@@ -44,10 +49,12 @@ public:
    virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
    virtual void   SetBBox();
 
-   virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
+   virtual void DirectDraw(TGLRnrCtx & rnrCtx) const;
+   virtual void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps) const;
 
    // To support two-level selection
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   virtual Bool_t AlwaysSecondarySelect()   const { return kTRUE; }
    virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
 
    ClassDef(TEveCalo2DGL, 0); // GL renderer class for TEveCalo2D.
diff --git a/graf3d/eve/inc/TEveCalo3DGL.h b/graf3d/eve/inc/TEveCalo3DGL.h
index 0b27fbf..e667cb9 100644
--- a/graf3d/eve/inc/TEveCalo3DGL.h
+++ b/graf3d/eve/inc/TEveCalo3DGL.h
@@ -29,12 +29,14 @@ private:
    void    RenderGridEndCap() const;
    void    RenderGridBarrel() const;
    void    RenderGrid(TGLRnrCtx & rnrCtx) const;
-   Float_t RenderBarrelCell(const TEveCaloData::CellData_t &cell, Float_t towerH, Float_t offset) const;
-   Float_t RenderEndCapCell(const TEveCaloData::CellData_t &cell, Float_t towerH, Float_t offset) const;
+   Float_t RenderBarrelCell(const TEveCaloData::CellGeom_t &cell, Float_t towerH, Float_t offset) const;
+   Float_t RenderEndCapCell(const TEveCaloData::CellGeom_t &cell, Float_t towerH, Float_t offset) const;
 
 protected:
    TEveCalo3D     *fM;  // Model object.
 
+   mutable std::vector<Float_t>     fOffset;
+
 public:
    TEveCalo3DGL();
    virtual ~TEveCalo3DGL() {}
@@ -43,9 +45,11 @@ public:
    virtual void   SetBBox();
 
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
+   virtual void   DrawHighlight(TGLRnrCtx & rnrCtx, const TGLPhysicalShape* ps) const;
 
    virtual Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const;
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   virtual Bool_t AlwaysSecondarySelect()   const { return kTRUE; }
    virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
 
    ClassDef(TEveCalo3DGL, 0); // GL renderer class for TEveCalo.
diff --git a/graf3d/eve/inc/TEveCaloData.h b/graf3d/eve/inc/TEveCaloData.h
index 6b2948b..ee1c2a5 100644
--- a/graf3d/eve/inc/TEveCaloData.h
+++ b/graf3d/eve/inc/TEveCaloData.h
@@ -13,26 +13,23 @@
 #define ROOT_TEveCaloData
 
 #include <vector>
-#include "Rtypes.h"
-#include "TEveUtil.h"
+#include "TEveElement.h"
 
 class TH2F;
 class TAxis;
 class THStack;
 
-class TEveCaloData: public TEveRefBackPtr
+class TEveCaloData: public TEveElement,
+                    public TNamed
 {
 public:
    struct SliceInfo_t
    {
       TString  fName;      // Name of the slice, eg. ECAL, HCAL.
       Float_t  fThreshold; // Only display towers with higher energy.
-      Int_t    fID;        // Unique identification of the slice.
       Color_t  fColor;     // Color used to draw this longitudinal slice.
-      TH2F    *fHist;
-
-      SliceInfo_t(): fName(""), fThreshold(0), fID(-1), fColor(Color_t(4)), fHist(0){}
-      SliceInfo_t(TH2F* h): fName(""), fThreshold(0), fID(-1), fColor(Color_t(4)), fHist(h) {}
+      
+      SliceInfo_t(): fName(""), fThreshold(0), fColor(kRed) {}
 
       virtual ~SliceInfo_t() {}
 
@@ -141,7 +138,7 @@ protected:
 
    TAxis*       fEtaAxis;
    TAxis*       fPhiAxis;
-   
+
    Bool_t       fWrapTwoPi;
 
    Float_t      fMaxValEt; // cached
@@ -149,14 +146,22 @@ protected:
 
    Float_t      fEps;
 
+   vCellId_t    fCellsSelected;
+
 public:
-   TEveCaloData();
+   TEveCaloData(const char* n="TEveCalData", const char* t="");
    virtual ~TEveCaloData() {}
 
+   virtual void    SelectElement(Bool_t state);
+   virtual void    FillImpliedSelectedSet(Set_t& impSelSet);
+
    virtual void    GetCellList(Float_t etaMin, Float_t etaMax,
                                Float_t phi,    Float_t phiRng,
                                vCellId_t &out) const = 0;
 
+   vCellId_t&      GetCellsSelected() { return fCellsSelected; }
+   void            PrintCellsSelected();
+
    virtual void    Rebin(TAxis *ax, TAxis *ay, vCellId_t &in, Bool_t et, RebinData_t &out) const = 0;
 
 
@@ -164,6 +169,7 @@ public:
 
    virtual void    InvalidateUsersCellIdCache();
    virtual void    DataChanged();
+   virtual void    CellSelectionChanged();
 
    Int_t           GetNSlices()    const { return fSliceInfos.size(); }
    SliceInfo_t&    RefSliceInfo(Int_t s) { return fSliceInfos[s]; }
@@ -187,12 +193,13 @@ public:
 
    virtual Float_t GetEps()      const { return fEps; }
    virtual void    SetEps(Float_t eps) { fEps=eps; }
-   
+
    Bool_t   GetWrapTwoPi() const { return fWrapTwoPi; }
    void     SetWrapTwoPi(Bool_t w) { fWrapTwoPi=w; }
 
    static  Float_t EtaToTheta(Float_t eta);
 
+
    ClassDef(TEveCaloData, 0); // Manages calorimeter event data.
 };
 
@@ -282,6 +289,8 @@ public:
 
    THStack* GetStack() { return fHStack; }
 
+   TH2F*    GetHist(Int_t slice) const;
+   
    Int_t   AddHistogram(TH2F* hist);
 
    ClassDef(TEveCaloDataHist, 0); // Manages calorimeter TH2F event data.
diff --git a/graf3d/eve/inc/TEveCaloLegoEditor.h b/graf3d/eve/inc/TEveCaloLegoEditor.h
index 9cb2177..eda34fa 100644
--- a/graf3d/eve/inc/TEveCaloLegoEditor.h
+++ b/graf3d/eve/inc/TEveCaloLegoEditor.h
@@ -33,19 +33,17 @@ private:
 protected:
    TEveCaloLego      *fM; // Model object.
 
-   TGCheckButton     *fTopViewUseMaxColor;
-   TGColorSelect     *fTopViewTowerColor;
    TGColorSelect     *fGridColor;
    TGColorSelect     *fFontColor;
    TGColorSelect     *fPlaneColor;
    TGNumberEntry     *fTransparency;
 
-   TEveGValuator     *fNZSteps;
-
    TGComboBox        *fProjection;
    TGComboBox        *f2DMode;
    TGComboBox        *fBoxMode;
 
+   TEveGValuator     *fCell2DTextMin;
+
    TGVerticalFrame   *fRebinFrame;
    TGCheckButton     *fAutoRebin;
    TEveGValuator     *fPixelsPerBin;
@@ -60,19 +58,17 @@ public:
    virtual void SetModel(TObject* obj);
 
    // Declare callback/slot methods
-   void DoTopViewUseMaxColor();
-   void DoTopViewTowerColor(Pixel_t color);
    void DoGridColor(Pixel_t color);
    void DoFontColor(Pixel_t color);
    void DoPlaneColor(Pixel_t color);
    void DoTransparency();
 
-   void DoNZSteps();
-
    void DoProjection();
    void Do2DMode();
    void DoBoxMode();
 
+   void DoCell2DTextMin();
+
    void DoAutoRebin();
    void DoPixelsPerBin();
    void DoNormalize();
diff --git a/graf3d/eve/inc/TEveCaloLegoGL.h b/graf3d/eve/inc/TEveCaloLegoGL.h
index d759f7a..f4a9614 100644
--- a/graf3d/eve/inc/TEveCaloLegoGL.h
+++ b/graf3d/eve/inc/TEveCaloLegoGL.h
@@ -26,16 +26,46 @@ class TEveCaloLego;
 class TEveCaloLegoGL : public TGLObject
 {
 private:
-   TEveCaloLegoGL(const TEveCaloLegoGL&);            // Not implemented
-   TEveCaloLegoGL& operator=(const TEveCaloLegoGL&); // Not implemented
+   struct Cell2D_t
+   {
+      Int_t   fId;
+      Float_t fSumVal;
+      Int_t   fMaxSlice;
+
+      Float_t  fX0, fX1, fY0, fY1;
+
+      Cell2D_t(Int_t id, Float_t sumVal, Int_t maxSlice)
+      {
+         fId       = id;
+         fSumVal   = sumVal;
+         fMaxSlice = maxSlice;
+      }
+
+      void SetGeom(Float_t x0, Float_t x1, Float_t y0, Float_t y1)
+      {
+         fX0 = x0; fX1 = x1;
+         fY0 = y0; fY1 = y1;
+      }
 
-   mutable Float_t   fDataMax; // cached
+      Float_t MinSize() { return TMath::Min(fX1- fX0, fY1 - fY0); }
+      Float_t X()       { return 0.5*(fX0 + fX1); }
+      Float_t Y()       { return 0.5*(fY0 + fY1); }
+   };
 
-   // axis
-   mutable TAxis    *fEtaAxis;
-   mutable TAxis    *fPhiAxis;
-   mutable TAxis    *fZAxis;
+   typedef std::vector<Cell2D_t>             vCell2D_t;
+   typedef std::vector<Cell2D_t>::iterator   vCell2D_i;
 
+   typedef std::map<Int_t, UInt_t>           SliceDLMap_t;
+   typedef std::map<Int_t, UInt_t>::iterator SliceDLMap_i;
+
+   // histogram base
+   mutable Float_t                   fDataMax;
+   mutable Color_t                   fGridColor;
+   mutable Color_t                   fFontColor;
+
+   mutable TAxis      *fEtaAxis;
+   mutable TAxis      *fPhiAxis;
+   mutable TAxis      *fZAxis;
    mutable TEveVector  fXAxisTitlePos;
    mutable TEveVector  fYAxisTitlePos;
    mutable TEveVector  fZAxisTitlePos;
@@ -44,6 +74,22 @@ private:
 
    mutable TGLAxisPainter fAxisPainter;
 
+   // cached
+   TEveCaloLego                     *fM;
+   mutable Bool_t                    fDLCacheOK;
+   mutable vCell2D_t                 fCells2D;
+
+   mutable TEveCaloData::RebinData_t fRebinData;
+   mutable Float_t                   fMaxValRebin;
+   mutable Float_t                   fValToPixel; // top logaritmic viewview
+   mutable Int_t                     fCurrentPixelsPerBin;
+
+   mutable SliceDLMap_t              fDLMap;
+   mutable Bool_t                    fCells3D;
+
+   TEveCaloLegoGL(const TEveCaloLegoGL&);            // Stop default
+   TEveCaloLegoGL& operator=(const TEveCaloLegoGL&); // Stop default
+
 protected:
    Int_t   GetGridStep(TGLRnrCtx &rnrCtx) const;
    void    RebinAxis(TAxis *orig, TAxis *curr) const;
@@ -53,24 +99,19 @@ protected:
    void    DrawAxis2D(TGLRnrCtx &rnrCtx) const;
    void    DrawHistBase(TGLRnrCtx &rnrCtx) const;
 
-   void    DrawCells2D(TGLRnrCtx & rnrCtx) const;
+   // top view
+   void    PrepareCell2DData(TEveCaloData::vCellId_t& cellList, vCell2D_t& cells2D) const;
+   void    PrepareCell2DDataRebin(TEveCaloData::RebinData_t& rebinData, vCell2D_t& cells2D) const;
+   void    DrawCells2D(TGLRnrCtx & rnrCtx, vCell2D_t& cells2D) const;
 
+   // 3D view
    void    DrawCells3D(TGLRnrCtx & rnrCtx) const;
    void    MakeQuad(Float_t x, Float_t y, Float_t z, Float_t xw, Float_t yw, Float_t zh) const;
-   void    MakeDisplayList() const;
+   void    Make3DDisplayList(TEveCaloData::vCellId_t& cellList, SliceDLMap_t& map, Bool_t select) const;
+   void    Make3DDisplayListRebin(TEveCaloData::RebinData_t& rebinData, SliceDLMap_t& map, Bool_t select) const;
 
    void    WrapTwoPi(Float_t &min, Float_t &max) const;
 
-   TEveCaloLego                     *fM;  // Model object.
-   mutable Bool_t                    fDLCacheOK;
-
-   typedef std::map<Int_t, UInt_t>           SliceDLMap_t;
-   typedef std::map<Int_t, UInt_t>::iterator SliceDLMap_i;
-
-   mutable SliceDLMap_t              fDLMap;
-   mutable TEveCaloData::RebinData_t fRebinData;
-
-   mutable Bool_t                    fCells3D;
 public:
    TEveCaloLegoGL();
    virtual ~TEveCaloLegoGL();
@@ -83,7 +124,10 @@ public:
    virtual void   DLCachePurge();
 
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
+   virtual void   DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps) const;
+
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   virtual Bool_t AlwaysSecondarySelect()   const { return kTRUE; }
    virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
 
    ClassDef(TEveCaloLegoGL, 0); // GL renderer class for TEveCaloLego.
diff --git a/graf3d/eve/inc/TEveCaloLegoOverlay.h b/graf3d/eve/inc/TEveCaloLegoOverlay.h
index 3f37119..2795fd8 100644
--- a/graf3d/eve/inc/TEveCaloLegoOverlay.h
+++ b/graf3d/eve/inc/TEveCaloLegoOverlay.h
@@ -27,7 +27,8 @@ private:
 
 
 protected:
-   void   RenderScales(TGLRnrCtx& rnrCtx);
+   void   RenderLogaritmicScales(TGLRnrCtx& rnrCtx);
+   void   RenderPaletteScales(TGLRnrCtx& rnrCtx);
    void   RenderPlaneInterface(TGLRnrCtx& rnrCtx);
    void   RenderHeader(TGLRnrCtx& rnrCtx);
 
@@ -39,6 +40,8 @@ protected:
    UChar_t        fScaleTransparency; //transaprency in %
    Double_t       fScaleCoordX;
    Double_t       fScaleCoordY;
+   Double_t       fScaleW;
+   Double_t       fScaleH;
    Double_t       fCellX;
    Double_t       fCellY;
 
@@ -48,7 +51,7 @@ protected:
 
    // move of scales
    Int_t             fMouseX, fMouseY; //! last mouse position
-   Bool_t            fInDrag; 
+   Bool_t            fInDrag;
 
    // text top right corner
    TString        fHeaderTxt;
diff --git a/graf3d/eve/inc/TEveCompound.h b/graf3d/eve/inc/TEveCompound.h
index 736c3ae..3d8f203 100644
--- a/graf3d/eve/inc/TEveCompound.h
+++ b/graf3d/eve/inc/TEveCompound.h
@@ -20,8 +20,7 @@
 // TEveCompound
 //==============================================================================
 
-class TEveCompound : public TEveElementList,
-                     public TEveProjectable
+class TEveCompound : public TEveElementList
 {
 private:
    TEveCompound(const TEveCompound&);            // Not implemented
@@ -47,7 +46,7 @@ public:
 
    virtual void FillImpliedSelectedSet(Set_t& impSelSet);
 
-   virtual TClass* ProjectedClass() const;
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
    ClassDef(TEveCompound, 0); // Container for managing compounds of TEveElements.
 };
@@ -65,6 +64,7 @@ private:
    TEveCompoundProjected& operator=(const TEveCompoundProjected&); // Not implemented
 
 protected:
+   virtual void SetDepthLocal(Float_t /*d*/) {}
 
 public:
    TEveCompoundProjected();
@@ -72,8 +72,6 @@ public:
 
    virtual void SetMainColor(Color_t color);
 
-   // Abstract from TEveProjected, we seem not to care.
-   virtual void SetDepth(Float_t /*d*/) {}
    virtual void UpdateProjection()      {}
 
    ClassDef(TEveCompoundProjected, 0); // Projected TEveCompund container.
diff --git a/graf3d/eve/inc/TEveElement.h b/graf3d/eve/inc/TEveElement.h
index d9695f8..e772fe7 100644
--- a/graf3d/eve/inc/TEveElement.h
+++ b/graf3d/eve/inc/TEveElement.h
@@ -13,6 +13,7 @@
 #define ROOT_TEveElement
 
 #include "TEveUtil.h"
+#include "TEveProjectionBases.h"
 
 #include "TNamed.h"
 #include "TRef.h"
@@ -164,8 +165,8 @@ public:
    TEveElement* FindChild(TPRegexp& regexp, const TClass* cls=0);
    Int_t        FindChildren(List_t& matches, const TString&  name, const TClass* cls=0);
    Int_t        FindChildren(List_t& matches, TPRegexp& regexp, const TClass* cls=0);
-   TEveElement* FirstChild() const { return fChildren.front(); }
-   TEveElement* LastChild () const { return fChildren.back();  }
+   TEveElement* FirstChild() const { return fChildren.empty() ? 0 : fChildren.front(); }
+   TEveElement* LastChild () const { return fChildren.empty() ? 0 : fChildren.back();  }
 
    void EnableListElements (Bool_t rnr_self=kTRUE,  Bool_t rnr_children=kTRUE);  // *MENU*
    void DisableListElements(Bool_t rnr_self=kFALSE, Bool_t rnr_children=kFALSE); // *MENU*
@@ -298,14 +299,17 @@ public:
 
    Bool_t IsPickable()    const { return fPickable; }
    void   SetPickable(Bool_t p) { fPickable = p; }
+   
+   virtual TEveElement* ForwardSelection();
+   virtual TEveElement* ForwardEdit();
 
-   void SelectElement(Bool_t state);
-   void IncImpliedSelected();
-   void DecImpliedSelected();
+   virtual void SelectElement(Bool_t state);
+   virtual void IncImpliedSelected();
+   virtual void DecImpliedSelected();
 
-   void HighlightElement(Bool_t state);
-   void IncImpliedHighlighted();
-   void DecImpliedHighlighted();
+   virtual void HighlightElement(Bool_t state);
+   virtual void IncImpliedHighlighted();
+   virtual void DecImpliedHighlighted();
 
    virtual void FillImpliedSelectedSet(Set_t& impSelSet);
 
@@ -396,7 +400,8 @@ public:
 /******************************************************************************/
 
 class TEveElementList : public TEveElement,
-                        public TNamed
+                        public TNamed,
+                        public TEveProjectable
 {
 private:
    TEveElementList& operator=(const TEveElementList&); // Not implemented
@@ -433,7 +438,34 @@ public:
 
    virtual Bool_t AcceptElement(TEveElement* el);
 
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
+
    ClassDef(TEveElementList, 0); // List of TEveElement objects with a possibility to limit the class of accepted elements.
 };
 
+
+/******************************************************************************/
+// TEveElementListProjected
+/******************************************************************************/
+
+class TEveElementListProjected : public TEveElementList,
+                                 public TEveProjected
+{
+private:
+   TEveElementListProjected(const TEveElementListProjected&);            // Not implemented
+   TEveElementListProjected& operator=(const TEveElementListProjected&); // Not implemented
+
+
+protected:
+   virtual void SetDepthLocal(Float_t d);
+
+public:
+   TEveElementListProjected();
+   virtual ~TEveElementListProjected() {}
+
+   virtual void UpdateProjection();
+
+   ClassDef(TEveElementListProjected, 0); // Projected TEveElementList.
+};
+
 #endif
diff --git a/graf3d/eve/inc/TEveGeoShape.h b/graf3d/eve/inc/TEveGeoShape.h
index ee1d0d6..ca52623 100644
--- a/graf3d/eve/inc/TEveGeoShape.h
+++ b/graf3d/eve/inc/TEveGeoShape.h
@@ -13,6 +13,7 @@
 
 #include "TEveElement.h"
 #include "TEveProjectionBases.h"
+#include "TAttBBox.h"
 
 class TGeoShape;
 class TEveGeoShapeExtract;
@@ -21,6 +22,7 @@ class TEveGeoShape : public TEveElement,
                      public TNamed,
                      public TEveProjectable
 {
+private:
    TEveGeoShape(const TEveGeoShape&);            // Not implemented
    TEveGeoShape& operator=(const TEveGeoShape&); // Not implemented
 
@@ -57,11 +59,41 @@ public:
 
    // GeoProjectable
    virtual TBuffer3D*   MakeBuffer3D();
-   virtual TClass*      ProjectedClass() const;
+   virtual TClass*      ProjectedClass(const TEveProjection* p) const;
 
    static TGeoManager*  GetGeoMangeur();
 
    ClassDef(TEveGeoShape, 1); // Wrapper for TGeoShape with absolute positioning and color attributes allowing display of extracted TGeoShape's (without an active TGeoManager) and simplified geometries (needed for NLT projections).
 };
 
+//------------------------------------------------------------------------------
+
+class TEveGeoShapeProjected : public TEveElementList,
+                              public TEveProjected,
+                              public TAttBBox
+{
+private:
+   TEveGeoShapeProjected(const TEveGeoShapeProjected&);            // Not implemented
+   TEveGeoShapeProjected& operator=(const TEveGeoShapeProjected&); // Not implemented
+
+protected:
+   TBuffer3D*  fBuff;
+
+   virtual void SetDepthLocal(Float_t d);
+
+public:
+   TEveGeoShapeProjected();
+   virtual ~TEveGeoShapeProjected() {}
+
+   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+
+   virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
+   virtual void UpdateProjection();
+
+   virtual void ComputeBBox();
+   virtual void Paint(Option_t* option = "");
+
+   ClassDef(TEveGeoShapeProjected, 0);
+};
+
 #endif
diff --git a/graf3d/eve/inc/TEveLegoEventHandler.h b/graf3d/eve/inc/TEveLegoEventHandler.h
index 84dfa4c..652b998 100644
--- a/graf3d/eve/inc/TEveLegoEventHandler.h
+++ b/graf3d/eve/inc/TEveLegoEventHandler.h
@@ -28,23 +28,25 @@ protected:
    enum EMode_e   { kLocked, kFree };
 
    EMode_e  fMode;       // current rotation mode
-   Float_t  fTransTheta; // transition theta
+   Float_t  fTransTheta; // transition theta in radians
    Float_t  fTheta;
 
-   TEveCaloLego*  fLastPickedLego;
-
    virtual Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
 
 public:
-   TEveLegoEventHandler(const char *name, TGWindow *w, TObject *obj, const char *title="");
+   TEveCaloLego*  fLego;
+
+   TEveLegoEventHandler(TGWindow *w, TObject *obj, TEveCaloLego* lego = 0);
    virtual ~TEveLegoEventHandler() {}
 
    virtual Bool_t HandleKey(Event_t *event);
-   virtual Bool_t HandleDoubleClick(Event_t *event);
 
    Float_t GetTransTheta() {return fTransTheta;}
    void    SetTransTheta(Float_t h) {fTransTheta=h;}
 
+   TEveCaloLego* GetLego() { return fLego; }
+   void          SetLego( TEveCaloLego* x) { fLego = x; }
+
    ClassDef(TEveLegoEventHandler, 0); // A GL event handler class. Swiches perspective or orthographic camera.
 };
 
diff --git a/graf3d/eve/inc/TEveLine.h b/graf3d/eve/inc/TEveLine.h
index 82cb291..2018ac9 100644
--- a/graf3d/eve/inc/TEveLine.h
+++ b/graf3d/eve/inc/TEveLine.h
@@ -61,7 +61,7 @@ public:
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
-   virtual TClass* ProjectedClass() const;
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
    static Bool_t GetDefaultSmooth()       { return fgDefaultSmooth; }
    static void SetDefaultSmooth(Bool_t r) { fgDefaultSmooth = r;    }
@@ -81,12 +81,14 @@ private:
    TEveLineProjected(const TEveLineProjected&);            // Not implemented
    TEveLineProjected& operator=(const TEveLineProjected&); // Not implemented
 
+protected:
+   virtual void SetDepthLocal(Float_t d);
+
 public:
    TEveLineProjected();
    virtual ~TEveLineProjected() {}
 
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
-   virtual void SetDepth(Float_t d);
    virtual void UpdateProjection();
 
    ClassDef(TEveLineProjected, 0); // Projected replica of a TEveLine.
diff --git a/graf3d/eve/inc/TEvePointSet.h b/graf3d/eve/inc/TEvePointSet.h
index ac09f0d..08d6684 100644
--- a/graf3d/eve/inc/TEvePointSet.h
+++ b/graf3d/eve/inc/TEvePointSet.h
@@ -92,7 +92,7 @@ public:
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
-   virtual TClass* ProjectedClass() const;
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
    ClassDef(TEvePointSet, 1); // Set of 3D points with same marker attributes; optionally each point can be assigned an external TRef or a number of integer indices.
 };
@@ -113,7 +113,7 @@ class TEvePointSetArray : public TEveElement,
    TEvePointSetArray& operator=(const TEvePointSetArray&); // Not implemented
 
 protected:
-   TEvePointSet**   fBins;                 //  Pointers to subjugated TEvePointSet's.
+   TEvePointSet **fBins;               //  Pointers to subjugated TEvePointSet's.
    Int_t        fDefPointSetCapacity;  //  Default capacity of subjugated TEvePointSet's.
    Int_t        fNBins;                //  Number of subjugated TEvePointSet's.
    Int_t        fLastBin;              //! Index of the last filled TEvePointSet.
@@ -172,12 +172,14 @@ private:
    TEvePointSetProjected(const TEvePointSetProjected&);            // Not implemented
    TEvePointSetProjected& operator=(const TEvePointSetProjected&); // Not implemented
 
+protected:
+   virtual void SetDepthLocal(Float_t d);
+
 public:
    TEvePointSetProjected();
    virtual ~TEvePointSetProjected() {}
 
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
-   virtual void SetDepth(Float_t d);
    virtual void UpdateProjection();
 
    ClassDef(TEvePointSetProjected, 1); // Projected copy of a TEvePointSet.
diff --git a/graf3d/eve/inc/TEvePolygonSetProjected.h b/graf3d/eve/inc/TEvePolygonSetProjected.h
index b3c000c..01d4ec3 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjected.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjected.h
@@ -78,12 +78,15 @@ protected:
    Color_t      fLineColor; // outline color of polygons
    Float_t      fLineWidth; // outline width of polygons
 
+   Bool_t       fHighlightFrame; // higlight mode
+
+   virtual void SetDepthLocal(Float_t d);
+
 public:
    TEvePolygonSetProjected(const char* n="TEvePolygonSetProjected", const char* t="");
    virtual ~TEvePolygonSetProjected();
 
    virtual void    SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
-   virtual void    SetDepth(Float_t d);
    virtual void    UpdateProjection();
 
    void            ProjectBuffer3D();
@@ -103,10 +106,12 @@ public:
    virtual Color_t GetFillColor() const { return fFillColor; }
    virtual Color_t GetLineColor() const { return fLineColor; }
    virtual Float_t GetLineWidth() const { return fLineWidth;}
+   virtual Bool_t  GetHighlightFrame() const { return fHighlightFrame; }
 
    virtual void    SetFillColor(Color_t c)  { fFillColor = c; }
    virtual void    SetLineColor(Color_t c)  { fLineColor = c; }
    virtual void    SetLineWidth(Float_t lw) { fLineWidth = lw;}
+   virtual void    SetHighlightFrame(Bool_t f) { fHighlightFrame = f; }
 
    ClassDef(TEvePolygonSetProjected,0); // Set of projected polygons with outline; typically produced from a TBuffer3D.
 
diff --git a/graf3d/eve/inc/TEvePolygonSetProjectedGL.h b/graf3d/eve/inc/TEvePolygonSetProjectedGL.h
index f2f68dd..7053781 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjectedGL.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjectedGL.h
@@ -23,10 +23,15 @@ public:
    virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
    virtual void   SetBBox();
    virtual void   Draw(TGLRnrCtx& rnrCtx) const;
-   virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
+   virtual void   DirectDraw(TGLRnrCtx& rnrCtx) const;
+
+   virtual void   DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const;
 
    virtual Bool_t IgnoreSizeForOfInterest() const { return kTRUE; }
 
+private:
+   void DrawOutline() const;
+
    ClassDef(TEvePolygonSetProjectedGL,0);  // GL-renderer for TEvePolygonSetProjected class.
 };
 
diff --git a/graf3d/eve/inc/TEveProjectionAxes.h b/graf3d/eve/inc/TEveProjectionAxes.h
index 7dea40b..a75e97c 100644
--- a/graf3d/eve/inc/TEveProjectionAxes.h
+++ b/graf3d/eve/inc/TEveProjectionAxes.h
@@ -40,7 +40,7 @@ private:
 protected:
    TEveProjectionManager*  fManager;  // Model object.
 
-   Color_t fColor;                    // Main eve-element color.
+   Bool_t  fUseColorSet;
 
    ELabMode  fLabMode;                // Division of distorted space.
    EAxesMode fAxesMode;               // Axis vertical/hotrizontal orientation.
@@ -48,8 +48,9 @@ protected:
    Bool_t fDrawCenter;           // Draw center of distortion.
    Bool_t fDrawOrigin;           // Draw origin.
 
+
 public:
-   TEveProjectionAxes(TEveProjectionManager* m);
+   TEveProjectionAxes(TEveProjectionManager* m, Bool_t useColorSet = kTRUE);
    virtual ~TEveProjectionAxes();
 
    TEveProjectionManager* GetManager(){
@@ -66,7 +67,6 @@ public:
    void            SetDrawOrigin(Bool_t x)   { fDrawOrigin = x; }
    Bool_t          GetDrawOrigin() const     { return fDrawOrigin; }
 
-   virtual Bool_t  CanEditMainColor() const  { return kTRUE;}
    virtual void    Paint(Option_t* option="");
    virtual void    ComputeBBox();
    virtual const   TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
diff --git a/graf3d/eve/inc/TEveProjectionBases.h b/graf3d/eve/inc/TEveProjectionBases.h
index 1da857a..993c22b 100644
--- a/graf3d/eve/inc/TEveProjectionBases.h
+++ b/graf3d/eve/inc/TEveProjectionBases.h
@@ -14,12 +14,11 @@
 
 #include "TEveUtil.h"
 
-#include <list>
-
 class TBuffer3D;
 
 class TEveElement;
 
+class TEveProjection;
 class TEveProjected;
 class TEveProjectionManager;
 
@@ -47,7 +46,7 @@ public:
    TEveProjectable();
    virtual ~TEveProjectable();
 
-   virtual TClass* ProjectedClass() const = 0;
+   virtual TClass* ProjectedClass(const TEveProjection* p) const = 0;
 
    virtual Bool_t HasProjecteds() const { return ! fProjectedList.empty(); }
 
@@ -83,6 +82,9 @@ protected:
    TEveProjectable       *fProjectable;   // link to original object
    Float_t                fDepth;         // z coordinate
 
+   void         SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox);
+   virtual void SetDepthLocal(Float_t d) = 0;
+
 public:
    TEveProjected();
    virtual ~TEveProjected();
@@ -92,11 +94,9 @@ public:
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void UnRefProjectable(TEveProjectable* assumed_parent);
 
-   virtual void SetDepth(Float_t d) = 0;
-
    virtual void UpdateProjection() = 0;
 
-   void SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox);
+   virtual void SetDepth(Float_t d);
 
    ClassDef(TEveProjected, 0); // Abstract base class for classes that hold results of a non-linear projection transformation.
 };
diff --git a/graf3d/eve/inc/TEveProjectionManager.h b/graf3d/eve/inc/TEveProjectionManager.h
index eb3750e..8fb99c6 100644
--- a/graf3d/eve/inc/TEveProjectionManager.h
+++ b/graf3d/eve/inc/TEveProjectionManager.h
@@ -40,7 +40,7 @@ protected:
    virtual void    UpdateDependentElsAndScenes(TEveElement* root);
 
 public:
-   TEveProjectionManager();
+   TEveProjectionManager(TEveProjection::EPType_e type=TEveProjection::kPT_Unknown);
    virtual ~TEveProjectionManager();
 
    void AddDependent(TEveElement* el);
diff --git a/graf3d/eve/inc/TEveProjections.h b/graf3d/eve/inc/TEveProjections.h
index 8fb455d..c0b17bd 100644
--- a/graf3d/eve/inc/TEveProjections.h
+++ b/graf3d/eve/inc/TEveProjections.h
@@ -16,18 +16,17 @@
 
 #include <vector>
 
-////////////////////////////////////////////////////////////////
-//                                                            //
-// TEveProjection                                             //
-//                                                            //
-////////////////////////////////////////////////////////////////
+
+//==============================================================================
+// TEveProjection
+//==============================================================================
 
 class TEveProjection
 {
 public:
-   enum EPType_e   { kPT_Unknown, kPT_RPhi, kPT_RhoZ, kPT_End };// type
-   enum EPProc_e   { kPP_Plane, kPP_Distort, kPP_Full };        // procedure
-   enum EGeoMode_e { kGM_Unknown, kGM_Polygons, kGM_Segments }; // reconstruction of geometry
+   enum EPType_e   { kPT_Unknown, kPT_RPhi, kPT_RhoZ, kPT_3D, kPT_End }; // projection type
+   enum EPProc_e   { kPP_Plane, kPP_Distort, kPP_Full };                 // projection procedure
+   enum EGeoMode_e { kGM_Unknown, kGM_Polygons, kGM_Segments };          // strategy for geometry projections
 
    struct PreScaleEntry_t
    {
@@ -57,7 +56,7 @@ protected:
    TEveVector          fZeroPosVal;    // projected origin (0, 0, 0)
 
    Bool_t              fUsePreScale;   // use pre-scaling
-   vPreScale_t         fPreScales[2];  // scaling before the distortion
+   vPreScale_t         fPreScales[3];  // scaling before the distortion
 
    Float_t             fDistortion;    // distortion
    Float_t             fFixR;          // radius from which scaling remains constant
@@ -73,25 +72,31 @@ protected:
    TEveVector          fLowLimit;      // convergence of point +infinity
    TEveVector          fUpLimit;       // convergence of point -infinity
 
+   void PreScaleVariable(Int_t dim, Float_t& v);
+
 public:
    TEveProjection();
    virtual ~TEveProjection() {}
 
-   virtual   void      ProjectPoint(Float_t&, Float_t&, Float_t&, EPProc_e p = kPP_Full ) = 0;
-   virtual   void      ProjectPointFv(Float_t* v) { ProjectPoint(v[0], v[1], v[2]); }
-   virtual   void      ProjectVector(TEveVector& v);
+   virtual Bool_t      Is2D() const = 0;
+   virtual Bool_t      Is3D() const = 0;
 
-   const     char*     GetName() { return fName.Data(); }
-   void                SetName(const char* txt) { fName = txt; }
+   virtual void        ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e p = kPP_Full) = 0;
+   virtual void        ProjectPointfv(Float_t* v, Float_t d);
+   virtual void        ProjectPointdv(Double_t* v, Float_t d);
+   virtual void        ProjectVector(TEveVector& v, Float_t d);
 
-   virtual void        SetCenter(TEveVector& v) { fCenter = v; UpdateLimit(); }
-   virtual Float_t*    GetProjectedCenter() { return fCenter.Arr(); }
+   const   Char_t*     GetName() const            { return fName.Data(); }
+   void                SetName(const Char_t* txt) { fName = txt; }
 
-   void                SetType(EPType_e t) { fType = t; }
-   EPType_e            GetType() { return fType; }
+   virtual void        SetCenter(TEveVector& v)   { fCenter = v; UpdateLimit(); }
+   virtual Float_t*    GetProjectedCenter()       { return fCenter.Arr(); }
 
-   void                SetGeoMode(EGeoMode_e m) { fGeoMode = m; }
-   EGeoMode_e          GetGeoMode() { return fGeoMode; }
+   void                SetType(EPType_e t)        { fType = t; }
+   EPType_e            GetType() const            { return fType; }
+
+   void                SetGeoMode(EGeoMode_e m)   { fGeoMode = m; }
+   EGeoMode_e          GetGeoMode() const         { return fGeoMode; }
 
    virtual void        UpdateLimit();
 
@@ -99,6 +104,7 @@ public:
    void     SetUsePreScale(Bool_t x) { fUsePreScale = x; }
 
    void     PreScalePoint(Float_t& x, Float_t& y);
+   void     PreScalePoint(Float_t& x, Float_t& y, Float_t& z);
    void     AddPreScaleEntry(Int_t coord, Float_t max_val, Float_t scale);
    void     ChangePreScaleEntry(Int_t coord, Int_t entry, Float_t new_scale);
    void     ClearPreScales();
@@ -130,11 +136,9 @@ public:
 };
 
 
-////////////////////////////////////////////////////////////////
-//                                                            //
-// TEveRhoZProjection                                         //
-//                                                            //
-////////////////////////////////////////////////////////////////
+//==============================================================================
+// TEveRhoZProjection
+//==============================================================================
 
 class TEveRhoZProjection: public TEveProjection
 {
@@ -145,7 +149,10 @@ public:
    TEveRhoZProjection();
    virtual ~TEveRhoZProjection() {}
 
-   virtual   void      ProjectPoint(Float_t& x, Float_t& y, Float_t& z, EPProc_e proc = kPP_Full);
+   virtual Bool_t      Is2D() const { return kTRUE;  }
+   virtual Bool_t      Is3D() const { return kFALSE; }
+
+   virtual   void      ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
 
    virtual   void      SetCenter(TEveVector& center);
    virtual   Float_t*  GetProjectedCenter() { return fProjectedCenter.Arr(); }
@@ -159,11 +166,9 @@ public:
 };
 
 
-////////////////////////////////////////////////////////////////
-//                                                            //
-// TEveRPhiProjection                                         //
-//                                                            //
-////////////////////////////////////////////////////////////////
+//==============================================================================
+// TEveRPhiProjection
+//==============================================================================
 
 class TEveRPhiProjection : public TEveProjection
 {
@@ -171,9 +176,31 @@ public:
    TEveRPhiProjection();
    virtual ~TEveRPhiProjection() {}
 
-   virtual void ProjectPoint(Float_t& x, Float_t& y, Float_t& z, EPProc_e proc = kPP_Full);
+   virtual Bool_t Is2D() const { return kTRUE;  }
+   virtual Bool_t Is3D() const { return kFALSE; }
+
+   virtual void   ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
 
    ClassDef(TEveRPhiProjection, 0); // XY non-linear projection.
 };
 
+
+//==============================================================================
+// TEve3DProjection
+//==============================================================================
+
+class TEve3DProjection : public TEveProjection
+{
+public:
+   TEve3DProjection();
+   virtual ~TEve3DProjection() {}
+
+   virtual Bool_t Is2D() const { return kFALSE; }
+   virtual Bool_t Is3D() const { return kTRUE;  }
+
+   virtual void   ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
+
+   ClassDef(TEve3DProjection, 0); // 3D scaling "projection"
+};
+
 #endif
diff --git a/graf3d/eve/inc/TEveRGBAPalette.h b/graf3d/eve/inc/TEveRGBAPalette.h
index 640f1bf..8912453 100644
--- a/graf3d/eve/inc/TEveRGBAPalette.h
+++ b/graf3d/eve/inc/TEveRGBAPalette.h
@@ -15,8 +15,11 @@
 #include "TEveUtil.h"
 
 #include "TObject.h"
+#include "TQObject.h"
 
-class TEveRGBAPalette : public TObject, public TEveRefCnt
+class TEveRGBAPalette : public TObject,
+                        public TQObject,
+                        public TEveRefCnt
 {
    friend class TEveRGBAPaletteEditor;
    friend class TEveRGBAPaletteSubEditor;
@@ -33,10 +36,10 @@ protected:
    Int_t     fHighLimit; // High limit for Min/Max values (used by editor)
    Int_t     fMinVal;
    Int_t     fMaxVal;
-   Int_t     fNBins;
 
-   Bool_t    fInterpolate;
-   Bool_t    fShowDefValue;
+   Bool_t    fInterpolate;    // Interpolate colors for signal values.
+   Bool_t    fShowDefValue;   // Flags whether signals with default value should be shown.
+   Bool_t    fFixColorRange;  // If true, map palette to low/high limit otherwise to min/max value.
    Int_t     fUnderflowAction;
    Int_t     fOverflowAction;
 
@@ -47,6 +50,9 @@ protected:
    Color_t   fOverColor;      // Overflow color
    UChar_t   fOverRGBA[4];
 
+   mutable Int_t    fNBins;      // Number of signal-color entries.
+   mutable Int_t    fCAMin;      // Minimal signal in color-array.
+   mutable Int_t    fCAMax;      // Maximal signal in color-array.
    mutable UChar_t* fColorArray; //[4*fNBins]
 
    void SetupColor(Int_t val, UChar_t* pix) const;
@@ -55,7 +61,8 @@ protected:
 
 public:
    TEveRGBAPalette();
-   TEveRGBAPalette(Int_t min, Int_t max, Bool_t interp=kFALSE, Bool_t showdef=kTRUE);
+   TEveRGBAPalette(Int_t min, Int_t max, Bool_t interp=kTRUE,
+                   Bool_t showdef=kTRUE, Bool_t fixcolrng=kFALSE);
    virtual ~TEveRGBAPalette();
 
    void SetupColorArray() const;
@@ -86,6 +93,9 @@ public:
    Bool_t GetShowDefValue() const { return fShowDefValue; }
    void   SetShowDefValue(Bool_t v) { fShowDefValue = v; }
 
+   Bool_t GetFixColorRange() const { return fFixColorRange; }
+   void   SetFixColorRange(Bool_t v);
+
    Int_t GetUnderflowAction() const  { return fUnderflowAction; }
    Int_t GetOverflowAction()  const  { return fOverflowAction;  }
    void  SetUnderflowAction(Int_t a) { fUnderflowAction = a;    }
@@ -99,8 +109,8 @@ public:
    const UChar_t* GetDefaultRGBA() const { return fDefaultRGBA;  }
 
    void   SetDefaultColor(Color_t ci);
-   void   SetDefaultColor(Pixel_t pix);
-   void   SetDefaultColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a=255);
+   void   SetDefaultColorPixel(Pixel_t pix);
+   void   SetDefaultColorRGBA(UChar_t r, UChar_t g, UChar_t b, UChar_t a=255);
 
    // ----------------------------------------------------------------
 
@@ -110,8 +120,8 @@ public:
    const UChar_t* GetUnderRGBA() const { return fUnderRGBA;  }
 
    void   SetUnderColor(Color_t ci);
-   void   SetUnderColor(Pixel_t pix);
-   void   SetUnderColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a=255);
+   void   SetUnderColorPixel(Pixel_t pix);
+   void   SetUnderColorRGBA(UChar_t r, UChar_t g, UChar_t b, UChar_t a=255);
 
    // ----------------------------------------------------------------
 
@@ -121,13 +131,12 @@ public:
    const UChar_t* GetOverRGBA() const { return fOverRGBA;  }
 
    void   SetOverColor(Color_t ci);
-   void   SetOverColor(Pixel_t pix);
-   void   SetOverColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a=255);
+   void   SetOverColorPixel(Pixel_t pix);
+   void   SetOverColorRGBA(UChar_t r, UChar_t g, UChar_t b, UChar_t a=255);
 
    // ================================================================
 
-   // ?? Should we emit some *SIGNALS* ??
-   // ?? Should we have a RendererTimeStamp ??
+   void MinMaxValChanged(); // *SIGNAL*
 
    ClassDef(TEveRGBAPalette, 1); // A generic, speed-optimised mapping from value to RGBA color supporting different wrapping and range truncation modes.
 };
@@ -154,23 +163,27 @@ inline const UChar_t* TEveRGBAPalette::ColorFromValue(Int_t val) const
    // for kLA_Wrap and kLA_Clip otherwise we proceed as for kLA_Mark.
 
    if (!fColorArray)  SetupColorArray();
-   if (val < fMinVal) {
+
+   if (val < fMinVal)
+   {
       if (fUnderflowAction == kLA_Wrap)
-         val = (val+1-fMinVal)%fNBins + fMaxVal;
+         val = (val+1-fCAMin)%fNBins + fCAMax;
       else if (fUnderflowAction == kLA_Clip)
          val = fMinVal;
       else
          return fUnderRGBA;
    }
-   else if(val > fMaxVal) {
+   else if(val > fMaxVal)
+   {
       if (fOverflowAction == kLA_Wrap)
-         val = (val-1-fMaxVal)%fNBins + fMinVal;
+         val = (val-1-fCAMax)%fNBins + fCAMin;
       else if (fOverflowAction == kLA_Clip)
          val = fMaxVal;
       else
          return fOverRGBA;
    }
-   return fColorArray + 4 * (val - fMinVal);
+
+   return fColorArray + 4 * (val - fCAMin);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/inc/TEveRGBAPaletteEditor.h b/graf3d/eve/inc/TEveRGBAPaletteEditor.h
index 5f30d3d..0c33ead 100644
--- a/graf3d/eve/inc/TEveRGBAPaletteEditor.h
+++ b/graf3d/eve/inc/TEveRGBAPaletteEditor.h
@@ -29,18 +29,19 @@ private:
    TEveRGBAPaletteSubEditor& operator=(const TEveRGBAPaletteSubEditor&); // Not implemented
 
 protected:
-   TEveRGBAPalette*      fM;
+   TEveRGBAPalette      *fM;
 
-   TGComboBox*       fUnderflowAction;
-   TGColorSelect*    fUnderColor;
-   TGComboBox*       fOverflowAction;
-   TGColorSelect*    fOverColor;
+   TGComboBox           *fUnderflowAction;
+   TGColorSelect        *fUnderColor;
+   TGComboBox           *fOverflowAction;
+   TGColorSelect        *fOverColor;
 
-   TEveGDoubleValuator* fMinMax;
+   TEveGDoubleValuator  *fMinMax;
 
-   TGCheckButton*    fInterpolate;
-   TGCheckButton*    fShowDefValue;
-   TGColorSelect*    fDefaultColor;
+   TGCheckButton        *fInterpolate;
+   TGCheckButton        *fShowDefValue;
+   TGColorSelect        *fDefaultColor;
+   TGCheckButton        *fFixColorRange;
 
 public:
    TEveRGBAPaletteSubEditor(const TGWindow* p);
@@ -55,6 +56,7 @@ public:
    void DoInterpolate();
    void DoShowDefValue();
    void DoDefaultColor(Pixel_t color);
+   void DoFixColorRange();
    void DoUnderColor(Pixel_t color);
    void DoOverColor(Pixel_t color);
    void DoUnderflowAction(Int_t mode);
@@ -74,8 +76,8 @@ private:
    TEveRGBAPaletteEditor& operator=(const TEveRGBAPaletteEditor&); // Not implemented
 
 protected:
-   TEveRGBAPalette*          fM;
-   TEveRGBAPaletteSubEditor* fSE;
+   TEveRGBAPalette           *fM;
+   TEveRGBAPaletteSubEditor  *fSE;
 
 public:
    TEveRGBAPaletteEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30, UInt_t options = kChildFrame, Pixel_t back=GetDefaultFrameBackground());
diff --git a/graf3d/eve/inc/TEveSelection.h b/graf3d/eve/inc/TEveSelection.h
index 651f694..f330063 100644
--- a/graf3d/eve/inc/TEveSelection.h
+++ b/graf3d/eve/inc/TEveSelection.h
@@ -75,9 +75,10 @@ public:
 
    virtual void RemoveImpliedSelected(TEveElement* el);
 
-   void SelectionAdded(TEveElement* el);   // *SIGNAL*
-   void SelectionRemoved(TEveElement* el); // *SIGNAL*
-   void SelectionCleared();                // *SIGNAL*
+   void SelectionAdded(TEveElement* el);    // *SIGNAL*
+   void SelectionRemoved(TEveElement* el);  // *SIGNAL*
+   void SelectionCleared();                 // *SIGNAL*
+   void SelectionRepeated(TEveElement* el); // *SIGNAL*
 
    // ----------------------------------------------------------------
    // Interface to make selection active/non-active.
@@ -92,6 +93,8 @@ public:
    TEveElement* MapPickedToSelected(TEveElement* el);
 
    virtual void UserPickedElement(TEveElement* el, Bool_t multi=kFALSE);
+   virtual void UserRePickedElement(TEveElement* el);
+   virtual void UserUnPickedElement(TEveElement* el);
 
    // ----------------------------------------------------------------
 
diff --git a/graf3d/eve/inc/TEveStraightLineSet.h b/graf3d/eve/inc/TEveStraightLineSet.h
index 24df2b7..d1c5f2a 100644
--- a/graf3d/eve/inc/TEveStraightLineSet.h
+++ b/graf3d/eve/inc/TEveStraightLineSet.h
@@ -104,7 +104,7 @@ public:
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
-   virtual TClass* ProjectedClass() const;
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
    virtual void ComputeBBox();
    virtual void Paint(Option_t* option="");
@@ -122,12 +122,14 @@ private:
    TEveStraightLineSetProjected(const TEveStraightLineSetProjected&);            // Not implemented
    TEveStraightLineSetProjected& operator=(const TEveStraightLineSetProjected&); // Not implemented
 
+protected:
+   virtual void SetDepthLocal(Float_t d);
+
 public:
    TEveStraightLineSetProjected();
    virtual ~TEveStraightLineSetProjected() {}
 
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
-   virtual void SetDepth(Float_t d);
    virtual void UpdateProjection();
 
    ClassDef(TEveStraightLineSetProjected, 1); // Projected copy of a TEveStraightLineSet.
diff --git a/graf3d/eve/inc/TEveText.h b/graf3d/eve/inc/TEveText.h
index cb3f5ee..ce277ab 100644
--- a/graf3d/eve/inc/TEveText.h
+++ b/graf3d/eve/inc/TEveText.h
@@ -40,6 +40,7 @@ protected:
    Bool_t    fAutoLighting; // use default lighting
    Bool_t    fLighting;     // force lighting
 
+   Float_t   fPolygonOffset[2]; // depth test
 
 public:
    TEveText(const char* txt="");
@@ -65,6 +66,9 @@ public:
    Float_t GetExtrude() const    { return fExtrude; }
    void    SetExtrude(Float_t x) { fExtrude = x;    }
 
+   Float_t  GetPolygonOffset(Int_t i) const { return fPolygonOffset[i]; }
+   void     SetPolygonOffset(Float_t factor, Float_t units);
+
    virtual Bool_t CanEditMainColor() const { return kTRUE; }
    virtual void   Paint(Option_t* option="");
    virtual void   ComputeBBox();
diff --git a/graf3d/eve/inc/TEveTextGL.h b/graf3d/eve/inc/TEveTextGL.h
index fc49dfe..eef76ef 100644
--- a/graf3d/eve/inc/TEveTextGL.h
+++ b/graf3d/eve/inc/TEveTextGL.h
@@ -28,7 +28,6 @@ protected:
    mutable TGLFont        fFont;     // FTFont wrapper
    mutable Double_t       fX[4][3];  // 3D position of font
 
-   void    SetFont(TGLRnrCtx & rnrCtx) const;
 public:
    TEveTextGL();
    virtual ~TEveTextGL() {}
diff --git a/graf3d/eve/inc/TEveTrack.h b/graf3d/eve/inc/TEveTrack.h
index a592baa..c79517c 100644
--- a/graf3d/eve/inc/TEveTrack.h
+++ b/graf3d/eve/inc/TEveTrack.h
@@ -113,7 +113,7 @@ public:
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
-   virtual TClass* ProjectedClass() const;
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
    Bool_t  ShouldBreakTrack() const;
 
@@ -131,7 +131,6 @@ public:
 /******************************************************************************/
 
 class TEveTrackList : public TEveElementList,
-		      public TEveProjectable,
 		      public TAttMarker,
 		      public TAttLine
 {
@@ -219,7 +218,7 @@ public:
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
-   virtual TClass* ProjectedClass() const;
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
    ClassDef(TEveTrackList, 1); // A list of tracks supporting change of common attributes and selection based on track parameters.
 };
diff --git a/graf3d/eve/inc/TEveTrackProjected.h b/graf3d/eve/inc/TEveTrackProjected.h
index ba53d21..dbfeb04 100644
--- a/graf3d/eve/inc/TEveTrackProjected.h
+++ b/graf3d/eve/inc/TEveTrackProjected.h
@@ -35,14 +35,14 @@ protected:
    std::vector<Int_t>   fBreakPoints; // indices of track break-points
    TEveProjection      *fProjection;  // projection
 
+   virtual void SetDepthLocal(Float_t d);
+
 public:
    TEveTrackProjected();
    virtual ~TEveTrackProjected() {}
 
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
 
-   virtual void SetDepth(Float_t d);
-
    virtual void UpdateProjection();
    virtual void MakeTrack(Bool_t recurse=kTRUE);
 
@@ -65,14 +65,17 @@ private:
    TEveTrackListProjected(const TEveTrackListProjected&);            // Not implemented
    TEveTrackListProjected& operator=(const TEveTrackListProjected&); // Not implemented
 
+protected:
+   virtual void SetDepthLocal(Float_t d);
+
 public:
    TEveTrackListProjected();
    virtual ~TEveTrackListProjected() {}
 
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
-   virtual void SetDepth(Float_t d);
    virtual void UpdateProjection()  {}
 
+   virtual void SetDepth(Float_t d);
    virtual void SetDepth(Float_t d, TEveElement* el);
 
    ClassDef(TEveTrackListProjected, 1); // Specialization of TEveTrackList for holding TEveTrackProjected objects.
diff --git a/graf3d/eve/inc/TEveViewer.h b/graf3d/eve/inc/TEveViewer.h
index 4c8dbbc..5702261 100644
--- a/graf3d/eve/inc/TEveViewer.h
+++ b/graf3d/eve/inc/TEveViewer.h
@@ -110,6 +110,8 @@ public:
 
    void OnMouseOver(TGLPhysicalShape* shape, UInt_t state);
    void OnClicked(TObject *obj, UInt_t button, UInt_t state);
+   void OnReClicked(TObject *obj, UInt_t button, UInt_t state);
+   void OnUnClicked(TObject *obj, UInt_t button, UInt_t state);
 
    // --------------------------------
 
diff --git a/graf3d/eve/src/TEveArrow.cxx b/graf3d/eve/src/TEveArrow.cxx
index a775a24..31539dc 100644
--- a/graf3d/eve/src/TEveArrow.cxx
+++ b/graf3d/eve/src/TEveArrow.cxx
@@ -31,7 +31,8 @@ TEveArrow::TEveArrow(Float_t xVec, Float_t yVec, Float_t zVec,
    TAtt3D(), TAttBBox(),
 
    fTubeR(0.02), fConeR(0.04), fConeL(0.08),
-   fOrigin(xOrg, yOrg, zOrg), fVector(xVec, yVec, zVec)
+   fOrigin(xOrg, yOrg, zOrg), fVector(xVec, yVec, zVec),
+   fDrawQuality(10)
 {
    // Constructor.
    // Org - starting point.
diff --git a/graf3d/eve/src/TEveArrowGL.cxx b/graf3d/eve/src/TEveArrowGL.cxx
index 642e52b..8f9fb3a 100644
--- a/graf3d/eve/src/TEveArrowGL.cxx
+++ b/graf3d/eve/src/TEveArrowGL.cxx
@@ -60,11 +60,7 @@ void TEveArrowGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
 {
    // Render with OpenGL.
 
-   // printf("TEveArrowGL::DirectDraw LOD \n");
-
    static TGLQuadric quad;
-   UInt_t drawQuality = 10;
-   // Draw 3D line (tube) with optional head shape
 
    glPushMatrix();
 
@@ -77,16 +73,16 @@ void TEveArrowGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
    // Line (tube) component
    Float_t r = size*fM->fTubeR;
    Float_t h = size*fM->fConeL;
-   gluCylinder(quad.Get(), r, r, size - h, drawQuality, 1);
+   gluCylinder(quad.Get(), r, r, size - h, fM->fDrawQuality, 1);
    gluQuadricOrientation(quad.Get(), (GLenum)GLU_INSIDE);
-   gluDisk(quad.Get(), 0.0, r, drawQuality, 1);
+   gluDisk(quad.Get(), 0.0, r, fM->fDrawQuality, 1);
 
    // Arrow cone
    r = size*fM->fConeR;
    glTranslated(0.0, 0.0, size -h );
-   gluDisk(quad.Get(), 0.0, r, drawQuality, 1);
+   gluDisk(quad.Get(), 0.0, r, fM->fDrawQuality, 1);
    gluQuadricOrientation(quad.Get(), (GLenum)GLU_OUTSIDE);
-   gluCylinder(quad.Get(), r, 0., h , drawQuality, 1);
+   gluCylinder(quad.Get(), r, 0., h , fM->fDrawQuality, 1);
 
    glPopMatrix();
 }
diff --git a/graf3d/eve/src/TEveBoxSetGL.cxx b/graf3d/eve/src/TEveBoxSetGL.cxx
index 0c74892..49b101f 100644
--- a/graf3d/eve/src/TEveBoxSetGL.cxx
+++ b/graf3d/eve/src/TEveBoxSetGL.cxx
@@ -11,12 +11,11 @@
 
 #include "TEveBoxSetGL.h"
 #include "TEveBoxSet.h"
+#include "TEveFrameBoxGL.h"
 
 #include "TGLIncludes.h"
 #include "TGLRnrCtx.h"
-#include "TGLScene.h"
 #include "TGLSelectRecord.h"
-#include "TGLContext.h"
 #include "TGLQuadric.h"
 
 //==============================================================================
@@ -406,6 +405,11 @@ void TEveBoxSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    if (rnrCtx.SecSelection()) glPopName();
 
    glPopAttrib();
+
+   if (mB.fFrame != 0 && ! rnrCtx.SecSelection())
+   {
+      TEveFrameBoxGL::Render(mB.fFrame);
+   }
 }
 
 /******************************************************************************/
diff --git a/graf3d/eve/src/TEveCalo.cxx b/graf3d/eve/src/TEveCalo.cxx
index b83c9ba..47c2b48 100644
--- a/graf3d/eve/src/TEveCalo.cxx
+++ b/graf3d/eve/src/TEveCalo.cxx
@@ -48,6 +48,7 @@ TEveCaloViz::TEveCaloViz(TEveCaloData* data, const char* n, const char* t) :
    TEveProjectable(),
 
    fData(0),
+   fCellIdCacheOK(kFALSE),
 
    fEtaMin(-10),
    fEtaMax(10),
@@ -67,12 +68,11 @@ TEveCaloViz::TEveCaloViz(TEveCaloData* data, const char* n, const char* t) :
    fMaxValAbs(100),
 
    fValueIsColor(kFALSE),
-   fPalette(0),
-
-   fCellIdCacheOK(kFALSE)
+   fPalette(0)
 {
    // Constructor.
 
+   fPickable = kTRUE;
    SetElementNameTitle(n, t);
    SetData(data);
 }
@@ -83,7 +83,6 @@ TEveCaloViz::~TEveCaloViz()
    // Destructor.
 
    if (fPalette) fPalette->DecRefCount();
-   if (fData) fData->DecRefCount(this);
 }
 
 //______________________________________________________________________________
@@ -95,6 +94,25 @@ Float_t TEveCaloViz::GetDataSliceThreshold(Int_t slice) const
 }
 
 //______________________________________________________________________________
+TEveElement* TEveCaloViz::ForwardSelection()
+{
+   // Management of selection state and ownership of selected cell list
+   // is done in TEveCaloData. This is a reason selection is forwared to it.
+
+   return fData;
+}
+
+//______________________________________________________________________________
+TEveElement* TEveCaloViz::ForwardEdit()
+{
+   // Management of selection state and ownership of selected cell list
+   // is done in TEveCaloData. We still want GUI editor to disply
+   // concrete calo-viz object.
+
+   return this;
+}
+
+//______________________________________________________________________________
 void TEveCaloViz::SetDataSliceThreshold(Int_t slice, Float_t val)
 {
    // Set threshold for given slice.
@@ -190,12 +208,13 @@ void TEveCaloViz::SetData(TEveCaloData* data)
 {
    // Set calorimeter event data.
 
+
    if (data == fData) return;
-   if (fData) fData->DecRefCount(this);
+   if (fData) fData->RemoveElement(this);
    fData = data;
    if (fData)
    {
-      fData->IncRefCount(this);
+      fData->AddElement(this);
       DataChanged();
    }
 }
@@ -238,6 +257,30 @@ void TEveCaloViz::DataChanged()
 }
 
 //______________________________________________________________________________
+void TEveCaloViz::AssertCellIdCache() const
+{
+   // Assert cell id cache is ok.
+ 
+   TEveCaloViz* cv = const_cast<TEveCaloViz*>(this);
+   if (!fCellIdCacheOK)
+      cv->BuildCellIdCache();
+}
+
+//______________________________________________________________________________
+Bool_t TEveCaloViz::CellInEtaPhiRng(TEveCaloData::CellData_t& cellData) const
+{
+   // Returns true if given cell is in the ceta phi range.
+
+   if (cellData.EtaMin() >= fEtaMin && cellData.EtaMax() <= fEtaMax)
+   {
+      if (TEveUtil::IsU1IntervalContainedByMinMax
+          (fPhi-fPhiOffset, fPhi+fPhiOffset, cellData.PhiMin(), cellData.PhiMax()))
+         return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
 void TEveCaloViz::AssignCaloVizParameters(TEveCaloViz* m)
 {
    // Assign paramteres from given model.
@@ -337,7 +380,7 @@ void TEveCaloViz::Paint(Option_t* /*option*/)
 }
 
 //______________________________________________________________________________
-TClass* TEveCaloViz::ProjectedClass() const
+TClass* TEveCaloViz::ProjectedClass(const TEveProjection*) const
 {
    // Virtual from TEveProjectable, returns TEveCalo2D class.
 
@@ -375,7 +418,7 @@ void TEveCaloViz::SetupColorHeight(Float_t value, Int_t slice, Float_t& outH) co
 ClassImp(TEveCalo3D);
 
 
-TEveCalo3D::TEveCalo3D(TEveCaloData* d, const char* n, const char* t): 
+TEveCalo3D::TEveCalo3D(TEveCaloData* d, const char* n, const char* t):
    TEveCaloViz(d, n, t),
 
    fRnrEndCapFrame    (kTRUE),
@@ -433,7 +476,9 @@ ClassImp(TEveCalo2D);
 TEveCalo2D::TEveCalo2D(const char* n, const char* t):
    TEveCaloViz(0, n, t),
    TEveProjected(),
-   fOldProjectionType(TEveProjection::kPT_Unknown)
+   fOldProjectionType(TEveProjection::kPT_Unknown),
+   fMaxESumBin( 0),
+   fMaxEtSumBin(0)
 {
    // Constructor.
 }
@@ -443,12 +488,28 @@ TEveCalo2D::~TEveCalo2D()
 {
    // Destructor.
 
-   for(UInt_t vi = 0; vi < fCellLists.size(); ++vi)
-   {
-      TEveCaloData::vCellId_t* cids = fCellLists[vi];
-      cids->clear();
-      delete cids;
+   TEveCaloData::vCellId_t* cids;
+   UInt_t n;
+
+   // clear selected cell ids
+   n = fCellListsSelected.size();
+   for(UInt_t i = 0; i < n; ++i) {
+      cids = fCellListsSelected[i];
+      if (cids) {
+         cids->clear(); delete cids;
+      }
    }
+   fCellListsSelected.clear();
+
+   // clear all cell dds
+   n = fCellLists.size();
+   for(UInt_t i = 0; i < n; ++i) {
+      cids = fCellLists[i];
+      if (cids) {
+         cids->clear(); delete cids;
+      }
+   }
+   fCellLists.clear();
 }
 
 //______________________________________________________________________________
@@ -480,63 +541,164 @@ void TEveCalo2D::BuildCellIdCache()
    // Build lists of drawn cell IDs. See TEveCalo2DGL::DirecDraw().
 
    // clear old cache
-   for (std::vector<TEveCaloData::vCellId_t*>::iterator it = fCellLists.begin(); it != fCellLists.end(); it++)
-      delete *it;
-
+   for (vBinCells_i it = fCellLists.begin(); it != fCellLists.end(); it++)
+   {
+      if (*it)
+      {
+         (*it)->clear();
+         delete *it;
+      }
+   }
    fCellLists.clear();
-   fBinIds.clear();
+   fCellLists.push_back(0);
 
    TEveProjection::EPType_e pt = fManager->GetProjection()->GetType();
-   TEveCaloData::vCellId_t*  clv; // ids per phi bin in r-phi projection else ids per eta bins in rho-z projection
+   TEveCaloData::vCellId_t* clv; // ids per phi bin in r-phi projection else ids per eta bins in rho-z projection
+
+   Bool_t isRPhi = (pt == TEveProjection::kPT_RPhi);
 
-   if (pt == TEveProjection::kPT_RPhi)
+   const TAxis* axis = isRPhi ? fData->GetPhiBins() :  fData->GetEtaBins();
+   Int_t nBins = axis->GetNbins();
+
+   Float_t min, max;
+   if (isRPhi)
    {
-      // build list on basis of phi bins
-      const TAxis* ay = fData->GetPhiBins();
-      assert(ay);
-      Int_t nBins = ay->GetNbins();
-      for (Int_t ibin = 1; ibin <= nBins; ++ibin)
-      {
+      min = GetPhiMin() - fData->GetEps();
+      max = GetPhiMax() + fData->GetEps();
+      for (Int_t ibin = 1; ibin <= nBins; ++ibin) {
+         clv = 0;
          if ( TEveUtil::IsU1IntervalOverlappingByMinMax
-              (GetPhiMin(), GetPhiMax(), ay->GetBinLowEdge(ibin), ay->GetBinUpEdge(ibin)))
+              (min, max, axis->GetBinLowEdge(ibin), axis->GetBinUpEdge(ibin)))
          {
             clv = new TEveCaloData::vCellId_t();
-            fData->GetCellList(GetEta(), GetEtaRng(), ay->GetBinCenter(ibin), ay->GetBinWidth(ibin),*clv);
+            fData->GetCellList(GetEta(), GetEtaRng(), axis->GetBinCenter(ibin), axis->GetBinWidth(ibin), *clv);
+            if (!clv->size()) {
+               delete clv; clv = 0;
+            }
+         }
+         fCellLists.push_back(clv);
+      }
+   }
+   else
+   {
+      min = GetEtaMin() - fData->GetEps();
+      max = GetEtaMax() + fData->GetEps();
+      for (Int_t ibin = 1; ibin <= nBins; ++ibin) {
+         clv = 0;
+         Float_t low = axis->GetBinLowEdge(ibin);
+         Float_t up = axis->GetBinUpEdge(ibin) ;
+         if (low >= min && up <= max)
+         {
+            clv = new TEveCaloData::vCellId_t();
+            fData->GetCellList(axis->GetBinCenter(ibin), axis->GetBinWidth(ibin), fPhi, GetPhiRng(), *clv);
+            if (!clv->size()) {
+               delete clv; clv = 0;
+            }
+         }
+         fCellLists.push_back(clv);
+      }
+   }
 
-            if (clv->size())
-            {
-               fCellLists.push_back(clv);
-               fBinIds.push_back(ibin);
+   // cache max bin sum for auto scale
+   if (!fScaleAbs)
+   {
+      fMaxESumBin  = 0;
+      fMaxEtSumBin = 0;
+      Float_t sumE  = 0;
+      Float_t sumEt = 0;
+      TEveCaloData::CellData_t  cellData;
+      for (Int_t ibin = 1; ibin <= nBins; ++ibin) {
+         TEveCaloData::vCellId_t* cids = fCellLists[ibin];
+         if (cids)
+         {
+            sumE = 0; sumEt = 0;
+            for (TEveCaloData::vCellId_i it = cids->begin(); it != cids->end(); it++)
+            {  
+               fData->GetCellData(*it, cellData);
+               sumE  += cellData.Value(kFALSE);
+               sumEt += cellData.Value(kTRUE);
             }
-            else
-               delete clv;
+            fMaxESumBin  = TMath::Max(fMaxESumBin,  sumE);
+            fMaxEtSumBin = TMath::Max(fMaxEtSumBin, sumEt);  
          }
       }
+      ComputeBBox();
    }
-   else if (pt == TEveProjection::kPT_RhoZ)
+
+   fCellIdCacheOK= kTRUE;
+}
+
+//______________________________________________________________________________
+void TEveCalo2D::CellSelectionChanged()
+{
+   // Sort slected cells in eta or phi bins.
+
+   // clear old cache
+   for (vBinCells_i it = fCellListsSelected.begin(); it != fCellListsSelected.end(); it++)
    {
-      // build list on basis of eta bins
-      const TAxis *ax    = fData->GetEtaBins();
-      assert(ax);
-      const Int_t  nBins = ax->GetNbins();
-      for (Int_t ibin = 1; ibin <= nBins; ++ibin)
+      if (*it)
       {
-         if (ax->GetBinLowEdge(ibin) > fEtaMin && ax->GetBinUpEdge(ibin) <= fEtaMax)
+         (*it)->clear();
+         delete *it;
+      }
+   }
+   fCellListsSelected.clear();
+
+   TEveCaloData::vCellId_t&  cells = fData->GetCellsSelected();
+   TEveCaloData::CellData_t  cellData;
+   if (cells.size())
+   {
+      Bool_t rPhi  = fManager->GetProjection()->GetType() == TEveProjection::kPT_RPhi;
+      UInt_t nBins = rPhi ? fData->GetPhiBins()->GetNbins() : fData->GetEtaBins()->GetNbins();
+
+      fCellListsSelected.resize(nBins+1);
+      for (UInt_t b = 0; b <= nBins; ++b)
+         fCellListsSelected[b] = 0;
+
+      Int_t bin;
+      for (TEveCaloData::vCellId_i i=cells.begin(); i!=cells.end(); i++)
+      {
+         fData->GetCellData(*i, cellData);
+         if (CellInEtaPhiRng(cellData))
          {
-            clv = new TEveCaloData::vCellId_t();
-            fData->GetCellList(ax->GetBinCenter(ibin), ax->GetBinWidth(ibin), fPhi, GetPhiRng(), *clv);
-            if (clv->size())
+            if (rPhi)
             {
-               fCellLists.push_back(clv);
-               fBinIds.push_back(ibin);
+               bin = fData->GetPhiBins()->FindBin(cellData.Phi());
+            }
+            else {
+               bin = fData->GetEtaBins()->FindBin(cellData.Eta());
             }
-            else
-               delete clv;
+            if (fCellListsSelected[bin] == 0)
+               fCellListsSelected[bin] = new TEveCaloData::vCellId_t();
+
+            fCellListsSelected[bin]->push_back(*i);
          }
       }
    }
+}
 
-   fCellIdCacheOK= kTRUE;
+//______________________________________________________________________________
+Float_t TEveCalo2D::GetValToHeight() const
+{
+   // Virtual function of TEveCaloViz.
+   // Get transformation factor from E/Et to height.
+
+   AssertCellIdCache();
+
+   if (fScaleAbs)
+   {
+      return fMaxTowerH/fMaxValAbs;
+   }
+   else
+   {
+     if (fData->Empty())
+       return 1;
+
+     if (fPlotEt)
+      return fMaxTowerH/fMaxEtSumBin;
+     else
+      return fMaxTowerH/fMaxESumBin;
+   }
 }
 
 //______________________________________________________________________________
@@ -548,29 +710,29 @@ void TEveCalo2D::ComputeBBox()
    BBoxZero();
 
    Float_t x, y, z;
-   Float_t th = fData ? GetValToHeight()*fData->GetMaxVal(fPlotEt) :0;
+   Float_t th = fMaxTowerH                                           ;
    Float_t r  = fBarrelRadius + th;
    Float_t ze = fEndCapPos + th;
 
    x = r,  y = 0, z = 0;
-   fManager->GetProjection()->ProjectPoint(x, y, z);
+   fManager->GetProjection()->ProjectPoint(x, y, z, fDepth);
    BBoxCheckPoint(x, y, z);
    x = -r, y = 0, z = 0;
-   fManager->GetProjection()->ProjectPoint(x, y, z);
+   fManager->GetProjection()->ProjectPoint(x, y, z, fDepth);
    BBoxCheckPoint(x, y, z);
 
    x = 0, y = 0, z = ze;
-   fManager->GetProjection()->ProjectPoint(x, y, z);
+   fManager->GetProjection()->ProjectPoint(x, y, z, fDepth);
    BBoxCheckPoint(x, y, z);
    x = 0, y = 0, z = -ze;
-   fManager->GetProjection()->ProjectPoint(x, y, z);
+   fManager->GetProjection()->ProjectPoint(x, y, z, fDepth);
    BBoxCheckPoint(x, y, z);
 
    x = 0, y = r,  z = 0;
-   fManager->GetProjection()->ProjectPoint(x, y, z);
+   fManager->GetProjection()->ProjectPoint(x, y, z, fDepth);
    BBoxCheckPoint(x, y, z);
    x = 0, y = -r, z = 0;
-   fManager->GetProjection()->ProjectPoint(x, y, z);
+   fManager->GetProjection()->ProjectPoint(x, y, z, fDepth);
    BBoxCheckPoint(x, y, z);
 }
 
@@ -589,10 +751,8 @@ ClassImp(TEveCaloLego);
 TEveCaloLego::TEveCaloLego(TEveCaloData* d, const char* n, const char* t):
    TEveCaloViz(d, n, t),
 
-   fTopViewUseMaxColor(kTRUE),
-   fTopViewTowerColor(kGreen),
-   fFontColor(0),
-   fGridColor(kGray+2),
+   fFontColor(-1),
+   fGridColor(-1),
    fPlaneColor(kRed-5),
    fPlaneTransparency(60),
 
@@ -600,21 +760,20 @@ TEveCaloLego::TEveCaloLego(TEveCaloData* d, const char* n, const char* t):
    fZAxisStep(0.f),
 
    fAutoRebin(kTRUE),
-   fPixelsPerBin(4),
+
+   fPixelsPerBin(12),
    fNormalizeRebin(kTRUE),
 
    fProjection(kAuto),
-   f2DMode(kValColor),
+   f2DMode(kValSize),
    fBoxMode(kBack),
 
    fDrawHPlane(kFALSE),
    fHPlaneVal(0),
 
-   fTowerPicked(-1),
-
    fBinStep(-1),
-   fDrawNumberCellPixels(30), // draw numbers on cell above 30 pixels
-   fCellPixelFontSize(15) // size of cell fonts in pixels 
+   fDrawNumberCellPixels(18), // draw numbers on cell above 30 pixels
+   fCellPixelFontSize(12) // size of cell fonts in pixels
 {
    // Constructor.
 
@@ -626,7 +785,6 @@ TEveCaloLego::TEveCaloLego(TEveCaloData* d, const char* n, const char* t):
 void TEveCaloLego::SetData(TEveCaloData* data)
 {
    TEveCaloViz::SetData(data);
-   fTowerPicked = -1;
 }
 
 //______________________________________________________________________________
@@ -646,10 +804,10 @@ void TEveCaloLego::ComputeBBox()
    // Fill bounding-box information of the base-class TAttBBox (virtual method).
    // If member 'TEveFrameBox* fFrame' is set, frame's corners are used as bbox.
 
-   BBoxZero();
 
-   // Float_t[6] X(min,max), Y(min,max), Z(min,max)
+   // fBBox = Float_t[6] X(min,max), Y(min,max), Z(min,max)
 
+   BBoxZero();
 
    Float_t ex = 1.2;
 
@@ -679,6 +837,6 @@ void TEveCaloLego::ComputeBBox()
    fBBox[4] =  0;
    if (fScaleAbs)
       fBBox[5] = fMaxTowerH;
-   else 
+   else
       fBBox[5] = 1;
 }
diff --git a/graf3d/eve/src/TEveCalo2DGL.cxx b/graf3d/eve/src/TEveCalo2DGL.cxx
index d718527..839ed0f 100644
--- a/graf3d/eve/src/TEveCalo2DGL.cxx
+++ b/graf3d/eve/src/TEveCalo2DGL.cxx
@@ -16,12 +16,12 @@
 #include "TEveRGBAPalette.h"
 
 #include "TGLRnrCtx.h"
+#include "TGLPhysicalShape.h"
 #include "TGLSelectRecord.h"
 #include "TGLIncludes.h"
 #include "TGLUtil.h"
 #include "TAxis.h"
 
-
 //______________________________________________________________________________
 // OpenGL renderer class for TEveCalo2D.
 //
@@ -62,9 +62,16 @@ void TEveCalo2DGL::SetBBox()
 }
 
 /******************************************************************************/
+//______________________________________________________________________________
+Bool_t TEveCalo2DGL::IsRPhi() const
+{
+   // Is current projection type RPhi
+
+   return fM->fManager->GetProjection()->GetType() == TEveProjection::kPT_RPhi;
+}
 
 //______________________________________________________________________________
-Float_t TEveCalo2DGL::MakeRPhiCell(Float_t phiMin, Float_t phiMax,
+void TEveCalo2DGL::MakeRPhiCell(Float_t phiMin, Float_t phiMax,
                                    Float_t towerH, Float_t offset) const
 {
    // Calculate vertices for the calorimeter cell in RPhi projection.
@@ -89,15 +96,14 @@ Float_t TEveCalo2DGL::MakeRPhiCell(Float_t phiMin, Float_t phiMax,
       x = pnts[2*i];
       y = pnts[2*i+1];
       z = 0.f;
-      fM->fManager->GetProjection()->ProjectPoint(x, y, z);
-      glVertex3f(x, y, fM->fDepth);
+      fM->fManager->GetProjection()->ProjectPoint(x, y, z, fM->fDepth);
+      glVertex3f(x, y, z);
    }
    glEnd();
-   return offset + towerH;
 }
 
 //______________________________________________________________________________
-void TEveCalo2DGL::DrawRPhi(TGLRnrCtx & rnrCtx) const
+void TEveCalo2DGL::DrawRPhi(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t& cellLists) const
 {
    // Draw calorimeter cells in RPhi projection.
 
@@ -106,54 +112,96 @@ void TEveCalo2DGL::DrawRPhi(TGLRnrCtx & rnrCtx) const
    Float_t *sliceVal = new Float_t[nSlices];
    TEveCaloData::CellData_t cellData;
    Float_t towerH;
-   Float_t phiMin, phiMax;
-   TAxis* ax = fM->fData->GetPhiBins();
 
-   if (rnrCtx.SecSelection()) glPushName(0);
+   UInt_t nPhi = data->GetPhiBins()->GetNbins();
 
-   for(UInt_t vi = 0; vi < fM->fCellLists.size(); ++vi)
+   for(UInt_t phiBin = 0; phiBin < nPhi; ++phiBin)
    {
-      // reset values
-      Float_t off = 0;
-      for (Int_t s=0; s<nSlices; ++s)
-         sliceVal[s] = 0;
-
-      // loop through eta bins
-      phiMin = 0;
-      phiMax =0;
-
+      if (cellLists[phiBin] )
+      {
+         // reset values
+         Float_t off = 0;
+         for (Int_t s=0; s<nSlices; ++s)
+            sliceVal[s] = 0;
+
+         // sum eta cells
+         TEveCaloData::vCellId_t* cids = cellLists[phiBin];
+         for (TEveCaloData::vCellId_i it = cids->begin(); it != cids->end(); it++)
+         {
+            data->GetCellData(*it, cellData);
+            sliceVal[(*it).fSlice] += cellData.Value(fM->fPlotEt);
+         }
 
-      TEveCaloData::vCellId_t* cids = fM->fCellLists[vi];
-      data->GetCellData(cids->front(), cellData);
+         if (rnrCtx.SecSelection()) {
+            glLoadName(phiBin); // set name-stack phi bin
+            glPushName(0);
+         }
+         for (Int_t s = 0; s < nSlices; ++s)
+         {
+            if (rnrCtx.SecSelection())  glLoadName(s); // set name-stack slice
+            fM->SetupColorHeight(sliceVal[s], s, towerH);
+            MakeRPhiCell(cellData.PhiMin(), cellData.PhiMax(), towerH, off);
+            off += towerH;
+         }
+         if (rnrCtx.SecSelection()) glPopName(); // slice
+      }
+   }
 
-      phiMin = cellData.PhiMin();
-      phiMax = cellData.PhiMax();
+   delete [] sliceVal;
+}
 
-      for (TEveCaloData::vCellId_i it = cids->begin(); it != cids->end(); it++)
-      {
+//______________________________________________________________________________
+void TEveCalo2DGL::DrawRPhiHighlighted(TGLRnrCtx & /*rnrCtx*/) const
+{
+   // Draw selected calorimeter cells in RPhi projection.
 
-         data->GetCellData(*it, cellData);
-         sliceVal[(*it).fSlice] += cellData.Value(fM->fPlotEt);
-         if(phiMin>cellData.PhiMin()) phiMin=cellData.PhiMin();
-         if(phiMax<cellData.PhiMax()) phiMax=cellData.PhiMax();
-      }
+   static const TEveException eh("TEveCalo2DGL::DrawRPhiHighlighted ");
 
-      // draw
-      if (rnrCtx.SecSelection()) {
-         glLoadName(vi);
-         glPushName(0);
-      }
+   TEveCaloData* data = fM->fData;
+   TEveCaloData::CellData_t cellData;
+   Int_t  nSlices  = data->GetNSlices();
+   UInt_t nPhiBins = data->GetPhiBins()->GetNbins();
+   Float_t *sliceVal    = new Float_t[nSlices];
+   Float_t *sliceValRef = new Float_t[nSlices];
+   Float_t  towerH, towerHRef;
 
-      Int_t bin = fM->fBinIds[vi];
-      for (Int_t s = 0; s < nSlices; ++s)
+   for(UInt_t phiBin = 1; phiBin <= nPhiBins; ++phiBin)
+   {
+      if (fM->fCellListsSelected[phiBin])
       {
-         fM->SetupColorHeight(sliceVal[s], s, towerH);
-         off = MakeRPhiCell(ax->GetBinLowEdge(bin), ax->GetBinUpEdge(bin), towerH, off);
+         if (!fM->fCellLists[phiBin])
+            throw eh + "selected cell not in cell list cache.";
+
+         Float_t off = 0;
+         // selected eta sum
+         for (Int_t s=0; s<nSlices; ++s) sliceVal[s] = 0;
+         TEveCaloData::vCellId_t& cids = *(fM->fCellListsSelected[phiBin]);
+         for (TEveCaloData::vCellId_i i=cids.begin(); i!=cids.end(); i++) {
+            data->GetCellData((*i), cellData);
+            sliceVal[i->fSlice] += cellData.Value(fM->fPlotEt);
+         }
+         // referenced eta sum
+         for (Int_t s=0; s<nSlices; ++s) sliceValRef[s] = 0;
+         TEveCaloData::vCellId_t& cidsRef = *(fM->fCellLists[phiBin]);
+         for (TEveCaloData::vCellId_i i=cidsRef.begin(); i!=cidsRef.end(); i++) {
+            data->GetCellData(*i, cellData);
+            sliceValRef[i->fSlice] += cellData.Value(fM->fPlotEt);
+         }
+         // draw
+         for (Int_t s = 0; s < nSlices; ++s)  {
+            fM->SetupColorHeight(sliceValRef[s], s, towerHRef);
+            if (sliceVal[s] > 0)
+            {
+               fM->SetupColorHeight(sliceVal[s], s, towerH);
+               MakeRPhiCell(cellData.PhiMin(), cellData.PhiMax(), towerH, off);
+            }
+            off += towerHRef;
+         }
       }
-      if (rnrCtx.SecSelection()) glPopName(); // slice
    }
 
    delete [] sliceVal;
+   delete [] sliceValRef;
 }
 
 
@@ -197,7 +245,6 @@ void TEveCalo2DGL::MakeRhoZCell(Float_t thetaMin, Float_t thetaMax,
       pnts[6] = r1*sin2; pnts[7] = r1*cos2;
    }
 
-   glPushName(phiPlus);
    glBegin(GL_QUADS);
    Float_t x, y, z;
    for (Int_t i = 0; i < 4; ++i)
@@ -205,87 +252,166 @@ void TEveCalo2DGL::MakeRhoZCell(Float_t thetaMin, Float_t thetaMax,
       x = 0.f;
       y = phiPlus ? Abs(pnts[2*i]) : -Abs(pnts[2*i]);
       z = pnts[2*i+1];
-      fM->fManager->GetProjection()->ProjectPoint(x, y, z);
-      glVertex3f(x, y, fM->fDepth);
+      fM->fManager->GetProjection()->ProjectPoint(x, y, z, fM->fDepth);
+      glVertex3f(x, y, z);
    }
    glEnd();
-   glPopName();
-
-   offset += towerH;
 }
 
 //______________________________________________________________________________
-void TEveCalo2DGL::DrawRhoZ(TGLRnrCtx & rnrCtx) const
+void TEveCalo2DGL::DrawRhoZ(TGLRnrCtx & rnrCtx, TEveCalo2D::vBinCells_t& cellLists) const
 {
    // Draw calorimeter in RhoZ projection.
 
-   TEveCaloData::CellData_t cellData;
-   Float_t towerH;
    TEveCaloData* data = fM->GetData();
    Int_t nSlices = data->GetNSlices();
 
+   TEveCaloData::CellData_t cellData;
    Float_t *sliceValsUp  = new Float_t[nSlices];
    Float_t *sliceValsLow = new Float_t[nSlices];
-   Float_t  thetaMin, thetaMax;
    Bool_t   isBarrel;
-   Int_t bin = 0;
+   Float_t  towerH;
 
-   TAxis* ax = fM->fData->GetEtaBins();
+   UInt_t nEta = data->GetEtaBins()->GetNbins();
+   for (UInt_t etaBin = 1; etaBin <= nEta; ++etaBin)
+   {
+      if (cellLists[etaBin] )
+      {
+         assert(fM->fCellLists[etaBin]);
+         // clear
+         Float_t offUp  = 0;
+         Float_t offLow = 0;
+         for (Int_t s = 0; s < nSlices; ++s) {
+            sliceValsUp [s] = 0;
+            sliceValsLow[s] = 0;
+         }
+         // values
+         TEveCaloData::vCellId_t* cids = cellLists[etaBin];
+         for (TEveCaloData::vCellId_i it = cids->begin(); it != cids->end(); ++it)
+         {
+            data->GetCellData(*it, cellData);
+            if (cellData.Phi() > 0)
+               sliceValsUp [it->fSlice] += cellData.Value(fM->fPlotEt);
+            else
+               sliceValsLow[it->fSlice] += cellData.Value(fM->fPlotEt);
+         }
+         isBarrel = TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta();
 
-   if (rnrCtx.SecSelection()) glPushName(0);
+         // draw
+         if (rnrCtx.SecSelection()) glLoadName(etaBin); // name-stack eta bin
+         if (rnrCtx.SecSelection()) glPushName(0);
 
-   for (UInt_t vi = 0; vi < fM->fCellLists.size(); ++vi)
-   {
-      // clear
-      Float_t offUp  = 0;
-      Float_t offLow = 0;
-      for (Int_t s = 0; s < nSlices; ++s) {
-         sliceValsUp [s] = 0;
-         sliceValsLow[s] = 0;
+         for (Int_t s = 0; s < nSlices; ++s)
+         {
+            if (rnrCtx.SecSelection()) glLoadName(s);  // name-stack slice
+            if (rnrCtx.SecSelection()) glPushName(0);
+            //  phi +
+            if (sliceValsUp[s])
+            {
+               if (rnrCtx.SecSelection()) glLoadName(1);  // name-stack phi sign
+               fM->SetupColorHeight(sliceValsUp[s], s, towerH);
+               MakeRhoZCell(cellData.ThetaMin(), cellData.ThetaMax(), offUp, isBarrel, kTRUE , towerH);
+               offUp += towerH;
+            }
+            // phi -
+            if (sliceValsLow[s])
+            {
+               if (rnrCtx.SecSelection()) glLoadName(0);  // name-stack phi sign
+               fM->SetupColorHeight(sliceValsLow[s], s, towerH);
+               MakeRhoZCell(cellData.ThetaMin(), cellData.ThetaMax(), offLow, isBarrel, kFALSE , towerH);
+               offLow += towerH;
+            }
+            if (rnrCtx.SecSelection())  glPopName(); // phi sign is pos
+         }
+         //
+         if (rnrCtx.SecSelection())  glPopName(); // slice
       }
+   }
 
-      // values
-      for (TEveCaloData::vCellId_i it = fM->fCellLists[vi]->begin();
-           it != fM->fCellLists[vi]->end(); ++it)
-      {
-         data->GetCellData(*it, cellData);
-         if (cellData.Phi() > 0)
-            sliceValsUp [it->fSlice] += cellData.Value(fM->fPlotEt);
-         else
-            sliceValsLow[it->fSlice] += cellData.Value(fM->fPlotEt);
-      }
+   delete [] sliceValsUp;
+   delete [] sliceValsLow;
+}
 
-      // draw
-      if (rnrCtx.SecSelection())
-      {
-         glLoadName(vi); // phi bin
-         glPushName(0);  // slice
-      }
+//______________________________________________________________________________
+void TEveCalo2DGL::DrawRhoZHighlighted(TGLRnrCtx & /*rnrCtx*/) const
+{
+   // Draw selected calorimeter cells in RhoZ projection.
+
+   static const TEveException eh("TEveCalo2DGL::DrawRhoZHighlighted ");
 
-      bin = fM->fBinIds[vi];
-      isBarrel = TMath::Abs(ax->GetBinUpEdge(bin)) < fM->GetTransitionEta();
-      thetaMin = TEveCaloData::EtaToTheta(ax->GetBinUpEdge(bin));
-      thetaMax = TEveCaloData::EtaToTheta(ax->GetBinLowEdge(bin));
+   TEveCaloData* data = fM->GetData();
+   Int_t  nSlices     = data->GetNSlices();
+   UInt_t nEtaBins    = data->GetEtaBins()->GetNbins();
+
+   Float_t *sliceValsUp     = new Float_t[nSlices];
+   Float_t *sliceValsLow    = new Float_t[nSlices];
+   Float_t *sliceValsUpRef  = new Float_t[nSlices];
+   Float_t *sliceValsLowRef = new Float_t[nSlices];
 
-      for (Int_t s = 0; s < nSlices; ++s)
+   Bool_t   isBarrel;
+   Float_t  towerH, towerHRef, offUp, offLow;
+   TEveCaloData::CellData_t cellData;
+
+   for (UInt_t etaBin = 1; etaBin <= nEtaBins; ++etaBin)
+   {
+      if (fM->fCellListsSelected[etaBin])
       {
-         if (rnrCtx.SecSelection()) glLoadName(s);
-         //  phi +
-         fM->SetupColorHeight(sliceValsUp[s], s, towerH);
-         MakeRhoZCell(thetaMin, thetaMax, offUp, isBarrel, kTRUE , towerH);
-
-         // phi -
-         fM->SetupColorHeight(sliceValsLow[s], s, towerH);
-         MakeRhoZCell(thetaMin, thetaMax, offLow, isBarrel, kFALSE , towerH);
-      }
+         if (!fM->fCellLists[etaBin])
+            throw(eh + "selected cell not in cell list cache.");
 
-      if (rnrCtx.SecSelection()) glPopName(); // slice
-   }
+         offUp = 0; offLow =0;
+         // selected phi sum
+         for (Int_t s = 0; s < nSlices; ++s) {
+            sliceValsUp[s] = 0; sliceValsLow[s] = 0;
+         }
+         TEveCaloData::vCellId_t& cids = *(fM->fCellListsSelected[etaBin]);
+         for (TEveCaloData::vCellId_i i=cids.begin(); i!=cids.end(); i++) {
+            data->GetCellData(*i, cellData);
+            if (cellData.Phi() > 0)
+               sliceValsUp [i->fSlice] += cellData.Value(fM->fPlotEt);
+            else
+               sliceValsLow[i->fSlice] += cellData.Value(fM->fPlotEt);
+         }
+
+         // reference phi sum
+         for (Int_t s = 0; s < nSlices; ++s) {
+            sliceValsUpRef[s] = 0; sliceValsLowRef[s] = 0;
+         }
+         TEveCaloData::vCellId_t& cidsRef = *(fM->fCellLists[etaBin]);
+         for (TEveCaloData::vCellId_i i=cidsRef.begin(); i!=cidsRef.end(); i++) {
+            data->GetCellData(*i, cellData);
+            if (cellData.Phi() > 0)
+               sliceValsUpRef [i->fSlice] += cellData.Value(fM->fPlotEt);
+            else
+               sliceValsLowRef[i->fSlice] += cellData.Value(fM->fPlotEt);
+         }
 
-   if (rnrCtx.SecSelection()) glPopName(); // phi bin
+         isBarrel = TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta();
+         for (Int_t s = 0; s < nSlices; ++s)
+         {
+            //  phi +
+            fM->SetupColorHeight(sliceValsUpRef[s], s, towerHRef);
+            if (sliceValsUp[s] > 0) {
+               fM->SetupColorHeight(sliceValsUp[s], s, towerH);
+               MakeRhoZCell(cellData.ThetaMin(), cellData.ThetaMax(), offUp, isBarrel, kTRUE , towerH);
+            }
+            offUp += towerHRef;
+
+            // phi -
+            fM->SetupColorHeight(sliceValsLowRef[s], s, towerHRef);
+            if (sliceValsLow[s] > 0) {
+               fM->SetupColorHeight(sliceValsLow[s], s, towerH);
+               MakeRhoZCell(cellData.ThetaMin(), cellData.ThetaMax(), offLow, isBarrel, kFALSE , towerH);
+            }
+            offLow += towerHRef;
+         } // slices
+      } // if eta bin
+   } //eta bin
 
    delete [] sliceValsUp;
    delete [] sliceValsLow;
+   delete [] sliceValsUpRef;
+   delete [] sliceValsLowRef;
 }
 
 //______________________________________________________________________________
@@ -301,62 +427,91 @@ void TEveCalo2DGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    fM->AssertPalette();
 
-   TEveProjection::EPType_e pt = fM->fManager->GetProjection()->GetType();
-   if (pt == TEveProjection::kPT_RhoZ)
-      DrawRhoZ(rnrCtx);
-   else if (pt == TEveProjection::kPT_RPhi)
-      DrawRPhi(rnrCtx);
+   if (rnrCtx.SecSelection()) glPushName(0);
+   if (IsRPhi())
+      DrawRPhi(rnrCtx, fM->fCellLists);
+   else
+      DrawRhoZ(rnrCtx, fM->fCellLists);
+   if (rnrCtx.SecSelection()) glPopName();
 }
 
 //______________________________________________________________________________
-void TEveCalo2DGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
+void TEveCalo2DGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const
 {
-   // Processes secondary selection from TGLViewer.
-
-   if (rec.GetN() < 2) return;
+   // Draw towers in highlight mode.
 
-   Int_t id = rec.GetItem(1);
-   Int_t slice = rec.GetItem(2);
-   TEveCaloData::CellData_t cellData;
-
-   Int_t n = 0;
-   for (TEveCaloData::vCellId_i it =fM->fCellLists[id]->begin(); it!=fM->fCellLists[id]->end(); it++)
-   {
-      if ((*it).fSlice == slice)
-         n++;
-   }
+   static const TEveException eh("TEveCalo2DGL::DrawHighlight ");
 
-   printf("Tower selected in slice %d number of hits: %2d \n", slice, n);
-   for (TEveCaloData::vCellId_i it =fM->fCellLists[id]->begin(); it!=fM->fCellLists[id]->end(); it++)
+   if ((pshp->GetSelected() == 2) && fM->fData->GetCellsSelected().size())
    {
-      if ((*it).fSlice == slice)
+      glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT  | GL_LINE_BIT );
+      glDisable(GL_CULL_FACE);
+      glDisable(GL_LIGHTING);
+      glEnable(GL_LINE_SMOOTH);
+      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+      TGLUtil::LineWidth(2);
+
+      glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
+      TGLUtil::LockColor();
+
+      try {
+         if (IsRPhi())
+            DrawRPhiHighlighted(rnrCtx);
+         else
+            DrawRhoZHighlighted(rnrCtx);
+      }
+      catch (TEveException& exc)
       {
-         fM->fData->GetCellData(*it, cellData);
-         cellData.Dump();
-
+         Warning(eh, exc);
       }
+      TGLUtil::UnlockColor();
+
+      glPopAttrib();
    }
+}
 
-   // rho Z
-   if (rec.GetN() == 4)
-   {
-      if(rec.GetItem(3))
-         printf("Cell in selected positive phi half \n");
-      else
-         printf("Cell in selected negative phi half \n");
+ //______________________________________________________________________________
+void TEveCalo2DGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
+{
+   // Processes tower selection in eta bin or phi bin.
+   // Virtual function from TGLogicalShape. Called from TGLViewer.
 
-      for (TEveCaloData::vCellId_i it = fM->fCellLists[id]->begin();
-           it != fM->fCellLists[id]->end(); ++it)
+   Int_t prev = fM->fData->GetCellsSelected().size();
+   if (!rec.GetMultiple()) fM->fData->GetCellsSelected().clear();
+
+   Int_t binID = -1;
+   if (rec.GetN() > 2)
+   {
+      binID       = rec.GetItem(1);
+      Int_t slice = rec.GetItem(2);
+      TEveCaloData::CellData_t cellData;
+      for (TEveCaloData::vCellId_i it = fM->fCellLists[binID]->begin();
+           it!=fM->fCellLists[binID]->end(); it++)
       {
-         fM->fData->GetCellData(*it, cellData);
          if ((*it).fSlice == slice)
          {
-            if ((rec.GetItem(3) && cellData.Phi() > 0) ||
-                (rec.GetItem(3) == kFALSE && cellData.Phi() < 0))
+
+            fM->fData->GetCellData(*it, cellData);
+            if (!IsRPhi())
             {
-               cellData.Dump();
+               if ((rec.GetItem(3) && cellData.Phi() > 0) || (rec.GetItem(3) == kFALSE && cellData.Phi() < 0)) {
+                  fM->fData->GetCellsSelected().push_back(*it);
+               }
+            }
+            else {
+               fM->fData->GetCellsSelected().push_back(*it);
             }
          }
       }
    }
+
+   // set secondary selection result
+   if (prev == 0 && binID >= 0)
+      rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
+   else if (prev  && binID < 0)
+      rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
+   else if (prev  && binID >= 0)
+      rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
+
+   fM->fData->CellSelectionChanged();
 }
diff --git a/graf3d/eve/src/TEveCalo3DGL.cxx b/graf3d/eve/src/TEveCalo3DGL.cxx
index b82d96b..e984ee5 100644
--- a/graf3d/eve/src/TEveCalo3DGL.cxx
+++ b/graf3d/eve/src/TEveCalo3DGL.cxx
@@ -17,6 +17,7 @@
 
 #include "TGLRnrCtx.h"
 #include "TGLSelectRecord.h"
+#include "TGLPhysicalShape.h"
 #include "TGLIncludes.h"
 #include "TGLUtil.h"
 #include "TEveRGBAPalette.h"
@@ -183,7 +184,7 @@ void TEveCalo3DGL::RenderGridEndCap() const
 void TEveCalo3DGL::RenderGridBarrel() const
 {
    // Render barrel grid.
-   
+
    using namespace TMath;
 
    Float_t etaMin = fM->GetEtaMin();
@@ -217,7 +218,7 @@ void TEveCalo3DGL::RenderGridBarrel() const
                glVertex3f(rB*Cos(phiL), rB*Sin(phiL), z);
                glVertex3f(rB*Cos(phiU), rB*Sin(phiU), z);
             }
-         }      
+         }
       }
    }
 
@@ -226,7 +227,7 @@ void TEveCalo3DGL::RenderGridBarrel() const
 
    if (etaMin > -trans)
       zB = rB/Tan(TEveCaloData::EtaToTheta(etaMin));
-   else 
+   else
       zB = -fM->GetEndCapPos();
 
 
@@ -258,7 +259,7 @@ void TEveCalo3DGL::RenderGrid(TGLRnrCtx & rnrCtx) const
 {
    // Draw frame reading eta, phi axis.
 
-   if (rnrCtx.Highlight() || rnrCtx.Selection()) return;
+   if (rnrCtx.Highlight() || rnrCtx.Selection() || rnrCtx.IsDrawPassOutlineLine()) return;
 
    Bool_t transparent_p = fM->fFrameTransparency > 0;
 
@@ -378,7 +379,7 @@ void TEveCalo3DGL::RenderBox(const Float_t pnts[8]) const
 }
 
 //______________________________________________________________________________
-Float_t TEveCalo3DGL::RenderBarrelCell(const TEveCaloData::CellData_t &cellData, Float_t towerH, Float_t offset ) const
+Float_t TEveCalo3DGL::RenderBarrelCell(const TEveCaloData::CellGeom_t &cellData, Float_t towerH, Float_t offset ) const
 {
    // Render barrel cell.
 
@@ -448,7 +449,7 @@ Float_t TEveCalo3DGL::RenderBarrelCell(const TEveCaloData::CellData_t &cellData,
 }// end RenderBarrelCell
 
 //______________________________________________________________________________
-Float_t TEveCalo3DGL::RenderEndCapCell(const TEveCaloData::CellData_t &cellData, Float_t towerH, Float_t offset ) const
+Float_t TEveCalo3DGL::RenderEndCapCell(const TEveCaloData::CellGeom_t &cellData, Float_t towerH, Float_t offset ) const
 {
    // Render an endcap cell.
 
@@ -515,61 +516,136 @@ Float_t TEveCalo3DGL::RenderEndCapCell(const TEveCaloData::CellData_t &cellData,
    return offset+towerH*Cos(cellData.ThetaMin());
 } // end RenderEndCapCell
 
+
 //______________________________________________________________________________
 void TEveCalo3DGL::DirectDraw(TGLRnrCtx &rnrCtx) const
 {
    // GL rendering.
 
-   RenderGrid(rnrCtx);
+   if ( fM->GetValueIsColor())  fM->AssertPalette();
 
+   // check if eta phi range has changed
    if (fM->fCellIdCacheOK == kFALSE)
       fM->BuildCellIdCache();
 
-   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
-   glEnable(GL_NORMALIZE);
+
    glEnable(GL_LIGHTING);
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
+   glEnable(GL_NORMALIZE);
 
-   fM->AssertPalette();
+   RenderGrid(rnrCtx);
 
    TEveCaloData::CellData_t cellData;
-   Float_t transEta = fM->GetTransitionEta();
    Float_t towerH;
-   Int_t   prevTower = 0;
+   Int_t   tower = 0;
+   Int_t   prevTower = -1;
    Float_t offset = 0;
+   Int_t cellID = 0;
 
    if (rnrCtx.SecSelection()) glPushName(0);
-   for (UInt_t i=0; i<fM->fCellList.size(); i++)
-   {
-      fM->fData->GetCellData(fM->fCellList[i], cellData);
 
-      if (fM->fCellList[i].fTower != prevTower)
+   fOffset.assign(fM->fCellList.size(), 0);
+   for (TEveCaloData::vCellId_i i = fM->fCellList.begin(); i != fM->fCellList.end(); ++i)
+   {
+      fM->fData->GetCellData((*i), cellData);
+      tower = i->fTower;
+      if (tower != prevTower)
       {
          offset = 0;
-         prevTower = fM->fCellList[i].fTower;
+         prevTower = tower;
       }
-      fM->SetupColorHeight(cellData.Value(fM->fPlotEt), fM->fCellList[i].fSlice, towerH);
-      if (rnrCtx.SecSelection()) glLoadName(i);
-      if (TMath::Abs(cellData.EtaMax()) < transEta)
+      fOffset[cellID] = offset;
+      fM->SetupColorHeight(cellData.Value(fM->fPlotEt), (*i).fSlice, towerH);
+
+      if (rnrCtx.SecSelection()) glLoadName(cellID);
+
+      if (TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta())
          offset = RenderBarrelCell(cellData, towerH, offset);
       else
          offset = RenderEndCapCell(cellData, towerH, offset);
+
+      ++cellID;
    }
-   if (rnrCtx.SecSelection()) glPopName();
 
+   if (rnrCtx.SecSelection()) glPopName();
    glPopAttrib();
 }
 
 //______________________________________________________________________________
+void TEveCalo3DGL::DrawHighlight(TGLRnrCtx & rnrCtx, const TGLPhysicalShape* pshp) const
+{
+   // Draw polygons in highlight mode.
+
+
+   if ((pshp->GetSelected() == 2) && fM->fData->GetCellsSelected().size())
+   {
+      glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT |GL_POLYGON_BIT );
+      glDisable(GL_LIGHTING);
+      glDisable(GL_CULL_FACE);
+      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+
+      TGLUtil::LineWidth(2);
+      glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
+      TGLUtil::LockColor();
+
+      TEveCaloData::CellData_t cellData;
+      Float_t towerH;
+      Int_t nCells =  fM->fCellList.size();
+
+      for (TEveCaloData::vCellId_i i = fM->fData->GetCellsSelected().begin();
+           i != fM->fData->GetCellsSelected().end(); i++)
+      {
+         fM->fData->GetCellData(*i, cellData);
+         fM->SetupColorHeight(cellData.Value(fM->fPlotEt), (*i).fSlice, towerH);
+
+         // find tower with offsets
+         Float_t offset = 0;
+         for (Int_t j = 0; j < nCells; ++j)
+         {
+            if (fM->fCellList[j].fTower == i->fTower && fM->fCellList[j].fSlice == i->fSlice )
+            {
+               offset = fOffset[j];
+               break;
+            }
+         }
+
+         if (fM->CellInEtaPhiRng(cellData)) 
+         {
+            if (TMath::Abs(cellData.EtaMax()) < fM->GetTransitionEta())
+               RenderBarrelCell(cellData, towerH, offset);
+            else
+               RenderEndCapCell(cellData, towerH, offset);
+         }  
+      }
+
+      TGLUtil::UnlockColor();
+      glPopAttrib();
+   }
+}
+
+//______________________________________________________________________________
 void TEveCalo3DGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
 {
-   // Processes secondary selection from TGLViewer.
+   // Processes tower selection.
+   // Virtual function from TGLogicalShape. Called from TGLViewer.
 
-   if (rec.GetN() < 2) return;
+   Int_t prev = fM->fData->GetCellsSelected().size();
+
+   if (!rec.GetMultiple()) fM->fData->GetCellsSelected().clear();
+   Int_t cellID = -1;
+   if (rec.GetN() > 1)
+   {
+      cellID = rec.GetItem(1);
+      fM->fData->GetCellsSelected().push_back(fM->fCellList[cellID]);
+   }
+
+   if (prev == 0 && cellID >= 0)
+      rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
+   else if (prev  && cellID < 0)
+      rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
+   else if (prev  && cellID >= 0)
+      rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
 
-   Int_t cellID = rec.GetItem(1);
-   TEveCaloData::CellData_t cellData;
-   fM->fData->GetCellData(fM->fCellList[cellID], cellData);
 
-   printf("Tower selected in slice %d \n", fM->fCellList[cellID].fSlice);
-   cellData.Dump();
+   fM->fData->CellSelectionChanged();
 }
diff --git a/graf3d/eve/src/TEveCaloData.cxx b/graf3d/eve/src/TEveCaloData.cxx
index 32c6178..a12b060 100644
--- a/graf3d/eve/src/TEveCaloData.cxx
+++ b/graf3d/eve/src/TEveCaloData.cxx
@@ -22,6 +22,10 @@
 #include <algorithm>
 
 
+//------------------------------------------------------------------------------
+// TEveCaloData::CellGeom_t
+//------------------------------------------------------------------------------
+
 
 //______________________________________________________________________________
 void TEveCaloData::CellGeom_t::Dump() const
@@ -31,6 +35,19 @@ void TEveCaloData::CellGeom_t::Dump() const
    printf("%f, %f %f, %f \n", fEtaMin, fEtaMax, fPhiMin, fPhiMax);
 }
 
+//______________________________________________________________________________
+void TEveCaloData::CellGeom_t::Configure(Float_t etaMin, Float_t etaMax, Float_t phiMin, Float_t phiMax)
+{
+   fEtaMin = etaMin;
+   fEtaMax = etaMax;
+
+   fPhiMin = phiMin;
+   fPhiMax = phiMax;
+
+   fThetaMin = EtaToTheta(fEtaMax);
+   fThetaMax = EtaToTheta(fEtaMin);
+}
+
 //------------------------------------------------------------------------------
 // TEveCaloData::CellData_t
 //------------------------------------------------------------------------------
@@ -84,8 +101,9 @@ Float_t* TEveCaloData::RebinData_t::GetSliceVals(Int_t bin)
 ClassImp(TEveCaloData);
 
 //______________________________________________________________________________
-TEveCaloData::TEveCaloData():
-   TEveRefBackPtr(),
+TEveCaloData::TEveCaloData(const char* n, const char* t):
+   TEveElement(),
+   TNamed(n, t),
 
    fEtaAxis(0),
    fPhiAxis(0),
@@ -101,6 +119,46 @@ TEveCaloData::TEveCaloData():
 }
 
 //______________________________________________________________________________
+void TEveCaloData::SelectElement(Bool_t s)
+{
+   // Virtual method TEveElement::SelectElement.
+   // Clear selected towers when deselected.
+
+   if (s == kFALSE)
+      fCellsSelected.clear();
+
+   TEveElement::SelectElement(s);
+}
+
+//______________________________________________________________________________
+void TEveCaloData::FillImpliedSelectedSet(Set_t& impSelSet)
+{
+   // Populate set impSelSet with derived / dependant elements.
+   //
+
+   for (List_ci i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      impSelSet.insert(*i);
+   }
+}
+
+//______________________________________________________________________________
+void TEveCaloData::PrintCellsSelected()
+{
+   // Print selected cells info.
+
+   printf("%d Selected selected cells:\n", (Int_t)fCellsSelected.size());
+   CellData_t cellData;
+
+   for (vCellId_i i = fCellsSelected.begin(); i != fCellsSelected.end(); ++i)
+   {
+      GetCellData(*i, cellData);
+      printf("Tower [%d] Slice [%d] Value [%.2f] ", i->fTower, i->fSlice, cellData.fValue);
+      printf("Eta:(%f, %f) Phi(%f, %f)\n",  cellData.fEtaMin, cellData.fEtaMax, cellData.fPhiMin, cellData.fPhiMax);
+   }
+}
+
+//______________________________________________________________________________
 void TEveCaloData::SetSliceThreshold(Int_t slice, Float_t val)
 {
    // Set threshold for given slice.
@@ -123,7 +181,10 @@ void TEveCaloData::SetSliceColor(Int_t slice, Color_t col)
    // Set color for given slice.
 
    fSliceInfos[slice].fColor = col;
-   StampBackPtrElements(TEveElement::kCBObjProps);
+   for (List_ci i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      (*i)->AddStamp(TEveElement::kCBObjProps);
+   }
 }
 
 //______________________________________________________________________________
@@ -140,13 +201,11 @@ void TEveCaloData::InvalidateUsersCellIdCache()
    // Invalidate cell ids cache on back ptr references.
 
    TEveCaloViz* calo;
-   std::list<TEveElement*>::iterator i = fBackRefs.begin();
-   while (i != fBackRefs.end())
+   for (List_ci i=fChildren.begin(); i!=fChildren.end(); ++i)
    {
       calo = dynamic_cast<TEveCaloViz*>(*i);
       calo->InvalidateCellIdCache();
       calo->StampObjProps();
-      ++i;
    }
 }
 
@@ -158,13 +217,27 @@ void TEveCaloData::DataChanged()
    // This is done by calling TEveCaloViz::DataChanged().
 
    TEveCaloViz* calo;
-   std::list<TEveElement*>::iterator i = fBackRefs.begin();
-   while (i != fBackRefs.end())
+   for (List_ci i=fChildren.begin(); i!=fChildren.end(); ++i)
    {
       calo = dynamic_cast<TEveCaloViz*>(*i);
       calo->DataChanged();
       calo->StampObjProps();
-      ++i;
+   }
+}
+
+//______________________________________________________________________________
+void TEveCaloData::CellSelectionChanged()
+{
+   // Tell users (TEveCaloViz instances using this data) that cell selection
+   // has changed and they should update selection cache if necessary. 
+   // This is done by calling TEveCaloViz::CellSelectionChanged().
+
+   TEveCaloViz* calo;
+   for (List_ci i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      calo = dynamic_cast<TEveCaloViz*>(*i);
+      calo->CellSelectionChanged();
+      calo->StampObjProps();
    }
 }
 
@@ -180,31 +253,13 @@ Float_t TEveCaloData::EtaToTheta(Float_t eta)
 }
 
 
-//------------------------------------------------------------------------------
-// TEveCaloData::CellGeom_t
-//------------------------------------------------------------------------------
-
-//______________________________________________________________________________
-void TEveCaloData::CellGeom_t::Configure(Float_t etaMin, Float_t etaMax, Float_t phiMin, Float_t phiMax)
-{
-   fEtaMin = etaMin;
-   fEtaMax = etaMax;
-
-   fPhiMin = phiMin;
-   fPhiMax = phiMax;
-
-   fThetaMin = EtaToTheta(fEtaMax);
-   fThetaMax = EtaToTheta(fEtaMin);
-}
-
-
 //==============================================================================
 // TEveCaloDataVec
 //==============================================================================
 
 //______________________________________________________________________________
 //
-// Calo data for universal cell geometry. 
+// Calo data for universal cell geometry.
 
 ClassImp(TEveCaloDataVec);
 
@@ -341,7 +396,7 @@ void TEveCaloDataVec::Rebin(TAxis* ax, TAxis* ay, vCellId_t &ids, Bool_t et, Reb
 
    CellData_t cd;
    Float_t left, right, up, down; // cell corners
-   for (TEveCaloData::vCellId_t::iterator it=ids.begin(); it!=ids.end(); ++it)
+   for (vCellId_i it = ids.begin(); it != ids.end(); ++it)
    {
       GetCellData(*it, cd);
       Int_t iMin = ax->FindBin(cd.EtaMin());
@@ -443,8 +498,8 @@ void  TEveCaloDataVec::SetAxisFromBins(Double_t epsX, Double_t epsY)
    std::vector<Double_t> newX;
    newX.push_back(binX.front()); // underflow
    Int_t nX = binX.size()-1;
-   for(Int_t i=0; i<nX; i++) 
-   { 
+   for(Int_t i=0; i<nX; i++)
+   {
       val = (sum +binX[i])/(cnt+1);
       if (binX[i+1] -val > epsX)
       {
@@ -452,7 +507,7 @@ void  TEveCaloDataVec::SetAxisFromBins(Double_t epsX, Double_t epsY)
          cnt = 0;
          sum = 0;
       }
-      else 
+      else
       {
          sum += binX[i];
          cnt++;
@@ -468,7 +523,7 @@ void  TEveCaloDataVec::SetAxisFromBins(Double_t epsX, Double_t epsY)
    epsY *= dy;
    newY.push_back(binY.front());// underflow
    Int_t nY = binY.size()-1;
-   for(Int_t i=0 ; i<nY; i++) 
+   for(Int_t i=0 ; i<nY; i++)
    {
       val = (sum +binY[i])/(cnt+1);
       if (binY[i+1] -val > epsY )
@@ -477,7 +532,7 @@ void  TEveCaloDataVec::SetAxisFromBins(Double_t epsX, Double_t epsY)
          cnt = 0;
          sum = 0;
       }
-      else 
+      else
       {
          sum += binY[i];
          cnt++;
@@ -540,10 +595,9 @@ void TEveCaloDataHist::DataChanged()
 
    if (GetNSlices() < 1) return;
 
-   TH2  *ah = (TH2*) RefSliceInfo(0).fHist;
-   fEtaAxis = ah->GetXaxis();
-   fPhiAxis = ah->GetYaxis();
-
+   TH2* hist = GetHist(0);
+   fEtaAxis  = hist->GetXaxis();
+   fPhiAxis  = hist->GetYaxis();
    for (Int_t ieta = 1; ieta <= fEtaAxis->GetNbins(); ++ieta)
    {
       Double_t eta = fEtaAxis->GetBinCenter(ieta); // conversion E/Et
@@ -552,8 +606,9 @@ void TEveCaloDataHist::DataChanged()
          Double_t value = 0;
          for (Int_t i = 0; i < GetNSlices(); ++i)
          {
-            Int_t bin = RefSliceInfo(i).fHist->GetBin(ieta, iphi);
-            value += RefSliceInfo(i).fHist->GetBinContent(bin);
+            hist = GetHist(i);
+            Int_t bin = hist->GetBin(ieta, iphi);
+            value += hist->GetBinContent(bin);
          }
 
          if (value > fMaxValEt ) fMaxValEt = value;
@@ -585,9 +640,8 @@ void TEveCaloDataHist::GetCellList(Float_t eta, Float_t etaD,
    Int_t nPhi = fPhiAxis->GetNbins();
    Int_t nSlices = GetNSlices();
 
-
-   TH2   *h0  = fSliceInfos[0].fHist;
-   Int_t  bin = 0;
+   TH2F* hist = GetHist(0);
+   Int_t bin  = 0;
 
    Bool_t accept;
    for (Int_t ieta = 1; ieta <= nEta; ++ieta)
@@ -600,19 +654,20 @@ void TEveCaloDataHist::GetCellList(Float_t eta, Float_t etaD,
             {
                accept = TEveUtil::IsU1IntervalContainedByMinMax
                   (phiMin, phiMax, fPhiAxis->GetBinLowEdge(iphi), fPhiAxis->GetBinUpEdge(iphi));
-            }         
+            }
             else
             {
                accept = fPhiAxis->GetBinLowEdge(iphi) >= phiMin &&  fPhiAxis->GetBinUpEdge(iphi) <= phiMax &&
                   fPhiAxis->GetBinLowEdge(iphi) >= phiMin &&  fPhiAxis->GetBinUpEdge(iphi) <= phiMax;
             }
-         
+
             if (accept)
             {
-               bin = h0->GetBin(ieta, iphi);
                for (Int_t s = 0; s < nSlices; ++s)
                {
-                  if (fSliceInfos[s].fHist->GetBinContent(bin) > fSliceInfos[s].fThreshold )
+                  hist = GetHist(s);
+                  bin = hist->GetBin(ieta, iphi);
+                  if (hist->GetBinContent(bin) > fSliceInfos[s].fThreshold)
                      out.push_back(TEveCaloData::CellId_t(bin, s));
                } // hist slices
             }
@@ -636,7 +691,7 @@ void TEveCaloDataHist::Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t &ids,
    for (vCellId_i it=ids.begin(); it!=ids.end(); ++it)
    {
       GetCellData(*it, cd);
-      fSliceInfos[(*it).fSlice].fHist->GetBinXYZ((*it).fTower, i, j, w);
+      GetHist(it->fSlice)->GetBinXYZ((*it).fTower, i, j, w);
       binx = ax->FindBin(fEtaAxis->GetBinCenter(i));
       biny = ay->FindBin(fPhiAxis->GetBinCenter(j));
       bin = biny*(ax->GetNbins()+2)+binx;
@@ -652,7 +707,7 @@ void TEveCaloDataHist::GetCellData(const TEveCaloData::CellId_t &id,
 {
    // Get cell geometry and value from cell ID.
 
-   TH2F* hist  = fSliceInfos[id.fSlice].fHist;
+   TH2F* hist = GetHist(id.fSlice);
 
    Int_t x, y, z;
    hist->GetBinXYZ(id.fTower, x, y, z);
@@ -673,19 +728,24 @@ Int_t TEveCaloDataHist::AddHistogram(TH2F* hist)
    // Return last index in the vector of slice infos.
 
    fHStack->Add(hist);
-
-   Int_t id = fSliceInfos.size();
-   fSliceInfos.push_back(SliceInfo_t(hist));
-   fSliceInfos[id].fName  = hist->GetName();
-   fSliceInfos[id].fColor = hist->GetLineColor();
-   fSliceInfos[id].fID    = id;
-
+   fSliceInfos.push_back(SliceInfo_t());
+   fSliceInfos.back().fName  = hist->GetName();
+   fSliceInfos.back().fColor = hist->GetLineColor();
+   
    DataChanged();
-
-   return id;
+   
+   return fSliceInfos.size() - 1;
 }
 
 //______________________________________________________________________________
+TH2F* TEveCaloDataHist::GetHist(Int_t slice) const
+{
+   // Get histogram in given slice.
+   
+   return (TH2F*) fHStack->GetHists()->At(slice);
+}
+   
+//______________________________________________________________________________
 void TEveCaloDataHist::GetEtaLimits(Double_t &min, Double_t &max) const
 {
    // Get eta limits.
diff --git a/graf3d/eve/src/TEveCaloLegoEditor.cxx b/graf3d/eve/src/TEveCaloLegoEditor.cxx
index d8340f6..4626efe 100644
--- a/graf3d/eve/src/TEveCaloLegoEditor.cxx
+++ b/graf3d/eve/src/TEveCaloLegoEditor.cxx
@@ -30,19 +30,17 @@ TEveCaloLegoEditor::TEveCaloLegoEditor(const TGWindow *p, Int_t width, Int_t hei
                                        UInt_t options, Pixel_t back) :
    TGedFrame(p, width, height, options | kVerticalFrame, back),
    fM(0),
-   fTopViewUseMaxColor(0),
-   fTopViewTowerColor(0),
    fGridColor(0),
    fFontColor(0),
    fPlaneColor(0),
    fTransparency(0),
 
-   fNZSteps(0),
-
    fProjection(0),
    f2DMode(0),
    fBoxMode(0),
 
+   fCell2DTextMin(0),
+
    fRebinFrame(0),
    fAutoRebin(0),
    fPixelsPerBin(0),
@@ -53,21 +51,6 @@ TEveCaloLegoEditor::TEveCaloLegoEditor(const TGWindow *p, Int_t width, Int_t hei
 
    MakeTitle("TEveCaloLego");
 
-   {  // tower color in 2d, top-view
-      TGHorizontalFrame* f = new TGHorizontalFrame(this);
-      TGLabel* lab = new TGLabel(f, "Tower-2D:");
-      f->AddFrame(lab, new TGLayoutHints(kLHintsLeft|kLHintsBottom, 1, 8, 1, 1));
-
-      fTopViewTowerColor = new TGColorSelect(f, 0, -1);
-      f->AddFrame(fTopViewTowerColor, new TGLayoutHints(kLHintsLeft|kLHintsTop, 3, 1, 0, 1));
-      fTopViewTowerColor->Connect("ColorSelected(Pixel_t)", "TEveCaloLegoEditor", this, "DoTopViewTowerColor(Pixel_t)");
-
-      fTopViewUseMaxColor = new TGCheckButton(f, "Auto color");
-      f->AddFrame(fTopViewUseMaxColor); // new TGLayoutHints());
-      fTopViewUseMaxColor->Connect("Clicked()", "TEveCaloLegoEditor", this, "DoTopViewUseMaxColor()");
-
-      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 1, 0));
-   }
    {  // grid color
       TGHorizontalFrame* f = new TGHorizontalFrame(this);
       TGLabel* lab = new TGLabel(f, "GridColor:");
@@ -110,22 +93,10 @@ TEveCaloLegoEditor::TEveCaloLegoEditor(const TGWindow *p, Int_t width, Int_t hei
       f->AddFrame(fTransparency, new TGLayoutHints(kLHintsLeft, 0, 0, 0, 0));
       fTransparency->Connect("ValueSet(Long_t)","TEveCaloLegoEditor", this, "DoTransparency()");
 
-
-
       AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 1, 0));
    }
 
    Int_t lw = 80;
-   fNZSteps = new TEveGValuator(this, "ZTickMarks:", 90, 0);
-   fNZSteps->SetLabelWidth(lw);
-   fNZSteps->SetNELength(5);
-   fNZSteps->SetShowSlider(kFALSE);
-   fNZSteps->Build();
-   fNZSteps->SetLimits(1, 20);
-   fNZSteps->SetToolTip("Number of labels along the Z axis.");
-   fNZSteps->Connect("ValueSet(Double_t)", "TEveCaloLegoEditor", this, "DoNZSteps()");
-   AddFrame(fNZSteps, new TGLayoutHints(kLHintsTop, 4, 2, 1, 2));
-
 
    fProjection = MakeLabeledCombo("Project:", 1);
    fProjection->AddEntry("Auto", TEveCaloLego::kAuto);
@@ -136,6 +107,7 @@ TEveCaloLegoEditor::TEveCaloLegoEditor(const TGWindow *p, Int_t width, Int_t hei
    f2DMode = MakeLabeledCombo("2DMode:", 4);
    f2DMode->AddEntry("ValColor", TEveCaloLego::kValColor);
    f2DMode->AddEntry("ValSize",  TEveCaloLego::kValSize);
+   f2DMode->AddEntry("ValSize",  TEveCaloLego::kValSizeOutline);
    f2DMode->Connect("Selected(Int_t)", "TEveCaloLegoEditor", this, "Do2DMode()");
 
    fBoxMode = MakeLabeledCombo("Box:", 4);
@@ -144,6 +116,16 @@ TEveCaloLegoEditor::TEveCaloLegoEditor(const TGWindow *p, Int_t width, Int_t hei
    fBoxMode->AddEntry("FrontBack",  TEveCaloLego::kFrontBack);
    fBoxMode->Connect("Selected(Int_t)", "TEveCaloLegoEditor", this, "DoBoxMode()");
 
+   fCell2DTextMin = new TEveGValuator(this, "Cell2DTexMin:", 90, 0);
+   fCell2DTextMin->SetLabelWidth(lw);
+   fCell2DTextMin->SetNELength(5);
+   fCell2DTextMin->SetShowSlider(kFALSE);
+   fCell2DTextMin->Build();
+   fCell2DTextMin->SetLimits(1, 1000);
+   fCell2DTextMin->SetToolTip("Draw cell values above N pixels.");
+   fCell2DTextMin->Connect("ValueSet(Double_t)", "TEveCaloLegoEditor", this, "DoCell2DTextMin()");
+   AddFrame(fCell2DTextMin, new TGLayoutHints(kLHintsTop, 1, 2, 1, 2));
+
    MakeRebinFrame();
 }
 
@@ -190,7 +172,7 @@ TGComboBox* TEveCaloLegoEditor::MakeLabeledCombo(const char* name, Int_t off)
    combo->Resize(90, 20);
    hf->AddFrame(combo, clh);
 
-   AddFrame(hf, new TGLayoutHints(kLHintsTop, 4, 1, 1, off));
+   AddFrame(hf, new TGLayoutHints(kLHintsTop, 1, 1, 1, off));
    return combo;
 }
 
@@ -201,15 +183,13 @@ void TEveCaloLegoEditor::SetModel(TObject* obj)
 
    fM = dynamic_cast<TEveCaloLego*>(obj);
 
-   fTopViewUseMaxColor->SetState(fM->GetTopViewUseMaxColor() ? kButtonDown : kButtonUp);
-   fTopViewTowerColor->SetColor(TColor::Number2Pixel(fM->GetTopViewTowerColor()), kFALSE);
-   fGridColor->SetColor(TColor::Number2Pixel(fM->GetGridColor()), kFALSE);
-   fFontColor->SetColor(TColor::Number2Pixel(fM->GetFontColor()), kFALSE);
+   fGridColor->SetColor(TColor::Number2Pixel(fM->GetGridColor() < 0 ? 0 : fM->GetGridColor()), kFALSE);
+   fFontColor->SetColor(TColor::Number2Pixel(fM->GetFontColor() < 0 ? 0 : fM->GetFontColor()), kFALSE);
 
    fPlaneColor->SetColor(TColor::Number2Pixel(fM->GetPlaneColor()), kFALSE);
    fTransparency->SetNumber(fM->GetPlaneTransparency());
 
-   fNZSteps->SetValue(fM->GetNZSteps());
+   fCell2DTextMin->SetValue(fM->GetDrawNumberCellPixels());
 
    fProjection->Select(fM->GetProjection(), kFALSE);
    f2DMode->Select(fM->Get2DMode(), kFALSE);
@@ -221,24 +201,6 @@ void TEveCaloLegoEditor::SetModel(TObject* obj)
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoEditor::DoTopViewUseMaxColor()
-{
-   // Slot for TopViewUseMaxColor.
-
-   fM->SetTopViewUseMaxColor(fTopViewUseMaxColor->IsOn());
-   Update();
-}
-
-//______________________________________________________________________________
-void TEveCaloLegoEditor::DoTopViewTowerColor(Pixel_t pixel)
-{
-   // Slot for TopViewTowerColor.
-
-   fM->SetTopViewTowerColor(Color_t(TColor::GetColor(pixel)));
-   Update();
-}
-
-//______________________________________________________________________________
 void TEveCaloLegoEditor::DoGridColor(Pixel_t pixel)
 {
    // Slot for GridColor.
@@ -266,11 +228,11 @@ void TEveCaloLegoEditor::DoPlaneColor(Pixel_t pixel)
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoEditor::DoNZSteps()
+void TEveCaloLegoEditor::DoCell2DTextMin()
 {
-   // Slot for NZStep.
+   // Slot for setting limit in pixels in which cell value is rendered.
 
-   fM->SetNZSteps((Int_t)fNZSteps->GetValue());
+   fM->SetDrawNumberCellPixels((Int_t)fCell2DTextMin->GetValue());
    Update();
 }
 
diff --git a/graf3d/eve/src/TEveCaloLegoGL.cxx b/graf3d/eve/src/TEveCaloLegoGL.cxx
index d0359ae..95d1a50 100644
--- a/graf3d/eve/src/TEveCaloLegoGL.cxx
+++ b/graf3d/eve/src/TEveCaloLegoGL.cxx
@@ -13,16 +13,21 @@
 #include "TH2.h"
 #include "THLimitsFinder.h"
 
+#include "TGLViewer.h"
 #include "TGLIncludes.h"
+#include "TGLPhysicalShape.h"
 #include "TGLRnrCtx.h"
 #include "TGLSelectRecord.h"
 #include "TGLScene.h"
 #include "TGLCamera.h"
 #include "TGLUtil.h"
+#include "TColor.h"
+#include "TROOT.h"
 
 
 #include "TEveCaloLegoGL.h"
 #include "TEveCalo.h"
+#include "TEveManager.h"
 #include "TEveRGBAPalette.h"
 
 #include <algorithm>
@@ -35,28 +40,28 @@ ClassImp(TEveCaloLegoGL);
 
 //______________________________________________________________________________
 TEveCaloLegoGL::TEveCaloLegoGL() :
-      TGLObject(),
-
-      fDataMax(0),
-
-      fEtaAxis(0),
-      fPhiAxis(0),
-      fZAxis(0),
-      fM(0),
-      fDLCacheOK(kFALSE),
-      fCells3D(kTRUE)
+   TGLObject(),
+
+   fDataMax(0),
+   fGridColor(-1),
+   fFontColor(-1),
+
+   fEtaAxis(0),
+   fPhiAxis(0),
+   fZAxis(0),
+   fM(0),
+   fDLCacheOK(kFALSE),
+   fCells3D(kTRUE)
 {
    // Constructor.
 
    fDLCache = kFALSE;
 
-   // need to set dummy parent, else loose settings in rebin
-
    fEtaAxis = new TAxis();
    fPhiAxis = new TAxis();
-   fZAxis = new TAxis();
+   fZAxis   = new TAxis();
 
-    fAxisPainter.SetFontMode(TGLFont::kPixmap);
+   fAxisPainter.SetFontMode(TGLFont::kPixmap);
 }
 
 //______________________________________________________________________________
@@ -109,6 +114,7 @@ void TEveCaloLegoGL::DLCachePurge()
 {
    // Unregister all display-lists.
 
+   // all lego cells
    fDLCacheOK = kFALSE;
    if (! fDLMap.empty()) {
       for (SliceDLMap_i i = fDLMap.begin(); i != fDLMap.end(); ++i) {
@@ -194,86 +200,93 @@ void TEveCaloLegoGL::MakeQuad(Float_t x1, Float_t y1, Float_t z1,
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoGL::MakeDisplayList() const
+void TEveCaloLegoGL::Make3DDisplayList(TEveCaloData::vCellId_t& cellList, SliceDLMap_t& dlMap, Bool_t selection) const
 {
-   // Create display-list that draws histogram bars.
+   // Create display-list that draws histogram bars for non-rebinned data.
    // It is used for filled and outline passes.
 
-   if (fM->fBinStep > 1)
+   TEveCaloData::CellData_t cellData;
+   Int_t   prevTower = 0;
+   Float_t offset = 0;
+
+   // ids in eta phi rng
+   Int_t nSlices = fM->fData->GetNSlices();
+   for (Int_t s = 0; s < nSlices; ++s)
    {
-      Int_t nSlices = fM->fData->GetNSlices();
-      Float_t *vals;
-      Int_t bin;
-      Float_t offset;
-      Float_t y0, y1;
-      for (Int_t s = 0; s < nSlices; ++s)
-      {
-         if (fDLMap.empty() || fDLMap[s] == 0)
-            fDLMap[s] = glGenLists(1);
+      if (dlMap.empty() || dlMap[s] == 0)
+         dlMap[s] = glGenLists(1);
 
-         glNewList(fDLMap[s], GL_COMPILE);
-         glLoadName(s);
-         glPushName(0);
-         for (Int_t i=1; i<=fEtaAxis->GetNbins(); ++i)
-         {
-            for (Int_t j=1; j<=fPhiAxis->GetNbins(); ++j)
-            {
-               bin = (i)+(j)*(fEtaAxis->GetNbins()+2);
+      glNewList(dlMap[s], GL_COMPILE);
 
-               if (fRebinData.fBinData[bin] !=-1)
-               {
-                  vals = fRebinData.GetSliceVals(bin);
-                  offset =0;
-                  for (Int_t t=0; t<s; t++)
-                     offset+=vals[t];
-
-                  y0 = fPhiAxis->GetBinLowEdge(j);
-                  y1 = fPhiAxis->GetBinUpEdge(j);
-                  WrapTwoPi(y0, y1);
-                  {
-                     glLoadName(bin);
-                     MakeQuad(fEtaAxis->GetBinLowEdge(i), y0, offset,
-                              fEtaAxis->GetBinWidth(i), y1-y0, vals[s]);
-                  }
-               }
-            }
+      for (UInt_t i = 0; i < cellList.size(); ++i) {
+         if (cellList[i].fSlice > s) continue;
+         if (cellList[i].fTower != prevTower) {
+            offset = 0;
+            prevTower = cellList[i].fTower;
          }
-         glPopName();
-         glEndList();
+
+         fM->fData->GetCellData(cellList[i], cellData);
+         if (s == cellList[i].fSlice) {
+            if (selection)
+               glLoadName(i);
+
+            WrapTwoPi(cellData.fPhiMin, cellData.fPhiMax);
+            MakeQuad(cellData.EtaMin(), cellData.PhiMin(), offset,
+                     cellData.EtaDelta(), cellData.PhiDelta(), cellData.Value(fM->fPlotEt));
+         }
+         offset += cellData.Value(fM->fPlotEt);
       }
+      glEndList();
    }
-   else {
-      TEveCaloData::CellData_t cellData;
-      Int_t   prevTower = 0;
-      Float_t offset = 0;
-
-      // ids in eta phi rng
-      Int_t nSlices = fM->fData->GetNSlices();
-      for (Int_t s = 0; s < nSlices; ++s) {
-         if (fDLMap.empty() || fDLMap[s] == 0)
-            fDLMap[s] = glGenLists(1);
-         glNewList(fDLMap[s], GL_COMPILE);
-
-         for (UInt_t i = 0; i < fM->fCellList.size(); ++i) {
-            if (fM->fCellList[i].fSlice > s) continue;
-            if (fM->fCellList[i].fTower != prevTower) {
-               offset = 0;
-               prevTower = fM->fCellList[i].fTower;
-            }
+}
 
-            fM->fData->GetCellData(fM->fCellList[i], cellData);
-            if (s == fM->fCellList[i].fSlice) {
-               glLoadName(i);
-               WrapTwoPi(cellData.fPhiMin, cellData.fPhiMax);
-               MakeQuad(cellData.EtaMin(), cellData.PhiMin(), offset,
-                        cellData.EtaDelta(), cellData.PhiDelta(), cellData.Value(fM->fPlotEt));
+//______________________________________________________________________________
+void TEveCaloLegoGL::Make3DDisplayListRebin(TEveCaloData::RebinData_t& rebinData, SliceDLMap_t& dlMap, Bool_t selection) const
+{
+   // Create display-list that draws histogram bars for rebinned data.
+   // It is used for filled and outline passes.
+
+   Int_t nSlices = fM->fData->GetNSlices();
+   Float_t *vals;
+   Int_t bin;
+   Float_t offset;
+   Float_t y0, y1;
+   for (Int_t s = 0; s < nSlices; ++s)
+   {
+      if (dlMap.empty() || dlMap[s] == 0)
+         dlMap[s] = glGenLists(1);
+
+      glNewList(dlMap[s], GL_COMPILE);
+
+      if (selection) glLoadName(s);
+      if (selection) glPushName(0);
+      for (Int_t i=1; i<= fEtaAxis->GetNbins(); ++i)
+      {
+         for (Int_t j=1; j <= fPhiAxis->GetNbins(); ++j)
+         {
+            bin = (i)+(j)*(fEtaAxis->GetNbins()+2);
+
+            if (rebinData.fBinData[bin] !=-1)
+            {
+               vals = rebinData.GetSliceVals(bin);
+               offset =0;
+               for (Int_t t=0; t<s; t++)
+                  offset+=vals[t];
+
+               y0 = fPhiAxis->GetBinLowEdge(j);
+               y1 = fPhiAxis->GetBinUpEdge(j);
+               WrapTwoPi(y0, y1);
+               {
+                  if (selection) glLoadName(bin);
+                  MakeQuad(fEtaAxis->GetBinLowEdge(i), y0, offset,
+                           fEtaAxis->GetBinWidth(i), y1-y0, vals[s]);
+               }
             }
-            offset += cellData.Value(fM->fPlotEt);
          }
-         glEndList();
       }
+      if (selection) glPopName();
+      glEndList();
    }
-   fDLCacheOK = kTRUE;
 }
 
 //______________________________________________________________________________
@@ -430,23 +443,23 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
    TGLVertex3 worldRef(fZAxisTitlePos.fX, fZAxisTitlePos.fY, fZAxisTitlePos.fZ);
 
    fAxisPainter.RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -len, 0,  &mm);
-   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
-   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
+   fAxisPainter.SetLabelPixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
+   fAxisPainter.SetTitlePixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
 
    // Z axis
    //
    if (fM->fData->Empty() == kFALSE)
    {
-      fZAxis->SetAxisColor(fM->fGridColor);
-      fZAxis->SetLabelColor(fM->fFontColor);
-      fZAxis->SetTitleColor(fM->fFontColor);
+      fZAxis->SetAxisColor(fGridColor);
+      fZAxis->SetLabelColor(fFontColor);
+      fZAxis->SetTitleColor(fFontColor);
       fZAxis->SetNdivisions(fM->fNZSteps*100 + 10);
       fZAxis->SetLimits(0, fDataMax);
       fZAxis->SetTitle(fM->GetPlotEt() ? "Et[GeV]" : "E[GeV]");
 
       fAxisPainter.SetTMNDim(1);
       fAxisPainter.RefDir().Set(0., 0., 1.);
-      fAxisPainter.SetLabelAlign(TGLFont::kRight);
+      fAxisPainter.SetLabelAlign(TGLFont::kRight, TGLFont::kCenterV);
       glPushMatrix();
       glTranslatef(fZAxisTitlePos.fX, fZAxisTitlePos.fY, 0);
 
@@ -458,18 +471,6 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
       glTranslated( fAxisPainter.RefTMOff(0).X(),  fAxisPainter.RefTMOff(0).Y(),  fAxisPainter.RefTMOff(0).Z());
       glPopMatrix();
 
-      // repaint axis if tower dobule-clicked
-      if (fM->fTowerPicked >= 0) {
-         TEveCaloData::CellData_t cd;
-         fM->fData->GetCellData(fM->fCellList[fM->fTowerPicked], cd);
-         WrapTwoPi(cd.fPhiMin, cd.fPhiMax);
-         glPushMatrix();
-         glTranslatef(cd.EtaMin(), cd.PhiMin(), 0);
-         fAxisPainter.RnrLines();
-         fAxisPainter.RnrLabels();
-         glPopMatrix();
-      }
-
       // draw box frame
       //
       if (fM->fBoxMode) {
@@ -479,7 +480,7 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
          // box verticals
          TGLUtil::LineWidth(1);
          glBegin(GL_LINES);
-         TGLUtil::Color(fM->GetGridColor());
+         TGLUtil::Color(fGridColor);
 
          glVertex3f(fBackPlaneXConst[0].fX   ,fBackPlaneXConst[0].fY   ,0);
          glVertex3f(fBackPlaneXConst[0].fX   ,fBackPlaneXConst[0].fY   ,fDataMax);
@@ -531,15 +532,15 @@ void TEveCaloLegoGL::DrawAxis3D(TGLRnrCtx & rnrCtx) const
    if (fYAxisTitlePos.fX < fM->GetEtaMax()) xOff = -xOff;
 
    TAxis ax;
-   ax.SetAxisColor(fM->fGridColor);
-   ax.SetLabelColor(fM->fFontColor);
-   ax.SetTitleColor(fM->fFontColor);
+   ax.SetAxisColor(fGridColor);
+   ax.SetLabelColor(fFontColor);
+   ax.SetTitleColor(fFontColor);
    ax.SetTitleFont(fM->GetData()->GetEtaBins()->GetTitleFont());
    ax.SetLabelOffset(0.02);
    ax.SetTickLength(0.05);
    fAxisPainter.SetTMNDim(2);
    fAxisPainter.RefTMOff(1).Set(0, 0, -fDataMax);
-   fAxisPainter.SetLabelAlign(TGLFont::kCenterUp);
+   fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
 
    // eta
    glPushMatrix();
@@ -573,9 +574,9 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
    // Draw XY axis.
 
    TAxis ax;
-   ax.SetAxisColor(fM->fGridColor);
-   ax.SetLabelColor(fM->fFontColor);
-   ax.SetTitleColor(fM->fFontColor);
+   ax.SetAxisColor(fGridColor);
+   ax.SetLabelColor(fFontColor);
+   ax.SetTitleColor(fFontColor);
    ax.SetTitleFont(fM->GetData()->GetEtaBins()->GetTitleFont());
    ax.SetLabelOffset(0.01);
    ax.SetTickLength(0.05);
@@ -600,15 +601,15 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
                               + (up[2] - dn[2]) * (up[2] - dn[2]));
 
    // eta
-   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
-   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
+   fAxisPainter.SetLabelPixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
+   fAxisPainter.SetTitlePixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
    ax.SetNdivisions(710);
    ax.SetLimits(fM->GetEtaMin(), fM->GetEtaMax());
    ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(fM->GetEtaMax(), -fM->GetPhiRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), 0 );
    fAxisPainter.RefDir().Set(1, 0, 0);
    fAxisPainter.RefTMOff(0).Set(0,  -fM->GetPhiRng(), 0);
-   fAxisPainter.SetLabelAlign(TGLFont::kCenterUp);
+   fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
 
    glPushMatrix();
    glTranslatef(0, fM->GetPhiMin(), 0);
@@ -616,15 +617,13 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
    glPopMatrix();
 
    // phi
-   fAxisPainter.SetLabelPixelFontSize(TMath::CeilNint(len*fM->GetData()->GetPhiBins()->GetLabelSize()));
-   fAxisPainter.SetTitlePixelFontSize(TMath::CeilNint(len*fM->GetData()->GetPhiBins()->GetTitleSize()));
    ax.SetNdivisions(510);
    ax.SetLimits(fM->GetPhiMin(), fM->GetPhiMax());
    ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(-fM->GetEtaRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), fM->GetPhiMax(), 0);
    fAxisPainter.RefDir().Set(0, 1, 0);
    fAxisPainter.RefTMOff(0).Set(-fM->GetEtaRng(), 0, 0);
-   fAxisPainter.SetLabelAlign(TGLFont::kRight);
+   fAxisPainter.SetLabelAlign(TGLFont::kRight, TGLFont::kCenterV);
 
    glPushMatrix();
    glTranslatef(fM->GetEtaMin(), 0, 0);
@@ -637,44 +636,40 @@ Int_t TEveCaloLegoGL::GetGridStep(TGLRnrCtx &rnrCtx) const
 {
    // Calculate view-dependent grid density.
 
-   using namespace TMath;
+   TGLCamera &camera = rnrCtx.RefCamera();
+   Float_t l = -camera.FrustumPlane(TGLCamera::kLeft).D();
+   Float_t r =  camera.FrustumPlane(TGLCamera::kRight).D();
+   Float_t t =  camera.FrustumPlane(TGLCamera::kTop).D();
+   Float_t b = -camera.FrustumPlane(TGLCamera::kBottom).D();
+   Float_t frustD    = TMath::Hypot(r-l, t-b);
 
-   GLdouble x0, y0, z0, x1, y1, z1;
-   GLdouble mm[16];
-   GLint    vp[4];
-   glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
-   glGetIntegerv(GL_VIEWPORT, vp);
-   const GLdouble *pmx = rnrCtx.RefCamera().RefLastNoPickProjM().CArr();
+   GLint   vp[4]; glGetIntegerv(GL_VIEWPORT, vp);
+   Float_t viewportD = TMath::Sqrt((vp[1] - vp[0]) * (vp[1] - vp[0]) + (vp[3] - vp[1]) * (vp[3] - vp[1]));
+   Float_t deltaToViewport = viewportD/frustD;
 
+   // average bin width
    GLdouble em, eM, pm, pM;
    fM->GetData()->GetEtaLimits(pm, pM);
    fM->GetData()->GetPhiLimits(em, eM);
-   gluProject(em, pm, 0.f , mm, pmx, vp, &x0, &y0, &z0);
-   gluProject(eM, pM, 0.f , mm, pmx, vp, &x1, &y1, &z1);
-   Float_t d0 = Sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));
-
-   gluProject(em, pm, 0.f , mm, pmx, vp, &x0, &y0, &z0);
-   gluProject(eM, pM, 0.f , mm, pmx, vp, &x1, &y1, &z1);
-   Float_t d1 = Sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));
-
-   Float_t d = d1 > d0 ? d1 : d0;
    Int_t i0 = fM->fData->GetEtaBins()->FindBin(fM->GetEtaMin());
    Int_t i1 = fM->fData->GetEtaBins()->FindBin(fM->GetEtaMax());
    Int_t j0 = fM->fData->GetPhiBins()->FindBin(fM->GetPhiMin());
    Int_t j1 = fM->fData->GetPhiBins()->FindBin(fM->GetPhiMax());
 
-   Int_t pixelsPerBin = TMath::Nint(d / Sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1)));
+   Float_t averageBinWidth = TMath::Hypot(eM - em, pM - pm)/TMath::Sqrt((i0 - i1) * (i0 - i1) + (j0 - j1) * (j0 - j1));
+   Float_t ppb = deltaToViewport*averageBinWidth;
+
    Int_t ngroup = 1;
-   if (fM->fAutoRebin)
+   if (fM->fAutoRebin && fM->fPixelsPerBin > ppb)
    {
-      if (pixelsPerBin < fM->fPixelsPerBin*0.5) {
-         ngroup = 4;
-      } else if (pixelsPerBin < fM->fPixelsPerBin) {
-         ngroup = 2;
-      } else {
-         ngroup = 1;
-      }
+      ngroup = TMath::Nint(fM->fPixelsPerBin*0.5/ppb); // symetrical rebin factor 2
+      // limit rebin realtive to number of axis bins
+      Int_t minN = TMath::Min(fM->fData->GetEtaBins()->GetNbins(), fM->fData->GetPhiBins()->GetNbins());
+      if (ngroup * 4 > minN)
+         ngroup = minN/4;
    }
+   fCurrentPixelsPerBin = TMath::Nint(ppb);
+
    return ngroup;
 }
 
@@ -708,12 +703,9 @@ void TEveCaloLegoGL::DrawHistBase(TGLRnrCtx &rnrCtx) const
    Float_t phi0 = fM->GetPhiMin();
    Float_t phi1 = fM->GetPhiMax();
 
-   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
-   TGLCapabilitySwitch sw_blend(GL_BLEND, kTRUE);
-
    // XY grid
    //
-   TGLUtil::Color(fM->fGridColor);
+   TGLUtil::Color(fGridColor);
    TGLUtil::LineWidth(1);
    glBegin(GL_LINES);
    glVertex2f(eta0, phi0);
@@ -793,227 +785,394 @@ void TEveCaloLegoGL::DrawCells3D(TGLRnrCtx & rnrCtx) const
 }
 
 //______________________________________________________________________________
-void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx & rnrCtx) const
+void TEveCaloLegoGL::PrepareCell2DData(TEveCaloData::vCellId_t& cellList, vCell2D_t& cells2D) const
 {
-   // Draw projected histogram.
-
-   std::vector<Double_t>  cellGeom;
-   std::vector<Float_t>   sumVal;
-   std::vector<Int_t>     maxSlice;
-   std::vector<Int_t>     id;
-
-   Int_t max_energy_slice, cellID=0;
-   Float_t sum, max_energy, x1, x2, y1, y2;
-
-   if (fM->fBinStep == 1)
-   {
-      TEveCaloData::vCellId_t::iterator currentCell = fM->fCellList.begin();
-      TEveCaloData::vCellId_t::iterator nextCell    = currentCell;
-      ++nextCell;
-
-      while (currentCell != fM->fCellList.end()) {
-         TEveCaloData::CellData_t currentCellData;
-         TEveCaloData::CellData_t nextCellData;
-
-         fM->fData->GetCellData(*currentCell, currentCellData);
-         sum = max_energy = currentCellData.Value(fM->fPlotEt);
-         max_energy_slice = currentCell->fSlice;
-         while (nextCell != fM->fCellList.end() && currentCell->fTower == nextCell->fTower) {
-            fM->fData->GetCellData(*nextCell, nextCellData);
-            Float_t energy = nextCellData.Value(fM->fPlotEt);
-            sum += energy;
-            if (fM->fTopViewUseMaxColor && energy > max_energy) {
-               max_energy       = energy;
-               max_energy_slice = nextCell->fSlice;
-            }
-            ++nextCell;
-            ++cellID;
+   // Prepare cells 2D data non-rebinned for drawing.
+
+   Int_t   max_energy_slice, cellID=0;
+   Float_t sum, max_energy;
+
+   TEveCaloData::vCellId_t::iterator currentCell = cellList.begin();
+   TEveCaloData::vCellId_t::iterator nextCell    = currentCell;
+   ++nextCell;
+
+   while (currentCell != cellList.end()) {
+      TEveCaloData::CellData_t currentCellData;
+      TEveCaloData::CellData_t nextCellData;
+
+      fM->fData->GetCellData(*currentCell, currentCellData);
+      sum = max_energy = currentCellData.Value(fM->fPlotEt);
+      max_energy_slice = currentCell->fSlice;
+      while (nextCell != cellList.end() && currentCell->fTower == nextCell->fTower) {
+         fM->fData->GetCellData(*nextCell, nextCellData);
+         Float_t energy = nextCellData.Value(fM->fPlotEt);
+         sum += energy;
+         if (energy > max_energy) {
+            max_energy       = energy;
+            max_energy_slice = nextCell->fSlice;
          }
-
-         WrapTwoPi(currentCellData.fPhiMin, currentCellData.fPhiMax);
-
-         cellGeom.push_back(currentCellData.fEtaMin); cellGeom.push_back(currentCellData.fPhiMin);
-         cellGeom.push_back(currentCellData.fEtaMax); cellGeom.push_back(currentCellData.fPhiMax);
-
-         sumVal.push_back(sum);
-         maxSlice.push_back(max_energy_slice);
-         id.push_back(cellID);
-
-         currentCell = nextCell;
          ++nextCell;
          ++cellID;
       }
+
+      WrapTwoPi(currentCellData.fPhiMin, currentCellData.fPhiMax);
+      cells2D.push_back(Cell2D_t(cellID, sum, max_energy_slice));
+      cells2D.back().SetGeom(currentCellData.fEtaMin, currentCellData.fEtaMax,
+                             currentCellData.fPhiMin, currentCellData.fPhiMax);
+      currentCell = nextCell;
+      ++nextCell;
+      ++cellID;
    }
-   else {
-      // get sum value in agragated cells
-      const Int_t nEta = fEtaAxis->GetNbins();
-      const Int_t nPhi = fPhiAxis->GetNbins();
-      std::vector<Float_t> vec;
-      vec.assign((nEta + 2)*(nPhi + 2), 0.f);
-      std::vector<Float_t> max_e;
-      std::vector<Int_t>   max_e_slice;
-      if (fM->fTopViewUseMaxColor) {
-         max_e.assign((nEta + 2) * (nPhi + 2), 0.f);
-         max_e_slice.assign((nEta + 2) * (nPhi + 2), -1);
-      }
-      for (UInt_t bin = 0; bin < fRebinData.fBinData.size(); ++bin) {
-         Float_t ssum = 0;
-         if (fRebinData.fBinData[bin] != -1) {
-            Float_t *val = fRebinData.GetSliceVals(bin);
-            for (Int_t s = 0; s < fRebinData.fNSlices; ++s) {
-               ssum += val[s];
-               if (fM->fTopViewUseMaxColor && val[s] > max_e[bin]) {
-                  max_e[bin]       = val[s];
-                  max_e_slice[bin] = s;
-               }
+}
+
+//______________________________________________________________________________
+void TEveCaloLegoGL::PrepareCell2DDataRebin(TEveCaloData::RebinData_t& rebinData, vCell2D_t& cells2D) const
+{
+   // Prepare cells 2D rebinned data for drawing.
+
+   const Int_t nEta = fEtaAxis->GetNbins();
+   const Int_t nPhi = fPhiAxis->GetNbins();
+   std::vector<Float_t> vec;
+   vec.assign((nEta + 2)*(nPhi + 2), 0.f);
+   std::vector<Float_t> max_e;
+   std::vector<Int_t>   max_e_slice;
+   max_e.assign((nEta + 2) * (nPhi + 2), 0.f);
+   max_e_slice.assign((nEta + 2) * (nPhi + 2), -1);
+
+   for (UInt_t bin = 0; bin < rebinData.fBinData.size(); ++bin) {
+      Float_t ssum = 0;
+      if (rebinData.fBinData[bin] != -1) {
+         Float_t *val = rebinData.GetSliceVals(bin);
+         for (Int_t s = 0; s < rebinData.fNSlices; ++s) {
+            ssum += val[s];
+            if (val[s] > max_e[bin]) {
+               max_e[bin]       = val[s];
+               max_e_slice[bin] = s;
             }
          }
-         vec[bin] = ssum;
       }
+      vec[bin] = ssum;
+   }
 
-      // take smallest threshold
-      Float_t threshold = fM->GetDataSliceThreshold(0);
-      for (Int_t s = 1; s < fM->fData->GetNSlices(); ++s) {
-         if (threshold > fM->GetDataSliceThreshold(s))
-            threshold = fM->GetDataSliceThreshold(s);
-      }
+   // smallest threshold
+   Float_t threshold = fM->GetDataSliceThreshold(0);
+   for (Int_t s = 1; s < fM->fData->GetNSlices(); ++s) {
+      if (threshold > fM->GetDataSliceThreshold(s))
+         threshold = fM->GetDataSliceThreshold(s);
+   }
 
-      for (Int_t i = 1; i <= fEtaAxis->GetNbins(); ++i) {
-         for (Int_t j = 1; j <= fPhiAxis->GetNbins(); ++j) {
-            const Int_t bin = j * (nEta + 2) + i;
-            if (vec[bin] > threshold && fRebinData.fBinData[bin] != -1) {
-               x1 = fEtaAxis->GetBinLowEdge(i);
-               x2 = fEtaAxis->GetBinUpEdge(i);
-               y1 = fPhiAxis->GetBinLowEdge(j);
-               y2 = fPhiAxis->GetBinUpEdge(j);
-               cellGeom.push_back(x1); cellGeom.push_back(y1);
-               cellGeom.push_back(x2); cellGeom.push_back(y2);
-               sumVal.push_back(vec[bin]);
-               maxSlice.push_back(max_e_slice[bin]);
-               id.push_back(bin);
-            }
+   // write cells
+   for (Int_t i = 1; i <= fEtaAxis->GetNbins(); ++i) {
+      for (Int_t j = 1; j <= fPhiAxis->GetNbins(); ++j) {
+         const Int_t bin = j * (nEta + 2) + i;
+         if (vec[bin] > threshold && rebinData.fBinData[bin] != -1) {
+            cells2D.push_back(Cell2D_t(bin, vec[bin], max_e_slice[bin]));
+            cells2D.back().SetGeom(fEtaAxis->GetBinLowEdge(i), fEtaAxis->GetBinUpEdge(i),
+                                   fPhiAxis->GetBinLowEdge(j), fPhiAxis->GetBinUpEdge(j));
          }
       }
    }
+}
 
-   //
-   // drawcells
-   //
+//--------------------------------------------------------------------------------
+void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
+{
+   // Draw cells in top view.
+
+   Float_t bws    = -1; //smallest bin
+   Float_t logMax = -1;
 
    if (fM->f2DMode == TEveCaloLego::kValColor ) {
       fM->AssertPalette();
       UChar_t col[4];
 
-      for (UInt_t i=0; i < sumVal.size(); i++) {
-         glLoadName(id[i]);
-         glBegin(GL_POLYGON);
 
-         fM->fPalette->ColorFromValue(TMath::FloorNint(sumVal[i]), col);
+      for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+         if (rnrCtx.SecSelection()) glLoadName(i->fId);
+         glBegin(GL_POLYGON);
+         Float_t val = i->fSumVal;
+         fM->fPalette->ColorFromValue(TMath::FloorNint(val), col);
          TGLUtil::Color4ubv(col);
-
-         x1 = cellGeom[4*i];
-         y1 = cellGeom[4*i+1];
-         x2 = cellGeom[4*i+2];
-         y2 = cellGeom[4*i+3];
-
-         glVertex3f(x1, y1, 0);
-         glVertex3f(x2, y1, 0);
-         glVertex3f(x2, y2, 0);
-         glVertex3f(x1, y2, 0);
+         glVertex3f(i->fX0, i->fY0, val);
+         glVertex3f(i->fX1, i->fY0, val);
+         glVertex3f(i->fX1, i->fY1, val);
+         glVertex3f(i->fX0, i->fY1, val);
          glEnd();
       }
    }
    else {
-      // antiflicekring
-      Float_t maxv =0;
       Float_t x, y;
-      glBegin(GL_POINTS);
-      for (UInt_t i=0; i< sumVal.size(); i++) {
-         TGLUtil::Color(fM->fData->GetSliceColor(maxSlice[i]));
-         x = 0.5* (cellGeom[4*i] +cellGeom[4*i+2]);
-         y = 0.5* (cellGeom[4*i+1] +cellGeom[4*i+3]);
-         glVertex3f(x, y, sumVal[i]);
-         if (sumVal[i] > maxv) maxv = sumVal[i];
+      if (!rnrCtx.HighlightOutline()) {
+         Float_t maxv = 0;
+         bws = 1e5;
+         for ( vCell2D_i i = fCells2D.begin(); i != fCells2D.end(); ++i) {
+            if ( i->MinSize() < bws)   bws = i->MinSize();
+            if ( i->fSumVal > maxv)   maxv = i->fSumVal;
+         }
+         bws   *= 0.5;
+         logMax = TMath::Log10(maxv + 1);
+         fValToPixel =  bws/logMax;
+      }
+
+      // special draw for name stack
+      if (rnrCtx.SecSelection())
+      {
+         for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+            // point
+            glLoadName(i->fMaxSlice);
+            glPushName(i->fId);
+            TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
+            glBegin(GL_POINTS);
+            glVertex3f(i->X(), i->Y() , i->fSumVal);
+            glEnd();
+            glPopName();
+
+            // polygon
+            glLoadName(i->fMaxSlice);
+            glPushName(i->fId);
+            glBegin(GL_QUADS);
+            Float_t bw = fValToPixel*TMath::Log10(i->fSumVal+1);
+            x = i->X();
+            y = i->Y();
+            glVertex3f(x - bw, y - bw, i->fSumVal);
+            glVertex3f(x + bw, y - bw, i->fSumVal);
+            glVertex3f(x + bw, y + bw, i->fSumVal);
+            glVertex3f(x - bw, y + bw, i->fSumVal);
+            glEnd();
+            glPopName();
+         }
       }
-      glEnd();
+      else
+      {// optimised draw without name stack
+         if (!rnrCtx.HighlightOutline())
+         {
+            glBegin(GL_POINTS);
+            for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+               TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
+               glVertex3f(i->X(), i->Y() , i->fSumVal);
+            }
+            glEnd();
+         }
 
-      // scale cells
-      Float_t logMax   = TMath::Log10(maxv + 1);
+         glBegin(GL_QUADS);
+         for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+            TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
+            Float_t bw = fValToPixel*TMath::Log10(i->fSumVal+1);
+            x = i->X();
+            y = i->Y();
+            glVertex3f(x - bw, y - bw, i->fSumVal);
+            glVertex3f(x + bw, y - bw, i->fSumVal);
+            glVertex3f(x + bw, y + bw, i->fSumVal);
+            glVertex3f(x - bw, y + bw, i->fSumVal);
+         }
+         glEnd();
 
-      // get smallest bin to deduce bin size 
-      Float_t bw = 1e5;
-      for (UInt_t i=0; i< cellGeom.size(); i += 4 ) {
-         if ( cellGeom[i+2] -cellGeom[i] < bw)   bw =  cellGeom[i+2] -cellGeom[i];
-         if ( cellGeom[i+3] -cellGeom[i+1] < bw) bw =  cellGeom[i+3] -cellGeom[i+1];
+         if (fM->f2DMode == TEveCaloLego::kValSizeOutline)
+         { 
+            glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
+            Float_t z    = 0;
+            Float_t zOff = fDataMax*0.1 ;
+            glBegin(GL_QUADS);
+            for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+               TGLUtil::ColorTransparency(fM->fData->GetSliceColor(i->fMaxSlice), 80);
+               z = i->fSumVal - zOff;
+               glVertex3f(i->fX0, i->fY0, z);
+               glVertex3f(i->fX1, i->fY0, z);
+               glVertex3f(i->fX1, i->fY1, z);
+               glVertex3f(i->fX0, i->fY1, z);
+            }
+            glEnd();
+
+            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+            glBegin(GL_QUADS);
+            for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+               TGLUtil::ColorTransparency(fM->fData->GetSliceColor(i->fMaxSlice), 60);
+               z = i->fSumVal + zOff;
+               glVertex3f(i->fX0, i->fY0, z);
+               glVertex3f(i->fX1, i->fY0, z);
+               glVertex3f(i->fX1, i->fY1, z);
+               glVertex3f(i->fX0, i->fY1, z);
+            }
+            glEnd();
+            glPopAttrib();
+         }
       }
-      bw *= 0.5;
+   }
 
-      for (UInt_t i=0; i< sumVal.size(); i++) {
-         glLoadName(id[i]);
-         glBegin(GL_POLYGON);
-         TGLUtil::Color(fM->fData->GetSliceColor(maxSlice[i]));
+   // text
+   if ( fCurrentPixelsPerBin >  fM->fDrawNumberCellPixels && 
+        (rnrCtx.Selection() || rnrCtx.Highlight() || rnrCtx.HighlightOutline()) == kFALSE) 
+   {
+      TGLUtil::Color(rnrCtx.ColorSet().Markup().GetColorIndex());
+      TGLFont font;
+      rnrCtx.RegisterFontNoScale(fM->fCellPixelFontSize, "arial", TGLFont::kPixmap, font);
+      const char* txt;
+      for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+
+         Float_t val = i->fSumVal;
+         if (val > 10)
+            txt = Form("%d", TMath::Nint(val));
+         else if (val > 1 )
+            txt = Form("%.1f", val);
+         else if (val > 0.01 )
+            txt = Form("%.2f", 0.01*TMath::Nint(val*100));
+         else
+            txt = Form("~1e%d", TMath::Nint(TMath::Log10(val)));
 
-         Float_t bws = bw*TMath::Log10(sumVal[i]+1)/logMax;
+         font.Render(txt, i->X(), i->Y(), val*1.2, TGLFont::kCenterH, TGLFont::kCenterV);
+      }
+   }
+}
 
-         x = 0.5* (cellGeom[4*i] +cellGeom[4*i+2]) ;
-         y = 0.5* (cellGeom[4*i+1] +cellGeom[4*i+3]) ;
-         glVertex3f(x - bws, y - bws, 0);
-         glVertex3f(x + bws, y - bws, 0);
-         glVertex3f(x + bws, y + bws, 0);
-         glVertex3f(x - bws, y + bws, 0);
+//______________________________________________________________________________
+void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const
+{
+   // Draw eta-phi range in highlight mode.
 
-         glEnd();
+   if (!fM->fData->GetCellsSelected().size() || pshp->GetSelected() != 2) return;
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT );
+   glDisable(GL_LIGHTING);
+   glDisable(GL_CULL_FACE);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+
+   TGLUtil::LineWidth(2);
+   glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
+   rnrCtx.SetHighlightOutline(kTRUE);
+   TGLUtil::LockColor();
+
+   // modelview matrix
+   glPushMatrix();
+   Double_t em, eM, pm, pM;
+   fM->fData->GetEtaLimits(em, eM);
+   fM->fData->GetPhiLimits(pm, pM);
+   Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
+   Float_t sx = (eM - em) / fM->GetEtaRng();
+   Float_t sy = (pM - pm) / fM->GetPhiRng();
+   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetValToHeight());
+   glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
+
+   // check eta&phi range of selected cells
+   TEveCaloData::vCellId_t cellsSelected;
+   TEveCaloData::CellData_t cellData;
+   for (TEveCaloData::vCellId_i i = fM->fData->GetCellsSelected().begin(); i != fM->fData->GetCellsSelected().end(); i++)
+   {
+      fM->fData->GetCellData((*i), cellData);
+      if(fM->CellInEtaPhiRng(cellData))
+         cellsSelected.push_back(*i); 
+   }
 
+   // prepare rebin for 2D or 3D if necessary
+   TEveCaloData::RebinData_t rebinDataSelected;
+   if (fM->fBinStep > 1)
+   {
+      fM->fData->Rebin(fEtaAxis, fPhiAxis, cellsSelected, fM->fPlotEt, rebinDataSelected);
+      Float_t scale = fM->GetMaxVal() / fMaxValRebin;
+      if (fM->fNormalizeRebin) {
+         for (std::vector<Float_t>::iterator it = rebinDataSelected.fSliceData.begin(); it != rebinDataSelected.fSliceData.end(); it++)
+            (*it) *= scale;
       }
+   }
 
-      // get value to pixels
-
-      // get projected length of diagonal to determine
-      TGLMatrix mm;
-      GLdouble pm[16];
-      GLint    vp[4];
-      glGetDoublev(GL_MODELVIEW_MATRIX, mm.Arr());
-      glGetDoublev(GL_PROJECTION_MATRIX, pm);
-      glGetIntegerv(GL_VIEWPORT, vp);
-
-      GLdouble dn[3];
-      GLdouble up[3];
-      gluProject(fM->GetEtaMin(), 0, 0, mm.Arr(), pm, vp, &dn[0], &dn[1], &dn[2]);
-      gluProject(fM->GetEtaMax(), 0, 0, mm.Arr(), pm, vp, &up[0], &up[1], &up[2]);
-      Double_t etaLenPix = up[0]-dn[0];
-      Float_t sx = etaLenPix/fM->GetEtaRng();
-
-      TGLUtil::Color(fM->GetFontColor());
-      Float_t llx, lly, llz, urx, ury, urz;
-      Float_t xOff, yOff;
-      TGLFont font;
-      rnrCtx.RegisterFont(TGLFontManager::GetFontSize(fM->fCellPixelFontSize), "arial", TGLFont::kPixmap, font);
-      for (UInt_t i=0; i< sumVal.size(); i++) {
 
-         Float_t bws = bw*TMath::Log10(sumVal[i]+1)/logMax;
-         if (bws*sx >  fM->fDrawNumberCellPixels)
+   if (fCells3D)
+   {
+      Int_t   prevTower = 0;
+      Float_t offset    = 0;
+      Int_t   nSlices   = fM->fData->GetNSlices();
+      if (fM->fBinStep == 1)
+      {
+         TEveCaloData::vCellId_i      j = cellsSelected.begin();
+         for (TEveCaloData::vCellId_i i = fM->fCellList.begin(); i != fM->fCellList.end(); ++i) {
+            if (i->fTower != prevTower) {
+               offset = 0;
+               prevTower = i->fTower;
+            }
+
+            // ceheck if this cell is in the list of slected cells
+            if (j->fTower == i->fTower && j->fSlice == i->fSlice)
+            {
+               fM->fData->GetCellData((*j), cellData);
+               WrapTwoPi(cellData.fPhiMin, cellData.fPhiMax);
+               MakeQuad(cellData.EtaMin(), cellData.PhiMin(), offset,
+                        cellData.EtaDelta(), cellData.PhiDelta(), cellData.Value(fM->fPlotEt));
+               j++;
+               if (j == cellsSelected.end())
+                  break;
+            }
+
+            fM->fData->GetCellData((*i), cellData);
+            offset += cellData.Value(fM->fPlotEt);
+         }
+      }
+      else
+      {
+         Int_t bin;
+         Float_t *vals;
+         Float_t *valsRef;
+         Float_t y0, y1;
+         for (Int_t i=1; i<= fEtaAxis->GetNbins(); ++i)
          {
-            x = 0.5* (cellGeom[4*i] +cellGeom[4*i+2]) ;
-            y = 0.5* (cellGeom[4*i+1] +cellGeom[4*i+3]) ;
-            const char* txt = Form("%.1f", sumVal[i]);
-            xOff = 0;
-            yOff = 0;
-            font.BBox(txt, llx, lly, llz, urx, ury, urz);
-            if (txt[0] == '-')
-               urx += (urx-llx)/strlen(txt);
-            xOff = -0.5 * urx;
-            yOff = -0.5 * (ury -lly);
-            glPushMatrix();
-            glTranslatef(x, y, 0.1);
-            glRasterPos2i(0, 0);
-            glBitmap(0, 0, 0, 0, xOff, yOff, 0);
-            font.Render(txt);
-            glPopMatrix();
+            for (Int_t j=1; j <= fPhiAxis->GetNbins(); ++j)
+            {
+               bin = (i)+(j)*(fEtaAxis->GetNbins()+2);
+               if (rebinDataSelected.fBinData[bin] !=-1)
+               {
+                  offset  = 0;
+                  vals    = rebinDataSelected.GetSliceVals(bin);
+                  valsRef = fRebinData.GetSliceVals(bin);
+                  for (Int_t s = 0; s < nSlices; ++s)
+                  {
+                     if (vals[s] > 0)
+                     {
+                        y0 = fPhiAxis->GetBinLowEdge(j);
+                        y1 = fPhiAxis->GetBinUpEdge(j);
+                        WrapTwoPi(y0, y1);
+                        MakeQuad(fEtaAxis->GetBinLowEdge(i), y0, offset,
+                                 fEtaAxis->GetBinWidth(i), y1-y0, vals[s]);
+                     }
+                     offset += valsRef[s];
+                  }
+               }
+            }
+         }
+      }
+   }
+   else
+   {
+      vCell2D_t cells2DSelected;
+      if (fM->fBinStep == 1)
+      {
+         // could be exact and call
+         // PrepareCell2DData( fM->fData->GetCellsSelected(), cells2DSelected);
+         // but is confusing since top view does no tdraw all slices at same time
+         TEveCaloData::vCellId_i j    = fM->fData->GetCellsSelected().begin();
+         TEveCaloData::vCellId_i jEnd = fM->fData->GetCellsSelected().end();
+         for ( vCell2D_i i = fCells2D.begin(); i != fCells2D.end(); ++i) {
+            TEveCaloData::CellId_t cell = fM->fCellList[i->fId];
+            if (cell.fTower == j->fTower)
+            {
+               cells2DSelected.push_back(*i);
+               while (cell.fTower == j->fTower && j != jEnd)
+                  j++;
+
+            }
 
          }
       }
+      else
+         PrepareCell2DDataRebin(rebinDataSelected, cells2DSelected);
+
+      DrawCells2D(rnrCtx, cells2DSelected);
+      fCells2D.clear(); // clear cache
    }
-} // end DrawCells2D
+
+
+   TGLUtil::UnlockColor();
+   rnrCtx.SetHighlightOutline(kFALSE);
+   glPopMatrix();
+   glPopAttrib();
+}
 
 //______________________________________________________________________________
 void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
@@ -1028,7 +1187,7 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
       fCells3D = (!(rnrCtx.RefCamera().IsOrthographic() && rnrCtx.RefCamera().GetCamBase().GetBaseVec(1).Z()));
    else if (fM->fProjection == TEveCaloLego::k2D)
       fCells3D = kFALSE;
-   else
+   else if (fM->fProjection == TEveCaloLego::k3D)
       fCells3D = kTRUE;
 
    // cache max val
@@ -1048,6 +1207,8 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    // rebin axsis , check limits, fix TwoPi cycling
    Int_t oldBinStep = fM->fBinStep;
    fM->fBinStep = GetGridStep(rnrCtx);
+   if (oldBinStep != fM->fBinStep) fDLCacheOK=kFALSE;
+
    RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
    RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
 
@@ -1059,55 +1220,93 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    }
 
    // rebin data
-   if (fDLCacheOK==kFALSE || oldBinStep != fM->fBinStep || idCacheChanged ) {
+   if (fDLCacheOK==kFALSE || idCacheChanged ) {
       fRebinData.fSliceData.clear();
       fRebinData.fSliceData.clear();
 
       if (fM->fBinStep > 1) {
          fM->fData->Rebin(fEtaAxis, fPhiAxis, fM->fCellList, fM->fPlotEt, fRebinData);
          if (fM->fNormalizeRebin) {
-            Double_t maxVal = 0;
+            //  Double_t maxVal = 0;
+            fMaxValRebin = 0;
             for (UInt_t i = 0; i < fRebinData.fSliceData.size(); i += fRebinData.fNSlices) {
                Double_t sum = 0;
                for (Int_t s = 0; s < fRebinData.fNSlices; s++)
                   sum += fRebinData.fSliceData[i+s];
 
-               if (sum > maxVal) maxVal = sum;
+               if (sum > fMaxValRebin) fMaxValRebin = sum;
             }
 
-            const Float_t scale = fM->GetMaxVal() / maxVal;
+            Float_t scale = fM->GetMaxVal() / fMaxValRebin;
             for (std::vector<Float_t>::iterator it = fRebinData.fSliceData.begin(); it != fRebinData.fSliceData.end(); it++)
                (*it) *= scale;
          }
       }
    }
 
-   if (!fM->fData->Empty()) {
-      glPushAttrib(GL_LINE_BIT | GL_POLYGON_BIT);
-      TGLUtil::LineWidth(1);
-      glDisable(GL_LIGHTING);
-      glEnable(GL_NORMALIZE);
-      glEnable(GL_POLYGON_OFFSET_FILL);
-      glPolygonOffset(0.8, 1);
+   fFontColor = fM->fFontColor;
+   fGridColor = fM->fGridColor;
+   if (fGridColor < 0 || fFontColor < 0)
+   {
+      TColor* c1 = gROOT->GetColor(rnrCtx.ColorSet().Markup().GetColorIndex());
+      TColor* c2 = gROOT->GetColor(rnrCtx.ColorSet().Background().GetColorIndex());
+      Float_t f1, f2;
+      if (fFontColor < 0) {
+         f1 = 0.8; f2 = 0.2;
+         fFontColor = TColor::GetColor(c1->GetRed()  *f1  + c2->GetRed()  *f2,
+                                       c1->GetGreen()*f1  + c2->GetGreen()*f2,
+                                       c1->GetBlue() *f1  + c2->GetBlue() *f2);
+      }
+      if (fGridColor < 0) {
+         f1 = 0.3; f2 = 0.3;
+         fGridColor = TColor::GetColor(c1->GetRed()  *f1  + c2->GetRed()  *f2,
+                                       c1->GetGreen()*f1  + c2->GetGreen()*f2,
+                                       c1->GetBlue() *f1  + c2->GetBlue() *f2);
+      }
+   }
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
+   TGLUtil::LineWidth(1);
+   glEnable(GL_BLEND);
 
+   if (!fM->fData->Empty()){
       glPushName(0);
       glLoadName(0);
       if (fCells3D) {
-         if (!fDLCacheOK) MakeDisplayList();
+         if (fDLCacheOK == kFALSE || idCacheChanged )
+         {
+            if (fM->fBinStep == 1)
+               Make3DDisplayList(fM->fCellList, fDLMap, kTRUE);
+            else
+               Make3DDisplayListRebin(fRebinData, fDLMap, kTRUE);
+            fDLCacheOK = kTRUE;
+         }
+         glEnable(GL_NORMALIZE);
+         glEnable(GL_POLYGON_OFFSET_FILL);
+         glPolygonOffset(0.8, 1);
+
          DrawCells3D(rnrCtx);
       } else {
-         DrawCells2D(rnrCtx);
+         glDisable(GL_LIGHTING);
+
+         fCells2D.clear();
+         if (fM->fBinStep == 1)
+            PrepareCell2DData(fM->fCellList, fCells2D);
+         else
+            PrepareCell2DDataRebin(fRebinData, fCells2D);
+
+         DrawCells2D(rnrCtx, fCells2D);
       }
       glPopName();
-      glPopAttrib();
    }
+   glPopAttrib();
 
    // draw histogram base
-   if (rnrCtx.Selection() == kFALSE && rnrCtx.Highlight() == kFALSE) {
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
+   if (rnrCtx.Selection() == kFALSE) {
+      glDisable(GL_LIGHTING);
       DrawHistBase(rnrCtx);
       if (fM->fDrawHPlane) {
-         glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
-         glEnable(GL_BLEND);
          glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
          glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
          glDisable(GL_CULL_FACE);
@@ -1119,57 +1318,68 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
          glVertex3f(fM->fEtaMax, fM->GetPhiMax(), zhp);
          glVertex3f(fM->fEtaMin, fM->GetPhiMax(), zhp);
          glEnd();
-         glPopAttrib();
       }
    }
+   glPopAttrib();
    glPopMatrix();
+
 }
 
 //______________________________________________________________________________
 void TEveCaloLegoGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
 {
-   // Processes secondary selection from TGLViewer.
+   // Processes tower selection from TGLViewer.
 
-   if (rec.GetN() < 2) return;
+   Int_t prev = fM->fData->GetCellsSelected().size();
+   if (!rec.GetMultiple()) fM->fData->GetCellsSelected().clear();
 
-   if (fM->fBinStep == 1) {
-      Int_t cellID = rec.GetItem(1);
-      TEveCaloData::CellData_t cellData;
-      fM->fData->GetCellData(fM->fCellList[cellID], cellData);
-      printf(">> Selected cell in eta %f phi %f \n", cellData.Eta(), cellData.Phi());
+   Int_t cellID = -1;
 
-      if (fCells3D) {
-         printf("Tower %d in slice %d val %f\n",
-                fM->fCellList[cellID].fTower,
-                fM->fCellList[cellID].fSlice, cellData.fValue);
-      } else {
-         printf("Tower %d in slice %d val %f\n",
-                fM->fCellList[cellID].fTower,
-                fM->fCellList[cellID].fSlice, cellData.fValue);
-      }
+   if (rec.GetN() > 1)
+   {
+      cellID = rec.GetItem(2);
+      Int_t slice  = rec.GetItem(1);
 
-   } else {
-      Int_t cellID = fCells3D ? rec.GetItem(2) : rec.GetItem(1);
-      if (cellID)
+      if (fM->fBinStep == 1)
       {
-         Int_t nEta   = fEtaAxis->GetNbins();
-         Int_t phiBin = Int_t(cellID/(nEta+2));
-         Int_t etaBin = cellID - phiBin*(nEta+2);
-         Float_t* v = fRebinData.GetSliceVals(cellID);
-
-         printf(">> Selected cell in eta %f phi %f \n", fEtaAxis->GetBinCenter(etaBin), fPhiAxis->GetBinCenter(phiBin));
-
-         if (fCells3D) {
-            Int_t s = rec.GetItem(1);
-            printf("Tower %d slice %d val %f \n", rec.GetItem(2), s, v[s]);
+         Int_t tower = fM->fCellList[cellID].fTower;
+         while (cellID > 0 && tower == fM->fCellList[cellID].fTower)
+         {
+            fM->fData->GetCellsSelected().push_back(fM->fCellList[cellID]);
+            if (fCells3D) break;
+            --cellID;
          }
-         else
+      }
+      else  {
+         if (cellID >0)
          {
-            printf("Tower %d vals: \n", cellID);
-            for (Int_t s = 0; s < fRebinData.fNSlices; s++) {
-               printf("slice %d val %f\n", s, v[s]);
+            Int_t nEta   = fEtaAxis->GetNbins();
+            Int_t phiBin = Int_t(cellID/(nEta+2));
+            Int_t etaBin = cellID - phiBin*(nEta+2);
+            TEveCaloData::vCellId_t sl;
+            fM->fData->GetCellList(fEtaAxis->GetBinCenter(etaBin), fEtaAxis->GetBinWidth(etaBin),
+                                   fPhiAxis->GetBinCenter(phiBin), fPhiAxis->GetBinWidth(phiBin),
+                                   sl);
+
+            for(TEveCaloData::vCellId_i it = sl.begin(); it != sl.end(); ++it)
+            {
+               if (fCells3D) {
+                  if ((*it).fSlice == slice )fM->fData->GetCellsSelected().push_back(*it);
+               } else {
+                  if ((*it).fSlice <= slice )fM->fData->GetCellsSelected().push_back(*it);
+               }
+
             }
          }
       }
    }
+
+   if (prev == 0 && cellID >= 0)
+      rec.SetSecSelResult(TGLSelectRecord::kEnteringSelection);
+   else if (prev  && cellID < 0)
+      rec.SetSecSelResult(TGLSelectRecord::kLeavingSelection);
+   else if (prev  && cellID >= 0)
+      rec.SetSecSelResult(TGLSelectRecord::kModifyingInternalSelection);
+
+   fM->fData->CellSelectionChanged();
 }
diff --git a/graf3d/eve/src/TEveCaloLegoOverlay.cxx b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
index 044acb8..b46349f 100644
--- a/graf3d/eve/src/TEveCaloLegoOverlay.cxx
+++ b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
@@ -12,6 +12,9 @@
 #include "TEveCaloLegoOverlay.h"
 
 #include "TAxis.h"
+#include "TColor.h"
+#include "TROOT.h"
+#include "THLimitsFinder.h"
 
 #include "TGLRnrCtx.h"
 #include "TGLIncludes.h"
@@ -19,9 +22,12 @@
 #include "TGLUtil.h"
 #include "TGLCamera.h"
 #include "TGLAxisPainter.h"
+#include "TGLFontManager.h"
 
 #include "TEveCalo.h"
 #include "TEveCaloData.h"
+#include "TEveRGBAPalette.h"
+
 #include <KeySymbols.h>
 
 
@@ -41,11 +47,11 @@ TEveCaloLegoOverlay::TEveCaloLegoOverlay() :
    fCalo(0),
 
    fShowScales(kTRUE),
-   fScaleColor(kWhite), fScaleTransparency(0),
-   fScaleCoordX(0.8), fScaleCoordY(0.2),
+   fScaleColor(-1), fScaleTransparency(0),
+   fScaleCoordX(0.85), fScaleCoordY(0.65),
    fCellX(-1), fCellY(-1),
 
-   fFrameColor(kGray), fFrameLineTransp(0), fFrameBgTransp(90),
+   fFrameColor(-1), fFrameLineTransp(70), fFrameBgTransp(90),
 
    fMouseX(0),  fMouseY(0),
    fInDrag(kFALSE),
@@ -100,37 +106,91 @@ Bool_t TEveCaloLegoOverlay::Handle(TGLRnrCtx          & rnrCtx,
 
    if (selRec.GetN() < 2) return kFALSE;
 
-   switch (event->fType)
+
+   if (rnrCtx.RefCamera().IsOrthographic())
    {
-      case kButtonPress:
-      {
-         fMouseX = event->fX;
-         fMouseY = event->fY;
-         fInDrag = kTRUE;
-         return kTRUE;
-      }
-      case kButtonRelease:
-      {
-         fInDrag = kFALSE;
-         return kTRUE;
-      }
-      case kMotionNotify:
-      {
-         if (fInDrag)
+      switch (event->fType)
+      {      case kButtonPress:
          {
-            const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
-            fScaleCoordX += (Float_t)(event->fX - fMouseX) / vp.Width();
-            fScaleCoordY -= (Float_t)(event->fY - fMouseY) / vp.Height();
             fMouseX = event->fX;
             fMouseY = event->fY;
+            fInDrag = kTRUE;
+            return kTRUE;
+         }
+         case kButtonRelease:
+         {
+            fInDrag = kFALSE;
+            return kTRUE;
          }
-         return kTRUE;
+         case kMotionNotify:
+         {
+            if (fInDrag)
+            {
+               const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+               fScaleCoordX += (Float_t)(event->fX - fMouseX) / vp.Width();
+               fScaleCoordY -= (Float_t)(event->fY - fMouseY) / vp.Height();
+               fMouseX = event->fX;
+               fMouseY = event->fY;
+               // Make sure we don't go offscreen (use fDraw variables set in draw)
+               if (fScaleCoordX < 0)
+                  fScaleCoordX = 0;
+               else if (fScaleCoordX + fScaleW > 1.0f)
+                  fScaleCoordX = 1.0f - fScaleW;
+               if (fScaleCoordY < 0)
+                  fScaleCoordY = 0;
+               else if (fScaleCoordY + fScaleH > 1.0f)
+                  fScaleCoordY = 1.0f - fScaleH;
+            }
+            return kTRUE;
+         }
+         default:
+            break;
       }
-      default:
+   }
+
+   else
+   {
+      switch (event->fType)
       {
-         return kFALSE;
+         case kMotionNotify:
+         {
+            Int_t item = selRec.GetN() < 2 ? -1 : (Int_t)selRec.GetItem(1);
+            if (fActiveID != item) {
+               fActiveID = item;
+               return kTRUE;
+            } else {
+               if (fActiveID == 2 && event->fState == 256)
+                  return SetSliderVal(event, rnrCtx);
+
+               return kFALSE;
+            }
+            break;
+         }
+         case kButtonPress:
+         {
+            if (event->fCode != kButton1) {
+               return kFALSE;
+            }
+            switch (selRec.GetItem(1))
+            {
+               case 1:
+                  fShowSlider = !fShowSlider;
+                  fCalo->SetDrawHPlane(fShowSlider);
+                  break;
+               case 2:
+                  return SetSliderVal(event, rnrCtx);
+               case 3:
+                  fHeaderSelected = !fHeaderSelected;
+               default:
+                  break;
+            }
+         }
+         default:
+            break;
       }
    }
+
+   return kFALSE;
 }
 
 //______________________________________________________________________________
@@ -141,7 +201,7 @@ Bool_t TEveCaloLegoOverlay::MouseEnter(TGLOvlSelectRecord& /*rec*/)
    return kTRUE;
 }
 
- //______________________________________________________________________________
+//______________________________________________________________________________
 void TEveCaloLegoOverlay::MouseLeave()
 {
    // Mouse has left overlay area.
@@ -161,7 +221,7 @@ void TEveCaloLegoOverlay::SetScaleColorTransparency(Color_t colIdx, UChar_t tran
 //______________________________________________________________________________
 void TEveCaloLegoOverlay::SetScalePosition(Double_t x, Double_t y)
 {
-   // Set scale coordinates in range [0,1]. 
+   // Set scale coordinates in range [0,1].
 
    fScaleCoordX = x;
    fScaleCoordY = y;
@@ -171,7 +231,7 @@ void TEveCaloLegoOverlay::SetScalePosition(Double_t x, Double_t y)
 void TEveCaloLegoOverlay:: SetFrameAttribs(Color_t frameColor, UChar_t lineTransp, UChar_t bgTransp)
 {
    // Set frame attribs.
-   
+
    fFrameColor = frameColor;
    fFrameLineTransp = lineTransp;
    fFrameBgTransp = bgTransp;
@@ -185,8 +245,8 @@ void TEveCaloLegoOverlay::RenderHeader(TGLRnrCtx& rnrCtx)
    TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
 
    TGLFont font;
-   Int_t fs = TGLFontManager::GetFontSize(vp.Height()*0.035, 12, 36);
-   rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
+   Int_t fs = TMath::Max(TMath::Nint(vp.Height()*0.035), 12);
+   rnrCtx.RegisterFontNoScale(fs, "arial", TGLFont::kPixmap, font);
    font.PreRender();
    Float_t off = fs*0.2;
    Float_t bb[6];
@@ -220,7 +280,6 @@ void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
 {
    // Render menu for plane-value and the plane if marked.
 
-   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LINE_BIT | GL_POINT_BIT);
    glEnable(GL_POINT_SMOOTH);
    glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
@@ -230,16 +289,15 @@ void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
    glDisable(GL_CULL_FACE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-   glPushName(0);
 
    // move to the center of menu
    Double_t maxVal = fCalo->GetMaxVal();
-   glScalef(fSliderH/(maxVal), fSliderH/maxVal, 1.);
 
    // button
    glPushMatrix();
-   glTranslatef(0, (1-fButtonW )*fMenuW*0.8, 0);
+   glTranslatef(1 -fMenuW, (1-fButtonW )*fMenuW*0.8, 0);
 
+   glPushName(0);
    glLoadName(1);
    Float_t a=0.6;
    (fActiveID == 1) ? TGLUtil::Color(fActiveCol):TGLUtil::Color4f(0, 1, 0, a);
@@ -253,10 +311,10 @@ void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
    glVertex2f(-bwt, bh);
    glEnd();
 
-   TGLUtil::Color(4);
 
    TGLUtil::LineWidth(1);
    glBegin(GL_LINES);
+   TGLUtil::Color(4);
    glVertex2f(0, 0); glVertex2f(0, bh);
    glVertex2f((bw+bwt)*0.5, bh*0.5); glVertex2f(-(bw+bwt)*0.5, bh*0.5);
    glEnd();
@@ -288,19 +346,16 @@ void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
       }
 
       // slider axis
-      glPushMatrix();
       fAxisPainter->SetLabelPixelFontSize(TMath::CeilNint(rnrCtx.GetCamera()->RefViewport().Height()*GetAttAxis()->GetLabelSize()));
       fAxisPainter->RefDir().Set(0, 1, 0);
       fAxisPainter->RefTMOff(0).Set(1, 0, 0);
-      fAxisPainter->SetLabelAlign(TGLFont::kLeft);
+      fAxisPainter->SetLabelAlign(TGLFont::kLeft, TGLFont::kCenterV);
       fPlaneAxis->SetRangeUser(0, maxVal);
       fPlaneAxis->SetLimits(0, maxVal);
       fPlaneAxis->SetNdivisions(710);
       fPlaneAxis->SetTickLength(0.02*maxVal);
       fPlaneAxis->SetLabelOffset(0.02*maxVal);
       fPlaneAxis->SetLabelSize(0.05);
-      fPlaneAxis->SetAxisColor(fAxisPlaneColor);
-      fPlaneAxis->SetLabelColor(fAxisPlaneColor);
 
       glPushMatrix();
       glScalef(fSliderH/(maxVal), fSliderH/maxVal, 1.);
@@ -316,29 +371,28 @@ void TEveCaloLegoOverlay::RenderPlaneInterface(TGLRnrCtx &rnrCtx)
    }
 
    glPopName();
-   glPopAttrib();
    glPopMatrix();
+   glPopAttrib();
 }
 
 /******************************************************************************/
-void TEveCaloLegoOverlay::RenderScales(TGLRnrCtx& rnrCtx)
+void TEveCaloLegoOverlay::RenderLogaritmicScales(TGLRnrCtx& rnrCtx)
 {
-   // Draw slider of calo 2D.
-
-   // scale position
+   // Draw slider of calo 2D in mode TEveCalo:fValSize.
 
    TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
 
    Double_t maxVal = fCalo->GetMaxVal();
-   Int_t maxe = TMath::CeilNint(TMath::Log10(maxVal+1)); // max round exponent
-   Double_t sqv = TMath::Power(10, maxe)+1; // starting max square value
-   Double_t fc = TMath::Log10(sqv)/TMath::Log10(fCalo->GetMaxVal()+1);
+   Int_t    maxe   = TMath::CeilNint(TMath::Log10(maxVal+1)); // max round exponent
+   Double_t sqv    = TMath::Power(10, maxe)+1; // starting max square value
+   Double_t fc     = TMath::Log10(sqv)/TMath::Log10(fCalo->GetMaxVal()+1);
    Double_t cellX = fCellX*fc;
    Double_t cellY = fCellY*fc;
 
    Double_t scaleStepY = 0.1; // step is 10% of screen
-   Double_t scaleStepX =  scaleStepY*vp.Height()/vp.Width(); // step is 10% of screen
-  
+   Double_t scaleStepX = scaleStepY*vp.Height()/vp.Width(); // step is 10% of screen
+
+   Double_t frameOff = 0.01;
 
    // define max starting exponent not to take more than scalStepY height
    while(cellY > scaleStepY)
@@ -351,7 +405,7 @@ void TEveCaloLegoOverlay::RenderScales(TGLRnrCtx& rnrCtx)
 
    sqv =  TMath::Power(10, maxe)+1;
    glPushMatrix();
-   glTranslatef(fScaleCoordX, fScaleCoordY, 0); // translate to lower left corner
+   glTranslatef(fScaleCoordX + 0.5*scaleStepX + frameOff, fScaleCoordY + 0.5*scaleStepY + frameOff, 0); // translate to lower left corner
 
    glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LINE_BIT | GL_POINT_BIT);
    glEnable(GL_BLEND);
@@ -360,24 +414,26 @@ void TEveCaloLegoOverlay::RenderScales(TGLRnrCtx& rnrCtx)
    glEnable(GL_POLYGON_OFFSET_FILL);
    glPolygonOffset(0.1, 1);
 
+   glPushName(0);
+   glLoadName(1);
+
    // draw cells
-   TGLUtil::ColorTransparency(fScaleColor, fScaleTransparency);
+   Color_t color = fScaleColor > -1 ? fScaleColor : rnrCtx.ColorSet().Markup().GetColorIndex();
+   TGLUtil::ColorTransparency(color, fScaleTransparency);
+
    Float_t pos, dx, dy;
    glBegin(GL_QUADS);
    Int_t ne = 3; // max number of columns
    for (Int_t i=0; i < ne; ++i)
-   { 
+   {
       Float_t valFac = TMath::Log10(TMath::Power(10, maxe-i)+1)/TMath::Log10(sqv);
       dx = 0.5* cellX * valFac;
       dy = 0.5* cellY * valFac;
       pos = i* scaleStepY;
-      dx = 0.5* cellX * TMath::Power(10, -i);
-      dy = 0.5* cellY * TMath::Power(10, -i);
       glVertex2f( - dx, pos - dy);
       glVertex2f( - dx, pos + dy);
       glVertex2f( + dx, pos + dy);
       glVertex2f( + dx, pos - dy);
-
    }
    glEnd();
 
@@ -387,14 +443,13 @@ void TEveCaloLegoOverlay::RenderScales(TGLRnrCtx& rnrCtx)
       glVertex2f(0, i* scaleStepY);
    glEnd();
 
-   // draw numbers 
-   TGLUtil::Color(fScaleColor);
+   // draw numbers
    TGLFont fontB;
-   Int_t fsb = TGLFontManager::GetFontSize(vp.Height()*0.03, 12, 36);
-   rnrCtx.RegisterFont(fsb, "arial", TGLFont::kPixmap, fontB);
+   Int_t fsb = TMath::Max(TMath::Nint(vp.Height()*0.03), 12);
+   rnrCtx.RegisterFontNoScale(fsb, "arial", TGLFont::kPixmap, fontB);
    TGLFont fontE;
-   Int_t fsE = TGLFontManager::GetFontSize(vp.Height()*0.008, 8, 36);
-   rnrCtx.RegisterFont(fsE, "arial", TGLFont::kPixmap, fontE);
+   Int_t fsE = TMath::Max(TMath::Nint(vp.Height()*0.01), 8);
+   rnrCtx.RegisterFontNoScale(fsE, "arial", TGLFont::kPixmap, fontE);
 
    Float_t llx, lly, llz, urx, ury, urz;
    fontB.BBox("10", llx, lly, llz, urx, ury, urz);
@@ -409,55 +464,135 @@ void TEveCaloLegoOverlay::RenderScales(TGLRnrCtx& rnrCtx)
    {
       if (i == maxe)
       {
-         fontB.RenderBitmap("1", 0, i*scaleStepY, 0, TGLFont::kLeft);
+         fontB.Render("1", 0, i*scaleStepY, 0, TGLFont::kLeft, TGLFont::kCenterV);
       }
       else if ( i == (maxe -1))
       {
-         fontB.RenderBitmap("10", 0, i*scaleStepY, 0, TGLFont::kLeft);
+         fontB.Render("10", 0, i*scaleStepY, 0, TGLFont::kLeft, TGLFont::kCenterV);
       }
       else
       {
-         fontB.RenderBitmap("10", 0, i*scaleStepY, 0, TGLFont::kLeft);
+         fontB.Render("10", 0, i*scaleStepY, 0, TGLFont::kLeft, TGLFont::kCenterV);
          fontB.BBox(Form("%d",  maxe-i), llx, lly, llz, urx, ury, urz);
          if (expOff >  urx/vp.Width()) expOff = urx/vp.Width();
-         fontE.RenderBitmap(Form("%d",  maxe-i), expX , i*scaleStepY+expY, 0, TGLFont::kLeft );
+         fontE.Render(Form("%d",  maxe-i), expX , i*scaleStepY+expY, 0, TGLFont::kLeft, TGLFont::kCenterV);
       }
    }
    glPopMatrix();
    fontB.PostRender();
    fontE.PostRender();
    if (expOff < 1)  expX += expOff;
+   glPopMatrix();
 
    // draw frame
    {
-      Double_t off = 0.1;
-      Double_t x0 = -(0.5+off) * scaleStepX;
-      Double_t x1 = (0.5+off) * scaleStepX + expX;
-      Double_t y0 = -(0.5+off) * scaleStepY; 
-      Double_t y1 = scaleStepY*(ne - 0.5 + off);
-      Double_t zf = -0.2;
-
-      TGLUtil::ColorTransparency(fFrameColor, fFrameLineTransp);
+      fScaleW = scaleStepX + expX+ frameOff*2;
+      fScaleH = scaleStepY * ne + frameOff*2;
+      Double_t x0 = fScaleCoordX;
+      Double_t x1 = x0 + fScaleW;
+      Double_t y0 = fScaleCoordY;
+      Double_t y1 = y0 + fScaleH;
+      Double_t zf = +0.2;
+
+      color = fFrameColor > -1 ?  fFrameColor : rnrCtx.ColorSet().Markup().GetColorIndex();
+      TGLUtil::ColorTransparency(color, fFrameLineTransp);
+
       glBegin(GL_LINE_LOOP);
       glVertex3f(x0, y0, zf); glVertex3f(x1, y0, zf);
       glVertex3f(x1, y1, zf); glVertex3f(x0, y1, zf);
       glEnd();
 
-      TGLUtil::ColorTransparency(fFrameColor, fFrameBgTransp);
-      glPushName(0);
-      glLoadName(1);
+      TGLUtil::ColorTransparency(color, fFrameBgTransp);
       glBegin(GL_QUADS);
       glVertex2f(x0, y0); glVertex2f(x1, y0);
       glVertex2f(x1, y1); glVertex2f(x0, y1);
       glEnd();
-      glPopName();
    }
-   
-   glPopMatrix();
+   glPopName();
+
    glPopAttrib();
 } // end draw scales
 
- /******************************************************************************/
+
+/******************************************************************************/
+void TEveCaloLegoOverlay::RenderPaletteScales(TGLRnrCtx& rnrCtx)
+{
+   // Draw slider of calo 2D in mode TEveCalo:fValColor.
+
+   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT | GL_LINE_BIT);
+   glEnable(GL_BLEND);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(0.1, 1);
+
+   TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+   Double_t maxVal = fCalo->GetMaxVal();
+   Int_t    bn;
+   Double_t bw; // bin with first second order
+   Double_t bl, bh; // bin low, high first
+   THLimitsFinder::Optimize(0, maxVal, 10, bl, bh, bn, bw);
+   bn = TMath::CeilNint(maxVal/bw) + 1;
+
+   fScaleH = 0.25; // relative height of the scale
+   fScaleW = fScaleH*1.5/(bn*vp.Aspect());
+   Float_t h = 0.5 * bw  ;
+   Float_t w = h * 1.5/ vp.Aspect();
+
+   glPushMatrix();
+   glTranslatef(fScaleCoordX + fScaleW*0.5, fScaleCoordY + fScaleH/bn*0.5, 0); // translate to lower left corner
+   glScalef(fScaleH/(bn*bw), fScaleH/(bn*bw), 1.);
+
+   glPushName(0);
+   glLoadName(1);   
+   TGLAxisPainter::LabVec_t &labVec = fAxisPainter->RefLabVec();
+   labVec.clear();
+   Float_t val = 0;
+   for (Int_t l= 0; l<bn; l++) {
+      labVec.push_back( TGLAxisPainter::Lab_t(val, val));
+      val += bw;
+   }
+
+   TGLUtil::Color(rnrCtx.ColorSet().Markup().GetColorIndex());
+   fAxisPainter->RefDir().Set(0, 1, 0);
+   Int_t fs = TMath::CeilNint(rnrCtx.GetCamera()->RefViewport().Height()*0.02);
+   fAxisPainter->SetLabelFont(rnrCtx, "arial", fs);
+   fAxisPainter->SetTextFormat(0, maxVal, bw);
+   fAxisPainter->SetLabelAlign(TGLFont::kCenterH, TGLFont::kCenterV);
+   TAttAxis att;
+   fAxisPainter->SetAttAxis(&att);
+   fAxisPainter->RnrLabels();
+
+   UChar_t c[4];
+   Float_t y;
+   Double_t zf = +0.2;
+   glBegin(GL_QUADS);
+   for (TGLAxisPainter::LabVec_t::iterator it = labVec.begin(); it != labVec.end(); ++it)
+   {
+      fCalo->GetPalette()->ColorFromValue((Int_t)((*it).first), c);
+      glColor4ub( c[0], c[1], c[2], c[3]);
+
+      y = (*it).second;
+      glVertex3f( -w, y - h, zf); glVertex3f( +w, y - h, zf);
+      glVertex3f( +w, y + h, zf); glVertex3f( -w, y + h, zf);
+   }
+   glEnd();
+
+   TGLUtil::Color(rnrCtx.ColorSet().Markup().GetColorIndex());
+   glBegin(GL_LINE_LOOP);
+   for (TGLAxisPainter::LabVec_t::iterator it = labVec.begin(); it != labVec.end(); ++it)
+   {
+      y = (*it).second;
+      glVertex3f( -w, y - h, zf); glVertex3f( +w, y - h, zf);
+      glVertex3f( +w, y + h, zf); glVertex3f( -w, y + h, zf);
+   }
+   glEnd();
+
+   glPopName();
+   glPopMatrix();
+   glPopAttrib();
+}
+
+/******************************************************************************/
 
 void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
 {
@@ -486,6 +621,8 @@ void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
    glTranslatef(-1, -1, 0);
    glScalef(2, 2, 1);
 
+
+   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    TGLCamera& cam = rnrCtx.RefCamera();
    Bool_t drawOverlayAxis = kFALSE;
 
@@ -534,8 +671,10 @@ void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
          fCellX = (res.X()*sq)/(fCalo->GetEtaRng()*1.*cam.RefViewport().Width());
          fCellY = (res.Y()*sq)/(fCalo->GetPhiRng()*1.*cam.RefViewport().Height());
          // printf("bin width %f cells size %f %f\n", sq, fCellX, fCellY);
-
-         RenderScales(rnrCtx);
+         if (fCalo->Get2DMode() == TEveCaloLego::kValSize)
+            RenderLogaritmicScales(rnrCtx);
+         else if (fCalo->GetPalette())
+            RenderPaletteScales(rnrCtx);
       }
 
       // draw camera overlay if projected lego bbox to large
diff --git a/graf3d/eve/src/TEveCompound.cxx b/graf3d/eve/src/TEveCompound.cxx
index 4b154d5..480a131 100644
--- a/graf3d/eve/src/TEveCompound.cxx
+++ b/graf3d/eve/src/TEveCompound.cxx
@@ -26,7 +26,6 @@ ClassImp(TEveCompound);
 //______________________________________________________________________________
 TEveCompound::TEveCompound(const char* n, const char* t, Bool_t doColor) :
    TEveElementList (n, t, doColor),
-   TEveProjectable (),
    fCompoundOpen   (0)
 {
    // Constructor.
@@ -115,7 +114,7 @@ void TEveCompound::FillImpliedSelectedSet(Set_t& impSelSet)
 //******************************************************************************
 
 //______________________________________________________________________________
-TClass* TEveCompound::ProjectedClass() const
+TClass* TEveCompound::ProjectedClass(const TEveProjection*) const
 {
    // Virtual from TEveProjectable, returns TEveCompoundProjected class.
 
diff --git a/graf3d/eve/src/TEveElement.cxx b/graf3d/eve/src/TEveElement.cxx
index 8024dc3..4d04f08 100644
--- a/graf3d/eve/src/TEveElement.cxx
+++ b/graf3d/eve/src/TEveElement.cxx
@@ -1537,6 +1537,26 @@ void TEveElement::ElementChanged(Bool_t update_scenes, Bool_t redraw)
 /******************************************************************************/
 
 //______________________________________________________________________________
+TEveElement* TEveElement::ForwardSelection()
+{
+   // Returns element to be selected on click.
+   // If value is zero the selected object will follow rules in
+   // TEveSelection.
+
+   return 0;
+}
+
+//______________________________________________________________________________
+TEveElement* TEveElement::ForwardEdit()
+{
+   // Returns element to be displayed in GUI editor on click.
+   // If value is zero the displayed object will follow rules in
+   // TEveSelection.
+
+   return 0;
+}
+
+//______________________________________________________________________________
 void TEveElement::SelectElement(Bool_t state)
 {
    // Set element's selection state. Stamp appropriately.
@@ -1782,6 +1802,7 @@ ClassImp(TEveElementList);
 TEveElementList::TEveElementList(const char* n, const char* t, Bool_t doColor) :
    TEveElement(),
    TNamed(n, t),
+   TEveProjectable(),
    fColor(0),
    fDoColor(doColor),
    fChildClass(0)
@@ -1797,6 +1818,7 @@ TEveElementList::TEveElementList(const char* n, const char* t, Bool_t doColor) :
 TEveElementList::TEveElementList(const TEveElementList& e) :
    TEveElement (e),
    TNamed      (e),
+   TEveProjectable(),
    fColor      (e.fColor),
    fDoColor    (e.fDoColor),
    fChildClass (e.fChildClass)
@@ -1814,3 +1836,45 @@ Bool_t TEveElementList::AcceptElement(TEveElement* el)
       return kFALSE;
    return kTRUE;
 }
+
+//______________________________________________________________________________
+TClass* TEveElementList::ProjectedClass(const TEveProjection*) const
+{
+   // Virtual from TEveProjectable, returns TEveCompoundProjected class.
+
+   return TEveElementListProjected::Class();
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+// TEveElementListProjected
+/******************************************************************************/
+
+//______________________________________________________________________________
+//
+// A projected element list -- required for proper propagation
+// of render state to projected views.
+
+ClassImp(TEveElementListProjected);
+
+//______________________________________________________________________________
+TEveElementListProjected::TEveElementListProjected() :
+   TEveElementList("TEveElementListProjected")
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+void TEveElementListProjected::SetDepthLocal(Float_t /*d*/)
+{
+   // This is abstract method from base-class TEveProjected.
+   // No implementation.
+}
+
+//______________________________________________________________________________
+void TEveElementListProjected::UpdateProjection()
+{
+   // This is abstract method from base-class TEveProjected.
+   // No implementation.
+}
diff --git a/graf3d/eve/src/TEveFrameBoxGL.cxx b/graf3d/eve/src/TEveFrameBoxGL.cxx
index f9181fd..69fd7b9 100644
--- a/graf3d/eve/src/TEveFrameBoxGL.cxx
+++ b/graf3d/eve/src/TEveFrameBoxGL.cxx
@@ -29,11 +29,21 @@ void TEveFrameBoxGL::RenderFrame(const TEveFrameBox& b, Bool_t fillp)
 {
    // Render the frame with GL.
 
-   const Float_t*  p =  b.fFramePoints;
+   const Float_t * p = b.fFramePoints;
+   Float_t normal[3];
 
    if (b.fFrameType == TEveFrameBox::kFT_Quad)
    {
-      glBegin(fillp ? GL_POLYGON : GL_LINE_LOOP);
+      if (fillp)
+      {
+         TMath::Normal2Plane(p, p+3, p+6, normal);
+         glNormal3fv(normal);
+         glBegin(GL_POLYGON);
+      }
+      else
+      {
+         glBegin(GL_LINE_LOOP);
+      }
       Int_t nPoints = b.fFrameSize / 3;
       for (Int_t i = 0; i < nPoints; ++i, p += 3)
          glVertex3fv(p);
@@ -41,20 +51,56 @@ void TEveFrameBoxGL::RenderFrame(const TEveFrameBox& b, Bool_t fillp)
    }
    else if (b.fFrameType == TEveFrameBox::kFT_Box)
    {
-      // !!! frame-fill not implemented for 3D frame.
-      glBegin(GL_LINE_STRIP);
-      glVertex3fv(p);       glVertex3fv(p + 3);
-      glVertex3fv(p + 6);   glVertex3fv(p + 9);
-      glVertex3fv(p);
-      glVertex3fv(p + 12);  glVertex3fv(p + 15);
-      glVertex3fv(p + 18);  glVertex3fv(p + 21);
-      glVertex3fv(p + 12);
-      glEnd();
-      glBegin(GL_LINES);
-      glVertex3fv(p + 3);   glVertex3fv(p + 15);
-      glVertex3fv(p + 6);   glVertex3fv(p + 18);
-      glVertex3fv(p + 9);   glVertex3fv(p + 21);
-      glEnd();
+      if (fillp)
+      {
+         glBegin(GL_QUADS);
+         TMath::Normal2Plane(p, p+3, p+6, normal);
+         glNormal3fv(normal);
+         glVertex3fv(p);      glVertex3fv(p + 3);
+         glVertex3fv(p + 6);  glVertex3fv(p + 9);
+         // top:    7654
+         TMath::Normal2Plane(p+21, p+18, p+15, normal);
+         glNormal3fv(normal);
+         glVertex3fv(p + 21); glVertex3fv(p + 18);
+         glVertex3fv(p + 15); glVertex3fv(p + 12);
+         // back:  0451
+         TMath::Normal2Plane(p, p+12, p+15, normal);
+         glNormal3fv(normal);
+         glVertex3fv(p);      glVertex3fv(p + 12);
+         glVertex3fv(p + 15); glVertex3fv(p + 3);
+         // front:   3267
+         TMath::Normal2Plane(p+9, p+6, p+18, normal);
+         glNormal3fv(normal);
+         glVertex3fv(p + 9);   glVertex3fv(p + 6);
+         glVertex3fv(p + 18);  glVertex3fv(p + 21);
+         // left:    0374
+         TMath::Normal2Plane(p, p+9, p+21, normal);
+         glNormal3fv(normal);
+         glVertex3fv(p);       glVertex3fv(p + 9);
+         glVertex3fv(p + 21);  glVertex3fv(p + 12);
+         // right:   1562
+         TMath::Normal2Plane(p+3, p+15, p+18, normal);
+         glNormal3fv(normal);
+         glVertex3fv(p + 3);   glVertex3fv(p + 15);
+         glVertex3fv(p + 18);  glVertex3fv(p + 6);
+         glEnd();
+      }
+      else
+      {
+         glBegin(GL_LINE_STRIP);
+         glVertex3fv(p);       glVertex3fv(p + 3);
+         glVertex3fv(p + 6);   glVertex3fv(p + 9);
+         glVertex3fv(p);
+         glVertex3fv(p + 12);  glVertex3fv(p + 15);
+         glVertex3fv(p + 18);  glVertex3fv(p + 21);
+         glVertex3fv(p + 12);
+         glEnd();
+         glBegin(GL_LINES);
+         glVertex3fv(p + 3);   glVertex3fv(p + 15);
+         glVertex3fv(p + 6);   glVertex3fv(p + 18);
+         glVertex3fv(p + 9);   glVertex3fv(p + 21);
+         glEnd();
+      }
    }
 }
 
@@ -71,7 +117,7 @@ void TEveFrameBoxGL::Render(const TEveFrameBox* box)
    glEnable(GL_COLOR_MATERIAL);
    glDisable(GL_CULL_FACE);
 
-   if (b.fFrameType == TEveFrameBox::kFT_Quad && b.fDrawBack)
+   if (b.fDrawBack)
    {
       GLboolean lmts;
       glGetBooleanv(GL_LIGHT_MODEL_TWO_SIDE, &lmts);
@@ -81,10 +127,11 @@ void TEveFrameBoxGL::Render(const TEveFrameBox* box)
       glPolygonOffset(2, 2);
       glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
 
-      const Float_t*  p =  b.fFramePoints;
-      Float_t normal[3];
-      TMath::Normal2Plane(p, p+3, p+6, normal);
-      glNormal3fv(normal);
+      if (b.fBackRGBA[3] < 255)
+      {
+         glEnable(GL_BLEND);
+         glDepthMask(GL_FALSE);
+      }
 
       TGLUtil::Color4ubv(b.fBackRGBA);
       RenderFrame(b, kTRUE);
diff --git a/graf3d/eve/src/TEveGeoNode.cxx b/graf3d/eve/src/TEveGeoNode.cxx
index 657916e..0a839b7 100644
--- a/graf3d/eve/src/TEveGeoNode.cxx
+++ b/graf3d/eve/src/TEveGeoNode.cxx
@@ -332,7 +332,6 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode*         geon,
 
    static const TEveException eh("TEveGeoNode::DumpShapeTree ");
 
-   printf("dump_shape_tree %s \n", geon->GetName());
    TGeoNode*   tnode   = 0;
    TGeoVolume* tvolume = 0;
    TGeoShape*  tshape  = 0;
diff --git a/graf3d/eve/src/TEveGeoShape.cxx b/graf3d/eve/src/TEveGeoShape.cxx
index db35148..ca25ce8 100644
--- a/graf3d/eve/src/TEveGeoShape.cxx
+++ b/graf3d/eve/src/TEveGeoShape.cxx
@@ -12,6 +12,8 @@
 #include "TEveTrans.h"
 #include "TEveManager.h"
 #include "TEvePolygonSetProjected.h"
+#include "TEveProjections.h"
+#include "TEveProjectionManager.h"
 
 #include "TEveGeoShapeExtract.h"
 #include "TEveGeoPolyShape.h"
@@ -287,12 +289,17 @@ TEveGeoShape* TEveGeoShape::SubImportShapeExtract(TEveGeoShapeExtract* gse,
 /******************************************************************************/
 
 //______________________________________________________________________________
-TClass* TEveGeoShape::ProjectedClass() const
+TClass* TEveGeoShape::ProjectedClass(const TEveProjection* p) const
 {
-   // Return class for projected objects, TEvePolygonSetProjected.
+   // Return class for projected objects:
+   //  - 2D projections: TEvePolygonSetProjected,
+   //  - 3D projections: TEveGeoShapeProjected.
    // Virtual from TEveProjectable.
 
-   return TEvePolygonSetProjected::Class();
+   if (p->Is2D())
+      return TEvePolygonSetProjected::Class();
+   else
+      return TEveGeoShapeProjected::Class();
 }
 
 /******************************************************************************/
@@ -325,3 +332,117 @@ TBuffer3D* TEveGeoShape::MakeBuffer3D()
    }
    return buff;
 }
+
+
+//==============================================================================
+//==============================================================================
+// TEveGeoShapeProjected
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// A 3D projected TEveGeoShape.
+
+ClassImp(TEveGeoShapeProjected);
+
+//______________________________________________________________________________
+TEveGeoShapeProjected::TEveGeoShapeProjected() :
+   TEveElementList("TEveGeoShapeProjected", "", kTRUE),
+   fBuff(0)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+void TEveGeoShapeProjected::SetDepthLocal(Float_t /*d*/)
+{
+   // This should never be called as this class is only used for 3D
+   // projections.
+   // The implementation is required as this metod is abstract.
+   // Just emits a warning if called.
+
+   Warning("SetDepthLocal", "This function only exists to fulfill an abstract interface.");
+}
+
+//______________________________________________________________________________
+void TEveGeoShapeProjected::SetProjection(TEveProjectionManager* mng,
+                                          TEveProjectable* model)
+{
+   // This is virtual method from base-class TEveProjected.
+
+   TEveProjected::SetProjection(mng, model);
+
+   TEveGeoShape* gre = dynamic_cast<TEveGeoShape*>(fProjectable);
+
+   SetMainColor(gre->GetMainColor());
+   SetMainTransparency(gre->GetMainTransparency());
+}
+
+//______________________________________________________________________________
+void TEveGeoShapeProjected::UpdateProjection()
+{
+   // This is virtual method from base-class TEveProjected.
+
+   TEveGeoShape   *gre = dynamic_cast<TEveGeoShape*>(fProjectable);
+   TEveProjection *prj = fManager->GetProjection();
+
+   delete fBuff;
+   fBuff = gre->MakeBuffer3D();
+
+   if (fBuff)
+   {
+      fBuff->SetSectionsValid(TBuffer3D::kCore | TBuffer3D::kRawSizes | TBuffer3D::kRaw);
+
+      Double_t *p = fBuff->fPnts;
+      for (UInt_t i = 0; i < fBuff->NbPnts(); ++i, p+=3)
+      {
+         prj->ProjectPointdv(p, 0);
+      }
+   }
+
+   ResetBBox();
+}
+
+//______________________________________________________________________________
+void TEveGeoShapeProjected::ComputeBBox()
+{
+   // Override of virtual method from TAttBBox.
+
+   if (fBuff && fBuff->NbPnts() > 0)
+   {
+      BBoxInit();
+
+      Double_t *p = fBuff->fPnts;
+      for (UInt_t i = 0; i < fBuff->NbPnts(); ++i, p+=3)
+      {
+         BBoxCheckPoint(p[0], p[1], p[2]);
+      }
+   }
+   else
+   {
+      BBoxZero();
+   }
+}
+
+//______________________________________________________________________________
+void TEveGeoShapeProjected::Paint(Option_t* /*option*/)
+{
+   // Paint object.
+
+   static const TEveException eh("TEveGeoShapeProjected::Paint ");
+
+   if (fBuff == 0)
+      return;
+
+   TBuffer3D &buff = *fBuff;
+
+   buff.fID           = this;
+   buff.fColor        = GetMainColor();
+   buff.fTransparency = GetMainTransparency();
+   buff.fLocalFrame   = kTRUE;
+
+   Int_t reqSec = gPad->GetViewer3D()->AddObject(buff);
+
+   if (reqSec != TBuffer3D::kNone)
+      Warning(eh, "Extra section required: reqSec=%d, shape=%s.", reqSec, GetName());
+}
diff --git a/graf3d/eve/src/TEveLegoEventHandler.cxx b/graf3d/eve/src/TEveLegoEventHandler.cxx
index 1762819..ca16b55 100644
--- a/graf3d/eve/src/TEveLegoEventHandler.cxx
+++ b/graf3d/eve/src/TEveLegoEventHandler.cxx
@@ -8,16 +8,21 @@
 
 
 #include "TEveLegoEventHandler.h"
+#include "TEveCaloLegoGL.h"
 
 #include "TGLViewer.h"
 #include "TGLWidget.h"
 #include "TGLOverlay.h"
 #include "TGLLogicalShape.h"
 #include "TGLPhysicalShape.h"
+#include "TGLCamera.h"
+#include "TGLPerspectiveCamera.h"
+#include "TGLOrthoCamera.h"
 #include "KeySymbols.h"
 
 #include "TMath.h"
 #include "TGLUtil.h"
+#include "TEveTrans.h"
 
 #include "TEveCalo.h"
 
@@ -37,15 +42,14 @@ ClassImp(TEveLegoEventHandler);
 //
 
 //______________________________________________________________________________
-TEveLegoEventHandler::TEveLegoEventHandler(const char *name, TGWindow *w, TObject *obj,
-                                 const char *title) :
-   TGLEventHandler(name, w, obj, title),
+TEveLegoEventHandler::TEveLegoEventHandler(TGWindow *w, TObject *obj, TEveCaloLego *lego):
+   TGLEventHandler(w, obj),
 
    fMode(kFree),
    fTransTheta(0.5f),
    fTheta(0.f),
 
-   fLastPickedLego(0)
+   fLego(lego)
 {
    // Constructor.
 }
@@ -63,49 +67,24 @@ Bool_t TEveLegoEventHandler::HandleKey(Event_t *event)
 }
 
 //______________________________________________________________________________
-Bool_t TEveLegoEventHandler::HandleDoubleClick(Event_t *event)
-{
-   // Virtual from TGLEventHandler.
-   // Sets id of the tower with scale.
-
-   if (fGLViewer->IsLocked()) return kFALSE;
-
-   if (event->fCode == kButton1)
-   {
-      fGLViewer->RequestSelect(event->fX, event->fY);
-      TGLPhysicalShape* pshape = fGLViewer->GetSelRec().GetPhysShape();
-      if (pshape && fGLViewer->GetSelRec().GetN() > 2)
-      {
-         TGLLogicalShape& lshape = const_cast<TGLLogicalShape&> (*pshape->GetLogical());
-         TGLLogicalShape* f = &lshape;
-         TEveCaloLego*  lego   = dynamic_cast<TEveCaloLego*>(f->GetExternal());
-
-         if (lego)
-         {
-            fLastPickedLego = lego;
-            lego->SetTowerPicked(fGLViewer->GetSelRec().GetItem(2));
-         }
-      }
-      else if (fLastPickedLego)
-      {
-         fLastPickedLego->SetTowerPicked(-1);
-      }
-      fGLViewer->RequestDraw();
-   }
-   return kTRUE;
-}
-
-//______________________________________________________________________________
 Bool_t TEveLegoEventHandler::Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2)
 {
    // Method to handle action TGLViewer::kDragCameraRotate. It switches from standard perspective
    // view to bird-view bellow angle fTransTheta and restores view when accumulated theta is larger
    // than transition angle.
 
-   using namespace TMath;
+   if ( !fLego ) return TGLEventHandler::Rotate(xDelta, yDelta, mod1, mod2);
 
    TGLCamera &cam =  fGLViewer->GetRnrCtx()->RefCamera();
-   Double_t hRotate = cam.AdjustDelta(-yDelta, Pi()/cam.RefViewport().Height(), mod1, mod2);
+   Double_t hRotate = cam.AdjustDelta(-yDelta, TMath::Pi()/cam.RefViewport().Height(), mod1, mod2);
+
+   // get lego bounding box
+   Float_t *bb = fLego->AssertBBox();
+   TGLBoundingBox box;
+   box.SetAligned(TGLVertex3(bb[0], bb[2], bb[4]), TGLVertex3(bb[1], bb[3], bb[5]));
+   box.Transform(fLego->RefMainTrans().Array());
+
+   Bool_t camChanged = kFALSE;
 
    if (cam.IsOrthographic())
    {
@@ -113,28 +92,73 @@ Bool_t TEveLegoEventHandler::Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Boo
       if (fTheta < 0) fTheta = 0;
       if (fTheta > fTransTheta)
       {
+         TGLCamera* ortho = &cam;
+         Double_t l = -ortho->FrustumPlane(TGLCamera::kLeft).D();
+         Double_t r =  ortho->FrustumPlane(TGLCamera::kRight).D();
+         Double_t t =  ortho->FrustumPlane(TGLCamera::kTop).D();
+         Double_t b = -ortho->FrustumPlane(TGLCamera::kBottom).D();
+
          fGLViewer->SetCurrentCamera(TGLViewer::kCameraPerspXOY);
+         TGLPerspectiveCamera* persp = dynamic_cast<TGLPerspectiveCamera*>(&fGLViewer->GetRnrCtx()->RefCamera());
+         persp->Setup(box, kTRUE);
+
+         TGLVector3 extents = box.Extents();
+         Int_t sortInd[3];
+         TMath::Sort(3, extents.CArr(), sortInd);
+         Double_t size = TMath::Hypot(extents[sortInd[0]], extents[sortInd[1]]);
+         Double_t dolly  = size / (2.0*TMath::Tan(30*TMath::Pi()/360));
+         Double_t fov = TMath::ATan(TMath::Hypot(t-b, r-l)/(2*dolly));
+
+         persp->SetCenterVecWarp(0.5*(l+r), 0.5*(t+b), 0);
+
+         Double_t vR =  -0.5 * TMath::Pi(); // switch XY
+         Double_t hR =  -0.5 * TMath::Pi() + fTransTheta; // fix top view angle
+         persp->Configure(fov*TMath::RadToDeg(), 0, 0, hR, vR);
+
          fMode = kFree;
+         camChanged = kTRUE;
       }
    }
    else
    {
       Double_t theta  = cam.GetTheta();
       Double_t thetaN = theta + hRotate;
-      if (thetaN > Pi() - cam.GetVAxisMinAngle()) thetaN = Pi() - cam.GetVAxisMinAngle();
+      if (thetaN > TMath::Pi() - cam.GetVAxisMinAngle()) thetaN = TMath::Pi() - cam.GetVAxisMinAngle();
       else if (thetaN < cam.GetVAxisMinAngle())   thetaN = cam.GetVAxisMinAngle();
 
       fTheta = thetaN;
 
       if (thetaN < fTransTheta)
       {
+         TGLPerspectiveCamera* persp =  (TGLPerspectiveCamera*)(&cam);
          fGLViewer->SetCurrentCamera(TGLViewer::kCameraOrthoXOY);
+         TGLOrthoCamera* ortho = dynamic_cast<TGLOrthoCamera*>(& fGLViewer->GetRnrCtx()->RefCamera());
+         ortho->Setup(box,  kTRUE);
+
+         // translation to the plane intersect
+         const TGLMatrix& mx =  cam.GetCamBase() * cam.GetCamTrans();
+         TGLVertex3 d   = mx.GetTranslation();
+         TGLVertex3 p = d + mx.GetBaseVec(1);
+         TGLLine3  line(d, p);
+         const TGLPlane rp = TGLPlane(cam.GetCamBase().GetBaseVec(3), TGLVertex3());
+         std::pair<Bool_t, TGLVertex3> intersection;
+         intersection = Intersection(rp, line, kTRUE);
+         TGLVertex3 v = intersection.second;
+         ortho->Truck( v.X() - box.Center().X(), v.Y() - box.Center().Y());
+
+         // zoom
+         Double_t t =  persp->FrustumPlane(TGLCamera::kTop).D();
+         Double_t b = -persp->FrustumPlane(TGLCamera::kBottom).D();
+         Double_t zoom = box.Extents().Y()/(t-b);
+         ortho->Configure(zoom, 0, 0, 0, 0);
+
          fMode = kLocked;
+         camChanged = kTRUE;
       }
       else
       {
-         fGLViewer->CurrentCamera().Rotate(xDelta, -yDelta, mod1, mod2);
+         camChanged = fGLViewer->CurrentCamera().Rotate(xDelta, -yDelta, mod1, mod2);
       }
    }
-   return kTRUE;
+   return camChanged;
 }
diff --git a/graf3d/eve/src/TEveLine.cxx b/graf3d/eve/src/TEveLine.cxx
index e2cbbbd..5afc224 100644
--- a/graf3d/eve/src/TEveLine.cxx
+++ b/graf3d/eve/src/TEveLine.cxx
@@ -224,7 +224,7 @@ void TEveLine::WriteVizParams(ostream& out, const TString& var)
 }
 
 //______________________________________________________________________________
-TClass* TEveLine::ProjectedClass() const
+TClass* TEveLine::ProjectedClass(const TEveProjection*) const
 {
    // Virtual from TEveProjectable, returns TEvePointSetProjected class.
 
@@ -263,16 +263,16 @@ void TEveLineProjected::SetProjection(TEveProjectionManager* mng,
 }
 
 //______________________________________________________________________________
-void TEveLineProjected::SetDepth(Float_t d)
+void TEveLineProjected::SetDepthLocal(Float_t d)
 {
    // Set depth (z-coordinate) of the projected points.
 
    SetDepthCommon(d, this, fBBox);
 
    Int_t    n = Size();
-   Float_t *p = GetP();
+   Float_t *p = GetP() + 2;
    for (Int_t i = 0; i < n; ++i, p+=3)
-      p[2] = fDepth;
+      *p = fDepth;
 }
 
 //______________________________________________________________________________
@@ -291,7 +291,6 @@ void TEveLineProjected::UpdateProjection()
    for (Int_t i = 0; i < n; ++i, o+=3, p+=3)
    {
       p[0] = o[0]; p[1] = o[1]; p[2] = o[2];
-      proj.ProjectPoint(p[0], p[1], p[2]);
-      p[2] = fDepth;
+      proj.ProjectPointfv(p, fDepth);
    }
 }
diff --git a/graf3d/eve/src/TEveManager.cxx b/graf3d/eve/src/TEveManager.cxx
index 9a5562d..beac964 100644
--- a/graf3d/eve/src/TEveManager.cxx
+++ b/graf3d/eve/src/TEveManager.cxx
@@ -878,11 +878,21 @@ TEveManager* TEveManager::Create(Bool_t map_window, Option_t* opt)
    // If global TEveManager* gEve is not set initialize it.
    // Returns gEve.
 
+   static const TEveException eh("TEveManager::Create ");
+
    if (gEve == 0)
    {
       // Make sure that the GUI system is initialized.
+      if (gROOT->IsBatch())
+      {
+         throw eh + "ROOT is running in batch mode.";
+      }
       TApplication::NeedGraphicsLibs();
       gApplication->InitializeGraphics();
+      if (gROOT->IsBatch() || gClient == 0 || gClient->IsZombie())
+      {
+         throw eh + "window system not initialized.";
+      }
 
       Int_t w = 1024;
       Int_t h =  768;
diff --git a/graf3d/eve/src/TEvePlot3D.cxx b/graf3d/eve/src/TEvePlot3D.cxx
index 421ae90..e6c6dd7 100644
--- a/graf3d/eve/src/TEvePlot3D.cxx
+++ b/graf3d/eve/src/TEvePlot3D.cxx
@@ -12,7 +12,7 @@
 #include "TEvePlot3D.h"
 #include "TEveTrans.h"
 
-#include "TPad.h"
+#include "TVirtualPad.h"
 #include "TVirtualViewer3D.h"
 #include "TBuffer3D.h"
 #include "TBuffer3DTypes.h"
diff --git a/graf3d/eve/src/TEvePointSet.cxx b/graf3d/eve/src/TEvePointSet.cxx
index 37cb5e1..d1cca9b 100644
--- a/graf3d/eve/src/TEvePointSet.cxx
+++ b/graf3d/eve/src/TEvePointSet.cxx
@@ -390,7 +390,7 @@ void TEvePointSet::WriteVizParams(ostream& out, const TString& var)
 //******************************************************************************
 
 //______________________________________________________________________________
-TClass* TEvePointSet::ProjectedClass() const
+TClass* TEvePointSet::ProjectedClass(const TEveProjection*) const
 {
    // Virtual from TEveProjectable, returns TEvePointSetProjected class.
 
@@ -538,7 +538,7 @@ void TEvePointSetArray::TakeAction(TEvePointSelector* sel)
    static const TEveException eh("TEvePointSetArray::TakeAction ");
 
    if (sel == 0)
-      throw(eh + "selector is <null>.");
+      throw eh + "selector is <null>.";
 
    Int_t n = sel->GetNfill();
 
@@ -547,24 +547,33 @@ void TEvePointSetArray::TakeAction(TEvePointSelector* sel)
    Double_t *vx = sel->GetV1(), *vy = sel->GetV2(), *vz = sel->GetV3();
    Double_t *qq = sel->GetV4();
 
-   if(qq == 0)
-      throw(eh + "requires 4-d varexp.");
+   if (qq == 0)
+      throw eh + "requires 4-d varexp.";
 
-   switch(fSourceCS) {
+   switch (fSourceCS)
+   {
       case kTVT_XYZ:
-         while(n-- > 0) {
+      {
+         while (n-- > 0)
+         {
             Fill(*vx, *vy, *vz, *qq);
             ++vx; ++vy; ++vz; ++qq;
          }
          break;
+      }
       case kTVT_RPhiZ:
-         while(n-- > 0) {
+      {
+         while (n-- > 0)
+         {
             Fill(*vx * TMath::Cos(*vy), *vx * TMath::Sin(*vy), *vz, *qq);
             ++vx; ++vy; ++vz; ++qq;
          }
          break;
+      }
       default:
-         throw(eh + "unknown tree variable type.");
+      {
+         throw eh + "unknown tree variable type.";
+      }
    }
 }
 
@@ -573,7 +582,7 @@ void TEvePointSetArray::TakeAction(TEvePointSelector* sel)
 //______________________________________________________________________________
 Int_t TEvePointSetArray::Size(Bool_t under, Bool_t over) const
 {
-   // Get the total of filled points.
+   // Get the total number of filled points.
    // 'under' and 'over' flags specify if under/overflow channels
    // should be added to the sum.
 
@@ -598,8 +607,8 @@ void TEvePointSetArray::InitBins(const char* quant_name,
 
    static const TEveException eh("TEvePointSetArray::InitBins ");
 
-   if (nbins < 1) throw(eh + "nbins < 1.");
-   if (min > max) throw(eh + "min > max.");
+   if (nbins < 1) throw eh + "nbins < 1.";
+   if (min > max) throw eh + "min > max.";
 
    RemoveElements();
 
@@ -615,7 +624,7 @@ void TEvePointSetArray::InitBins(const char* quant_name,
    for (Int_t i = 0; i < fNBins; ++i)
    {
       fBins[i] = new TEvePointSet
-         (Form("Slice %d [%4.3lf, %4.3lf]", i, fMin + i*fBinWidth, fMin + (i+1)*fBinWidth),
+         (Form("Slice %d [%4.3lf, %4.3lf]", i, fMin + (i-1)*fBinWidth, fMin + i*fBinWidth),
           fDefPointSetCapacity);
       fBins[i]->SetMarkerColor(fMarkerColor);
       fBins[i]->SetMarkerStyle(fMarkerStyle);
@@ -638,7 +647,7 @@ Bool_t TEvePointSetArray::Fill(Double_t x, Double_t y, Double_t z, Double_t quan
    // If the selected bin does not have an associated TEvePointSet
    // the point is discarded and false is returned.
 
-   fLastBin =TMath::FloorNint((quant - fMin)/fBinWidth) + 1;
+   fLastBin = TMath::FloorNint((quant - fMin)/fBinWidth) + 1;
 
    if (fLastBin < 0)
    {
@@ -676,8 +685,10 @@ void TEvePointSetArray::CloseBins()
    // At this point we can calculate bounding-boxes of individual
    // point-sets.
 
-   for (Int_t i=0; i<fNBins; ++i) {
-      if (fBins[i] != 0) {
+   for (Int_t i=0; i<fNBins; ++i)
+   {
+      if (fBins[i] != 0)
+      {
          fBins[i]->SetTitle(Form("N=%d", fBins[i]->Size()));
          fBins[i]->ComputeBBox();
       }
@@ -711,8 +722,9 @@ void TEvePointSetArray::SetRange(Double_t min, Double_t max)
    using namespace TMath;
 
    fCurMin = min; fCurMax = max;
-   Int_t  low_b = (Int_t) Max(Double_t(0),       Floor((min-fMin)/fBinWidth));
-   Int_t high_b = (Int_t) Min(Double_t(fNBins-1), Ceil((max-fMin)/fBinWidth));
+   Int_t  low_b = Max(0,        FloorNint((min-fMin)/fBinWidth)) + 1;
+   Int_t high_b = Min(fNBins-2, CeilNint ((max-fMin)/fBinWidth));
+
    for (Int_t i = 1; i < fNBins - 1; ++i)
    {
       if (fBins[i] != 0)
@@ -752,16 +764,16 @@ void TEvePointSetProjected::SetProjection(TEveProjectionManager* proj,
 }
 
 //______________________________________________________________________________
-void TEvePointSetProjected::SetDepth(Float_t d)
+void TEvePointSetProjected::SetDepthLocal(Float_t d)
 {
    // Set depth (z-coordinate) of the projected points.
 
    SetDepthCommon(d, this, fBBox);
 
    Int_t    n = Size();
-   Float_t *p = GetP();
+   Float_t *p = GetP() + 2;
    for (Int_t i = 0; i < n; ++i, p+=3)
-      p[2] = fDepth;
+      *p = fDepth;
 }
 
 //______________________________________________________________________________
@@ -780,7 +792,6 @@ void TEvePointSetProjected::UpdateProjection()
    for (Int_t i = 0; i < n; ++i, o+=3, p+=3)
    {
       p[0] = o[0]; p[1] = o[1]; p[2] = o[2];
-      proj.ProjectPoint(p[0], p[1], p[2]);
-      p[2] = fDepth;
+      proj.ProjectPoint(p[0], p[1], p[2], fDepth);
    }
 }
diff --git a/graf3d/eve/src/TEvePointSetArrayEditor.cxx b/graf3d/eve/src/TEvePointSetArrayEditor.cxx
index 9b5e17f..4dcc1c8 100644
--- a/graf3d/eve/src/TEvePointSetArrayEditor.cxx
+++ b/graf3d/eve/src/TEvePointSetArrayEditor.cxx
@@ -23,11 +23,10 @@
 #include "TGDoubleSlider.h"
 
 //______________________________________________________________________________
-// TEvePointSetArrayEditor
 //
 // Editor for TEvePointSetArray class.
 
-ClassImp(TEvePointSetArrayEditor)
+ClassImp(TEvePointSetArrayEditor);
 
 //______________________________________________________________________________
 TEvePointSetArrayEditor::TEvePointSetArrayEditor(const TGWindow *p,
@@ -44,7 +43,6 @@ TEvePointSetArrayEditor::TEvePointSetArrayEditor(const TGWindow *p,
 
    fRange = new TEveGDoubleValuator(this,"Range", 200, 0);
    fRange->SetNELength(6);
-   //fRange->SetLabelWidth(labelW);
    fRange->Build();
    fRange->GetSlider()->SetWidth(224);
    fRange->Connect("ValueSet()",
diff --git a/graf3d/eve/src/TEvePolygonSetProjected.cxx b/graf3d/eve/src/TEvePolygonSetProjected.cxx
index 442a0e5..b39d8e7 100644
--- a/graf3d/eve/src/TEvePolygonSetProjected.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjected.cxx
@@ -59,7 +59,9 @@ TEvePolygonSetProjected::TEvePolygonSetProjected(const char* n, const char* t) :
 
    fFillColor(5),
    fLineColor(3),
-   fLineWidth(1)
+   fLineWidth(1),
+
+   fHighlightFrame(kTRUE)
 {
    // Constructor.
 
@@ -97,7 +99,7 @@ void TEvePolygonSetProjected::SetProjection(TEveProjectionManager* mng,
 }
 
 //______________________________________________________________________________
-void TEvePolygonSetProjected::SetDepth(Float_t d)
+void TEvePolygonSetProjected::SetDepthLocal(Float_t d)
 {
    // Set depth (z-coordinate) of the projected points.
 
@@ -140,17 +142,17 @@ Int_t* TEvePolygonSetProjected::ProjectAndReducePoints()
 
    Int_t buffN = fBuff->NbPnts();
    TEveVector*  pnts  = new TEveVector[buffN];
-   for (Int_t i = 0; i<buffN; ++i)
+   for (Int_t i = 0; i < buffN; ++i)
    {
       pnts[i].Set(fBuff->fPnts[3*i],fBuff->fPnts[3*i+1], fBuff->fPnts[3*i+2]);
-      projection->ProjectPoint(pnts[i].fX, pnts[i].fY, pnts[i].fZ,
+      projection->ProjectPoint(pnts[i].fX, pnts[i].fY, pnts[i].fZ, 0,
                                TEveProjection::kPP_Plane);
    }
 
    if (fPnts) delete [] fPnts;
    fNPnts=0;
-   Int_t* idxMap   = new Int_t[buffN];
-   Int_t* ra = new Int_t[buffN];  // list of reduced vertices
+   Int_t *idxMap = new Int_t[buffN];
+   Int_t *ra     = new Int_t[buffN];  // list of reduced vertices
    for (UInt_t v = 0; v < (UInt_t)buffN; ++v)
    {
       idxMap[v] = -1;
@@ -176,9 +178,8 @@ Int_t* TEvePolygonSetProjected::ProjectAndReducePoints()
    for (Int_t idx = 0; idx < fNPnts; ++idx)
    {
       Int_t i = ra[idx];
-      projection->ProjectPoint(pnts[i].fX, pnts[i].fY, pnts[i].fZ,
+      projection->ProjectPoint(pnts[i].fX, pnts[i].fY, pnts[i].fZ, fDepth,
                                TEveProjection::kPP_Distort);
-      pnts[i].fZ = fDepth;
       fPnts[idx].Set(pnts[i]);
    }
    delete [] ra;
diff --git a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
index 99cc65a..4fc6fea 100644
--- a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
@@ -14,6 +14,8 @@
 #include "TEveVSDStructs.h"
 
 #include "TGLRnrCtx.h"
+#include "TGLCamera.h"
+#include "TGLPhysicalShape.h"
 #include "TGLIncludes.h"
 
 //==============================================================================
@@ -69,14 +71,34 @@ void TEvePolygonSetProjectedGL::Draw(TGLRnrCtx& rnrCtx) const
 }
 
 //______________________________________________________________________________
-void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
+void TEvePolygonSetProjectedGL::DrawOutline() const
 {
-   // Do GL rendering.
+   // Draw polygons outline.
 
    TEvePolygonSetProjected& refPS = * (TEvePolygonSetProjected*) fExternalObj;
    if (refPS.fPols.size() == 0) return;
 
-   fMultiColor = (refPS.fFillColor != refPS.fLineColor);
+   Int_t vi;
+   for (TEvePolygonSetProjected::vpPolygon_ci i = refPS.fPols.begin();
+        i != refPS.fPols.end(); ++i)
+   {
+      glBegin(GL_LINE_LOOP);
+      for(Int_t k = 0; k < (*i).fNPnts; ++k)
+      {
+         vi = (*i).fPnts[k];
+         glVertex3fv(refPS.fPnts[vi].Arr());
+      }
+      glEnd();
+   }
+}
+
+//______________________________________________________________________________
+void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
+{
+   // Do GL rendering.
+
+   TEvePolygonSetProjected& refPS = * (TEvePolygonSetProjected*) fExternalObj;
+   if (refPS.fPols.size() == 0) return;
 
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
 
@@ -86,6 +108,8 @@ void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glDisable(GL_CULL_FACE);
 
+   fMultiColor = (refPS.fFillColor != refPS.fLineColor);
+
    // polygons
    glEnable(GL_POLYGON_OFFSET_FILL);
    glPolygonOffset(1.,1.);
@@ -129,20 +153,62 @@ void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx & /*rnrCtx*/) const
    // outline
    TGLUtil::Color(refPS.fLineColor);
    glEnable(GL_LINE_SMOOTH);
-
    TGLUtil::LineWidth(refPS.fLineWidth);
-   Int_t vi;
-   for (TEvePolygonSetProjected::vpPolygon_ci i = refPS.fPols.begin();
-        i != refPS.fPols.end(); ++i)
+   DrawOutline();
+
+   glPopAttrib();
+}
+
+//______________________________________________________________________________
+void TEvePolygonSetProjectedGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const
+{
+   // Draw polygons in highlight mode.
+
+   TEvePolygonSetProjected& refPS = * (TEvePolygonSetProjected*) fExternalObj;
+
+   if (refPS.GetHighlightFrame())
    {
-      glBegin(GL_LINE_LOOP);
-      for(Int_t k = 0; k < (*i).fNPnts; ++k)
+      glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
+      glDisable(GL_LIGHTING);
+      glEnable(GL_LINE_SMOOTH);
+
+      glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
+
+      const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+      Int_t inner[4][2] = { { 0,-1}, { 1, 0}, { 0, 1}, {-1, 0} };
+      Int_t outer[8][2] = { {-1,-1}, { 1,-1}, { 1, 1}, {-1, 1},
+                            { 0,-2}, { 2, 0}, { 0, 2}, {-2, 0} };
+
+      rnrCtx.SetHighlightOutline(kTRUE);
+      TGLUtil::LockColor();
+      Int_t first_outer = (rnrCtx.CombiLOD() == TGLRnrCtx::kLODHigh) ? 0 : 4;
+      for (int i = first_outer; i < 8; ++i)
       {
-         vi = (*i).fPnts[k];
-         glVertex3fv(refPS.fPnts[vi].Arr());
+         glViewport(vp.X() + outer[i][0], vp.Y() + outer[i][1], vp.Width(), vp.Height());
+         DrawOutline();
       }
-      glEnd();
-   }
+      TGLUtil::UnlockColor();
+      rnrCtx.SetHighlightOutline(kFALSE);
 
-   glPopAttrib();
+      TGLUtil::Color(refPS.fLineColor);
+      for (int i = 0; i < 4; ++i)
+      {
+         glViewport(vp.X() + inner[i][0], vp.Y() + inner[i][1], vp.Width(), vp.Height());
+         DrawOutline();
+      }
+      glViewport(vp.X(), vp.Y(), vp.Width(), vp.Height());
+
+      pshp->SetupGLColors(rnrCtx);
+      Float_t dr[2];
+      glGetFloatv(GL_DEPTH_RANGE,dr);
+      glDepthRange(dr[0], 0.5*dr[1]);
+      DrawOutline();
+      glDepthRange(dr[0], dr[1]);
+
+      glPopAttrib();
+   }
+   else
+   {
+      TGLLogicalShape::DrawHighlight(rnrCtx, pshp);
+   }
 }
diff --git a/graf3d/eve/src/TEveProjectionAxes.cxx b/graf3d/eve/src/TEveProjectionAxes.cxx
index a9c0bd6..262ed9e 100644
--- a/graf3d/eve/src/TEveProjectionAxes.cxx
+++ b/graf3d/eve/src/TEveProjectionAxes.cxx
@@ -28,12 +28,12 @@
 ClassImp(TEveProjectionAxes);
 
 //______________________________________________________________________________
-TEveProjectionAxes::TEveProjectionAxes(TEveProjectionManager* m) :
-   TEveElement(fColor),
+TEveProjectionAxes::TEveProjectionAxes(TEveProjectionManager* m, Bool_t useCS) :
+   TEveElement(),
    TNamed("TEveProjectionAxes", ""),
    fManager(m),
 
-   fColor(kGray),
+   fUseColorSet(useCS),
 
    fLabMode(kValue),
    fAxesMode(kAll),
diff --git a/graf3d/eve/src/TEveProjectionAxesGL.cxx b/graf3d/eve/src/TEveProjectionAxesGL.cxx
index 203c480..eb05b32 100644
--- a/graf3d/eve/src/TEveProjectionAxesGL.cxx
+++ b/graf3d/eve/src/TEveProjectionAxesGL.cxx
@@ -327,6 +327,12 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
    Float_t t =  camera.FrustumPlane(TGLCamera::kTop).D();
    Float_t b = -camera.FrustumPlane(TGLCamera::kBottom).D();
 
+   if (fM->fUseColorSet)
+   {
+       TGLUtil::Color(rnrCtx.ColorSet().Markup());
+       fAxisPainter.SetUseAxisColors(kFALSE);
+   }
+
    fProjection = fM->GetManager()->GetProjection();
    glDisable(GL_LIGHTING);
    // Projection center and origin marker.
@@ -336,7 +342,7 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
       if (fM->GetDrawCenter())
       {
          Float_t* c = fProjection->GetProjectedCenter();
-         TGLUtil::Color3f(1., 0., 0.);
+         TGLUtil::LineWidth(1);
          glBegin(GL_LINES);
          glVertex3f(c[0] + d, c[1], c[2]); glVertex3f(c[0] - d, c[1], c[2]);
          glVertex3f(c[0], c[1] + d, c[2]); glVertex3f(c[0], c[1] - d, c[2]);
@@ -346,8 +352,8 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
       if (fM->GetDrawOrigin())
       {
          TEveVector zero;
-         fProjection->ProjectVector(zero);
-         TGLUtil::Color3f(1., 1., 1.);
+         fProjection->ProjectVector(zero, 0);
+         TGLUtil::LineWidth(1);
          glBegin(GL_LINES);
          glVertex3f(zero[0] + d, zero[1], zero[2]); glVertex3f(zero[0] - d, zero[1], zero[2]);
          glVertex3f(zero[0], zero[1] + d, zero[2]); glVertex3f(zero[0], zero[1] - d, zero[2]);
@@ -364,6 +370,7 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
       glGetIntegerv(GL_VIEWPORT, vp);
       Float_t refLength =  TMath::Sqrt((TMath::Power(vp[2]-vp[0], 2) + TMath::Power(vp[3]-vp[1], 2)));
       Float_t tickLength = TMath::Sqrt((TMath::Power(r-l, 2) + TMath::Power(t-b, 2)));
+      fAxisPainter.SetFontMode(TGLFont::kPixmap);
       fAxisPainter.SetLabelFont(rnrCtx, TGLFontManager::GetFontNameFromId(fM->GetLabelFont()),  TMath::CeilNint(refLength*0.02), tickLength*fM->GetLabelSize());
 
       Float_t min, max;
@@ -380,7 +387,7 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
          // Bottom.
          glPushMatrix();
          glTranslatef( 0, b, 0);
-         fAxisPainter.SetLabelAlign(TGLFont::kCenterDown);
+         fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kTop);
          fAxisPainter.RnrLabels();
          fAxisPainter.RnrLines();
          glPopMatrix();
@@ -388,13 +395,13 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
          // Top.
          glPushMatrix();
          glTranslatef( 0, t, 0);
-         fAxisPainter.SetLabelAlign(TGLFont::kCenterUp);
+         fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
          fAxisPainter.RefTMOff(0).Negate();
          fAxisPainter.RnrLabels();
          fAxisPainter.RnrLines();
          glPopMatrix();
       }
-     
+
       // Y-axis.
       if (fM->fAxesMode == TEveProjectionAxes::kAll ||
           fM->fAxesMode == TEveProjectionAxes::kVertical)
@@ -408,7 +415,7 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
          // Left.
          glPushMatrix();
          glTranslatef(l, 0, 0);
-         fAxisPainter.SetLabelAlign(TGLFont::kLeft);
+         fAxisPainter.SetLabelAlign(TGLFont::kLeft, TGLFont::kCenterV);
          fAxisPainter.RnrLabels();
          fAxisPainter.RnrLines();
          glPopMatrix();
@@ -416,7 +423,7 @@ void TEveProjectionAxesGL::DirectDraw(TGLRnrCtx& rnrCtx) const
          // Right.
          glPushMatrix();
          glTranslatef(r, 0, 0);
-         fAxisPainter.SetLabelAlign(TGLFont::kRight);
+         fAxisPainter.SetLabelAlign(TGLFont::kRight, TGLFont::kCenterV);
          fAxisPainter.RefTMOff(0).Negate();
          fAxisPainter.RnrLabels();
          fAxisPainter.RnrLines();
diff --git a/graf3d/eve/src/TEveProjectionBases.cxx b/graf3d/eve/src/TEveProjectionBases.cxx
index 34c4799..e99f69b 100644
--- a/graf3d/eve/src/TEveProjectionBases.cxx
+++ b/graf3d/eve/src/TEveProjectionBases.cxx
@@ -10,6 +10,7 @@
  *************************************************************************/
 
 #include "TEveProjectionBases.h"
+#include "TEveProjectionManager.h"
 #include "TEveManager.h"
 
 #include <cassert>
@@ -23,8 +24,9 @@
 //
 // Abstract base-class for non-linear projectable objects.
 //
-// Via ProjectedClass() method it returns a TClass instance for the
-// projected class and keeps references to the projected objects.
+// Via ProjectedClass(const TEveProjection* p) method it returns a
+// TClass instance for the projected class and keeps references to the
+// projected objects.
 //
 // It is assumed that all classes deriving from TEveProjectable are also
 // derived from TEveElement.
@@ -177,6 +179,23 @@ void TEveProjected::UnRefProjectable(TEveProjectable* assumed_parent)
 }
 
 //______________________________________________________________________________
+void TEveProjected::SetDepth(Float_t d)
+{
+   // Set depth coordinate for the element.
+   // Bounding-box should also be updated.
+   // If projection type is 3D, this only sets fDepth member.
+
+   if (fManager->GetProjection()->Is2D())
+   {
+      SetDepthLocal(d);
+   }
+   else
+   {
+      fDepth = d;
+   }
+}
+
+//______________________________________________________________________________
 void TEveProjected::SetDepthCommon(Float_t d, TEveElement* el, Float_t* bbox)
 {
    // Utility function to update the z-values of the bounding-box.
diff --git a/graf3d/eve/src/TEveProjectionManager.cxx b/graf3d/eve/src/TEveProjectionManager.cxx
index 3ecdf73..2e88e1a 100644
--- a/graf3d/eve/src/TEveProjectionManager.cxx
+++ b/graf3d/eve/src/TEveProjectionManager.cxx
@@ -40,7 +40,7 @@
 ClassImp(TEveProjectionManager);
 
 //______________________________________________________________________________
-TEveProjectionManager::TEveProjectionManager():
+TEveProjectionManager::TEveProjectionManager(TEveProjection::EPType_e type):
    TEveElementList("TEveProjectionManager",""),
    TAttBBox(),
    fProjection  (0),
@@ -51,7 +51,9 @@ TEveProjectionManager::TEveProjectionManager():
 
    for (Int_t i = 0; i < TEveProjection::kPT_End; ++i)
       fProjections[i] = 0;
-   SetProjection(TEveProjection::kPT_RPhi);
+
+   if (type != TEveProjection::kPT_Unknown)
+      SetProjection(type);
 }
 
 //______________________________________________________________________________
@@ -91,7 +93,10 @@ void TEveProjectionManager::UpdateName()
 {
    // Updates name to have consitent information with prjection.
 
-   SetName(Form ("%s (%3.1f)", fProjection->GetName(), fProjection->GetDistortion()*1000));
+   if (fProjection->Is2D())
+      SetName(Form ("%s (%3.1f)", fProjection->GetName(), fProjection->GetDistortion()*1000));
+   else
+      SetName(fProjection->GetName());
 }
 
 //______________________________________________________________________________
@@ -115,11 +120,22 @@ void TEveProjectionManager::SetProjection(TEveProjection::EPType_e type)
             fProjections[type] = new TEveRhoZProjection();
             break;
          }
+	 case TEveProjection::kPT_3D:
+         {
+            fProjections[type] = new TEve3DProjection();
+            break;
+         }
          default:
-            throw(eH + "projection type not valid.");
+            throw eH + "projection type not valid.";
             break;
       }
    }
+
+   if (fProjection && fProjection->Is2D() != fProjections[type]->Is2D())
+   {
+      throw eH + "switching between 2D and 3D projections not implemented.";
+   }
+
    fProjection = fProjections[type];
    fProjection->SetCenter(fCenter);
    UpdateName();
@@ -158,7 +174,7 @@ Bool_t TEveProjectionManager::ShouldImport(TEveElement* el)
    if (fImportEmpty)
       return kTRUE;
 
-   if (el->IsA()->InheritsFrom(TEveProjectable::Class()))
+   if (el->IsA() != TEveElementList::Class() && el->IsA()->InheritsFrom(TEveProjectable::Class()))
       return kTRUE;
    for (List_i i=el->BeginChildren(); i!=el->EndChildren(); ++i)
       if (ShouldImport(*i))
@@ -205,7 +221,7 @@ TEveElement* TEveProjectionManager::ImportElementsRecurse(TEveElement* el,
       TEveProjectable *pble   = dynamic_cast<TEveProjectable*>(el);
       if (pble)
       {
-         new_el = (TEveElement*) pble->ProjectedClass()->New();
+         new_el = (TEveElement*) pble->ProjectedClass(fProjection)->New();
          new_pr = dynamic_cast<TEveProjected*>(new_el);
          new_pr->SetProjection(this, pble);
          new_pr->SetDepth(fCurrentDepth);
diff --git a/graf3d/eve/src/TEveProjectionManagerEditor.cxx b/graf3d/eve/src/TEveProjectionManagerEditor.cxx
index c0bed57..6ce119c 100644
--- a/graf3d/eve/src/TEveProjectionManagerEditor.cxx
+++ b/graf3d/eve/src/TEveProjectionManagerEditor.cxx
@@ -56,6 +56,7 @@ TEveProjectionManagerEditor::TEveProjectionManagerEditor(const TGWindow *p,
       fType = new TGComboBox(f);
       fType->AddEntry("RPhi", TEveProjection::kPT_RPhi);
       fType->AddEntry("RhoZ", TEveProjection::kPT_RhoZ);
+      fType->AddEntry("3D",   TEveProjection::kPT_3D);
       TGListBox* lb = fType->GetListBox();
       lb->Resize(lb->GetWidth(), 2*18);
       fType->Resize(80, 20);
@@ -201,9 +202,17 @@ void TEveProjectionManagerEditor::DoType(Int_t type)
 {
    // Slot for setting of projection type.
 
-   fM->SetProjection((TEveProjection::EPType_e)type);
-   fM->ProjectChildren();
-   Update();
+   try
+   {
+      fM->SetProjection((TEveProjection::EPType_e)type);
+      fM->ProjectChildren();
+      Update();
+   }
+   catch (...)
+   {
+      SetModel(fM);
+      throw;
+   }
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveProjections.cxx b/graf3d/eve/src/TEveProjections.cxx
index 4243fa4..680a554 100644
--- a/graf3d/eve/src/TEveProjections.cxx
+++ b/graf3d/eve/src/TEveProjections.cxx
@@ -53,56 +53,80 @@ TEveProjection::TEveProjection() :
 }
 
 //______________________________________________________________________________
-void TEveProjection::ProjectVector(TEveVector& v)
+void TEveProjection::ProjectPointfv(Float_t* v, Float_t d)
+{
+   // Project float array.
+
+   ProjectPoint(v[0], v[1], v[2], d);
+}
+
+//______________________________________________________________________________
+void TEveProjection::ProjectPointdv(Double_t* v, Float_t d)
+{
+   // Project double array.
+   // This is a bit piggish as we convert the doubles to floats and back.
+
+   Float_t x = v[0], y = v[1], z = v[2];
+   ProjectPoint(x, y, z, d);
+   v[0] = x; v[1] = y; v[2] = z;
+}
+
+//______________________________________________________________________________
+void TEveProjection::ProjectVector(TEveVector& v, Float_t d)
 {
    // Project TEveVector.
 
-   ProjectPoint(v.fX, v.fY, v.fZ);
+   ProjectPoint(v.fX, v.fY, v.fZ, d);
 }
 
 //______________________________________________________________________________
-void TEveProjection::PreScalePoint(Float_t& v0, Float_t& v1)
+void TEveProjection::PreScaleVariable(Int_t dim, Float_t& v)
 {
-   // Pre-scale point (v0, v1) in projected coordinates:
-   //   RhoZ ~ (rho, z)
-   //   RPhi ~ (r, phi), scaling phi doesn't make much sense.
+   // Pre-scale single variable with pre-scale entry dim.
 
-   if (!fPreScales[0].empty())
+   if (!fPreScales[dim].empty())
    {
       Bool_t invp = kFALSE;
-      if (v0 < 0) {
-         v0    = -v0;
+      if (v < 0) {
+         v    = -v;
          invp = kTRUE;
       }
-      vPreScale_i i = fPreScales[0].begin();
-      while (v0 > i->fMax)
+      vPreScale_i i = fPreScales[dim].begin();
+      while (v > i->fMax)
          ++i;
-      v0 = i->fOffset + (v0 - i->fMin)*i->fScale;
+      v = i->fOffset + (v - i->fMin)*i->fScale;
       if (invp)
-         v0 = -v0;
-   }
-   if (!fPreScales[1].empty())
-   {
-      Bool_t invp = kFALSE;
-      if (v1 < 0) {
-         v1    = -v1;
-         invp = kTRUE;
-      }
-      vPreScale_i i = fPreScales[1].begin();
-      while (v1 > i->fMax)
-         ++i;
-      v1 = i->fOffset + (v1 - i->fMin)*i->fScale;
-      if (invp)
-         v1 = -v1;
+         v = -v;
    }
 }
 
 //______________________________________________________________________________
+void TEveProjection::PreScalePoint(Float_t& x, Float_t& y)
+{
+   // Pre-scale point (x, y) in projected coordinates for 2D projections:
+   //   RhoZ ~ (rho, z)
+   //   RPhi ~ (r, phi), scaling phi doesn't make much sense.
+
+   PreScaleVariable(0, x);
+   PreScaleVariable(1, y);
+}
+
+//______________________________________________________________________________
+void TEveProjection::PreScalePoint(Float_t& x, Float_t& y, Float_t& z)
+{
+   // Pre-scale point (x, y, z) in projected coordinates for 3D projection.
+
+   PreScaleVariable(0, x);
+   PreScaleVariable(1, y);
+   PreScaleVariable(2, z);
+}
+
+//______________________________________________________________________________
 void TEveProjection::AddPreScaleEntry(Int_t coord, Float_t value, Float_t scale)
 {
    // Add new scaling range for given coordinate.
    // Arguments:
-   //  coord    0 ~ x, 1 ~ y;
+   //  coord    0 ~ x, 1 ~ y, 2 ~ z
    //  value    value of input coordinate from which to apply this scale;
    //  scale    the scale to apply from value onwards.
    //
@@ -112,7 +136,7 @@ void TEveProjection::AddPreScaleEntry(Int_t coord, Float_t value, Float_t scale)
 
    static const TEveException eh("TEveProjection::AddPreScaleEntry ");
 
-   if (coord < 0 || coord > 1)
+   if (coord < 0 || coord > 2)
       throw (eh + "coordinate out of range.");
 
    const Float_t infty  = std::numeric_limits<Float_t>::infinity();
@@ -155,7 +179,7 @@ void TEveProjection::ChangePreScaleEntry(Int_t   coord, Int_t entry,
 
    static const TEveException eh("TEveProjection::ChangePreScaleEntry ");
 
-   if (coord < 0 || coord > 1)
+   if (coord < 0 || coord > 2)
       throw (eh + "coordinate out of range.");
 
    vPreScale_t& vec = fPreScales[coord];
@@ -180,6 +204,7 @@ void TEveProjection::ClearPreScales()
 
    fPreScales[0].clear();
    fPreScales[1].clear();
+   fPreScales[2].clear();
 }
 
 //______________________________________________________________________________
@@ -274,14 +299,14 @@ Float_t TEveProjection::GetValForScreenPos(Int_t i, Float_t sv)
    if (fDistortion > 0.0f && ((sv > 0 && sv > fUpLimit[i]) || (sv < 0 && sv < fLowLimit[i])))
       throw(eH + Form("screen value '%f' out of limit '%f'.", sv, sv > 0 ? fUpLimit[i] : fLowLimit[i]));
 
-   TEveVector zero; ProjectVector(zero);
+   TEveVector zero; ProjectVector(zero, 0);
    // search from -/+ infinity according to sign of screen value
    if (sv > zero[i])
    {
       xL = 0; xR = 1000;
       while (1)
       {
-         vec.Mult(dirVec, xR); ProjectVector(vec);
+         vec.Mult(dirVec, xR); ProjectVector(vec, 0);
          // printf("positive projected %f, value %f,xL, xR ( %f, %f)\n", vec[i], sv, xL, xR);
          if (vec[i] > sv || vec[i] == sv) break;
          xL = xR; xR *= 2;
@@ -292,7 +317,7 @@ Float_t TEveProjection::GetValForScreenPos(Int_t i, Float_t sv)
       xR = 0; xL = -1000;
       while (1)
       {
-         vec.Mult(dirVec, xL); ProjectVector(vec);
+         vec.Mult(dirVec, xL); ProjectVector(vec, 0);
          // printf("negative projected %f, value %f,xL, xR ( %f, %f)\n", vec[i], sv, xL, xR);
          if (vec[i] < sv || vec[i] == sv) break;
          xR = xL; xL *= 2;
@@ -307,7 +332,7 @@ Float_t TEveProjection::GetValForScreenPos(Int_t i, Float_t sv)
    {
       xM = 0.5f * (xL + xR);
       vec.Mult(dirVec, xM);
-      ProjectVector(vec);
+      ProjectVector(vec, 0);
       // printf("safr xL=%f, xR=%f; vec[i]=%f, sv=%f\n", xL, xR, vec[i], sv);
       if (vec[i] > sv)
          xR = xM;
@@ -325,7 +350,7 @@ Float_t TEveProjection::GetScreenVal(Int_t i, Float_t x)
 
    TEveVector dv;
    SetDirectionalVector(i, dv); dv = dv*x;
-   ProjectVector(dv);
+   ProjectVector(dv, 0);
    return dv[i];
 }
 
@@ -354,7 +379,7 @@ TEveRhoZProjection::TEveRhoZProjection() :
 
 //______________________________________________________________________________
 void TEveRhoZProjection::ProjectPoint(Float_t& x, Float_t& y, Float_t& z,
-                                      EPProc_e proc)
+                                      Float_t  d, EPProc_e proc)
 {
    // Project point.
 
@@ -394,7 +419,7 @@ void TEveRhoZProjection::ProjectPoint(Float_t& x, Float_t& y, Float_t& z,
       x += fProjectedCenter.fX;
       y += fProjectedCenter.fY;
    }
-   z = 0.0f;
+   z = d;
 }
 
 //______________________________________________________________________________
@@ -491,7 +516,7 @@ TEveRPhiProjection::TEveRPhiProjection() :
 
 //______________________________________________________________________________
 void TEveRPhiProjection::ProjectPoint(Float_t& x, Float_t& y, Float_t& z,
-                                      EPProc_e proc)
+                                      Float_t d, EPProc_e proc)
 {
    // Project point.
 
@@ -524,5 +549,49 @@ void TEveRPhiProjection::ProjectPoint(Float_t& x, Float_t& y, Float_t& z,
       x = r*Cos(phi) + fCenter.fX;
       y = r*Sin(phi) + fCenter.fY;
    }
-   z = 0.0f;
+   z = d;
+}
+
+
+//==============================================================================
+//==============================================================================
+// TEve3DProjection
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// 3D scaling projection. One has to use pre-scaling to make any ise of this.
+
+ClassImp(TEve3DProjection);
+
+//______________________________________________________________________________
+TEve3DProjection::TEve3DProjection() :
+   TEveProjection()
+{
+   // Constructor.
+
+   fType    = kPT_3D;
+   fGeoMode = kGM_Unknown;
+   fName    = "3D";
+}
+
+//______________________________________________________________________________
+void TEve3DProjection::ProjectPoint(Float_t& x, Float_t& y, Float_t& z,
+                                    Float_t /*d*/, EPProc_e proc)
+{
+   // Project point.
+
+   using namespace TMath;
+
+   if (proc != kPP_Plane)
+   {
+      if (fUsePreScale)
+      {
+         PreScalePoint(x, y, z);
+      }
+
+      x -= fCenter.fX;
+      y -= fCenter.fY;
+      z -= fCenter.fZ;
+   }
 }
diff --git a/graf3d/eve/src/TEveQuadSetGL.cxx b/graf3d/eve/src/TEveQuadSetGL.cxx
index f4a267d..6016527 100644
--- a/graf3d/eve/src/TEveQuadSetGL.cxx
+++ b/graf3d/eve/src/TEveQuadSetGL.cxx
@@ -105,13 +105,6 @@ void TEveQuadSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    TEveQuadSet& mQ = * fM;
 
-   if (mQ.fFrame != 0 && ! rnrCtx.SecSelection())
-   {
-      TGLUtil::LockColor(); // Keep color from TGLPhysicalShape.
-      TEveFrameBoxGL::Render(mQ.fFrame);
-      TGLUtil::UnlockColor();
-   }
-
    if (mQ.fPlex.Size() == 0)
       return;
    if ( ! mQ.fValueIsColor && mQ.fPalette == 0)
@@ -136,6 +129,11 @@ void TEveQuadSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    else if (mQ.fQuadType < TEveQuadSet::kQT_Hexagon_End) RenderHexagons(rnrCtx);
 
    glPopAttrib();
+
+   if (mQ.fFrame != 0 && ! rnrCtx.SecSelection())
+   {
+      TEveFrameBoxGL::Render(mQ.fFrame);
+   }
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveRGBAPalette.cxx b/graf3d/eve/src/TEveRGBAPalette.cxx
index 3ddf0ad..b635c85 100644
--- a/graf3d/eve/src/TEveRGBAPalette.cxx
+++ b/graf3d/eve/src/TEveRGBAPalette.cxx
@@ -20,53 +20,70 @@
 // A generic, speed-optimised mapping from value to RGBA color
 // supporting different wrapping and range truncation modes.
 //
+// Flag fFixColorRange: specifies how the palette is mapped to signal values:
+//  true  - LowLimit -> HighLimit
+//  false - MinValue -> MaxValue
+
 
 ClassImp(TEveRGBAPalette)
 
 //______________________________________________________________________________
 TEveRGBAPalette::TEveRGBAPalette() :
-   TObject(),
+   TObject(), TQObject(),
    TEveRefCnt(),
 
-   fLowLimit(0), fHighLimit(0), fMinVal(0), fMaxVal(0), fNBins(0),
+   fLowLimit(0), fHighLimit(0), fMinVal(0), fMaxVal(0),
 
-   fInterpolate     (kFALSE),
+   fInterpolate     (kTRUE),
    fShowDefValue    (kTRUE),
+   fFixColorRange   (kFALSE),
    fUnderflowAction (kLA_Cut),
    fOverflowAction  (kLA_Clip),
 
-   fDefaultColor(0),
-   fUnderColor  (1),
-   fOverColor   (2),
-   fColorArray  (0)
+   fDefaultColor(-1),
+   fUnderColor  (-1),
+   fOverColor   (-1),
+
+   fNBins(0), fCAMin(0), fCAMax(0), fColorArray(0)
 {
    // Constructor.
 
    SetLimits(0, 1024);
    SetMinMax(0,  512);
+
+   SetDefaultColor(0);
+   SetUnderColor(1);
+   SetOverColor(2);
 }
 
 //______________________________________________________________________________
-TEveRGBAPalette::TEveRGBAPalette(Int_t min, Int_t max, Bool_t interp, Bool_t showdef) :
-   TObject(),
+TEveRGBAPalette::TEveRGBAPalette(Int_t min, Int_t max, Bool_t interp,
+                                 Bool_t showdef, Bool_t fixcolrng) :
+   TObject(), TQObject(),
    TEveRefCnt(),
 
-   fLowLimit(0), fHighLimit(0), fMinVal(0), fMaxVal(0), fNBins(0),
+   fLowLimit(0), fHighLimit(0), fMinVal(0), fMaxVal(0),
 
    fInterpolate     (interp),
    fShowDefValue    (showdef),
+   fFixColorRange   (fixcolrng),
    fUnderflowAction (kLA_Cut),
    fOverflowAction  (kLA_Clip),
 
-   fDefaultColor(0),
-   fUnderColor  (1),
-   fOverColor   (2),
-   fColorArray  (0)
+   fDefaultColor(-1),
+   fUnderColor  (-1),
+   fOverColor   (-1),
+
+   fNBins(0), fCAMin(0), fCAMax(0), fColorArray(0)
 {
    // Constructor.
 
    SetLimits(min, max);
    SetMinMax(min, max);
+
+   SetDefaultColor(0);
+   SetUnderColor(1);
+   SetOverColor(2);
 }
 
 //______________________________________________________________________________
@@ -85,13 +102,13 @@ void TEveRGBAPalette::SetupColor(Int_t val, UChar_t* pixel) const
    // Set RGBA color 'pixel' for signal-value 'val'.
 
    using namespace TMath;
-   Float_t div  = Max(1, fMaxVal - fMinVal);
+   Float_t div  = Max(1, fCAMax - fCAMin);
    Int_t   nCol = gStyle->GetNumberOfColors();
 
    Float_t f;
-   if      (val >= fMaxVal) f = nCol - 1;
-   else if (val <= fMinVal) f = 0;
-   else                     f = (val - fMinVal)/div*(nCol - 1);
+   if      (val >= fCAMax) f = nCol - 1;
+   else if (val <= fCAMin) f = 0;
+   else                     f = (val - fCAMin)/div*(nCol - 1);
 
    if (fInterpolate) {
       Int_t  bin = (Int_t) f;
@@ -112,9 +129,16 @@ void TEveRGBAPalette::SetupColorArray() const
    if (fColorArray)
       delete [] fColorArray;
 
+   if (fFixColorRange) {
+      fCAMin = fLowLimit; fCAMax = fHighLimit;
+   } else {
+      fCAMin = fMinVal;   fCAMax = fMaxVal;
+   }
+   fNBins = fCAMax - fCAMin + 1;
+
    fColorArray = new UChar_t [4 * fNBins];
    UChar_t* p = fColorArray;
-   for(Int_t v=fMinVal; v<=fMaxVal; ++v, p+=4)
+   for(Int_t v = fCAMin; v <= fCAMax; ++v, p+=4)
       SetupColor(v, p);
 }
 
@@ -126,6 +150,7 @@ void TEveRGBAPalette::ClearColorArray()
    if (fColorArray) {
       delete [] fColorArray;
       fColorArray = 0;
+      fNBins = fCAMin = fCAMax = 0;
    }
 }
 
@@ -139,13 +164,13 @@ void TEveRGBAPalette::SetLimits(Int_t low, Int_t high)
 
    fLowLimit  = low;
    fHighLimit = high;
-   Bool_t changed = kFALSE;
-   if (fMaxVal < fLowLimit)  { SetMax(fLowLimit);  changed = kTRUE; }
-   if (fMinVal < fLowLimit)  { SetMin(fLowLimit);  changed = kTRUE; }
-   if (fMinVal > fHighLimit) { SetMin(fHighLimit); changed = kTRUE; }
-   if (fMaxVal > fHighLimit) { SetMax(fHighLimit); changed = kTRUE; }
-   if (changed)
-      ClearColorArray();
+
+   if (fMaxVal < fLowLimit)  SetMax(fLowLimit);
+   if (fMinVal < fLowLimit)  SetMin(fLowLimit);
+   if (fMinVal > fHighLimit) SetMin(fHighLimit);
+   if (fMaxVal > fHighLimit) SetMax(fHighLimit);
+
+   ClearColorArray();
 }
 
 //______________________________________________________________________________
@@ -161,7 +186,6 @@ void TEveRGBAPalette::SetLimitsScaleMinMax(Int_t low, Int_t high)
    fLowLimit  = low;
    fHighLimit = high;
 
-   fNBins  = fMaxVal - fMinVal + 1;
    ClearColorArray();
 }
 
@@ -171,7 +195,6 @@ void TEveRGBAPalette::SetMin(Int_t min)
    // Set current min value.
 
    fMinVal = TMath::Min(min, fMaxVal);
-   fNBins  = fMaxVal - fMinVal + 1;
    ClearColorArray();
 }
 
@@ -181,7 +204,6 @@ void TEveRGBAPalette::SetMax(Int_t max)
    // Set current max value.
 
    fMaxVal = TMath::Max(max, fMinVal);
-   fNBins  = fMaxVal - fMinVal + 1;
    ClearColorArray();
 }
 
@@ -192,7 +214,6 @@ void TEveRGBAPalette::SetMinMax(Int_t min, Int_t max)
 
    fMinVal = min;
    fMaxVal = max;
-   fNBins  = fMaxVal - fMinVal + 1;
    ClearColorArray();
 }
 
@@ -208,6 +229,17 @@ void TEveRGBAPalette::SetInterpolate(Bool_t b)
    ClearColorArray();
 }
 
+//______________________________________________________________________________
+void TEveRGBAPalette::SetFixColorRange(Bool_t v)
+{
+   // Set flag specifying how the palette is mapped to signal values:
+   //  true  - LowLimit -> HighLimit
+   //  false - MinValue -> MaxValue
+
+   fFixColorRange = v;
+   ClearColorArray();
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
@@ -220,7 +252,7 @@ void TEveRGBAPalette::SetDefaultColor(Color_t ci)
 }
 
 //______________________________________________________________________________
-void TEveRGBAPalette::SetDefaultColor(Pixel_t pix)
+void TEveRGBAPalette::SetDefaultColorPixel(Pixel_t pix)
 {
    // Set default color.
 
@@ -228,7 +260,7 @@ void TEveRGBAPalette::SetDefaultColor(Pixel_t pix)
 }
 
 //______________________________________________________________________________
-void TEveRGBAPalette::SetDefaultColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
+void TEveRGBAPalette::SetDefaultColorRGBA(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
 {
    // Set default color.
 
@@ -251,7 +283,7 @@ void TEveRGBAPalette::SetUnderColor(Color_t ci)
 }
 
 //______________________________________________________________________________
-void TEveRGBAPalette::SetUnderColor(Pixel_t pix)
+void TEveRGBAPalette::SetUnderColorPixel(Pixel_t pix)
 {
    // Set underflow color.
 
@@ -259,7 +291,7 @@ void TEveRGBAPalette::SetUnderColor(Pixel_t pix)
 }
 
 //______________________________________________________________________________
-void TEveRGBAPalette::SetUnderColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
+void TEveRGBAPalette::SetUnderColorRGBA(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
 {
    // Set underflow color.
 
@@ -282,7 +314,7 @@ void TEveRGBAPalette::SetOverColor(Color_t ci)
 }
 
 //______________________________________________________________________________
-void TEveRGBAPalette::SetOverColor(Pixel_t pix)
+void TEveRGBAPalette::SetOverColorPixel(Pixel_t pix)
 {
    // Set overflow color.
 
@@ -290,7 +322,7 @@ void TEveRGBAPalette::SetOverColor(Pixel_t pix)
 }
 
 //______________________________________________________________________________
-void TEveRGBAPalette::SetOverColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
+void TEveRGBAPalette::SetOverColorRGBA(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
 {
    // Set overflow color.
 
@@ -300,3 +332,14 @@ void TEveRGBAPalette::SetOverColor(UChar_t r, UChar_t g, UChar_t b, UChar_t a)
    fOverRGBA[2] = b;
    fOverRGBA[3] = a;
 }
+
+//______________________________________________________________________________
+void TEveRGBAPalette::MinMaxValChanged()
+{
+   // Emit the "MinMaxValChanged()" signal.
+   // This is NOT called automatically from SetMin/Max functions but
+   // it IS called from TEveRGBAPaletteEditor after it changes the
+   // min/max values.
+
+   Emit("MinMaxValChanged()");
+}
diff --git a/graf3d/eve/src/TEveRGBAPaletteEditor.cxx b/graf3d/eve/src/TEveRGBAPaletteEditor.cxx
index 6acacc9..e22033c 100644
--- a/graf3d/eve/src/TEveRGBAPaletteEditor.cxx
+++ b/graf3d/eve/src/TEveRGBAPaletteEditor.cxx
@@ -44,7 +44,8 @@ TEveRGBAPaletteSubEditor::TEveRGBAPaletteSubEditor(const TGWindow* p) :
 
    fInterpolate(0),
    fShowDefValue(0),
-   fDefaultColor(0)
+   fDefaultColor(0),
+   fFixColorRange(0)
 {
    // Constructor.
 
@@ -70,11 +71,22 @@ TEveRGBAPaletteSubEditor::TEveRGBAPaletteSubEditor(const TGWindow* p) :
                              "TEveRGBAPaletteSubEditor", this, "DoShowDefValue()");
 
       fDefaultColor = new TGColorSelect(f, 0, -1);
-      f->AddFrame(fDefaultColor, new TGLayoutHints(kLHintsLeft|kLHintsTop, 3, 1, 0, 2));
+      f->AddFrame(fDefaultColor, new TGLayoutHints(kLHintsLeft|kLHintsTop, 0, 0, 0, 0));
       fDefaultColor->Connect("ColorSelected(Pixel_t)",
                              "TEveRGBAPaletteSubEditor", this, "DoDefaultColor(Pixel_t)");
 
-      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 1, 0));
+      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 2, 0));
+   }
+
+   {
+      TGHorizontalFrame* f = new TGHorizontalFrame(this);
+
+      fFixColorRange = new TGCheckButton(f, "Fix color range");
+      f->AddFrame(fFixColorRange, new TGLayoutHints(kLHintsLeft, 3, 1, 0, 0));
+      fFixColorRange->Connect("Toggled(Bool_t)",
+                              "TEveRGBAPaletteSubEditor", this, "DoFixColorRange()");
+
+      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 0, 2));
    }
 
    { // Underflow
@@ -149,15 +161,16 @@ void TEveRGBAPaletteSubEditor::SetModel(TEveRGBAPalette* p)
    fMinMax->SetValues(fM->fMinVal, fM->fMaxVal);
    fMinMax->SetLimits(fM->fLowLimit, fM->fHighLimit);
 
-   fInterpolate->SetState(fM->fInterpolate ? kButtonDown : kButtonUp);
-   fShowDefValue->SetState(fM->fShowDefValue ? kButtonDown : kButtonUp);
-   fDefaultColor->SetColor(TColor::Number2Pixel(fM->GetDefaultColor()), kFALSE);
+   fInterpolate  ->SetState(fM->fInterpolate ? kButtonDown : kButtonUp);
+   fShowDefValue ->SetState(fM->fShowDefValue ? kButtonDown : kButtonUp);
+   fDefaultColor ->SetColor(TColor::Number2Pixel(fM->GetDefaultColor()), kFALSE);
+   fFixColorRange->SetState(fM->fFixColorRange ? kButtonDown : kButtonUp);
 
    fUnderColor->SetColor(TColor::Number2Pixel(fM->GetUnderColor()), kFALSE);
-   fOverColor->SetColor(TColor::Number2Pixel(fM->GetOverColor()), kFALSE);
+   fOverColor ->SetColor(TColor::Number2Pixel(fM->GetOverColor()), kFALSE);
 
    fUnderflowAction->Select(fM->fUnderflowAction, kFALSE);
-   fOverflowAction->Select(fM->fOverflowAction, kFALSE);
+   fOverflowAction ->Select(fM->fOverflowAction, kFALSE);
 }
 
 /******************************************************************************/
@@ -179,6 +192,7 @@ void TEveRGBAPaletteSubEditor::DoMinMax()
 
    fM->SetMinMax((Int_t) fMinMax->GetMin(), (Int_t) fMinMax->GetMax());
    Changed();
+   fM->MinMaxValChanged();
 }
 
 /******************************************************************************/
@@ -206,7 +220,16 @@ void TEveRGBAPaletteSubEditor::DoDefaultColor(Pixel_t color)
 {
    // Slot for DefaultColor.
 
-   fM->SetDefaultColor(color);
+   fM->SetDefaultColorPixel(color);
+   Changed();
+}
+
+//______________________________________________________________________________
+void TEveRGBAPaletteSubEditor::DoFixColorRange()
+{
+   // Slot for FixColorRange.
+
+   fM->SetFixColorRange(fFixColorRange->IsOn());
    Changed();
 }
 
@@ -215,7 +238,7 @@ void TEveRGBAPaletteSubEditor::DoUnderColor(Pixel_t color)
 {
    // Slot for UnderColor.
 
-   fM->SetUnderColor(color);
+   fM->SetUnderColorPixel(color);
    Changed();
 }
 
@@ -224,7 +247,7 @@ void TEveRGBAPaletteSubEditor::DoOverColor(Pixel_t color)
 {
    // Slot for OverColor.
 
-   fM->SetOverColor(color);
+   fM->SetOverColorPixel(color);
    Changed();
 }
 
diff --git a/graf3d/eve/src/TEveScene.cxx b/graf3d/eve/src/TEveScene.cxx
index ea6591d..5940e39 100644
--- a/graf3d/eve/src/TEveScene.cxx
+++ b/graf3d/eve/src/TEveScene.cxx
@@ -131,6 +131,7 @@ void TEveScene::RetransHierarchically()
    fGLScene->EndUpdate();
 }
 
+//______________________________________________________________________________
 void TEveScene::RetransHierarchicallyRecurse(TEveElement* el, const TEveTrans& tp)
 {
    // Set transformation matrix for physical shape of element el in
diff --git a/graf3d/eve/src/TEveSelection.cxx b/graf3d/eve/src/TEveSelection.cxx
index b5d0143..f2501cb 100644
--- a/graf3d/eve/src/TEveSelection.cxx
+++ b/graf3d/eve/src/TEveSelection.cxx
@@ -218,6 +218,14 @@ void TEveSelection::SelectionCleared()
    Emit("SelectionCleared()");
 }
 
+//______________________________________________________________________________
+void TEveSelection::SelectionRepeated(TEveElement* el)
+{
+   // Called when secondary selection changed internally.
+
+   Emit("SelectionRepeated(TEveElement*)", (Long_t)el);
+}
+
 /******************************************************************************/
 // Activation / deactivation of selection
 /******************************************************************************/
@@ -257,6 +265,11 @@ TEveElement* TEveSelection::MapPickedToSelected(TEveElement* el)
    if (el == 0)
       return 0;
 
+   if (el->ForwardSelection())
+   {
+      return el->ForwardSelection();
+   }
+
    switch (fPickToSelect)
    {
       case kPS_Ignore:
@@ -310,6 +323,8 @@ void TEveSelection::UserPickedElement(TEveElement* el, Bool_t multi)
    // associated with control-key being pressed at the time of pick
    // event).
 
+   TEveElement *edit_el = el ? el->ForwardEdit() : 0;
+
    el = MapPickedToSelected(el);
 
    if (el || HasChildren())
@@ -324,7 +339,33 @@ void TEveSelection::UserPickedElement(TEveElement* el, Bool_t multi)
             AddElement(el);
       }
       if (fIsMaster)
-         gEve->ElementSelect(el);
+         gEve->ElementSelect(edit_el ? edit_el : el);
+      gEve->Redraw3D();
+   }
+}
+
+//______________________________________________________________________________
+void TEveSelection::UserRePickedElement(TEveElement* el)
+{
+   // Called when secondary selection becomes empty.
+
+   el = MapPickedToSelected(el);
+   if (el && HasChild(el))
+   {
+      SelectionRepeated(el);
+      gEve->Redraw3D();
+   }
+}
+
+//______________________________________________________________________________
+void TEveSelection::UserUnPickedElement(TEveElement* el)
+{
+   // Called when secondary selection becomes empty.
+
+   el = MapPickedToSelected(el);
+   if (el)
+   {
+      RemoveElement(el);
       gEve->Redraw3D();
    }
 }
diff --git a/graf3d/eve/src/TEveStraightLineSet.cxx b/graf3d/eve/src/TEveStraightLineSet.cxx
index 5596b38..f853d4b 100644
--- a/graf3d/eve/src/TEveStraightLineSet.cxx
+++ b/graf3d/eve/src/TEveStraightLineSet.cxx
@@ -110,7 +110,7 @@ void TEveStraightLineSet::WriteVizParams(ostream& out, const TString& var)
 /******************************************************************************/
 
 //______________________________________________________________________________
-TClass* TEveStraightLineSet::ProjectedClass() const
+TClass* TEveStraightLineSet::ProjectedClass(const TEveProjection*) const
 {
    // Return class of projected object.
    // Virtual from TEveProjectable.
@@ -200,7 +200,7 @@ void TEveStraightLineSetProjected::SetProjection(TEveProjectionManager* mng,
 }
 
 //______________________________________________________________________________
-void TEveStraightLineSetProjected::SetDepth(Float_t d)
+void TEveStraightLineSetProjected::SetDepthLocal(Float_t d)
 {
    // Set depth (z-coordinate) of the projected points.
 
@@ -224,6 +224,8 @@ void TEveStraightLineSetProjected::UpdateProjection()
    TEveProjection&      proj = * fManager->GetProjection();
    TEveStraightLineSet& orig = * dynamic_cast<TEveStraightLineSet*>(fProjectable);
 
+   BBoxClear();
+
    // Lines
    fLinePlex.Reset(sizeof(Line_t), orig.GetLinePlex().Size());
    Float_t p1[3];
@@ -247,9 +249,9 @@ void TEveStraightLineSetProjected::UpdateProjection()
       mx.MultiplyIP(p2);
       p1[0] += x; p1[1] += y; p1[2] += z;
       p2[0] += x; p2[1] += y; p2[2] += z;
-      proj.ProjectPointFv(p1);
-      proj.ProjectPointFv(p2);
-      AddLine(p1[0], p1[1], fDepth, p2[0], p2[1], fDepth);
+      proj.ProjectPointfv(p1, fDepth);
+      proj.ProjectPointfv(p2, fDepth);
+      AddLine(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
    }
 
    // Markers
@@ -264,7 +266,7 @@ void TEveStraightLineSetProjected::UpdateProjection()
       TEveVector t1, d, xx;
 
       t1.Set(lo->fV1); xx.Set(lo->fV2); xx -= t1; xx *= m->fPos; xx += t1;
-      proj.ProjectVector(xx);
+      proj.ProjectVector(xx, 0);
       t1.Set(lp->fV1); d.Set(lp->fV2); d -= t1; xx -= t1;
 
       AddMarker(m->fLineID, d.Dot(xx) / d.Mag2());
diff --git a/graf3d/eve/src/TEveStraightLineSetGL.cxx b/graf3d/eve/src/TEveStraightLineSetGL.cxx
index 9c2bb68..3af1429 100644
--- a/graf3d/eve/src/TEveStraightLineSetGL.cxx
+++ b/graf3d/eve/src/TEveStraightLineSetGL.cxx
@@ -180,7 +180,7 @@ void TEveStraightLineSetGL::DirectDraw(TGLRnrCtx& rnrCtx) const
          TEveStraightLineSet::Line_t& l = * (TEveStraightLineSet::Line_t*) mL.GetLinePlex().Atom(lidx);
          pnt[0] = l.fV1[0] + (l.fV2[0] - l.fV1[0])*m.fPos;
          pnt[1] = l.fV1[1] + (l.fV2[1] - l.fV1[1])*m.fPos;
-         pnt[2] = l.fV1[2] + (l.fV2[2] - l.fV1[2])*m.fPos;;
+         pnt[2] = l.fV1[2] + (l.fV2[2] - l.fV1[2])*m.fPos;
          pnt   += 3;
       }
       if (rnrCtx.SecSelection()) glPushName(2);
diff --git a/graf3d/eve/src/TEveText.cxx b/graf3d/eve/src/TEveText.cxx
index 714cfbb..26fc47a 100644
--- a/graf3d/eve/src/TEveText.cxx
+++ b/graf3d/eve/src/TEveText.cxx
@@ -54,6 +54,9 @@ TEveText::TEveText(const char* txt) :
 {
    // Constructor.
 
+   fPolygonOffset[0] = 0;
+   fPolygonOffset[1] = 0;
+
    InitMainTrans();
    SetFontMode(TGLFont::kPixmap);
 }
@@ -105,6 +108,16 @@ void TEveText::SetFontMode( Int_t mode)
 }
 
 //______________________________________________________________________________
+void TEveText::SetPolygonOffset(Float_t factor, Float_t units)
+{
+   // Set the scale and units used to calculate depth values.
+   // See glPolygonOffset manual page.
+
+   fPolygonOffset[0] = factor;
+   fPolygonOffset[1] = units;
+}
+
+//______________________________________________________________________________
 void TEveText::Paint(Option_t* )
 {
    // Paint this object. Only direct rendering is supported.
diff --git a/graf3d/eve/src/TEveTextGL.cxx b/graf3d/eve/src/TEveTextGL.cxx
index 57e1104..426eb7e 100644
--- a/graf3d/eve/src/TEveTextGL.cxx
+++ b/graf3d/eve/src/TEveTextGL.cxx
@@ -56,25 +56,6 @@ void TEveTextGL::SetBBox()
    fBoundingBox.SetEmpty();
 }
 
-//______________________________________________________________________________
-void TEveTextGL::SetFont(TGLRnrCtx & rnrCtx) const
-{
-   // Set FTGL font according to TEveText font attributes.
-
-   if (fFont.GetMode() == TGLFont::kUndef)
-   {
-      rnrCtx.RegisterFont(fM->GetFontSize(), fM->GetFontFile(), fM->GetFontMode(), fFont);
-   }
-   else if (fFont.GetSize() != fM->GetFontSize() ||
-            fFont.GetFile() != fM->GetFontFile() ||
-            fFont.GetMode() != fM->GetFontMode())
-   {
-      rnrCtx.ReleaseFont(fFont);
-      rnrCtx.RegisterFont(fM->GetFontSize(), fM->GetFontFile(), fM->GetFontMode(), fFont);
-   }
-   fFont.SetDepth(fM->GetExtrude());
-}
-
 /******************************************************************************/
 
 //______________________________________________________________________________
@@ -85,7 +66,13 @@ void TEveTextGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    static const TEveException eH("TEveTextGL::DirectDraw ");
 
-   SetFont(rnrCtx);
+   Int_t fm = fM->GetFontMode();
+   if (fm == TGLFont::kBitmap || fm == TGLFont::kPixmap || fm == TGLFont::kTexture)
+      rnrCtx.RegisterFont(fM->GetFontSize(), fM->GetFontFile(), fM->GetFontMode(), fFont);
+   else
+      rnrCtx.RegisterFontNoScale(fM->GetFontSize(), fM->GetFontFile(), fM->GetFontMode(), fFont);
+
+   fFont.SetDepth(fM->GetExtrude());
 
    //  bbox initialisation
    if (fBoundingBox.IsEmpty() && fFont.GetMode() > TGLFont::kPixmap)
@@ -152,6 +139,7 @@ void TEveTextGL::DirectDraw(TGLRnrCtx & rnrCtx) const
       case TGLFont::kOutline:
       case TGLFont::kExtrude:
       case TGLFont::kPolygon:
+         glPolygonOffset(fM->GetPolygonOffset(0), fM->GetPolygonOffset(1));
          if (fM->GetExtrude() != 1.0) {
             glPushMatrix();
             glScalef(1.0f, 1.0f, fM->GetExtrude());
@@ -162,6 +150,7 @@ void TEveTextGL::DirectDraw(TGLRnrCtx & rnrCtx) const
          }
          break;
       case TGLFont::kTexture:
+         glPolygonOffset(fM->GetPolygonOffset(0), fM->GetPolygonOffset(1));
          fFont.Render(fM->GetText());
          break;
       default:
diff --git a/graf3d/eve/src/TEveTrack.cxx b/graf3d/eve/src/TEveTrack.cxx
index d32b846..49d3ccd 100644
--- a/graf3d/eve/src/TEveTrack.cxx
+++ b/graf3d/eve/src/TEveTrack.cxx
@@ -430,7 +430,7 @@ void TEveTrack::WriteVizParams(ostream& out, const TString& var)
 }
 
 //______________________________________________________________________________
-TClass* TEveTrack::ProjectedClass() const
+TClass* TEveTrack::ProjectedClass(const TEveProjection*) const
 {
    // Virtual from TEveProjectable, return TEveTrackProjected class.
 
@@ -1166,7 +1166,7 @@ void TEveTrackList::WriteVizParams(ostream& out, const TString& var)
 }
 
 //______________________________________________________________________________
-TClass* TEveTrackList::ProjectedClass() const
+TClass* TEveTrackList::ProjectedClass(const TEveProjection*) const
 {
    // Virtual from TEveProjectable, returns TEveTrackListProjected class.
 
diff --git a/graf3d/eve/src/TEveTrackGL.cxx b/graf3d/eve/src/TEveTrackGL.cxx
index cd2fe6a..fa1fe3e 100644
--- a/graf3d/eve/src/TEveTrackGL.cxx
+++ b/graf3d/eve/src/TEveTrackGL.cxx
@@ -54,16 +54,19 @@ Bool_t TEveTrackGL::SetModel(TObject* obj, const Option_t* /*opt*/)
 void TEveTrackGL::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
 {
    // Processes secondary selection from TGLViewer.
-   // Calls TPointSet3D::PointSelected(Int_t) with index of selected
-   // point as an argument.
+   // Just calls SecSelected(track) in model object which emits a signal.
+   // This is used in user code for alternate selection of good / bad tracks.
 
-   printf("TEveTrackGL::ProcessSelection %d names on the stack (z1=%g, z2=%g).\n",
-          rec.GetN(), rec.GetMinZ(), rec.GetMaxZ());
-   printf("  Names: ");
-   for (Int_t j=0; j<rec.GetN(); ++j) printf ("%d ", rec.GetItem(j));
-   printf("\n");
+   if (gDebug > 0)
+   {
+      printf("TEveTrackGL::ProcessSelection %d names on the stack (z1=%g, z2=%g).\n",
+             rec.GetN(), rec.GetMinZ(), rec.GetMaxZ());
+      printf("  Names: ");
+      for (Int_t j=0; j<rec.GetN(); ++j) printf ("%d ", rec.GetItem(j));
+      printf("\n");
+   }
 
-   ((TEveTrack*)fM)->SecSelected((TEveTrack*)fM);
+   fTrack->SecSelected(fTrack);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveTrackProjected.cxx b/graf3d/eve/src/TEveTrackProjected.cxx
index b67f360..2980f4e 100644
--- a/graf3d/eve/src/TEveTrackProjected.cxx
+++ b/graf3d/eve/src/TEveTrackProjected.cxx
@@ -46,21 +46,23 @@ void TEveTrackProjected::SetProjection(TEveProjectionManager* mng, TEveProjectab
 
    SetTrackParams(*origTrack);
    SetPathMarks  (*origTrack);
+
+   SetLockPoints(origTrack->GetLockPoints());
 }
 
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveTrackProjected::SetDepth(Float_t d)
+void TEveTrackProjected::SetDepthLocal(Float_t d)
 {
    // Set depth (z-coordinate) of the projected points.
 
    SetDepthCommon(d, this, fBBox);
 
    Int_t    n = Size();
-   Float_t *p = GetP();
+   Float_t *p = GetP() + 2;
    for (Int_t i = 0; i < n; ++i, p+=3)
-      p[2] = fDepth;
+      *p = fDepth;
 
    // !!!! Missing path-marks move. But they are not projected anyway
 }
@@ -86,8 +88,8 @@ void TEveTrackProjected::GetBreakPoint(Int_t idx, Bool_t back,
    while ((vL-vR).Mag() > 0.01)
    {
       vM.Mult(vL+vR, 0.5f);
-      vLP.Set(vL); fProjection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ);
-      vMP.Set(vM); fProjection->ProjectPoint(vMP.fX, vMP.fY, vMP.fZ);
+      vLP.Set(vL); fProjection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
+      vMP.Set(vM); fProjection->ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
       if (fProjection->AcceptSegment(vLP, vMP, 0.0f))
       {
          vL.Set(vM);
@@ -103,11 +105,11 @@ void TEveTrackProjected::GetBreakPoint(Int_t idx, Bool_t back,
    } else {
       x = vR.fX; y = vR.fY; z = vR.fZ;
    }
-   fProjection->ProjectPoint(x, y, z);
+   fProjection->ProjectPoint(x, y, z, fDepth);
 }
 
 //______________________________________________________________________________
-Int_t  TEveTrackProjected::GetBreakPointIdx(Int_t start)
+Int_t TEveTrackProjected::GetBreakPointIdx(Int_t start)
 {
    // Findex index of the last point that lies within the same
    // segment of projected space.
@@ -145,7 +147,15 @@ void TEveTrackProjected::MakeTrack(Bool_t recurse)
    // required for full representation.
 
    fBreakPoints.clear();
-   TEveTrack::MakeTrack(recurse);
+
+   if (GetLockPoints())
+   {
+      ClonePoints(*dynamic_cast<TEveTrack*>(fProjectable));
+   }
+   else
+   {
+      TEveTrack::MakeTrack(recurse);
+   }
    if (Size() == 0) return; // All points can be outside of MaxR / MaxZ limits.
 
    // Break segments additionally if required by the projection.
@@ -157,8 +167,7 @@ void TEveTrackProjected::MakeTrack(Bool_t recurse)
    for (Int_t i = 0; i < Size(); ++i, p+=3)
    {
       fOrigPnts[i].Set(p);
-      fProjection->ProjectPoint(p[0], p[1], p[2]);
-      p[2] = fDepth;
+      fProjection->ProjectPoint(p[0], p[1], p[2], fDepth);
    }
 
    Float_t x, y, z;
@@ -279,6 +288,16 @@ void TEveTrackListProjected::SetProjection(TEveProjectionManager* proj, TEveProj
 }
 
 //______________________________________________________________________________
+void TEveTrackListProjected::SetDepthLocal(Float_t /*d*/)
+{
+   // This is not needed for functionality as SetDepth(Float_t d)
+   // is overriden -- but SetDepthLocal() is abstract.
+   // Just emits a warning if called.
+
+   Warning("SetDepthLocal", "This function only exists to fulfill an abstract interface.");
+}
+
+//______________________________________________________________________________
 void TEveTrackListProjected::SetDepth(Float_t d)
 {
    // Set depth of all children inheriting from TEveTrackProjected.
@@ -292,7 +311,7 @@ void TEveTrackListProjected::SetDepth(Float_t d, TEveElement* el)
    // Set depth of all children of el inheriting from TEveTrackProjected.
 
    TEveTrackProjected* ptrack;
-   for (List_i i=el->BeginChildren(); i!=el->EndChildren(); ++i)
+   for (List_i i = el->BeginChildren(); i != el->EndChildren(); ++i)
    {
       ptrack = dynamic_cast<TEveTrackProjected*>(*i);
       if (ptrack)
diff --git a/graf3d/eve/src/TEveTrackProjectedGL.cxx b/graf3d/eve/src/TEveTrackProjectedGL.cxx
index de0cb05..be49379 100644
--- a/graf3d/eve/src/TEveTrackProjectedGL.cxx
+++ b/graf3d/eve/src/TEveTrackProjectedGL.cxx
@@ -122,8 +122,8 @@ void TEveTrackProjectedGL::DirectDraw(TGLRnrCtx& rnrCtx) const
                pnt[0] = pm->fV.fX;
                pnt[1] = pm->fV.fY;
                pnt[2] = pm->fV.fZ;
-               fM->fProjection->ProjectPointFv(pnt);
-               pnt   += 3;
+               fM->fProjection->ProjectPointfv(pnt, fM->fDepth);
+               pnt += 3;
                ++pntsN;
             }
          }
diff --git a/graf3d/eve/src/TEveViewer.cxx b/graf3d/eve/src/TEveViewer.cxx
index dc952a2..5c7406a 100644
--- a/graf3d/eve/src/TEveViewer.cxx
+++ b/graf3d/eve/src/TEveViewer.cxx
@@ -101,6 +101,8 @@ TEveViewer::~TEveViewer()
 {
    // Destructor.
 
+   fGLViewer->SetEventHandler(0);
+
    fGLViewerFrame->UnmapWindow();
    GetGUICompositeFrame()->RemoveFrame(fGLViewerFrame);
    fGLViewerFrame->ReparentWindow(gClient->GetDefaultRoot());
@@ -134,8 +136,14 @@ void TEveViewer::PreUndock()
    // On mac we have to force recreation of gl-context.
 
    TEveWindowFrame::PreUndock();
-   if (fgRecreateGlOnDockOps) {
-      fGLViewer->DestroyGLWidget();
+   if (fgRecreateGlOnDockOps)
+   {
+      // Mac only: TGLWidget can be already deleted
+      // in case of recursive delete
+      if (fGLViewer->GetGLWidget())
+      {
+         fGLViewer->DestroyGLWidget();
+      }
    }
 }
 
@@ -312,7 +320,7 @@ TEveViewerList::TEveViewerList(const char* n, const char* t) :
    fShowTooltip   (kTRUE),
 
    fBrightness(0),
-  fUseLightColorSet(kFALSE)
+   fUseLightColorSet(kFALSE)
 {
    // Constructor.
 
@@ -363,8 +371,15 @@ void TEveViewerList::Connect()
 
    TQObject::Connect("TGLViewer", "MouseOver(TGLPhysicalShape*,UInt_t)",
                      "TEveViewerList", this, "OnMouseOver(TGLPhysicalShape*,UInt_t)");
+
    TQObject::Connect("TGLViewer", "Clicked(TObject*,UInt_t,UInt_t)",
                      "TEveViewerList", this, "OnClicked(TObject*,UInt_t,UInt_t)");
+
+   TQObject::Connect("TGLViewer", "ReClicked(TObject*,UInt_t,UInt_t)",
+                     "TEveViewerList", this, "OnReClicked(TObject*,UInt_t,UInt_t)");
+
+   TQObject::Connect("TGLViewer", "UnClicked(TObject*,UInt_t,UInt_t)",
+                     "TEveViewerList", this, "OnUnClicked(TObject*,UInt_t,UInt_t)");
 }
 
 /******************************************************************************/
@@ -498,7 +513,7 @@ void TEveViewerList::OnMouseOver(TGLPhysicalShape *pshape, UInt_t state)
 }
 
 //______________________________________________________________________________
-void TEveViewerList::OnClicked(TObject *obj, UInt_t button, UInt_t state)
+void TEveViewerList::OnClicked(TObject *obj, UInt_t /*button*/, UInt_t state)
 {
    // Slot for global TGLViewer::Clicked().
    //
@@ -508,9 +523,6 @@ void TEveViewerList::OnClicked(TObject *obj, UInt_t button, UInt_t state)
    // If TEveElement::IsPickable() returns false, the element is not
    // selected.
 
-   if (button != kButton1 || state & kKeyShiftMask || state & kKeyMod1Mask)
-      return;
-
    TEveElement* el = dynamic_cast<TEveElement*>(obj);
    if (el && !el->IsPickable())
       el = 0;
@@ -518,6 +530,41 @@ void TEveViewerList::OnClicked(TObject *obj, UInt_t button, UInt_t state)
 }
 
 //______________________________________________________________________________
+void TEveViewerList::OnReClicked(TObject *obj, UInt_t /*button*/, UInt_t /*state*/)
+{
+   // Slot for global TGLViewer::ReClicked().
+   //
+   // The obj is dyn-casted to the TEveElement and global selection is
+   // updated accordingly.
+   //
+   // If TEveElement::IsPickable() returns false, the element is not
+   // selected.
+
+   TEveElement* el = dynamic_cast<TEveElement*>(obj);
+   if (el && !el->IsPickable())
+      el = 0;
+
+   gEve->GetSelection()->UserRePickedElement(el);
+}
+
+//______________________________________________________________________________
+void TEveViewerList::OnUnClicked(TObject *obj, UInt_t /*button*/, UInt_t /*state*/)
+{
+   // Slot for global TGLViewer::UnClicked().
+   //
+   // The obj is dyn-casted to the TEveElement and global selection is
+   // updated accordingly.
+   //
+   // If TEveElement::IsPickable() returns false, the element is not
+   // selected.
+
+   TEveElement* el = dynamic_cast<TEveElement*>(obj);
+   if (el && !el->IsPickable())
+      el = 0;
+   gEve->GetSelection()->UserUnPickedElement(el);
+}
+
+//______________________________________________________________________________
 void TEveViewerList::SetColorBrightness(Float_t b)
 {
    // Set color brightness.
diff --git a/graf3d/gl/inc/LinkDef.h b/graf3d/gl/inc/LinkDef.h
index 2f05098..d9d0a0d 100644
--- a/graf3d/gl/inc/LinkDef.h
+++ b/graf3d/gl/inc/LinkDef.h
@@ -14,6 +14,12 @@
 #pragma link off all classes;
 #pragma link off all functions;
 
+#pragma link C++ class TGLWidget;
+#pragma link C++ class TGLContext;
+#pragma link C++ class TGLContextIdentity;
+#pragma link C++ class TGLFormat;
+// #pragma link C++ class TGLFBO+;
+
 #pragma link C++ class TGLVertex3;
 #pragma link C++ class TGLVector3;
 #pragma link C++ class TGLLine3;
@@ -71,8 +77,10 @@
 
 #pragma link C++ class TGLViewerBase+;
 #pragma link C++ class TGLViewer+;
+#pragma link C++ class TGLEventHandler;
 #pragma link C++ class TGLFaderHelper+;
 #pragma link C++ class TGLViewerEditor+;
+#pragma link C++ class TGLEmbeddedViewer;
 #pragma link C++ class TGLSAViewer;
 #pragma link C++ class TGLSAFrame;
 
@@ -113,17 +121,11 @@
 #pragma link C++ class TGLBoxCut;
 #pragma link C++ class TGLParametricEquation;
 #pragma link C++ class TGLParametricPlot;
-#pragma link C++ class TGLWidget;
-#pragma link C++ class TGLContext;
-#pragma link C++ class TGLContextIdentity;
-#pragma link C++ class TGLFormat;
 #pragma link C++ class TGLAdapter;
 #pragma link C++ class TF2GL+;
 #pragma link C++ class TH2GL+;
 #pragma link C++ class TH3GL+;
 #pragma link C++ class TGLParametricEquationGL;
-#pragma link C++ class TGLEmbeddedViewer;
-#pragma link C++ class TGLEventHandler;
 
 #ifndef _WIN32
 #pragma link C++ class TX11GLManager;
diff --git a/graf3d/gl/inc/TGLAnnotation.h b/graf3d/gl/inc/TGLAnnotation.h
index 97bbf91..997e056 100644
--- a/graf3d/gl/inc/TGLAnnotation.h
+++ b/graf3d/gl/inc/TGLAnnotation.h
@@ -30,36 +30,58 @@ private:
 
    void MakeEditor();
 
-protected:
-   TGMainFrame      *fMainFrame;
-   TGTextEdit       *fTextEdit;
-
-   TGLViewer        *fParent;
-
-   TString           fText;           // annotation text
-   Float_t           fLabelFontSize;  // relative font size
-   TGLFont           fLabelFont;      // font used to render labels
-   TGLFont           fMenuFont;       // font used to render menu buttons
-
-   Pixel_t           fBackColor;      // background color
-   Pixel_t           fBackHighColor;  // background active color
-   Pixel_t           fTextColor;      // text color
-   Pixel_t           fTextHighColor;  // text active color
-   Float_t           fAlpha;          // label transparency
 
    Float_t           fPosX;           // x position [0, 1]
    Float_t           fPosY;           // y position [0, 1]
 
    Int_t             fMouseX, fMouseY; //! last mouse position
    Bool_t            fInDrag;          //!
+   Float_t           fDrawW, fDrawH;   //! width/height of drawn annotation
+   Float_t           fDrawY;           //! y-position of annotation box
 
    TGLVector3        fPointer;         // picked location in 3D space
    Bool_t            fActive;          // active item identifier
 
+   TGMainFrame      *fMainFrame;       // editors
+   TGTextEdit       *fTextEdit;        // editors
+
+   static Color_t    fgBackColor;
+   static Color_t    fgTextColor;
+
+protected:
+   TGLViewer        *fParent;
+
+   TString           fText;           // annotation text
+   Float_t           fTextSize;       // relative font size
+   TGLFont           fFont;           // font used to render labels
+   TGLFont           fMenuFont;       // font used to render menu buttons
+   TGLFont::ETextAlignH_e fTextAlign;
+
+   Color_t           fBackColor;      // background color
+   Color_t           fTextColor;      // text color
+   Char_t            fTransparency;   // transparency of background
+
+   Bool_t            fDrawRefLine;    // draw 3D refrence line
+   Bool_t            fUseColorSet;    // use color set from rnrCtx
+
 public:
+   TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy);
    TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref);
    virtual ~TGLAnnotation();
 
+   void SetTransparency(Char_t x) { fTransparency = x;}
+   Char_t GetTransparency() const { return fTransparency;}
+   void SetUseColorSet(Bool_t x)  { fUseColorSet = x; }
+   Bool_t GetUseColorSet() const  { return fUseColorSet;}
+   void SetBackColor(Color_t x)   { fBackColor = x;}
+   Color_t GetBackColor() const   { return fBackColor;}
+   void SetTextColor(Color_t x)   { fTextColor = x;   }
+   Color_t GetTextColor() const   { return fTextColor;}
+   void SetTextSize(Float_t x)    { fTextSize = x;   }
+   Float_t GetTextSize() const    { return fTextSize;}
+   TGLFont::ETextAlignH_e GetTextAlign() const { return fTextAlign; }
+   void SetTextAlign(TGLFont::ETextAlignH_e a) { fTextAlign = a; }
+
    virtual Bool_t MouseEnter(TGLOvlSelectRecord& selRec);
    virtual Bool_t Handle(TGLRnrCtx& rnrCtx, TGLOvlSelectRecord& selRec,
                          Event_t* event);
diff --git a/graf3d/gl/inc/TGLAxisPainter.h b/graf3d/gl/inc/TGLAxisPainter.h
index 047644f..0037aec 100644
--- a/graf3d/gl/inc/TGLAxisPainter.h
+++ b/graf3d/gl/inc/TGLAxisPainter.h
@@ -73,7 +73,8 @@ protected:
    Double_t fTitle3DFontSize;
 
    // Labels options. Allready exist in TAttAxis, but can't be set.
-   TGLFont::ETextAlign_e fLabelAlign;
+   TGLFont::ETextAlignH_e fLabelAlignH;
+   TGLFont::ETextAlignV_e fLabelAlignV;
    TGLVector3 fTitlePos;
 
 public:
@@ -99,8 +100,7 @@ public:
    TGLVector3&  RefTitlePos() { return fTitlePos; }
 
 
-   TGLFont::ETextAlign_e GetLabelAlign() const { return fLabelAlign; }
-   void         SetLabelAlign(TGLFont::ETextAlign_e x) { fLabelAlign = x; }
+   void         SetLabelAlign(TGLFont::ETextAlignH_e, TGLFont::ETextAlignV_e);
 
    LabVec_t& RefLabVec() { return fLabVec; }
    TMVec_t&  RefTMVec()  { return fTMVec; }
@@ -118,8 +118,8 @@ public:
    void SetTextFormat(Double_t min, Double_t max, Double_t binWidth);
 
    // Renderers.
-   void RnrText (const char* txt, const TGLVector3 &pos, const TGLFont::ETextAlign_e align, const TGLFont &font) const;
-   void RnrTitle(const char* title, TGLVector3 &pos, TGLFont::ETextAlign_e align) const;
+   void RnrText (const TString &txt, const TGLVector3 &pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV, const TGLFont &font) const;
+   void RnrTitle(const TString &title, TGLVector3 &pos, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV) const;
    void RnrLabels() const;
    void RnrLines() const;
 
diff --git a/graf3d/gl/inc/TGLCamera.h b/graf3d/gl/inc/TGLCamera.h
index 6e59ef8..b92a721 100644
--- a/graf3d/gl/inc/TGLCamera.h
+++ b/graf3d/gl/inc/TGLCamera.h
@@ -145,7 +145,8 @@ public:
    void    SetExternalCenter(Bool_t x);
    Bool_t  GetExternalCenter(){ return fExternalCenter; }
 
-   void    SetCenterVec( Double_t x, Double_t y, Double_t z);
+   void    SetCenterVec(Double_t x, Double_t y, Double_t z);
+   void    SetCenterVecWarp(Double_t x, Double_t y, Double_t z);
    Double_t* GetCenterVec() { return fCenter->Arr(); }
 
    Double_t GetNearClip() const { return fNearClip; }
@@ -153,6 +154,9 @@ public:
 
    const TGLMatrix& GetCamBase()  const { return fCamBase;  }
    const TGLMatrix& GetCamTrans() const { return fCamTrans; }
+   // If you manipulate camera ... also call IncTimeStamp() before redraw.
+   TGLMatrix& RefCamBase()  { return fCamBase;  }
+   TGLMatrix& RefCamTrans() { return fCamTrans; }
 
    Double_t GetTheta() const;
 
diff --git a/graf3d/gl/inc/TGLEventHandler.h b/graf3d/gl/inc/TGLEventHandler.h
index 5ff9e15..3552534 100644
--- a/graf3d/gl/inc/TGLEventHandler.h
+++ b/graf3d/gl/inc/TGLEventHandler.h
@@ -43,15 +43,17 @@ protected:
    TPoint            fTooltipPos;
    UInt_t            fActiveButtonID;
    UInt_t            fLastEventState;
+   Bool_t            fIgnoreButtonUp;
    Bool_t            fInPointerGrab;
    Bool_t            fMouseTimerRunning;
    Bool_t            fTooltipShown;
    Int_t             fTooltipPixelTolerance;
+   Int_t             fSecSelType; // secondary selection type
 
    virtual Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
 
 public:
-   TGLEventHandler(const char *name, TGWindow *w, TObject *obj, const char *title="");
+   TGLEventHandler(TGWindow *w, TObject *obj);
    virtual ~TGLEventHandler();
 
    virtual void   ExecuteEvent(Int_t event, Int_t px, Int_t py);
@@ -79,6 +81,9 @@ public:
    Int_t GetTooltipPixelTolerance()  const { return fTooltipPixelTolerance; }
    void  SetTooltipPixelTolerance(Int_t t) { fTooltipPixelTolerance = t; }
 
+   Int_t GetSecSelType()  const { return fSecSelType; }
+   void  SetSecSelType(Int_t t) { fSecSelType = t; }
+
    ClassDef(TGLEventHandler, 0); // Base-class and default implementation of event-handler for TGLViewer.
 };
 
diff --git a/graf3d/gl/inc/TGLFontManager.h b/graf3d/gl/inc/TGLFontManager.h
index 34c636d..e123a88 100644
--- a/graf3d/gl/inc/TGLFontManager.h
+++ b/graf3d/gl/inc/TGLFontManager.h
@@ -30,7 +30,8 @@ public:
       kTexture, kOutline, kPolygon, kExtrude
    }; // Font-types of FTGL.
 
-   enum ETextAlign_e { kCenterDown, kCenterUp, kLeft, kRight };
+   enum ETextAlignH_e { kLeft, kRight, kCenterH };
+   enum ETextAlignV_e   { kBottom, kTop, kCenterV };
 
 private:
    TGLFont& operator=(const TGLFont& o); // Not implemented.
@@ -81,8 +82,8 @@ public:
               Float_t& llx, Float_t& lly, Float_t& llz,
               Float_t& urx, Float_t& ury, Float_t& urz) const;
 
-   void  Render(const char* txt) const;
-   void  RenderBitmap(const char* txt, Float_t x, Float_t y, Float_t zs, ETextAlign_e align) const;
+   void  Render(const TString &txt) const;
+   void  Render(const TString &txt, Float_t x, Float_t y, Float_t z, ETextAlignH_e alignH, ETextAlignV_e alignV) const;
 
    // helper gl draw functions
    virtual void PreRender(Bool_t autoLight=kTRUE, Bool_t lightOn=kFALSE) const;
@@ -143,8 +144,8 @@ public:
    static TObjArray*        GetFontFileArray();
    static FontSizeVec_t*    GetFontSizeArray();
 
-   static Int_t             GetFontSize(Float_t ds);
-   static Int_t             GetFontSize(Float_t ds, Int_t min, Int_t max);
+   static Int_t             GetFontSize(Int_t ds);
+   static Int_t             GetFontSize(Int_t ds, Int_t min, Int_t max);
    static const char*       GetFontNameFromId(Int_t);
 
    void   ClearFontTrash();
diff --git a/graf3d/gl/inc/TGLLogicalShape.h b/graf3d/gl/inc/TGLLogicalShape.h
index bda4bbf..9dff862 100644
--- a/graf3d/gl/inc/TGLLogicalShape.h
+++ b/graf3d/gl/inc/TGLLogicalShape.h
@@ -46,7 +46,7 @@ public:
 
 protected:
    mutable UInt_t             fRef;           //! physical instance ref counting
-   mutable TGLPhysicalShape * fFirstPhysical; //! first replica
+   mutable TGLPhysicalShape  *fFirstPhysical; //! first replica
 
    TObject           *fExternalObj; //! Also plays the role of ID.
    TGLBoundingBox     fBoundingBox; //! Shape's bounding box.
@@ -74,15 +74,15 @@ public:
    void   DestroyPhysicals();
    UInt_t UnrefFirstPhysical();
 
-   const TGLPhysicalShape * GetFirstPhysical() const { return fFirstPhysical; }
+   const TGLPhysicalShape* GetFirstPhysical() const { return fFirstPhysical; }
 
-   TObject  * ID()          const { return fExternalObj; }
-   TObject  * GetExternal() const { return fExternalObj; }
-   TGLScene * GetScene()    const { return fScene; }
+   TObject*  ID()          const { return fExternalObj; }
+   TObject*  GetExternal() const { return fExternalObj; }
+   TGLScene* GetScene()    const { return fScene; }
 
-   const TGLBoundingBox & BoundingBox() const { return fBoundingBox; }
-   virtual void           UpdateBoundingBox() {}
-   void                   UpdateBoundingBoxesOfPhysicals();
+   const TGLBoundingBox& BoundingBox() const { return fBoundingBox; }
+   virtual void          UpdateBoundingBox() {}
+   void                  UpdateBoundingBoxesOfPhysicals();
 
    // Display List Caching
            Bool_t SetDLCache(Bool_t cached);
@@ -94,8 +94,10 @@ public:
 
    virtual ELODAxes SupportedLODAxes() const { return kLODAxesNone; }
    virtual Short_t  QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const;
-   virtual void     Draw(TGLRnrCtx & rnrCtx) const;
-   virtual void     DirectDraw(TGLRnrCtx & rnrCtx) const = 0; // Actual draw method (non DL cached)
+   virtual void     Draw(TGLRnrCtx& rnrCtx) const;
+   virtual void     DirectDraw(TGLRnrCtx& rnrCtx) const = 0; // Actual draw method (non DL cached)
+
+   virtual void     DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp) const;
 
    virtual Bool_t IgnoreSizeForOfInterest() const { return kFALSE; }
 
@@ -103,7 +105,8 @@ public:
    virtual Bool_t KeepDuringSmartRefresh() const { return kFALSE; }
    // Override in sub-classes that support secondary selection (e.g. TPointSet3DGL).
    virtual Bool_t SupportsSecondarySelect() const { return kFALSE; }
-   virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+   virtual Bool_t AlwaysSecondarySelect()   const { return kFALSE; }
+   virtual void   ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec);
 
    void InvokeContextMenu(TContextMenu & menu, UInt_t x, UInt_t y) const;
 
diff --git a/graf3d/gl/inc/TGLRnrCtx.h b/graf3d/gl/inc/TGLRnrCtx.h
index 08d4e51..166c0a6 100644
--- a/graf3d/gl/inc/TGLRnrCtx.h
+++ b/graf3d/gl/inc/TGLRnrCtx.h
@@ -138,6 +138,7 @@ protected:
 
    // Picture grabbing
    Bool_t           fGrabImage;    // Set to true to store the image.
+   Int_t            fGrabBuffer;   // Which buffer to grab after render.
    UChar_t         *fGrabbedImage; // Buffer where image was stored after rendering.
 
 public:
@@ -248,13 +249,16 @@ public:
 
    void  RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out);
    void  RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out);
+   void  RegisterFontNoScale(Int_t size, Int_t file, Int_t mode, TGLFont& out);
+   void  RegisterFontNoScale(Int_t size, const char* name, Int_t mode, TGLFont& out);
    void  ReleaseFont(TGLFont& font);
 
    GLUquadric* GetGluQuadric() { return fQuadric; }
 
    // Picture grabbing
-   void     SetGrabImage(Bool_t gi) { fGrabImage = gi; }
+   void     SetGrabImage(Bool_t gi, Int_t buf=-1) { fGrabImage = gi; fGrabBuffer = buf; }
    Bool_t   GetGrabImage()    const { return fGrabImage; }
+   Int_t    GetGrabBuffer()   const { return fGrabBuffer; }
    UChar_t* GetGrabbedImage() const { return fGrabbedImage; }
    void     SetGrabbedImage(UChar_t* img) { fGrabbedImage = img; }
 
diff --git a/graf3d/gl/inc/TGLSelectRecord.h b/graf3d/gl/inc/TGLSelectRecord.h
index 722af46..dc802b9 100644
--- a/graf3d/gl/inc/TGLSelectRecord.h
+++ b/graf3d/gl/inc/TGLSelectRecord.h
@@ -72,6 +72,9 @@ public:
 
 class TGLSelectRecord : public TGLSelectRecordBase
 {
+public:
+   enum ESecSelResult { kNone, kEnteringSelection, kLeavingSelection, kModifyingInternalSelection };
+
 protected:
    // Secondary data (scene dependent) - use
    // TGLSceneBase::ResolveSelectRecord to fill.
@@ -80,6 +83,9 @@ protected:
    TGLPhysicalShape *fPhysShape; // PhysicalShape, if applicable
    TObject          *fObject;    // Master TObject, if applicable
    void             *fSpecific;  // Scene specific, if applicable
+   Bool_t            fMultiple;  // Mutliple selection, requested by event handler
+
+   ESecSelResult     fSecSelRes; // Result of ProcessSelection;
 
 public:
    TGLSelectRecord();
@@ -97,12 +103,18 @@ public:
    TGLPhysicalShape * GetPhysShape()   const { return fPhysShape; }
    TObject          * GetObject()      const { return fObject; }
    void             * GetSpecific()    const { return fSpecific; }
+   Bool_t             GetMultiple()    const { return fMultiple; }
+
+   ESecSelResult      GetSecSelResult() const { return fSecSelRes; }
 
    void SetTransparent(Bool_t t)               { fTransparent = t; }
    void SetSceneInfo  (TGLSceneInfo* si)       { fSceneInfo = si; }
    void SetPhysShape  (TGLPhysicalShape* pshp) { fPhysShape = pshp; }
    void SetObject     (TObject* obj)           { fObject = obj; }
    void SetSpecific   (void* spec)             { fSpecific = spec; }
+   void SetMultiple   (Bool_t multi)           { fMultiple = multi; }
+
+   void SetSecSelResult(ESecSelResult r)       { fSecSelRes = r; }
 
    void Print();
 
diff --git a/graf3d/gl/inc/TGLViewer.h b/graf3d/gl/inc/TGLViewer.h
index f52c05d..68f68f7 100644
--- a/graf3d/gl/inc/TGLViewer.h
+++ b/graf3d/gl/inc/TGLViewer.h
@@ -59,6 +59,8 @@ public:
                       kCameraOrthoXOY,  kCameraOrthoXOZ,  kCameraOrthoZOY,
                       kCameraOrthoXnOY, kCameraOrthoXnOZ, kCameraOrthoZnOY };
 
+   enum ESecSelType { kOnRequest, kOnKeyMod1 };
+
 private:
    TGLViewer(const TGLViewer &);             // Not implemented
    TGLViewer & operator=(const TGLViewer &); // Not implemented
@@ -122,6 +124,8 @@ protected:
    TGLColorSet    fLightColorSet;  //! color-set with light background
    Float_t        fPointScale;     //! size scale for points
    Float_t        fLineScale;      //! width scale for lines
+   Bool_t         fSmoothPoints;   //! smooth point edge rendering
+   Bool_t         fSmoothLines;    //! smooth line edge rendering
    Int_t          fAxesType;       //! axes type
    Bool_t         fAxesDepthTest;  //! remove guides hidden-lines
    Bool_t         fReferenceOn;    //! reference marker on?
@@ -155,6 +159,7 @@ protected:
 
    // Cameras
    void        SetViewport(Int_t x, Int_t y, Int_t width, Int_t height);
+   void        SetViewport(const TGLRect& vp);
    void        SetupCameras(Bool_t reset);
 
 protected:
@@ -219,6 +224,7 @@ public:
 
    void         UseDefaultColorSet(Bool_t x);
    Bool_t       IsUsingDefaultColorSet() const;
+   Bool_t       IsColorSetDark() const;
 
    void         SetClearColor(Color_t col);
 
@@ -230,7 +236,10 @@ public:
    Float_t GetLineScale()     const { return fLineScale; }
    void    SetPointScale(Float_t s) { fPointScale = s; }
    void    SetLineScale (Float_t s) { fLineScale  = s; }
-
+   Bool_t  GetSmoothPoints()  const { return fSmoothPoints; }
+   Bool_t  GetSmoothLines()   const { return fSmoothLines; }
+   void    SetSmoothPoints(Bool_t s){ fSmoothPoints = s; }
+   void    SetSmoothLines(Bool_t s) { fSmoothLines  = s; }
 
    TGLLightSet* GetLightSet() const { return fLightSet; }
    TGLClipSet * GetClipSet()  const { return fClipSet; }
@@ -277,16 +286,24 @@ public:
    void DrawGuides();
    void DrawDebugInfo();
 
-   Bool_t RequestSelect(Int_t x, Int_t y, Bool_t trySecSel=kFALSE); // Cross thread select request
-   Bool_t DoSelect(Int_t x, Int_t y, Bool_t trySecSel=kFALSE);      // Window coords origin top left
+   Bool_t RequestSelect(Int_t x, Int_t y);          // Cross thread select request
+   Bool_t DoSelect(Int_t x, Int_t y);               // First level selecton (shapes/objects).
+   Bool_t RequestSecondarySelect(Int_t x, Int_t y); // Cross thread secondary select request
+   Bool_t DoSecondarySelect(Int_t x, Int_t y);      // Second level selecton (inner structure).
    void   ApplySelection();
 
    Bool_t RequestOverlaySelect(Int_t x, Int_t y); // Cross thread select request
    Bool_t DoOverlaySelect(Int_t x, Int_t y);      // Window coords origin top left
 
-   // Saveing of screen image
-   Bool_t       SavePicture(const TString &fileName);
-   Bool_t       SavePicture();
+   // Saving of screen image
+   Bool_t SavePicture();
+   Bool_t SavePicture(const TString &fileName);
+   Bool_t SavePictureUsingBB (const TString &fileName);
+   Bool_t SavePictureUsingFBO(const TString &fileName, Int_t w, Int_t h, Float_t pixel_object_scale=0);
+   Bool_t SavePictureWidth (const TString &fileName, Int_t width, Bool_t pixel_object_scale=kTRUE);
+   Bool_t SavePictureHeight(const TString &fileName, Int_t height, Bool_t pixel_object_scale=kTRUE);
+   Bool_t SavePictureScale (const TString &fileName, Float_t scale, Bool_t pixel_object_scale=kTRUE);
+
    const char*  GetPictureFileName() const { return fPictureFileName.Data(); }
    void         SetPictureFileName(const TString& f) { fPictureFileName = f; }
    Float_t      GetFader() const { return fFader; }
@@ -313,6 +330,8 @@ public:
    virtual void Activated() { Emit("Activated()"); } // *SIGNAL*
    virtual void Clicked(TObject *obj); //*SIGNAL*
    virtual void Clicked(TObject *obj, UInt_t button, UInt_t state); //*SIGNAL*
+   virtual void ReClicked(TObject *obj, UInt_t button, UInt_t state); //*SIGNAL*
+   virtual void UnClicked(TObject *obj, UInt_t button, UInt_t state); //*SIGNAL*
    virtual void DoubleClicked() { Emit("DoubleClicked()"); } // *SIGNAL*
 
    TGEventHandler *GetEventHandler() const { return fEventHandler; }
diff --git a/graf3d/gl/inc/TGLViewerEditor.h b/graf3d/gl/inc/TGLViewerEditor.h
index 638990e..c409b78 100644
--- a/graf3d/gl/inc/TGLViewerEditor.h
+++ b/graf3d/gl/inc/TGLViewerEditor.h
@@ -46,6 +46,8 @@ private:
 
    TGNumberEntry    *fPointSizeScale;
    TGNumberEntry    *fLineWidthScale;
+   TGCheckButton    *fPointSmooth;
+   TGCheckButton    *fLineSmooth;
    TGNumberEntry    *fWFLineWidth;
    TGNumberEntry    *fOLLineWidth;
 
diff --git a/graf3d/gl/src/TGLAnnotation.cxx b/graf3d/gl/src/TGLAnnotation.cxx
index 8380619..637209d 100644
--- a/graf3d/gl/src/TGLAnnotation.cxx
+++ b/graf3d/gl/src/TGLAnnotation.cxx
@@ -12,6 +12,7 @@
 #include "TGLAnnotation.h"
 
 #include "TGLIncludes.h"
+#include "TROOT.h"
 #include "TColor.h"
 #include "TGLUtil.h"
 #include "TGLCamera.h"
@@ -24,6 +25,8 @@
 #include "TGButton.h"
 #include "TGLViewer.h"
 
+#include "TMath.h"
+
 #include <KeySymbols.h>
 
 //______________________________________________________________________________
@@ -35,24 +38,59 @@
 
 ClassImp(TGLAnnotation);
 
+Color_t  TGLAnnotation::fgBackColor = kAzure + 10;
+Color_t  TGLAnnotation::fgTextColor = kOrange;
+
 //______________________________________________________________________________
-TGLAnnotation::TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref) :
+TGLAnnotation::TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy) :
    TGLOverlayElement(TGLOverlayElement::kAnnotation),
+
+   fPosX(posx), fPosY(posy),
+   fMouseX(0),  fMouseY(0),
+   fInDrag(kFALSE),
+   fActive(kFALSE),
    fMainFrame(0), fTextEdit(0),
+
    fParent(0),
+
    fText(text),
-   fLabelFontSize(0.02),
-   fBackColor(0x4872fa),
-   fBackHighColor(0x488ffa),
-   fTextColor(0xfbbf84),
-   fTextHighColor(0xf1da44),
-   fAlpha(0.6),
+   fTextSize(0.02),
+   fTextAlign(TGLFont::kLeft),
+   fBackColor(fgBackColor),
+   fTextColor(fgTextColor),
+   fTransparency(100),
+   fDrawRefLine(kFALSE),
+   fUseColorSet(kTRUE)
+{
+   // Constructor.
+   // Create annotation as plain text
+
+   parent->AddOverlayElement(this);
+   fParent = (TGLViewer*)parent;
+}
+
+//______________________________________________________________________________
+TGLAnnotation::TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref) :
+   TGLOverlayElement(TGLOverlayElement::kAnnotation),
    fPosX(posx), fPosY(posy),
    fMouseX(0),  fMouseY(0),
    fInDrag(kFALSE),
-   fActive(kFALSE)
+   fActive(kFALSE),
+   fMainFrame(0), fTextEdit(0),
+
+   fParent(0),
+
+   fText(text),
+   fTextSize(0.02),
+   fTextAlign(TGLFont::kLeft),
+   fBackColor(fgBackColor),
+   fTextColor(fgTextColor),
+   fTransparency(40),
+   fDrawRefLine(kTRUE),
+   fUseColorSet(kFALSE)
 {
    // Constructor.
+   // Create annotaton by picking an object.
 
    fPointer = ref;
    parent->AddOverlayElement(this);
@@ -83,26 +121,26 @@ Bool_t TGLAnnotation::Handle(TGLRnrCtx&          rnrCtx,
    {
       case kButtonPress:
       {
-         // Chech selRec ... if pressed in 'X', 'E'
+         fMouseX = event->fX;
+         fMouseY = event->fY;
+         fInDrag = kTRUE;
+
+         return kTRUE;
+      }
+      case kButtonRelease:
+      {
+         fInDrag = kFALSE;
+
          if (recID == 2)
          {
             delete this;
+            fParent->RequestDraw(rnrCtx.ViewerLOD());
          }
          else if (recID == 3)
          {
             MakeEditor();
          }
-         else
-         {
-            fMouseX = event->fX;
-            fMouseY = event->fY;
-            fInDrag = kTRUE;
-         }
-         return kTRUE;
-      }
-      case kButtonRelease:
-      {
-         fInDrag = kFALSE;
+
          return kTRUE;
       }
       case kMotionNotify:
@@ -114,23 +152,18 @@ Bool_t TGLAnnotation::Handle(TGLRnrCtx&          rnrCtx,
             fPosY -= (Float_t)(event->fY - fMouseY) / vp.Height();
             fMouseX = event->fX;
             fMouseY = event->fY;
+            // Make sure we don't go offscreen (use fDraw variables set in draw)
+            if (fPosX < 0)
+               fPosX = 0;
+            else if (fPosX + fDrawW > 1.0f)
+               fPosX = 1.0f - fDrawW;
+            if (fPosY - fDrawH + fDrawY < 0)
+               fPosY = fDrawH - fDrawY;
+            else if (fPosY + fDrawY > 1.0f)
+               fPosY = 1.0f - fDrawY;
          }
          return kTRUE;
       }
-      case kGKeyPress:
-      {
-         switch (rnrCtx.GetEventKeySym())
-         {
-            case kKey_E: case kKey_e:
-               MakeEditor();
-               return kTRUE;
-            case kKey_X: case kKey_x:
-               delete this;
-               return kTRUE;
-            default:
-               return kFALSE;
-         }
-      }
       default:
       {
          return kFALSE;
@@ -160,221 +193,214 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
 {
    // Render the annotation.
 
-   glDisable(GL_LIGHTING);
-
-   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POINT_BIT);
-   Float_t r, g, b;
-   // button
-   //
-   {
-      glMatrixMode(GL_PROJECTION);
-      glPushMatrix();
-      glLoadIdentity();
-      if (rnrCtx.Selection())
-      {
-         TGLRect rect(*rnrCtx.GetPickRectangle());
-         rnrCtx.GetCamera()->WindowToViewport(rect);
-         gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
-                       (Int_t*) rnrCtx.GetCamera()->RefViewport().CArr());
-      }
-      const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
-      glOrtho(vp.X(), vp.Width(), vp.Y(), vp.Height(), 0, 1);
-      glMatrixMode(GL_MODELVIEW);
-      glPushMatrix();
-      glLoadIdentity();
-
-      TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
-      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-      glDisable(GL_CULL_FACE);
-      glEnable(GL_BLEND);
-      glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-      glShadeModel(GL_FLAT);
-      glClearColor(0.0, 0.0, 0.0, 0.0);
-
-      Float_t posX = vp.Width()  * fPosX;
-      Float_t posY = vp.Height() * fPosY;
-
-      // Text rendering
-      Float_t cfs = fLabelFontSize*vp.Width();
-      Int_t fs = TGLFontManager::GetFontSize(cfs);
-      if (fLabelFont.GetMode() == TGLFont::kUndef)
-      {
-         rnrCtx.RegisterFont(fs, "arial",  TGLFont::kPixmap, fLabelFont);
-      }
-      else if (fLabelFont.GetSize() != fs)
-      {
-         rnrCtx.ReleaseFont(fLabelFont);
-         rnrCtx.RegisterFont(fs, "arial",  TGLFont::kPixmap, fLabelFont);
-      }
+   Float_t old_depth_range[2];
+   glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
+   glDepthRange(0, 0.001);
 
-      // move to picked location
-      glTranslatef(posX, posY, -0.99);
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT );
+   TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
+   glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+   glDisable(GL_CULL_FACE);
+   glEnable(GL_BLEND);
+   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-      glEnable(GL_POLYGON_OFFSET_FILL);
-      glPolygonOffset(1, 1);
+   const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
 
-      TGLUtil::LineWidth(1);
-
-      // get size of bg area
-      Float_t ascent, descent, line_height;
-      fLabelFont.MeasureBaseLineParams(ascent, descent, line_height);
+   // prepare colors
+   Color_t bgCol, fgCol;
+   if (fUseColorSet)
+   {
+      fgCol = rnrCtx.ColorSet().Markup().GetColorIndex();
+
+      TColor* c1 = gROOT->GetColor(rnrCtx.ColorSet().Markup().GetColorIndex());
+      TColor* c2 = gROOT->GetColor(rnrCtx.ColorSet().Background().GetColorIndex());
+      Float_t f1 = 0.5, f2 = 0.5;
+      bgCol = TColor::GetColor(c1->GetRed()  *f1  + c2->GetRed()  *f2,
+                               c1->GetGreen()*f1  + c2->GetGreen()*f2,
+                               c1->GetBlue() *f1  + c2->GetBlue() *f2);
+   }
+   else {
+      fgCol = fTextColor;
+      bgCol = fBackColor;
+   }
 
-      Float_t llx, lly, llz, urx, ury, urz;
+   if (fDrawRefLine)
+   {
+      TGLUtil::ColorTransparency(bgCol, fTransparency);
+      TGLUtil::LineWidth(2);
+      glBegin(GL_LINES);
+      TGLVertex3 v = rnrCtx.RefCamera().ViewportToWorld(TGLVertex3(fPosX*vp.Width(), fPosY*vp.Height(), 0));
+      glVertex3dv(v.Arr());
+      glVertex3dv(fPointer.Arr());
+      glEnd();
+   }
 
-      TObjArray* lines = fText.Tokenize("\n");
-      Float_t width  = 0;
-      Float_t height = 0;
-      TIter  lit(lines);
-      TObjString* osl;
-      while ((osl = (TObjString*) lit()) != 0)
-      {
-         fLabelFont.BBox(osl->GetString().Data(), llx, lly, llz, urx, ury, urz);
-         width = TMath::Max(width, urx);
-         height += line_height + descent;
-      }
-      width  += 2 * descent;
-      height += 2 * descent;
+   // reset matrix
+   glMatrixMode(GL_PROJECTION);
+   glPushMatrix();
+   glLoadIdentity();
+   if (rnrCtx.Selection())
+   {
+      TGLRect rect(*rnrCtx.GetPickRectangle());
+      rnrCtx.GetCamera()->WindowToViewport(rect);
+      gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
+                    (Int_t*) rnrCtx.GetCamera()->RefViewport().CArr());
+   }
+   glOrtho(vp.X(), vp.Width(), vp.Y(), vp.Height(), 0, 1);
+   glMatrixMode(GL_MODELVIEW);
+   glPushMatrix();
+   glLoadIdentity();
+
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(0.1, 1);
+
+   TGLUtil::LineWidth(1);
+
+   // move to pos
+   Float_t posX = vp.Width()  * fPosX;
+   Float_t posY = vp.Height() * fPosY;
+   glTranslatef(posX, posY, -0.99);
+
+
+   // get size of bg area, look at font attributes
+   rnrCtx.RegisterFontNoScale(TMath::Nint(fTextSize*vp.Width()), "arial",  TGLFont::kPixmap, fFont);
+   Float_t ascent, descent, line_height;
+   fFont.MeasureBaseLineParams(ascent, descent, line_height);
+   TObjArray* lines = fText.Tokenize("\n");
+   Float_t width  = 0;
+   Float_t height = 0;
+   TIter  lit(lines);
+   TObjString* osl;
+   Float_t llx, lly, llz, urx, ury, urz;
+   while ((osl = (TObjString*) lit()) != 0)
+   {
+      fFont.BBox(osl->GetString().Data(), llx, lly, llz, urx, ury, urz);
+      width = TMath::Max(width, urx);
+      height -= (line_height + descent);
+   }
+   width  += 2 * descent;
+   height -= 2 * descent;
+
+   // Store variables needed for border check when box is dragged.
+   fDrawW = (Float_t) width / vp.Width();
+   fDrawH = (Float_t) - height / vp.Height();
+   fDrawY = line_height / vp.Height();
+
+   // polygon background
+   Float_t padT =  2;
+   Int_t   padF = 10;
+   Float_t padM = padF + 2 * padT;
+
+   glPushName(0);
+
+   // bg plain
+   Float_t y = line_height;
+   Float_t x = 0;
+   glLoadName(1);
+   TGLUtil::ColorTransparency(bgCol, fTransparency);
+   glBegin(GL_QUADS);
+   glVertex2f(x, y);
+   glVertex2f(x, y + height);
+   glVertex2f(x+width, y + height);
+   glVertex2f(x+width, y);
+   glEnd();
 
-      // polygon background
-      Float_t padT =  2;
-      Int_t   padF = 10;
-      Float_t padM = padF + 2 * padT;
+   // outline
+   TGLUtil::ColorTransparency(fgCol, fTransparency);
+   glBegin(GL_LINE_LOOP);
+   glVertex2f(x, y);
+   glVertex2f(x, y + height);
+   glVertex2f(x+width, y + height);
+   glVertex2f(x+width, y);
+   glEnd();
 
-      {
-         glPushName(0);
-
-         TColor::Pixel2RGB(fActive ? fBackHighColor : fBackColor, r, g, b);
-         TGLUtil::Color4f(r, g, b, fAlpha);
-
-         // bg plain
-         glLoadName(1);
-         glBegin(GL_QUADS);
-         glVertex2f(0, 0);
-         glVertex2f(0, height);
-         glVertex2f(width, height);
-         glVertex2f(width, 0);
-         glEnd();
-
-         // outline
-         TColor::Pixel2RGB(fActive?fTextHighColor:fTextColor, r, g, b);
-         TGLUtil::Color4f(r, g, b, fAlpha);
-
-         glBegin(GL_LINE_LOOP);
-         glVertex2f(0, 0);
-         glVertex2f(0, height);
-         glVertex2f(width, height);
-         glVertex2f(width, 0);
-         glEnd();
-
-         // edit area
-         if (fActive)
-         {
-            Float_t y = height;
-            Float_t x = 0;
-            TColor::Pixel2RGB(fBackHighColor, r, g, b);
-            TGLUtil::Color4f(r, g, b, fAlpha);
-
-            // edit button
-            glLoadName(2);
-            glBegin(GL_QUADS);
-            glVertex2f(x + padM, y);
-            glVertex2f(x,        y);
-            glVertex2f(x,        y + padM);
-            glVertex2f(x + padM, y + padM);
-            glEnd();
-            // close button
-            glLoadName(3);
-            x = padM;
-            TColor::Pixel2RGB(fBackHighColor, r, g, b);
-            TGLUtil::Color4f(r, g, b, fAlpha);
-            glBegin(GL_QUADS);
-            glVertex2f(x + padM, y);
-            glVertex2f(x,        y);
-            glVertex2f(x,        y + padM);
-            glVertex2f(x + padM, y + padM);
-            glEnd();
-
-            // outlines
-            TColor::Pixel2RGB(fTextHighColor, r, g, b);
-            TGLUtil::Color4f(r, g, b, fAlpha);
-            // left
-            x = 0;
-            glBegin(GL_LINE_LOOP);
-            glVertex2f(x + padM, y);
-            glVertex2f(x,        y);
-            glVertex2f(x,        y + padM);
-            glVertex2f(x + padM, y + padM);
-            glEnd();
-            // right
-            x = padM;
-            glBegin(GL_LINE_LOOP);
-            glVertex2f(x + padM, y);
-            glVertex2f(x,        y);
-            glVertex2f(x,        y + padM);
-            glVertex2f(x + padM, y + padM);
-            glEnd();
-         }
-         glPopName();
+   if (fActive && fTransparency < 100)
+   {  // edit area
+
+      TGLUtil::ColorTransparency(bgCol, fTransparency);
+      // edit button
+      glLoadName(2);
+      glBegin(GL_QUADS);
+      glVertex2f(x + padM, y);
+      glVertex2f(x,        y);
+      glVertex2f(x,        y + padM);
+      glVertex2f(x + padM, y + padM);
+      glEnd();
+      // close button
+      glLoadName(3);
+      x = padM;
+      glBegin(GL_QUADS);
+      glVertex2f(x + padM, y);
+      glVertex2f(x,        y);
+      glVertex2f(x,        y + padM);
+      glVertex2f(x + padM, y + padM);
+      glEnd();
+
+      // outlines
+      TGLUtil::ColorTransparency(fgCol, fTransparency);
+      x = 0; // left
+      glBegin(GL_LINE_LOOP);
+      glVertex2f(x + padM, y);
+      glVertex2f(x,        y);
+      glVertex2f(x,        y + padM);
+      glVertex2f(x + padM, y + padM);
+      glEnd(); // right
+      x = padM;
+      glBegin(GL_LINE_LOOP);
+      glVertex2f(x + padM, y);
+      glVertex2f(x,        y);
+      glVertex2f(x,        y + padM);
+      glVertex2f(x + padM, y + padM);
+      glEnd();
+   }
+   glPopName();
+
+   // text
+   Float_t zOff = 0.2; // more than 0, else not rendered
+   fFont.PreRender();
+   TGLUtil::Color(fgCol);
+   TIter  next_base(lines);
+   TObjString* os;
+   glPushMatrix();
+   glTranslatef(descent, line_height, zOff);
+   Float_t tx = 0;
+   while ((os = (TObjString*) next_base()) != 0)
+   {
+      glTranslatef(0, -(line_height + descent), 0);
+      if (fTextAlign == TGLFont::kLeft) {
+         tx = 0;
       }
-
-      glDisable(GL_POLYGON_OFFSET_FILL);
-
-      // labels
-      fLabelFont.PreRender();
-      TColor::Pixel2RGB(fActive?fTextHighColor:fTextColor, r, g, b);
-      TGLUtil::Color3f(r, g, b);
-      TIter  next_base(lines);
-      TObjString* os;
-      glPushMatrix();
-      glTranslatef(descent, height, 0);
-      while ((os = (TObjString*) next_base()) != 0)
-      {
-         glTranslatef(0, -(line_height + descent), 0);
-         fLabelFont.BBox(os->GetString().Data(), llx, lly, llz, urx, ury, urz);
-         glRasterPos2i(0, 0);
-         glBitmap(0, 0, 0, 0, 0, 0, 0);
-         fLabelFont.Render(os->GetString().Data());
+      else if  (fTextAlign == TGLFont::kCenterH) {
+         tx = 0.5 * width - descent ;
       }
-      glPopMatrix();
-      fLabelFont.PostRender();
-
-      // menu
-      if (fMenuFont.GetMode() == TGLFont::kUndef)
-      {
-         rnrCtx.RegisterFont(padF, "arial",  TGLFont::kPixmap, fMenuFont);
+      else {
+         tx = width - 2*descent;
       }
+      fFont.Render(os->GetString(), tx, 0, 0, fTextAlign, TGLFont::kTop);
+   }
+   glPopMatrix();
+   fFont.PostRender();
 
-      if (fActive)
-      {
-         TColor::Pixel2RGB(fTextHighColor, r, g, b);
-         TGLUtil::Color3f(r, g, b);
-         Float_t x = padT;
-         Float_t y = height + padT + 0.5*padF;
-         fMenuFont.PreRender();
-         fMenuFont.RenderBitmap("X", x, y, 0, TGLFont::kLeft);
-         x += padM + padT;
-         fMenuFont.RenderBitmap("E", x, y, 0, TGLFont::kLeft);
-         fMenuFont.PostRender();
-      }
+   // menu
 
-      glMatrixMode(GL_PROJECTION);
-      glPopMatrix();
-      glMatrixMode(GL_MODELVIEW);
-      glPopMatrix();
+   if (fActive && fTransparency < 100)
+   {
+      x = padT;
+      y = padT + 0.5*padF + line_height;
+      rnrCtx.RegisterFontNoScale(padF, "arial",  TGLFont::kPixmap, fMenuFont);
+      fMenuFont.PreRender();
+      fMenuFont.Render("X", x, y, zOff, TGLFont::kLeft, TGLFont::kCenterV);
+      x += padM + padT;
+      fMenuFont.Render("E", x, y, zOff, TGLFont::kLeft, TGLFont::kCenterV);
+      fMenuFont.PostRender();
    }
 
-   // line
-   //
-   TGLUtil::LineWidth(2);
-   TColor::Pixel2RGB(fActive ?fBackHighColor : fBackColor, r, g, b);
-   TGLUtil::Color4f(r, g, b, fAlpha);
-   glBegin(GL_LINES);
-   TGLRect& vp = rnrCtx.RefCamera().RefViewport();
-   TGLVertex3 v = rnrCtx.RefCamera().ViewportToWorld(TGLVertex3(fPosX*vp.Width(), fPosY*vp.Height(), 0));
-
-   glVertex3dv(v.Arr());
-   glVertex3dv(fPointer.Arr());
-   glEnd();
+   glMatrixMode(GL_PROJECTION);
+   glPopMatrix();
+   glMatrixMode(GL_MODELVIEW);
+   glPopMatrix();
+
+   glDepthRange(old_depth_range[0], old_depth_range[1]);
    glPopAttrib();
 }
 
@@ -438,5 +464,6 @@ void TGLAnnotation::UpdateText()
    // Modify the annotation text from the text-edit widget.
 
    fText = fTextEdit->GetText()->AsString();
+   fMainFrame->UnmapWindow();
    fParent->RequestDraw();
 }
diff --git a/graf3d/gl/src/TGLAxisPainter.cxx b/graf3d/gl/src/TGLAxisPainter.cxx
index 1c57d0c..fb8a0da 100644
--- a/graf3d/gl/src/TGLAxisPainter.cxx
+++ b/graf3d/gl/src/TGLAxisPainter.cxx
@@ -47,7 +47,10 @@ TGLAxisPainter::TGLAxisPainter():
    fDir(1, 0, 0),
    fTMNDim(1),
    fLabelPixelFontSize(14),
-   fTitlePixelFontSize(14)
+   fTitlePixelFontSize(14),
+
+   fLabelAlignH(TGLFont::kCenterH),
+   fLabelAlignV(TGLFont::kCenterV)
 {
    // Constructor.
 }
@@ -61,6 +64,15 @@ TGLAxisPainter::~TGLAxisPainter()
 }
 
 //______________________________________________________________________________
+void TGLAxisPainter::SetLabelAlign(TGLFont::ETextAlignH_e h, TGLFont::ETextAlignV_e v)
+{
+   // Set label align.
+
+   fLabelAlignH = h;
+   fLabelAlignV = v;
+}
+
+//______________________________________________________________________________
 void TGLAxisPainter::LabelsLimits(const char *label, Int_t &first, Int_t &last) const
 {
    // Find first and last character of a label.
@@ -83,7 +95,8 @@ void TGLAxisPainter::FormAxisValue(Double_t  val, TString &s) const
    static char label[256];
 
    sprintf(label, &fFormat[0], val);
-   s =  label;
+   s = label;
+   s = s.Strip(TString::kLeading);
 
    if (s == "-." || s == "-0")
    {
@@ -99,7 +112,7 @@ void TGLAxisPainter::FormAxisValue(Double_t  val, TString &s) const
       s.Remove(ld + fDecimals);
 
    TPMERegexp zeroes("[-+]?0\\.0*$");
-   zeroes.Substitute(s, "0");   
+   zeroes.Substitute(s, "0");
 }
 
 //______________________________________________________________________________
@@ -189,57 +202,27 @@ void TGLAxisPainter::SetTextFormat(Double_t min, Double_t max, Double_t bw1)
 //
 // Utility functions.
 
-
-
 //______________________________________________________________________________
-void TGLAxisPainter::RnrText( const char* txt, const TGLVector3 &pos, const TGLFont::ETextAlign_e align, const TGLFont &font) const
+void TGLAxisPainter::RnrText(const TString &txt, const TGLVector3 &p, TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV, const TGLFont &font) const
 {
    // Render text at the given position. Offset depends of text aligment.
 
-   glPushMatrix();
-
-   glTranslatef(pos.X(), pos.Y(), pos.Z());
-   Float_t llx, lly, llz, urx, ury, urz;
-   font.BBox(txt, llx, lly, llz, urx, ury, urz);
-
-   Float_t x=0, y=0;
-   switch (align)
-   {
-      case TGLFont::kCenterUp:
-         if (txt[0] == '-')
-            urx += (urx-llx)/strlen(txt);
-         x = -urx*0.5; y = -ury;
-         break;
-      case TGLFont::kCenterDown:
-         if (txt[0] == '-')
-            urx += (urx-llx)/strlen(txt);
-         x = -urx*0.5; y = 0;
-         break;
-      case TGLFont::kRight:
-         x = -urx; y =(lly -ury)*0.5;
-         break;
-      case TGLFont::kLeft:
-         x = 0; y = -ury*0.5;
-         break;
-      default:
-         break;
-   };
-
-
    if (fFontMode == TGLFont::kPixmap || fFontMode ==  TGLFont::kBitmap)
    {
-      glRasterPos2i(0, 0);
-      glBitmap(0, 0, 0, 0, x, y, 0);
+     font.Render(txt, p.X(), p.Y(), p.Z(), aH, aV);
    }
    else
    {
+      // In case of non pixmap font, size is adjusted to the projected view in order to
+      // be visible on zoom out. In other words texture and polygon fonts imitate
+      // pixmap font behaviour.
+      glPushMatrix();
+      glTranslated(p.X(), p.Y(), p.Z());
       Double_t sc = fLabel3DFontSize/fLabelPixelFontSize;
       glScaled(sc, sc, 1);
-      glTranslatef(x, y, 0);
+      font.Render(txt, 0, 0, 0, aH, aV);
+      glPopMatrix();
    }
-
-   font.Render(txt);
-   glPopMatrix();
 }
 
 //______________________________________________________________________________
@@ -247,17 +230,9 @@ void TGLAxisPainter::SetLabelFont(TGLRnrCtx &rnrCtx, const char* fontName, Int_t
 {
    // Set label font derived from TAttAxis.
 
-   fLabelPixelFontSize = TGLFontManager::GetFontSize(fontSize);
+   rnrCtx.RegisterFontNoScale(fontSize, fontName, fFontMode, fLabelFont);
    fLabel3DFontSize = size3d;
-   if (fLabelFont.GetMode() == TGLFont::kUndef)
-   {
-      rnrCtx.RegisterFont(fLabelPixelFontSize, fontName, fFontMode, fLabelFont);
-   }
-   else if (fLabelFont.GetSize() != fontSize|| fLabelFont.GetFile() != fAttAxis->GetLabelFont() || fLabelFont.GetMode() != fFontMode )
-   {
-      rnrCtx.ReleaseFont(fLabelFont);
-      rnrCtx.RegisterFont(fLabelPixelFontSize, fontName, fFontMode, fLabelFont);
-   }
+   fLabelPixelFontSize = fLabelFont.GetSize();
 }
 
 //______________________________________________________________________________
@@ -280,7 +255,7 @@ void TGLAxisPainter::RnrLabels() const
    for (LabVec_t::const_iterator it = fLabVec.begin(); it != fLabVec.end(); ++it) {
       FormAxisValue((*it).second, s);
       p = (*it).first;
-      RnrText(s.Data(), fDir*p, fLabelAlign, fLabelFont);
+      RnrText(s, fDir*p, fLabelAlignH, fLabelAlignV, fLabelFont);
    }
 
    fLabelFont.PostRender();
@@ -293,31 +268,22 @@ void TGLAxisPainter::SetTitleFont(TGLRnrCtx &rnrCtx, const char* fontName,
 {
    // Set title font derived from TAttAxis.
 
-   fTitlePixelFontSize = TGLFontManager::GetFontSize(fontSize);
+   rnrCtx.RegisterFontNoScale(fontSize, fontName, fFontMode, fTitleFont);
+   fTitlePixelFontSize = fTitleFont.GetSize();
    fTitle3DFontSize = size3d;
-
-   if (fTitleFont.GetMode() == TGLFont::kUndef)
-   {
-      rnrCtx.RegisterFont(fontSize, fontName, fFontMode, fTitleFont);
-   }
-   else if (fTitleFont.GetSize() != fontSize|| fTitleFont.GetFile() != fAttAxis->GetTitleFont() || fTitleFont.GetMode() != fFontMode )
-   {
-      rnrCtx.ReleaseFont(fTitleFont);
-      rnrCtx.RegisterFont(fTitlePixelFontSize, fontName, fFontMode, fTitleFont);
-   }
 }
 
 //______________________________________________________________________________
-void TGLAxisPainter::RnrTitle(const char* txt, TGLVector3 &pos , TGLFont::ETextAlign_e align) const
+void TGLAxisPainter::RnrTitle(const TString &txt, TGLVector3 &pos , TGLFont::ETextAlignH_e aH, TGLFont::ETextAlignV_e aV) const
 {
    // Draw title at given position.
 
    if (fUseAxisColors)
       TGLUtil::Color(fAttAxis->GetTitleColor());
 
-   const char* title = (fExp) ? Form("%s [10^%d]", fExp, txt) : txt;
+   TString title = (fExp) ? Form("%s [10^%d]", txt.Data(), fExp) : txt;
    fTitleFont.PreRender();
-   RnrText(title, pos, align, fTitleFont);
+   RnrText(title, pos, aH, aV, fTitleFont);
    fTitleFont.PostRender();
 }
 
@@ -329,6 +295,7 @@ void TGLAxisPainter::RnrLines() const
    if (fUseAxisColors)
       TGLUtil::Color(fAttAxis->GetAxisColor());
 
+   TGLUtil::LineWidth(1);
    glBegin(GL_LINES);
 
    // Main line.
@@ -441,10 +408,10 @@ void TGLAxisPainter::PaintAxis(TGLRnrCtx &rnrCtx, TAxis* ax)
    const char* labFontName   = TGLFontManager::GetFontNameFromId(fAttAxis->GetLabelFont());
    const char* titleFontName = TGLFontManager::GetFontNameFromId(fAttAxis->GetTitleFont());
 
+   // pixel font size is set externaly for pixmap and bitmap fonts
+   // for texture and polygon fonts font size is set here, to get font resolution
    if (fFontMode == TGLFont::kPolygon || fFontMode == TGLFont::kTexture)
    {
-      // get sensible pixel resolution relative to projected axis length
-      // in pixmap for this is given explicitly
       GLdouble mm[16], pm[16];
       GLint    vp[4];
       glGetDoublev(GL_MODELVIEW_MATRIX,  mm);
@@ -458,8 +425,8 @@ void TGLAxisPainter::PaintAxis(TGLRnrCtx &rnrCtx, TAxis* ax)
                                  (up[1] - dn[1]) * (up[1] - dn[1]) +
                                  (up[2] - dn[2]) * (up[2] - dn[2]));
 
-      fLabelPixelFontSize = TMath::CeilNint(len*fAttAxis->GetLabelSize());
-      fTitlePixelFontSize = TMath::CeilNint(len*fAttAxis->GetTitleSize());
+      fLabelPixelFontSize = TMath::Nint(len*fAttAxis->GetLabelSize());
+      fTitlePixelFontSize = TMath::Nint(len*fAttAxis->GetTitleSize());
    }
 
    SetLabelFont(rnrCtx, labFontName,   fLabelPixelFontSize, (max - min)*fAttAxis->GetLabelSize());
@@ -476,7 +443,7 @@ void TGLAxisPainter::PaintAxis(TGLRnrCtx &rnrCtx, TAxis* ax)
    RnrLabels();
 
    if (ax->GetTitle())
-      RnrTitle(ax->GetTitle(), fTitlePos, fLabelAlign);
+      RnrTitle(ax->GetTitle(), fTitlePos, fLabelAlignH, fLabelAlignV);
 }
 
 
@@ -515,7 +482,7 @@ void TGLAxisPainterBox::SetAxis3DTitlePos(TGLRnrCtx &rnrCtx)
 
    Double_t y0 =  fAxis[1]->GetXmin();
    Double_t y1 =  fAxis[1]->GetXmax();
- 
+
    Double_t z0 =  fAxis[2]->GetXmin();
    Double_t z1 =  fAxis[2]->GetXmax();
 
@@ -611,17 +578,17 @@ void TGLAxisPainterBox::DrawAxis3D(TGLRnrCtx &rnrCtx)
    SetLabelPixelFontSize(TMath::CeilNint(len*fAxis[2]->GetLabelSize()));
    SetTitlePixelFontSize(TMath::CeilNint(len*fAxis[2]->GetTitleSize()));
 
- 
+
    // Z axis
-   //  
+   //
    // tickmark vector = 10 pixels left
    fAxis[2]->SetTickLength(1.); // leave this relative factor neutral
    TGLVertex3 worldRef(fAxisTitlePos[2].X(), fAxisTitlePos[2].Y(), fAxisTitlePos[2].Z());
    RefTMOff(0) = rnrCtx.RefCamera().ViewportDeltaToWorld(worldRef, -10, 0, &mm);
    SetTMNDim(1);
    RefDir().Set(0., 0., 1.);
-   SetLabelAlign(TGLFont::kRight);
-   glPushMatrix();  
+   SetLabelAlign(TGLFont::kRight,  TGLFont::kBottom);
+   glPushMatrix();
    glTranslatef(fAxisTitlePos[2].X(), fAxisTitlePos[2].Y(), 0);
    RefTitlePos().Set(RefTMOff(0).X(), RefTMOff(0).Y(),fAxisTitlePos[2].Z());
    PaintAxis(rnrCtx, fAxis[2]);
@@ -631,7 +598,7 @@ void TGLAxisPainterBox::DrawAxis3D(TGLRnrCtx &rnrCtx)
    //
    SetTMNDim(2);
    RefTMOff(1).Set(0, 0, fAxis[2]->GetXmin()- fAxis[2]->GetXmax());
-   SetLabelAlign(TGLFont::kCenterUp);
+   SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
    // X
    glPushMatrix();
    RefDir().Set(1, 0, 0);
diff --git a/graf3d/gl/src/TGLCamera.cxx b/graf3d/gl/src/TGLCamera.cxx
index 3644942..8bc8d08 100644
--- a/graf3d/gl/src/TGLCamera.cxx
+++ b/graf3d/gl/src/TGLCamera.cxx
@@ -832,6 +832,23 @@ void TGLCamera::SetCenterVec(Double_t x, Double_t y, Double_t z)
 }
 
 //______________________________________________________________________________
+void TGLCamera::SetCenterVecWarp(Double_t x, Double_t y, Double_t z)
+{
+   // Set camera center vector and do not keep the same combined
+   // camera transformation matrix.
+   // It appears as if the camera warped to the new center.
+
+   if (fExternalCenter)
+      fExtCenter.Set(x, y, z);
+   else
+      fDefCenter.Set(x, y, z);
+
+   fCamBase.SetBaseVec(4, *fCenter);
+
+   IncTimeStamp();
+}
+
+//______________________________________________________________________________
 Double_t TGLCamera::GetTheta() const
 {
    // Get angle between camera up axis.
diff --git a/graf3d/gl/src/TGLCameraOverlay.cxx b/graf3d/gl/src/TGLCameraOverlay.cxx
index 91a1e58..c84f5a8 100644
--- a/graf3d/gl/src/TGLCameraOverlay.cxx
+++ b/graf3d/gl/src/TGLCameraOverlay.cxx
@@ -57,6 +57,7 @@ TGLCameraOverlay::TGLCameraOverlay(Bool_t showOrtho, Bool_t showPersp) :
 
    fAxisPainter = new TGLAxisPainter();
    fAxisPainter->SetFontMode(TGLFont::kBitmap);
+   fAxisPainter->SetUseAxisColors(kFALSE);
 }
 
 //______________________________________________________________________________
@@ -105,14 +106,11 @@ void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx)
 
       TGLRect &vp = rnrCtx.GetCamera()->RefViewport();
       TGLFont font;
-      Int_t fs = TGLFontManager::GetFontSize((vp.Width()+vp.Height())*0.01);
-      rnrCtx.RegisterFont(fs, "arial", TGLFont::kPixmap, font);
-      Float_t bb[6];
+      Int_t fs = TMath::Nint(TMath::Sqrt(vp.Width()*vp.Width() + vp.Height()*vp.Height())*0.02);
+      rnrCtx.RegisterFontNoScale(fs, "arial", TGLFont::kPixmap, font);
       const char* txt = Form("(%f, %f, %f)", v[0], v[1], v[2]);
-      font.BBox(txt, bb[0], bb[1], bb[2], bb[3], bb[4], bb[5]);
-      Float_t off = 1.5*bb[4];
-      off /= vp.Height() ;
-      font.RenderBitmap(txt, 1 -off, 1-off, 0,TGLFont::kRight);
+      TGLUtil::Color(rnrCtx.ColorSet().Markup());
+      font.Render(txt, 0.98, 0.98, 0, TGLFont::kRight, TGLFont::kBottom);
 
       // render cross
       TGLUtil::Color(kRed);
@@ -148,7 +146,7 @@ void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx, Bool_t grid)
    fAxisPainter->SetAttAxis(fAxis);
    fAxisPainter->SetUseAxisColors(fUseAxisColors);
 
-   Color_t lineColor = fUseAxisColors ? fAxis->GetAxisColor() : rnrCtx.ColorSet().Foreground().GetColorIndex();
+   Color_t lineColor = fUseAxisColors ? fAxis->GetAxisColor() : rnrCtx.ColorSet().Markup().GetColorIndex();
 
    // font size calculated relative to viewport diagonal
    GLint   vp[4]; glGetIntegerv(GL_VIEWPORT, vp);
@@ -173,8 +171,8 @@ void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx, Bool_t grid)
    Double_t minY = fFrustum[1] + off;
    Double_t maxY = fFrustum[3] - off;
    // grid lines
-   Char_t alpha = 70; //primary
-   Char_t alpha2 = 80; //seconndary
+   Char_t alpha = 80; //primary
+   Char_t alpha2 = 90; //seconndary
    Int_t secSteps = fAxis->GetNdivisions() % 100;
    GLushort stipple =  0x5555; // 33333 more rare
 
@@ -189,19 +187,20 @@ void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx, Bool_t grid)
    // bottom
    glPushMatrix();
    glTranslated(vy1.X(), vy1.Y(), vy1.Z());
-   fAxisPainter->SetLabelAlign(TGLFont::kCenterDown);
+   fAxisPainter->SetLabelAlign(TGLFont::kCenterH, TGLFont::kTop);
    fAxisPainter->PaintAxis(rnrCtx, fAxis);
    glPopMatrix();
 
    // top
    glPushMatrix();
    glTranslated(vy2.X(), vy2.Y(), vy2.Z());
-   fAxisPainter->SetLabelAlign(TGLFont::kCenterUp);
+   fAxisPainter->SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
    fAxisPainter->RefTMOff(0).Negate();
    fAxisPainter->RnrLabels();
    fAxisPainter->RnrLines();
    glPopMatrix();
 
+   TGLUtil::LineWidth(1);
    if (grid)
    {
       TGLAxisPainter::LabVec_t& labs = fAxisPainter->RefLabVec();
@@ -268,13 +267,13 @@ void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx, Bool_t grid)
    // left
    glPushMatrix();
    glTranslated(vx1.X(), vx1.Y(), vx1.Z());
-   fAxisPainter->SetLabelAlign(TGLFont::kLeft);
+   fAxisPainter->SetLabelAlign(TGLFont::kLeft, TGLFont::kCenterV);
    fAxisPainter->PaintAxis(rnrCtx, fAxis);
    glPopMatrix();
    // right
    glPushMatrix();
    glTranslated(vx2.X(), vx2.Y(), vx2.Z());
-   fAxisPainter->SetLabelAlign(TGLFont::kRight);
+   fAxisPainter->SetLabelAlign(TGLFont::kRight, TGLFont::kCenterV);
    fAxisPainter->RefTMOff(0).Negate();
    fAxisPainter->RnrLabels();
    fAxisPainter->RnrLines();
@@ -366,6 +365,8 @@ void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx)
    xdir.Normalise();
    ydir.Normalise();
 
+   TGLUtil::Color(rnrCtx.ColorSet().Foreground());
+
    const char* txt = Form("%.*f", (exp < 0) ? -exp : 0, red);
    Float_t bb[6];
    TGLFont font;
@@ -377,7 +378,6 @@ void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx)
    v = xdir*(fFrustum[2]-barsize) + ydir*(fFrustum[3] - mH*1.5);
    glTranslated(v.X(), v.Y(), v.Z());
    glRasterPos2i(0,0);
-   TGLUtil::Color(kGray);
    font.Render(txt);
    glPopMatrix();
 
@@ -451,16 +451,18 @@ void TGLCameraOverlay::Render(TGLRnrCtx& rnrCtx)
    Float_t old_depth_range[2];
    glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
 
-   TGLUtil::Color(rnrCtx.ColorSet().Foreground());
+   TGLUtil::Color(rnrCtx.ColorSet().Markup());
 
    if (cam.IsOrthographic())
    {
       switch (fOrthographicMode)
       {
          case kBar:
+            glDepthRange(0, 0.1);
             RenderBar(rnrCtx);
             break;
          case kAxis:
+            glDepthRange(0, 0.1);
             RenderAxis(rnrCtx, kFALSE);
             break;
          case kGridFront:
diff --git a/graf3d/gl/src/TGLEmbeddedViewer.cxx b/graf3d/gl/src/TGLEmbeddedViewer.cxx
index 5b86773..57173f6 100644
--- a/graf3d/gl/src/TGLEmbeddedViewer.cxx
+++ b/graf3d/gl/src/TGLEmbeddedViewer.cxx
@@ -110,7 +110,7 @@ void TGLEmbeddedViewer::CreateFrames()
    fGLWidget = TGLWidget::Create(fFrame, kTRUE, kTRUE, 0, 10, 10);
 
    // Direct events from the TGWindow directly to the base viewer
-   fEventHandler = new TGLEventHandler("Default", 0, this);
+   fEventHandler = new TGLEventHandler(0, this);
    fGLWidget->SetEventHandler(fEventHandler);
 
    fFrame->AddFrame(fGLWidget, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY,
diff --git a/graf3d/gl/src/TGLEventHandler.cxx b/graf3d/gl/src/TGLEventHandler.cxx
index 916be7d..613155c 100644
--- a/graf3d/gl/src/TGLEventHandler.cxx
+++ b/graf3d/gl/src/TGLEventHandler.cxx
@@ -50,9 +50,8 @@
 ClassImp(TGLEventHandler);
 
 //______________________________________________________________________________
-TGLEventHandler::TGLEventHandler(const char *name, TGWindow *w, TObject *obj,
-                                 const char *title) :
-   TGEventHandler(name, w, obj, title),
+TGLEventHandler::TGLEventHandler(TGWindow *w, TObject *obj) :
+   TGEventHandler      ("TGLEventHandler", w, obj),
    fGLViewer           ((TGLViewer *)obj),
    fMouseTimer         (0),
    fLastPos            (-1, -1),
@@ -61,10 +60,12 @@ TGLEventHandler::TGLEventHandler(const char *name, TGWindow *w, TObject *obj,
    fTooltip            (0),
    fActiveButtonID     (0),
    fLastEventState     (0),
+   fIgnoreButtonUp     (kFALSE),
    fInPointerGrab      (kFALSE),
    fMouseTimerRunning  (kFALSE),
    fTooltipShown       (kFALSE),
-   fTooltipPixelTolerance (3)
+   fTooltipPixelTolerance (3),
+   fSecSelType(TGLViewer::kOnRequest)
 {
    // Constructor.
 
@@ -336,7 +337,7 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
                fGLViewer->CurrentCamera().SetCenterVec(v.X(), v.Y(), v.Z());
             }
             else
-            { 
+            {
                TGLSelectRecord& rec = fGLViewer->GetSelRec();
                TObject* obj = rec.GetObject();
                TGLRect& vp = fGLViewer->CurrentCamera().RefViewport();
@@ -378,8 +379,10 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
                   } else {
                      fGLViewer->SelectionChanged(); // Just notify clients.
                   }
-               } else if (event->fState & kKeyMod1Mask) {
-                  fGLViewer->RequestSelect(event->fX, event->fY, kTRUE);
+                  fIgnoreButtonUp = kTRUE;
+               } else if ((fSecSelType == TGLViewer::kOnRequest || fSecSelType == TGLViewer::kOnKeyMod1) && (event->fState & kKeyMod1Mask)) {
+                  fGLViewer->RequestSelect(event->fX, event->fY);
+                  fGLViewer->RequestSecondarySelect(event->fX, event->fY);
                   if (fGLViewer->fSecSelRec.GetPhysShape() != 0)
                   {
                      TGLLogicalShape& lshape = const_cast<TGLLogicalShape&>
@@ -387,8 +390,10 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
                      lshape.ProcessSelection(*fGLViewer->fRnrCtx, fGLViewer->fSecSelRec);
                      handled = kTRUE;
                   }
+                  fIgnoreButtonUp = kTRUE;
                }
-               if ( ! handled) {
+               if ( ! handled)
+               {
                   fGLViewer->fDragAction = TGLViewer::kDragCameraRotate;
                   grabPointer = kTRUE;
                   if (fMouseTimer) {
@@ -444,13 +449,19 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
    // Button UP
    else if (event->fType == kButtonRelease)
    {
+      if (fIgnoreButtonUp)
+      {
+         fIgnoreButtonUp = kFALSE;
+         return kTRUE;
+      }
+
       if (fInPointerGrab)
       {
          gVirtualX->GrabPointer(0, 0, 0, 0, kFALSE);
          fInPointerGrab = kFALSE;
       }
 
-      if (fGLViewer->GetPushAction() !=  TGLViewer::kPushStd)
+      if (fGLViewer->GetPushAction() != TGLViewer::kPushStd)
       {
          // This should be 'tool' dependant.
          fGLViewer->fPushAction = TGLViewer::kPushStd;
@@ -501,13 +512,46 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
           (eventSt.fCode == event->fCode))
       {
          TObject *obj = 0;
-         fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY, kFALSE);
+         fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
          TGLPhysicalShape *phys_shape = fGLViewer->fSelRec.GetPhysShape();
-         if (phys_shape) {
-            obj = phys_shape->GetLogical()->GetExternal();
+
+         if (phys_shape) obj = phys_shape->GetLogical()->GetExternal();
+      
+         // secondary selection
+         if (phys_shape && fSecSelType == TGLViewer::kOnRequest
+             && phys_shape->GetLogical()->AlwaysSecondarySelect())
+         {
+            fGLViewer->RequestSecondarySelect(fLastPos.fX, fLastPos.fY);
+            fGLViewer->fSecSelRec.SetMultiple(event->fState & kKeyControlMask);
+
+            if (fGLViewer->fSecSelRec.GetPhysShape() != 0)
+            {
+               TGLLogicalShape& lshape = const_cast<TGLLogicalShape&>
+                  (*fGLViewer->fSecSelRec.GetPhysShape()->GetLogical());
+
+               lshape.ProcessSelection(*fGLViewer->fRnrCtx, fGLViewer->fSecSelRec);
+               switch (fGLViewer->fSecSelRec.GetSecSelResult())
+               {
+                  case TGLSelectRecord::kEnteringSelection:
+                     fGLViewer->Clicked(obj, event->fCode, event->fState);
+                     break;
+                  case TGLSelectRecord::kLeavingSelection:
+                     fGLViewer->UnClicked(obj, event->fCode, event->fState);
+                     break;
+                  case TGLSelectRecord::kModifyingInternalSelection:
+                     fGLViewer->ReClicked(obj, event->fCode, event->fState);
+                     break;
+                  default:
+                     break;
+               };
+            }
          }
-         fGLViewer->Clicked(obj);
-         fGLViewer->Clicked(obj, event->fCode, event->fState);
+         else
+         {
+            fGLViewer->Clicked(obj);
+            fGLViewer->Clicked(obj, event->fCode, event->fState);
+         }
+
          eventSt.fX = 0;
          eventSt.fY = 0;
          eventSt.fCode = 0;
@@ -648,7 +692,7 @@ Bool_t TGLEventHandler::HandleKey(Event_t *event)
             break;
 
          case kKey_F1:
-            fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY, kFALSE);
+            fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
             fGLViewer->MouseIdle(fGLViewer->fSelRec.GetPhysShape(), (UInt_t)fLastPos.fX, (UInt_t)fLastPos.fY);
             break;
 
@@ -766,7 +810,8 @@ Bool_t TGLEventHandler::HandleMotion(Event_t * event)
    }
    else if (fGLViewer->fDragAction == TGLViewer::kDragOverlay)
    {
-      processed = fGLViewer->fCurrentOvlElm->Handle(*fGLViewer->fRnrCtx, fGLViewer->fOvlSelRec, event);
+      if (fGLViewer->fCurrentOvlElm)
+         processed = fGLViewer->fCurrentOvlElm->Handle(*fGLViewer->fRnrCtx, fGLViewer->fOvlSelRec, event);
    }
 
    fLastPos.fX = event->fX;
@@ -814,7 +859,7 @@ Bool_t TGLEventHandler::HandleTimer(TTimer *t)
    {
       if (fLastMouseOverPos != fLastPos)
       {
-         fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY, kFALSE);
+         fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
          if (fLastMouseOverShape != fGLViewer->fSelRec.GetPhysShape())
          {
             fLastMouseOverShape = fGLViewer->fSelRec.GetPhysShape();
diff --git a/graf3d/gl/src/TGLFontManager.cxx b/graf3d/gl/src/TGLFontManager.cxx
index c4a5d4c..a9d9764 100644
--- a/graf3d/gl/src/TGLFontManager.cxx
+++ b/graf3d/gl/src/TGLFontManager.cxx
@@ -153,7 +153,7 @@ void TGLFont::BBox(const char* txt,
 }
 
 //______________________________________________________________________________
-void TGLFont::Render(const char* txt) const
+void TGLFont::Render(const TString &txt) const
 {
    // Render text.
 
@@ -175,40 +175,54 @@ void TGLFont::Render(const char* txt) const
 }
 
 //______________________________________________________________________________
-void TGLFont::RenderBitmap(const char* txt, Float_t xs, Float_t ys, Float_t zs, ETextAlign_e align) const
+void  TGLFont:: Render(const TString &txt, Float_t x, Float_t y, Float_t z,
+             ETextAlignH_e alignH, ETextAlignV_e alignV) const
 {
-   // Render text at the given position. Offset depends of text aligment.
+   // Render text with given alignmentrepl and at given position.
 
    glPushMatrix();
-   glTranslatef(xs, ys, zs);
 
+   glTranslatef(x, y, z);
+
+   x=0, y=0;
    Float_t llx, lly, llz, urx, ury, urz;
    BBox(txt, llx, lly, llz, urx, ury, urz);
-   if (txt[0] == '-')
-      urx += (urx-llx)/strlen(txt);
 
-   Float_t x=0, y=0;
-   switch (align)
+   switch (alignH)
    {
-      case kCenterUp:
-         x = -urx*0.5; y = -ury;
+      case TGLFont::kRight:
+         x = -urx;
+         break;
+
+      case  TGLFont::kCenterH:
+         x = -urx*0.5;
          break;
-      case kCenterDown:
-         x = -urx*0.5; y = 0;
+      default:
          break;
-      case kRight:
-         x = -urx; y =(lly -ury)*0.5;
+   };
+
+   switch (alignV)
+   {
+      case TGLFont::kBottom:
+         y = -ury;
          break;
-      case kLeft:
-         x = 0; y = -ury*0.5;
+      case  TGLFont::kCenterV:
+         y = -ury*0.5;
          break;
       default:
          break;
    };
-   glRasterPos2i(0, 0);
-   glBitmap(0, 0, 0, 0, x, y, 0);
-   Render(txt);
 
+   if (fMode == TGLFont::kPixmap || fMode ==  TGLFont::kBitmap)
+   {
+      glRasterPos2i(0, 0);
+      glBitmap(0, 0, 0, 0, x, y, 0);
+   }
+   else
+   {
+      glTranslatef(x, y, 0);
+   }
+   Render(txt);
    glPopMatrix();
 }
 
@@ -289,12 +303,16 @@ TGLFontManager::~TGLFontManager()
 }
 
 //______________________________________________________________________________
-void TGLFontManager::RegisterFont(Int_t size, Int_t fileID, TGLFont::EMode mode, TGLFont &out)
+void TGLFontManager::RegisterFont(Int_t sizeIn, Int_t fileID, TGLFont::EMode mode, TGLFont &out)
 {
    // Provide font with given size, file and FTGL class.
 
    if (fgStaticInitDone == kFALSE) InitStatics();
 
+   Int_t  size = GetFontSize(sizeIn);
+   if (mode == out.GetMode() && fileID == out.GetFile() && size == out.GetSize())
+      return;
+
    FontMap_i it = fFontMap.find(TGLFont(size, fileID, mode));
    if (it == fFontMap.end())
    {
@@ -411,7 +429,7 @@ TGLFontManager::FontSizeVec_t* TGLFontManager::GetFontSizeArray()
 }
 
 //______________________________________________________________________________
-Int_t TGLFontManager::GetFontSize(Float_t ds)
+Int_t TGLFontManager::GetFontSize(Int_t ds)
 {
    // Get availabe font size.
 
@@ -424,7 +442,7 @@ Int_t TGLFontManager::GetFontSize(Float_t ds)
 }
 
 //______________________________________________________________________________
-Int_t TGLFontManager::GetFontSize(Float_t ds, Int_t min, Int_t max)
+Int_t TGLFontManager::GetFontSize(Int_t ds, Int_t min, Int_t max)
 {
    // Get availabe font size.
 
@@ -454,7 +472,7 @@ void TGLFontManager::InitStatics()
    fgFontFileArray.Add(new TObjString("timesi"));   //  10
    fgFontFileArray.Add(new TObjString("timesbd"));  //  20
    fgFontFileArray.Add(new TObjString("timesbi"));  //  30
- 
+
    fgFontFileArray.Add(new TObjString("arial"));    //  40
    fgFontFileArray.Add(new TObjString("ariali"));   //  50
    fgFontFileArray.Add(new TObjString("arialbd"));  //  60
diff --git a/graf3d/gl/src/TGLLogicalShape.cxx b/graf3d/gl/src/TGLLogicalShape.cxx
index 504a886..f93a82a 100644
--- a/graf3d/gl/src/TGLLogicalShape.cxx
+++ b/graf3d/gl/src/TGLLogicalShape.cxx
@@ -5,6 +5,7 @@
 #include "TGLPhysicalShape.h"
 #include "TGLRnrCtx.h"
 #include "TGLScene.h"
+#include "TGLCamera.h"
 #include "TGLSelectRecord.h"
 #include "TGLContext.h"
 #include "TGLIncludes.h"
@@ -268,7 +269,7 @@ Bool_t TGLLogicalShape::SetDLCache(Bool_t cache)
 }
 
 //______________________________________________________________________________
-Bool_t TGLLogicalShape::ShouldDLCache(const TGLRnrCtx & rnrCtx) const
+Bool_t TGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const
 {
    // Returns kTRUE if draws should be display list cached
    // kFALSE otherwise.
@@ -360,7 +361,7 @@ Short_t TGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD,
 }
 
 //______________________________________________________________________________
-void TGLLogicalShape::Draw(TGLRnrCtx & rnrCtx) const
+void TGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const
 {
    // Draw the GL drawable, using draw flags. If DL caching is enabled
    // (see SetDLCache) then attempt to draw from the cache, if not found
@@ -414,9 +415,47 @@ entry_point:
    }
 }
 
+//______________________________________________________________________________
+void TGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx,const TGLPhysicalShape* pshp) const
+{
+   // Draw the logical shape in highlight mode.
+
+   const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+   Int_t inner[4][2] = { { 0,-1}, { 1, 0}, { 0, 1}, {-1, 0} };
+   Int_t outer[8][2] = { {-1,-1}, { 1,-1}, { 1, 1}, {-1, 1},
+                         { 0,-2}, { 2, 0}, { 0, 2}, {-2, 0} };
+
+   rnrCtx.SetHighlightOutline(kTRUE);
+   TGLUtil::LockColor();
+   Int_t first_outer = (rnrCtx.CombiLOD() == TGLRnrCtx::kLODHigh) ? 0 : 4;
+   for (int i = first_outer; i < 8; ++i)
+   {
+      glViewport(vp.X() + outer[i][0], vp.Y() + outer[i][1], vp.Width(), vp.Height());
+      glColor4ubv(rnrCtx.ColorSet().Selection(pshp->GetSelected()).CArr());
+      Draw(rnrCtx);
+   }
+   TGLUtil::UnlockColor();
+   rnrCtx.SetHighlightOutline(kFALSE);
+
+   pshp->SetupGLColors(rnrCtx);
+   for (int i = 0; i < 4; ++i)
+   {
+      glViewport(vp.X() + inner[i][0], vp.Y() + inner[i][1], vp.Width(), vp.Height());
+      glColor4fv(pshp->Color());
+      Draw(rnrCtx);
+   }
+   glViewport(vp.X(), vp.Y(), vp.Width(), vp.Height());
+
+   pshp->SetupGLColors(rnrCtx);
+   Float_t dr[2];
+   glGetFloatv(GL_DEPTH_RANGE,dr);
+   glDepthRange(dr[0], 0.5*dr[1]);
+   Draw(rnrCtx);
+   glDepthRange(dr[0], dr[1]);
+}
 
 //______________________________________________________________________________
-void TGLLogicalShape::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord & rec)
+void TGLLogicalShape::ProcessSelection(TGLRnrCtx& /*rnrCtx*/, TGLSelectRecord& rec)
 {
    // Virtual method called-back after a secondary selection hit
    // is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).
@@ -432,7 +471,7 @@ void TGLLogicalShape::ProcessSelection(TGLRnrCtx & /*rnrCtx*/, TGLSelectRecord &
 }
 
 //______________________________________________________________________________
-void TGLLogicalShape::InvokeContextMenu(TContextMenu & menu, UInt_t x, UInt_t y) const
+void TGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const
 {
    // Invoke popup menu or our bound external TObject (if any), using passed
    // 'menu' object, at location 'x' 'y'
diff --git a/graf3d/gl/src/TGLOverlayButton.cxx b/graf3d/gl/src/TGLOverlayButton.cxx
index 665945c..2642e9b 100644
--- a/graf3d/gl/src/TGLOverlayButton.cxx
+++ b/graf3d/gl/src/TGLOverlayButton.cxx
@@ -11,6 +11,7 @@
 
 #include "TGLOverlayButton.h"
 #include "TColor.h"
+#include "TMath.h"
 
 #include <TGLRnrCtx.h>
 #include <TGLIncludes.h>
@@ -83,17 +84,7 @@ void TGLOverlayButton::Render(TGLRnrCtx& rnrCtx)
    glPushName(0);
 
    // Text rendering
-   Float_t cfs = fHeight*0.8;
-   Int_t fs = TGLFontManager::GetFontSize(cfs);
-   if (fFont.GetMode() == TGLFont::kUndef)
-   {
-      rnrCtx.RegisterFont(fs, "arial",  TGLFont::kPixmap, fFont);
-   }
-   else if (fFont.GetSize() != fs)
-   {
-      rnrCtx.ReleaseFont(fFont);
-      rnrCtx.RegisterFont(fs, "arial",  TGLFont::kPixmap, fFont);
-   }
+   rnrCtx.RegisterFontNoScale(TMath::Nint(fHeight*0.8), "arial",  TGLFont::kPixmap, fFont);
    fFont.PreRender(kFALSE);
 
    TColor::Pixel2RGB(fTextColor, r, g, b);
diff --git a/graf3d/gl/src/TGLPhysicalShape.cxx b/graf3d/gl/src/TGLPhysicalShape.cxx
index 6149835..60e764c 100644
--- a/graf3d/gl/src/TGLPhysicalShape.cxx
+++ b/graf3d/gl/src/TGLPhysicalShape.cxx
@@ -372,44 +372,9 @@ void TGLPhysicalShape::Draw(TGLRnrCtx & rnrCtx) const
    glPushMatrix();
    glMultMatrixd(fTransform.CArr());
    if (fInvertedWind)  glFrontFace(GL_CW);
-   if (fSelected && !rnrCtx.Selection() && !rnrCtx.IsDrawPassOutlineLine())
+   if (rnrCtx.Highlight() && !rnrCtx.Selection() && !rnrCtx.IsDrawPassOutlineLine())
    {
-      const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
-      Int_t inner[4][2] = { { 0,-1}, { 1, 0}, { 0, 1}, {-1, 0} };
-      Int_t outer[8][2] = { {-1,-1}, { 1,-1}, { 1, 1}, {-1, 1},
-                            { 0,-2}, { 2, 0}, { 0, 2}, {-2, 0} };
-
-      // TGLCapabilitySwitch bs(GL_BLEND, kTRUE), lss(GL_LINE_SMOOTH, kTRUE);
-
-      rnrCtx.SetHighlight(kTRUE);
-      rnrCtx.SetHighlightOutline(kTRUE);
-      TGLUtil::LockColor();
-      Int_t first_outer = (rnrCtx.CombiLOD() == TGLRnrCtx::kLODHigh) ? 0 : 4;
-      for (int i = first_outer; i < 8; ++i)
-      {
-         glViewport(vp.X() + outer[i][0], vp.Y() + outer[i][1], vp.Width(), vp.Height());
-         glColor4ubv(rnrCtx.ColorSet().Selection(fSelected).CArr());
-         fLogicalShape->Draw(rnrCtx);
-      }
-      TGLUtil::UnlockColor();
-      rnrCtx.SetHighlightOutline(kFALSE);
-
-      SetupGLColors(rnrCtx);
-      for (int i = 0; i < 4; ++i)
-      {
-         glViewport(vp.X() + inner[i][0], vp.Y() + inner[i][1], vp.Width(), vp.Height());
-         glColor4fv(fColor);
-         fLogicalShape->Draw(rnrCtx);
-      }
-      glViewport(vp.X(), vp.Y(), vp.Width(), vp.Height());
-      rnrCtx.SetHighlight(kFALSE);
-
-      SetupGLColors(rnrCtx);
-      Float_t dr[2];
-      glGetFloatv(GL_DEPTH_RANGE,dr);
-      glDepthRange(dr[0], 0.5*dr[1]);
-      fLogicalShape->Draw(rnrCtx);
-      glDepthRange(dr[0], dr[1]);
+      fLogicalShape->DrawHighlight(rnrCtx, this);
    }
    else
    {
@@ -420,7 +385,7 @@ void TGLPhysicalShape::Draw(TGLRnrCtx & rnrCtx) const
       if (rnrCtx.IsDrawPassOutlineLine())
          TGLUtil::UnlockColor();
    }
-   if (fInvertedWind)  glFrontFace(GL_CCW);
+   if (fInvertedWind) glFrontFace(GL_CCW);
    glPopMatrix();
 }
 
diff --git a/graf3d/gl/src/TGLRnrCtx.cxx b/graf3d/gl/src/TGLRnrCtx.cxx
index f633653..d5fc671 100644
--- a/graf3d/gl/src/TGLRnrCtx.cxx
+++ b/graf3d/gl/src/TGLRnrCtx.cxx
@@ -23,6 +23,7 @@
 
 #include "TError.h"
 #include "TMathBase.h"
+#include "TMath.h"
 
 #include <list>
 #include <algorithm>
@@ -93,6 +94,7 @@ TGLRnrCtx::TGLRnrCtx(TGLViewerBase* viewer) :
    fQuadric       (0),
 
    fGrabImage     (kFALSE),
+   fGrabBuffer    (-1),
    fGrabbedImage  (0)
 {
    // Constructor.
@@ -351,30 +353,47 @@ void TGLRnrCtx::CloseDLCapture()
 /******************************************************************************/
 // TGLFont interface
 /******************************************************************************/
+//______________________________________________________________________
+void TGLRnrCtx::ReleaseFont(TGLFont& font)
+{
+   // Release font in the GL rendering context.
+
+   fGLCtxIdentity->GetFontManager()->ReleaseFont(font);
+}
 
 //______________________________________________________________________
-void TGLRnrCtx::RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out)
+void TGLRnrCtx::RegisterFontNoScale(Int_t size, Int_t file, Int_t mode, TGLFont& out)
 {
    // Get font in the GL rendering context.
 
-   fGLCtxIdentity->GetFontManager()->RegisterFont(size, file, (TGLFont::EMode)mode, out);
+   fGLCtxIdentity->GetFontManager()->RegisterFont( size, file, (TGLFont::EMode)mode, out);
 }
 
 //______________________________________________________________________
-void TGLRnrCtx::RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out)
+void TGLRnrCtx::RegisterFontNoScale(Int_t size, const char* name, Int_t mode, TGLFont& out)
 {
    // Get font in the GL rendering context.
 
    fGLCtxIdentity->GetFontManager()->RegisterFont(size, name, (TGLFont::EMode)mode, out);
 }
+
 //______________________________________________________________________
-void TGLRnrCtx::ReleaseFont(TGLFont& font)
+void TGLRnrCtx::RegisterFont(Int_t size, Int_t file, Int_t mode, TGLFont& out)
 {
-   // Release font in the GL rendering context.
+   // Get font in the GL rendering context.
+   // The font is scaled relative to current render scale.
 
-   fGLCtxIdentity->GetFontManager()->ReleaseFont(font);
+  RegisterFontNoScale(TMath::Nint(size*fRenderScale), file, mode, out);
 }
 
+//______________________________________________________________________
+void TGLRnrCtx::RegisterFont(Int_t size, const char* name, Int_t mode, TGLFont& out)
+{
+   // Get font in the GL rendering context.
+   // The font is scaled relative to current render scale.
+
+  RegisterFontNoScale(TMath::Nint(size*fRenderScale), name, mode, out);
+}
 
 /**************************************************************************/
 // Static helpers
diff --git a/graf3d/gl/src/TGLSAViewer.cxx b/graf3d/gl/src/TGLSAViewer.cxx
index 6e005ac..6a233b9 100644
--- a/graf3d/gl/src/TGLSAViewer.cxx
+++ b/graf3d/gl/src/TGLSAViewer.cxx
@@ -409,7 +409,7 @@ void TGLSAViewer::CreateFrames()
 
    fGLWidget = TGLWidget::Create(fRightVerticalFrame, kTRUE, kTRUE, 0, 10, 10);
 
-   SetEventHandler(new TGLEventHandler("Default", 0, this));
+   SetEventHandler(new TGLEventHandler(0, this));
 
    fRightVerticalFrame->AddFrame(fGLWidget, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));
 }
diff --git a/graf3d/gl/src/TGLSelectRecord.cxx b/graf3d/gl/src/TGLSelectRecord.cxx
index 447b9e2..0f97838 100644
--- a/graf3d/gl/src/TGLSelectRecord.cxx
+++ b/graf3d/gl/src/TGLSelectRecord.cxx
@@ -156,7 +156,9 @@ TGLSelectRecord::TGLSelectRecord() :
    fSceneInfo   (0),
    fPhysShape   (0),
    fObject      (0),
-   fSpecific    (0)
+   fSpecific    (0),
+   fMultiple    (0),
+   fSecSelRes   (kNone)
 {
    // Default constructor.
 }
@@ -168,7 +170,9 @@ TGLSelectRecord::TGLSelectRecord(UInt_t* data) :
    fSceneInfo   (0),
    fPhysShape   (0),
    fObject      (0),
-   fSpecific    (0)
+   fSpecific    (0),
+   fMultiple    (0),
+   fSecSelRes   (kNone)
 {
    // Constructor from raw GL-select record.
 }
@@ -180,7 +184,9 @@ TGLSelectRecord::TGLSelectRecord(const TGLSelectRecord& rec) :
    fSceneInfo   (rec.fSceneInfo),
    fPhysShape   (rec.fPhysShape),
    fObject      (rec.fObject),
-   fSpecific    (rec.fSpecific)
+   fSpecific    (rec.fSpecific),
+   fMultiple    (rec.fMultiple),
+   fSecSelRes   (kNone)
 {
    // Copy constructor.
 }
@@ -204,6 +210,8 @@ TGLSelectRecord& TGLSelectRecord::operator=(const TGLSelectRecord& rec)
       fPhysShape   = rec.fPhysShape;
       fObject      = rec.fObject;
       fSpecific    = rec.fSpecific;
+      fMultiple    = rec.fMultiple;
+      fSecSelRes   = rec.fSecSelRes;
    }
    return *this;
 }
@@ -220,6 +228,8 @@ void TGLSelectRecord::Set(UInt_t* data)
    fPhysShape   = 0;
    fObject      = 0;
    fSpecific    = 0;
+   fMultiple    = 0;
+   fSecSelRes   = kNone;
 }
 
 //______________________________________________________________________________
@@ -233,6 +243,8 @@ void TGLSelectRecord::Reset()
    fPhysShape   = 0;
    fObject      = 0;
    fSpecific    = 0;
+   fMultiple    = 0;
+   fSecSelRes   = kNone;
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/gl/src/TGLViewer.cxx b/graf3d/gl/src/TGLViewer.cxx
index be2c696..f1c5780 100644
--- a/graf3d/gl/src/TGLViewer.cxx
+++ b/graf3d/gl/src/TGLViewer.cxx
@@ -46,12 +46,14 @@
 #include "TVirtualGL.h"
 
 #include "TGLWidget.h"
+// #include "TGLFBO.h"
 #include "TGLViewerEditor.h"
 
 #include "KeySymbols.h"
 #include "TContextMenu.h"
 #include "TImage.h"
 
+#include <stdexcept>
 
 #ifndef GL_BGRA
 #define GL_BGRA GL_BGRA_EXT
@@ -119,7 +121,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad, Int_t x, Int_t y,
    fRedrawTimer(0),
    fMaxSceneDrawTimeHQ(5000),
    fMaxSceneDrawTimeLQ(100),
-   fPointScale (1), fLineScale(1),
+   fPointScale (1), fLineScale(1), fSmoothPoints(kFALSE), fSmoothLines(kFALSE),
    fAxesType(TGLUtil::kAxesNone),
    fAxesDepthTest(kTRUE),
    fReferenceOn(kFALSE),
@@ -176,7 +178,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad) :
    fRedrawTimer(0),
    fMaxSceneDrawTimeHQ(5000),
    fMaxSceneDrawTimeLQ(100),
-   fPointScale (1), fLineScale(1),
+   fPointScale (1), fLineScale(1), fSmoothPoints(kFALSE), fSmoothLines(kFALSE),
    fAxesType(TGLUtil::kAxesNone),
    fAxesDepthTest(kTRUE),
    fReferenceOn(kFALSE),
@@ -469,6 +471,9 @@ void TGLViewer::PreRender()
    TGLUtil::SetPointSizeScale(fPointScale * fRnrCtx->GetRenderScale());
    TGLUtil::SetLineWidthScale(fLineScale  * fRnrCtx->GetRenderScale());
 
+   if (fSmoothPoints) glEnable(GL_POINT_SMOOTH); else glDisable(GL_POINT_SMOOTH);
+   if (fSmoothLines)  glEnable(GL_LINE_SMOOTH);  else glDisable(GL_LINE_SMOOTH);
+
    TGLViewerBase::PreRender();
 
    // Setup lighting
@@ -544,12 +549,14 @@ void TGLViewer::DoDraw()
    if (fFader < 1)
    {
       RenderNonSelected();
+      RenderSelected();
       DrawGuides();
       RenderOverlay();
 
       glClear(GL_DEPTH_BUFFER_BIT);
+      fRnrCtx->SetHighlight(kTRUE);
       RenderSelected();
-
+      fRnrCtx->SetHighlight(kFALSE);
       glClear(GL_DEPTH_BUFFER_BIT);
       DrawDebugInfo();
    }
@@ -588,6 +595,16 @@ void TGLViewer::DoDraw()
 }
 
 //______________________________________________________________________________
+Bool_t TGLViewer::SavePicture()
+{
+   // Save current image using the defualt file name which can be set
+   // via SetPictureFileName() and defaults to "viewer.jpg".
+   // Really useful for the files ending with 'gif+'.
+
+   return SavePicture(fPictureFileName);
+}
+
+//______________________________________________________________________________
 Bool_t TGLViewer::SavePicture(const TString &fileName)
 {
    // Save current image in various formats (gif, gif+, jpg, png, eps, pdf).
@@ -597,58 +614,210 @@ Bool_t TGLViewer::SavePicture(const TString &fileName)
    // can be covered by other windows.
    // Returns false if something obvious goes wrong, true otherwise.
 
-   if (fileName.EndsWith(".gif") || fileName.EndsWith(".gif+") ||
-       fileName.EndsWith(".jpg") || fileName.EndsWith(".png"))
+   if (fileName.EndsWith(".eps"))
    {
-      if ( ! TakeLock(kDrawLock)) {
-         Error("TGLViewer::SavePicture", "viewer locked - try later.");
-         return kFALSE;
+      return TGLOutput::Capture(*this, TGLOutput::kEPS_BSP, fileName.Data());
+   }
+   else if (fileName.EndsWith(".pdf"))
+   {
+      return TGLOutput::Capture(*this, TGLOutput::kPDF_BSP, fileName.Data());
+   }
+   else
+   {
+      /*
+      if (GLEW_VERSION_1_5)
+      {
+         return SavePictureUsingFBO(fileName, fViewport.Width(), fViewport.Height(), kFALSE);
+      }
+      else
+      {
+         return SavePictureUsingBB(fileName);
       }
+      */
+      return SavePictureUsingBB(fileName);
+   }
+}
+
+//______________________________________________________________________________
+Bool_t TGLViewer::SavePictureUsingBB(const TString &fileName)
+{
+   // Save current image in various formats (gif, gif+, jpg, png).
+   // 'gif+' will append image to an existng file (animated gif).
+   // Back-Buffer is used for capturing of the image.
+   // The viewer window most be fully contained within the desktop but
+   // can be covered by other windows.
+   // Returns false if something obvious goes wrong, true otherwise.
 
-      std::auto_ptr<TImage> image(TImage::Create());
+   static const TString eh("TGLViewer::SavePictureUsingBB");
 
-      fRnrCtx->SetGrabImage(kTRUE);
+   if (! fileName.EndsWith(".gif") && ! fileName.EndsWith(".gif+") &&
+       ! fileName.EndsWith(".jpg") && ! fileName.EndsWith(".png"))
+   {
+      Warning(eh, "file %s cannot be saved with this extension.", fileName.Data());
+      return kFALSE;
+   }
 
-      fLOD = TGLRnrCtx::kLODHigh;
+   if ( ! TakeLock(kDrawLock)) {
+      Error(eh, "viewer locked - try later.");
+      return kFALSE;
+   }
 
-      if (!gVirtualX->IsCmdThread())
-         gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoDraw()", this));
-      else
-         DoDraw();
+   std::auto_ptr<TImage> image(TImage::Create());
 
-      image->FromGLBuffer(fRnrCtx->GetGrabbedImage(), fViewport.Width(), fViewport.Height());
+   fRnrCtx->SetGrabImage(kTRUE, GL_BACK);
 
-      fRnrCtx->SetGrabImage(kFALSE);
-      delete [] fRnrCtx->GetGrabbedImage();
-      fRnrCtx->SetGrabbedImage(0);
+   fLOD = TGLRnrCtx::kLODHigh;
 
-      image->WriteImage(fileName.Data());
+   if (!gVirtualX->IsCmdThread())
+      gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoDraw()", this));
+   else
+      DoDraw();
+
+   image->FromGLBuffer(fRnrCtx->GetGrabbedImage(), fViewport.Width(), fViewport.Height());
+
+   fRnrCtx->SetGrabImage(kFALSE);
+   delete [] fRnrCtx->GetGrabbedImage();
+   fRnrCtx->SetGrabbedImage(0);
+
+   image->WriteImage(fileName.Data());
+
+   return kTRUE;
+}
+
+//______________________________________________________________________________
+/*
+Bool_t TGLViewer::SavePictureUsingFBO(const TString &fileName, Int_t w, Int_t h,
+                                      Float_t pixel_object_scale)
+*/
+Bool_t TGLViewer::SavePictureUsingFBO(const TString &, Int_t, Int_t, Float_t)
+{
+   // Save current image in various formats (gif, gif+, jpg, png).
+   // 'gif+' will append image to an existng file (animated gif).
+   // Frame-Buffer-Object is used for capturing of the image - OpenGL
+   // 1.5 is required.
+   // The viewer window does not have to be visible at all.
+   // Returns false if something obvious goes wrong, true otherwise.
+   //
+   // pixel_object_scale is used to scale (as much as possible) the
+   // objects whose representation size is pixel based (point-sizes,
+   // line-widths, bitmap/pixmap font-sizes).
+   // If set to 0 (default) no scaling is applied.
+
+   static const TString eh("TGLViewer::SavePictureUsingFBO");
+
+   throw eh + "frame-buffer objects not supported on fireworks branch.";
+
+   /*
+   if (! fileName.EndsWith(".gif") && ! fileName.EndsWith(".gif+") &&
+       ! fileName.EndsWith(".jpg") && ! fileName.EndsWith(".png"))
+   {
+      Warning(eh, "file %s cannot be saved with this extension.", fileName.Data());
+      return kFALSE;
    }
-   else if (fileName.EndsWith(".eps"))
+
+   if ( ! TakeLock(kDrawLock)) {
+      Error(eh, "viewer locked - try later.");
+      return kFALSE;
+   }
+
+   std::auto_ptr<TImage> image(TImage::Create());
+
+   MakeCurrent();
+
+   TGLFBO *fbo = new TGLFBO();
+   try
    {
-      TGLOutput::Capture(*this, TGLOutput::kEPS_BSP, fileName.Data());
+      fbo->Init(w, h);
    }
-   else if (fileName.EndsWith(".pdf"))
+   catch (std::runtime_error& exc)
    {
-      TGLOutput::Capture(*this, TGLOutput::kPDF_BSP, fileName.Data());
+      Error(eh, exc.what());
+      return kFALSE;
    }
+
+   TGLRect old_vp(fViewport);
+   SetViewport(0, 0, w, h);
+
+   Float_t old_scale = 1;
+   if (pixel_object_scale != 0)
+   {
+      old_scale = fRnrCtx->GetRenderScale();
+      fRnrCtx->SetRenderScale(old_scale * pixel_object_scale);
+   }
+
+   fRnrCtx->SetGrabImage(kTRUE, 0);
+
+   fLOD = TGLRnrCtx::kLODHigh;
+
+   fbo->Bind();
+
+   if (!gVirtualX->IsCmdThread())
+      gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoDraw()", this));
    else
+      DoDraw();
+
+   fbo->Unbind();
+   delete fbo;
+
+   image->FromGLBuffer(fRnrCtx->GetGrabbedImage(), fViewport.Width(), fViewport.Height());
+
+   fRnrCtx->SetGrabImage(kFALSE);
+   delete [] fRnrCtx->GetGrabbedImage();
+   fRnrCtx->SetGrabbedImage(0);
+
+   image->WriteImage(fileName.Data());
+
+   if (pixel_object_scale != 0)
    {
-      Warning("TGLViewer::SavePicture",
-              "file %s cannot be saved with this extension.", fileName.Data());
-      return kFALSE;
+      fRnrCtx->SetRenderScale(old_scale);
    }
+
+   SetViewport(old_vp);
+
    return kTRUE;
+   */
 }
 
 //______________________________________________________________________________
-Bool_t TGLViewer::SavePicture()
+Bool_t TGLViewer::SavePictureWidth(const TString &fileName, Int_t width,
+                                   Bool_t pixel_object_scale)
 {
-   // Save current image using the defualt file name which can be set
-   // via SetPictureFileName() and defaults to "viewer.jpg".
-   // Really useful for the files ending with 'gif+'.
+   // Save picture with given width (height scaled proportinally).
+   // If pixel_object_scale is true (default), the corresponding
+   // scaling gets calculated from the current window size.
 
-   return SavePicture(fPictureFileName);
+   Float_t scale  = Float_t(width) / fViewport.Width();
+   Int_t   height = TMath::Nint(scale*fViewport.Height());
+
+   return SavePictureUsingFBO(fileName, width, height, pixel_object_scale ? scale : 0);
+}
+
+//______________________________________________________________________________
+Bool_t TGLViewer::SavePictureHeight(const TString &fileName, Int_t height,
+                                    Bool_t pixel_object_scale)
+{
+   // Save picture with given height (width scaled proportinally).
+   // If pixel_object_scale is true (default), the corresponding
+   // scaling gets calculated from the current window size.
+
+   Float_t scale = Float_t(height) / fViewport.Height();
+   Int_t   width = TMath::Nint(scale*fViewport.Width());
+
+   return SavePictureUsingFBO(fileName, width, height, pixel_object_scale ? scale : 0);
+}
+
+//______________________________________________________________________________
+Bool_t TGLViewer::SavePictureScale (const TString &fileName, Float_t scale,
+                                    Bool_t pixel_object_scale)
+{
+   // Save picture with given scale to current window size.
+   // If pixel_object_scale is true (default), the same scaling is
+   // used.
+
+   Int_t w = TMath::Nint(scale*fViewport.Width());
+   Int_t h = TMath::Nint(scale*fViewport.Height());
+
+   return SavePictureUsingFBO(fileName, w, h, pixel_object_scale ? scale : 0);
 }
 
 //______________________________________________________________________________
@@ -750,7 +919,10 @@ void TGLViewer::PostDraw()
    if (fRnrCtx->GetGrabImage())
    {
       UChar_t* xx = new UChar_t[4 * fViewport.Width() * fViewport.Height()];
-      glReadBuffer(GL_BACK);
+      if (fRnrCtx->GetGrabBuffer() != 0)
+      {
+         glReadBuffer(fRnrCtx->GetGrabBuffer());
+      }
       glPixelStorei(GL_PACK_ALIGNMENT,1);
       glReadPixels(0, 0, fViewport.Width(), fViewport.Height(),
                    GL_BGRA, GL_UNSIGNED_BYTE, xx);
@@ -815,28 +987,26 @@ void TGLViewer::SwapBuffers() const
 }
 
 //______________________________________________________________________________
-Bool_t TGLViewer::RequestSelect(Int_t x, Int_t y, Bool_t trySecSel)
+Bool_t TGLViewer::RequestSelect(Int_t x, Int_t y)
 {
-   // Post request for select draw of viewer, picking objects round the WINDOW
-   // point (x,y).
-   // Request is directed via cross thread gVirtualGL object
+   // Post request for selection render pass viewer, picking objects
+   // around the window point (x,y).
 
    // Take select lock on scene immediately we enter here - it is released
-   // in the other (drawing) thread - see TGLViewer::Select()
-   // Removed when gVirtualGL removed
+   // in the other (drawing) thread - see TGLViewer::DoSelect()
 
    if ( ! TakeLock(kSelectLock)) {
       return kFALSE;
    }
 
    if (!gVirtualX->IsCmdThread())
-      return Bool_t(gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoSelect(%d, %d, %s)", this, x, y, trySecSel ? "kTRUE" : "kFALSE")));
+      return Bool_t(gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoSelect(%d, %d, %s)", this, x, y)));
    else
-      return DoSelect(x, y, trySecSel);
+      return DoSelect(x, y);
 }
 
 //______________________________________________________________________________
-Bool_t TGLViewer::DoSelect(Int_t x, Int_t y, Bool_t trySecSel)
+Bool_t TGLViewer::DoSelect(Int_t x, Int_t y)
 {
    // Perform GL selection, picking objects overlapping WINDOW
    // area described by 'rect'. Return kTRUE if selection should be
@@ -881,68 +1051,81 @@ Bool_t TGLViewer::DoSelect(Int_t x, Int_t y, Bool_t trySecSel)
       fSelRec.Reset();
    }
 
-   if ( ! trySecSel)
+   ReleaseLock(kSelectLock);
+   return ! TGLSelectRecord::AreSameSelectionWise(fSelRec, fCurrentSelRec);
+}
+
+//______________________________________________________________________________
+Bool_t TGLViewer::RequestSecondarySelect(Int_t x, Int_t y)
+{
+   // 
+   if (!gVirtualX->IsCmdThread())
+      return Bool_t(gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoSecondarySelect(%d, %d, %s)", this, x, y)));
+   else
+      return DoSecondarySelect(x, y);
+}
+
+//______________________________________________________________________________
+Bool_t TGLViewer::DoSecondarySelect(Int_t x, Int_t y)
+{
+   // Secondary selection.
+
+   GLint nHits = 1;
+   //glGetIntegerv(GL_RENDER, &nHits);
+   if ( nHits < 1 || ! fSelRec.GetSceneInfo() || ! fSelRec.GetPhysShape() ||
+         ! fSelRec.GetPhysShape()->GetLogical()->SupportsSecondarySelect())
    {
-      ReleaseLock(kSelectLock);
-      return ! TGLSelectRecord::AreSameSelectionWise(fSelRec, fCurrentSelRec);
+      if (gDebug > 0)
+         Info("TGLViewer::SecondarySelect", "Skipping secondary selection "
+              "(nPrimHits=%d, sinfo=0x%lx, pshape=0x%lx).\n",
+              nHits, fSelRec.GetSceneInfo(), fSelRec.GetPhysShape());
+      fSecSelRec.Reset();
+      return kFALSE;
    }
 
-   //  Secondary selection.
-   {
-      if ( nHits < 1 || ! fSelRec.GetSceneInfo() || ! fSelRec.GetPhysShape() ||
-           ! fSelRec.GetPhysShape()->GetLogical()->SupportsSecondarySelect())
-      {
-         if (gDebug > 0)
-            Info("TGLViewer::DoSelect", "Skipping secondary selection "
-                 "(nPrimHits=%d, sinfo=0x%lx, pshape=0x%lx).\n",
-                 nHits, fSelRec.GetSceneInfo(), fSelRec.GetPhysShape());
-         ReleaseLock(kSelectLock);
-         fSecSelRec.Reset();
-         return kFALSE;
-      }
+   TakeLock(kSelectLock);
 
-      TGLSceneInfo*    sinfo = fSelRec.GetSceneInfo();
-      TGLSceneBase*    scene = sinfo->GetScene();
-      TGLPhysicalShape* pshp = fSelRec.GetPhysShape();
-
-      SceneInfoList_t foo;
-      foo.push_back(sinfo);
-      fScenes.swap(foo);
-      fRnrCtx->BeginSelection(x, y, 3);
-      fRnrCtx->SetSecSelection(kTRUE);
-      glRenderMode(GL_SELECT);
-
-      PreRender();
-      fRnrCtx->SetSceneInfo(sinfo);
-      scene->PreRender(*fRnrCtx);
-      fRnrCtx->SetDrawPass(TGLRnrCtx::kPassFill);
-      fRnrCtx->SetShapeLOD(TGLRnrCtx::kLODHigh);
-      glPushName(pshp->ID());
-      // !!! Hack: does not use clipping and proper draw-pass settings.
-      pshp->Draw(*fRnrCtx);
-      glPopName();
-      scene->PostRender(*fRnrCtx);
-      fRnrCtx->SetSceneInfo(0);
-      PostRender();
-
-      Int_t nSecHits = glRenderMode(GL_RENDER);
-      fRnrCtx->EndSelection(nSecHits);
-      fScenes.swap(foo);
-
-      if (gDebug > 0) Info("TGLViewer::DoSelect", "Secondary select nSecHits=%d.", nSecHits);
-
-      ReleaseLock(kSelectLock);
-
-      if (nSecHits > 0)
-      {
-         fSecSelRec = fSelRec;
-         fSecSelRec.SetRawOnly(fRnrCtx->GetSelectBuffer()->RawRecord(0));
-         if (gDebug > 1) fSecSelRec.Print();
-         return kTRUE;
-      } else {
-         fSecSelRec.Reset();
-         return kFALSE;
-      }
+   TGLSceneInfo*    sinfo = fSelRec.GetSceneInfo();
+   TGLSceneBase*    scene = sinfo->GetScene();
+   TGLPhysicalShape* pshp = fSelRec.GetPhysShape();
+
+   SceneInfoList_t foo;
+   foo.push_back(sinfo);
+   fScenes.swap(foo);
+   fRnrCtx->BeginSelection(x, y, 3);
+   fRnrCtx->SetSecSelection(kTRUE);
+   glRenderMode(GL_SELECT);
+
+   PreRender();
+   fRnrCtx->SetSceneInfo(sinfo);
+   scene->PreRender(*fRnrCtx);
+   fRnrCtx->SetDrawPass(TGLRnrCtx::kPassFill);
+   fRnrCtx->SetShapeLOD(TGLRnrCtx::kLODHigh);
+   glPushName(pshp->ID());
+   // !!! Hack: does not use clipping and proper draw-pass settings.
+   pshp->Draw(*fRnrCtx);
+   glPopName();
+   scene->PostRender(*fRnrCtx);
+   fRnrCtx->SetSceneInfo(0);
+   PostRender();
+
+   Int_t nSecHits = glRenderMode(GL_RENDER);
+   fRnrCtx->EndSelection(nSecHits);
+   fScenes.swap(foo);
+
+   if (gDebug > 0) Info("TGLViewer::DoSelect", "Secondary select nSecHits=%d.", nSecHits);
+
+   ReleaseLock(kSelectLock);
+
+   if (nSecHits > 0)
+   {
+      fSecSelRec = fSelRec;
+      fSecSelRec.SetRawOnly(fRnrCtx->GetSelectBuffer()->RawRecord(0));
+      if (gDebug > 1) fSecSelRec.Print();
+      return kTRUE;
+   } else {
+      fSecSelRec.Reset();
+      return kFALSE;
    }
 }
 
@@ -967,20 +1150,18 @@ void TGLViewer::ApplySelection()
 //______________________________________________________________________________
 Bool_t TGLViewer::RequestOverlaySelect(Int_t x, Int_t y)
 {
-   // Post request for select draw of viewer, picking objects round the WINDOW
-   // point (x,y).
-   // Request is directed via cross thread gVirtualGL object
+   // Post request for secondary selection rendering of selected object
+   // around the window point (x,y).
 
    // Take select lock on viewer immediately - it is released
-   // in the other (drawing) thread - see TGLViewer::Select().
-   // Removed when gVirtualGL removed
+   // in the other (drawing) thread - see TGLViewer::DoSecondarySelect().
 
    if ( ! TakeLock(kSelectLock)) {
       return kFALSE;
    }
 
    if (!gVirtualX->IsCmdThread())
-      return Bool_t(gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoSelect(%d, %d)", this, x, y)));
+      return Bool_t(gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoOverlaySelect(%d, %d)", this, x, y)));
    else
       return DoOverlaySelect(x, y);
 }
@@ -1181,6 +1362,13 @@ Bool_t TGLViewer::IsUsingDefaultColorSetForNewViewers()
    return fgUseDefaultColorSetForNewViewers;
 }
 
+//______________________________________________________________________________
+Bool_t TGLViewer::IsColorSetDark() const
+{
+   // Returns true if curremt color set is dark.
+
+   return fRnrCtx->GetBaseColorSet() == &fDarkColorSet;
+}
 
 /**************************************************************************/
 // Viewport
@@ -1192,10 +1380,6 @@ void TGLViewer::SetViewport(Int_t x, Int_t y, Int_t width, Int_t height)
    // Set viewer viewport (window area) with bottom/left at (x,y), with
    // dimensions 'width'/'height'
 
-   if (IsLocked() && fGLDevice == -1) {
-      Error("TGLViewer::SetViewport", "expected kUnlocked, found %s", LockName(CurrentLock()));
-      return;
-   }
    // Only process if changed
    if (fViewport.X() == x && fViewport.Y() == y &&
        fViewport.Width() == width && fViewport.Height() == height) {
@@ -1210,6 +1394,12 @@ void TGLViewer::SetViewport(Int_t x, Int_t y, Int_t width, Int_t height)
    }
 }
 
+void TGLViewer::SetViewport(const TGLRect& vp)
+{
+   // Set viewr viewport from TGLRect.
+
+   SetViewport(vp.X(), vp.Y(), vp.Width(), vp.Height());
+}
 
 /**************************************************************************/
 // Camera methods
@@ -1518,6 +1708,31 @@ void TGLViewer::Clicked(TObject *obj, UInt_t button, UInt_t state)
    Emit("Clicked(TObject*,UInt_t,UInt_t)", args);
 }
 
+
+//______________________________________________________________________________
+void TGLViewer::ReClicked(TObject *obj, UInt_t button, UInt_t state)
+{
+   // Emit ReClicked signal with button id and modifier state.
+
+   Long_t args[3];
+   args[0] = (Long_t)obj;
+   args[1] = button;
+   args[2] = state;
+   Emit("ReClicked(TObject*,UInt_t,UInt_t)", args);
+}
+
+//______________________________________________________________________________
+void TGLViewer::UnClicked(TObject *obj, UInt_t button, UInt_t state)
+{
+   // Emit UnClicked signal with button id and modifier state.
+
+   Long_t args[3];
+   args[0] = (Long_t)obj;
+   args[1] = button;
+   args[2] = state;
+   Emit("UnClicked(TObject*,UInt_t,UInt_t)", args);
+}
+
 //______________________________________________________________________________
 void TGLViewer::MouseIdle(TGLPhysicalShape *shape, UInt_t posx, UInt_t posy)
 {
@@ -1575,6 +1790,9 @@ void TGLViewer::SetEventHandler(TGEventHandler *handler)
 {
    // Set the event-handler. The event-handler is owned by the viewer.
    // If GLWidget is set, the handler is propagated to it.
+   //
+   // If called with handler=0, the current handler will be deleted
+   // (also from TGLWidget).
 
    if (fEventHandler)
       delete fEventHandler;
diff --git a/graf3d/gl/src/TGLViewerEditor.cxx b/graf3d/gl/src/TGLViewerEditor.cxx
index 83c593d..fac0a64 100644
--- a/graf3d/gl/src/TGLViewerEditor.cxx
+++ b/graf3d/gl/src/TGLViewerEditor.cxx
@@ -40,10 +40,9 @@ TGLViewerEditor::TGLViewerEditor(const TGWindow *p,  Int_t width, Int_t height,
    fCameraHome(0),
    fMaxSceneDrawTimeHQ(0),
    fMaxSceneDrawTimeLQ(0),
-   fPointSizeScale(0),
-   fLineWidthScale(0),
-   fWFLineWidth(0),
-   fOLLineWidth(0),
+   fPointSizeScale(0),  fLineWidthScale(0),
+   fPointSmooth(0),     fLineSmooth(0),
+   fWFLineWidth(0),     fOLLineWidth(0),
 
    fCameraCenterExt(0),
    fCaptureCenter(0),
@@ -98,6 +97,8 @@ void TGLViewerEditor::ConnectSignals2Slots()
    fMaxSceneDrawTimeLQ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateMaxDrawTimes()");
    fPointSizeScale->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
    fLineWidthScale->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
+   fPointSmooth->Connect("Clicked()", "TGLViewerEditor", this, "UpdatePointLineStuff()");
+   fLineSmooth ->Connect("Clicked()", "TGLViewerEditor", this, "UpdatePointLineStuff()");
    fWFLineWidth->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
    fOLLineWidth->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdatePointLineStuff()");
 
@@ -161,6 +162,8 @@ void TGLViewerEditor::SetModel(TObject* obj)
    fMaxSceneDrawTimeLQ->SetNumber(fViewer->GetMaxSceneDrawTimeLQ());
    fPointSizeScale->SetNumber(fViewer->GetPointScale());
    fLineWidthScale->SetNumber(fViewer->GetLineScale ());
+   fPointSmooth->SetState(fViewer->GetSmoothPoints() ? kButtonDown : kButtonUp);
+   fLineSmooth ->SetState(fViewer->GetSmoothLines () ? kButtonDown : kButtonUp);
    fWFLineWidth->SetNumber(fViewer->WFLineW());
    fOLLineWidth->SetNumber(fViewer->OLLineW());
    //camera look at
@@ -248,6 +251,8 @@ void TGLViewerEditor::UpdatePointLineStuff()
 
    fViewer->SetPointScale(fPointSizeScale->GetNumber());
    fViewer->SetLineScale (fLineWidthScale->GetNumber());
+   fViewer->SetSmoothPoints(fPointSmooth->IsDown());
+   fViewer->SetSmoothLines (fLineSmooth->IsDown());
    fViewer->SetWFLineW(fWFLineWidth->GetNumber());
    fViewer->SetOLLineW(fOLLineWidth->GetNumber());
    ViewerRedraw();
@@ -416,13 +421,23 @@ void TGLViewerEditor::CreateStyleTab()
    AddFrame(fLightSet, new TGLayoutHints(kLHintsTop | kLHintsExpandX, 2, 0, 0, 0));
 
    // Point-sizes / line-widths.
-   fPointSizeScale = MakeLabeledNEntry(af, "Point-size scale:", 120, 6, TGNumberFormat::kNESRealOne);
+   hf = new TGHorizontalFrame(af);
+   fPointSizeScale = MakeLabeledNEntry(hf, "Point-size scale:", 116, 4, TGNumberFormat::kNESRealOne);
    fPointSizeScale->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
-   fLineWidthScale = MakeLabeledNEntry(af, "Line-width scale:", 120, 6, TGNumberFormat::kNESRealOne);
+   fPointSmooth = new TGCheckButton(hf);
+   fPointSmooth->SetToolTipText("Use smooth points.");
+   hf->AddFrame(fPointSmooth, new TGLayoutHints(kLHintsNormal, 3, 0, 3, 0));
+   af->AddFrame(hf);
+   hf = new TGHorizontalFrame(af);
+   fLineWidthScale = MakeLabeledNEntry(hf, "Line-width scale:", 116, 4, TGNumberFormat::kNESRealOne);
    fLineWidthScale->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
-   fWFLineWidth = MakeLabeledNEntry(af, "Wireframe line-width:", 120, 6, TGNumberFormat::kNESRealOne);
+   fLineSmooth = new TGCheckButton(hf);
+   fLineSmooth->SetToolTipText("Use smooth lines.");
+   hf->AddFrame(fLineSmooth, new TGLayoutHints(kLHintsNormal, 3, 0, 3, 0));
+   af->AddFrame(hf);
+   fWFLineWidth = MakeLabeledNEntry(af, "Wireframe line-width:", 116, 4, TGNumberFormat::kNESRealOne);
    fWFLineWidth->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
-   fOLLineWidth = MakeLabeledNEntry(af, "Outline line-width:", 120, 6, TGNumberFormat::kNESRealOne);
+   fOLLineWidth = MakeLabeledNEntry(af, "Outline line-width:", 116, 4, TGNumberFormat::kNESRealOne);
    fOLLineWidth->SetLimits(TGNumberFormat::kNELLimitMinMax, 0.1, 16);
 }
 
diff --git a/gui/gui/inc/TGMenu.h b/gui/gui/inc/TGMenu.h
index b51368e..25641f0 100644
--- a/gui/gui/inc/TGMenu.h
+++ b/gui/gui/inc/TGMenu.h
@@ -87,6 +87,7 @@ protected:
    Int_t             fEx, fEy;   // position of entry
    UInt_t            fEw, fEh;   // width and height of entry
    TGHotString      *fLabel;     // menu entry label
+   TGString         *fShortcut;  // menu entry shortcut
    const TGPicture  *fPic;       // menu entry icon
    TGPopupMenu      *fPopup;     // pointer to popup menu (in case of cascading menus)
 
@@ -96,11 +97,12 @@ private:
 
 public:
    TGMenuEntry(): fEntryId(0), fUserData(0), fType(), fStatus(0),
-      fEx(0), fEy(0), fEw(0), fEh(0), fLabel(0), fPic(0), fPopup(0) { }
-   virtual ~TGMenuEntry() { if (fLabel) delete fLabel; }
+      fEx(0), fEy(0), fEw(0), fEh(0), fLabel(0), fShortcut(0), fPic(0), fPopup(0) { }
+   virtual ~TGMenuEntry() { if (fLabel) delete fLabel; if (fShortcut) delete fShortcut; }
 
    Int_t          GetEntryId() const { return fEntryId; }
    const char    *GetName() const { return fLabel ? fLabel->GetString() : 0; }
+   const char    *GetShortcut() const { return fShortcut ? fShortcut->GetString() : 0; }
    virtual Int_t  GetStatus() const { return fStatus; }
    EMenuEntryType GetType() const { return fType; }
    TGPopupMenu   *GetPopup() const { return fPopup; }
diff --git a/gui/gui/src/TGMenu.cxx b/gui/gui/src/TGMenu.cxx
index 3eb4414..d51c5db 100644
--- a/gui/gui/src/TGMenu.cxx
+++ b/gui/gui/src/TGMenu.cxx
@@ -974,8 +974,17 @@ void TGPopupMenu::AddEntry(TGHotString *s, Int_t id, void *ud,
    // If before is not 0, the entry will be added before it.
 
    TGMenuEntry *nw = new TGMenuEntry;
-
-   nw->fLabel    = s;
+   Ssiz_t tab = s->Index('\t');
+   if (tab > 0) {
+      TString ts(s->Data());
+      TString shortcut = ts(tab+1, s->Length());
+      nw->fShortcut = new TGString(shortcut.Data());
+      nw->fLabel = new TGHotString(*s);
+      nw->fLabel->Remove(tab);
+   }
+   else {
+      nw->fLabel = s;
+   }
    nw->fPic      = p;
    nw->fType     = kMenuEntry;
    nw->fEntryId  = id;
@@ -997,6 +1006,10 @@ void TGPopupMenu::AddEntry(TGHotString *s, Int_t id, void *ud,
       pw = p->GetWidth();
       if (pw+12 > fXl) { fMenuWidth += pw+12-fXl; fXl = pw+12; }
    }
+   if (nw->fShortcut) {
+      tw += 10;
+      if (s) delete s;
+   }
 
    Int_t max_ascent, max_descent;
    nw->fEw = tw + pw /*+8*/+18+12;
@@ -1473,6 +1486,7 @@ void TGPopupMenu::DrawEntry(TGMenuEntry *entry)
       font = fFontStruct;
    }
 
+   UInt_t tw = 0;
    int max_ascent, max_descent;
    gVirtualX->GetFontProperties(font, max_ascent, max_descent);
    int tx = entry->fEx + fXl;
@@ -1481,6 +1495,8 @@ void TGPopupMenu::DrawEntry(TGMenuEntry *entry)
    if (offset > 0) offset -= 1;
    else offset = 0;
    int ty = entry->fEy + max_ascent + offset;
+   if (entry->fShortcut)
+      tw = 7 + gVirtualX->TextWidth(fFontStruct, entry->fShortcut->Data(), entry->fShortcut->Length());
 
    switch (entry->fType) {
       case kMenuPopup:
@@ -1500,6 +1516,9 @@ void TGPopupMenu::DrawEntry(TGMenuEntry *entry)
             entry->fLabel->Draw(fId,
                            (entry->fStatus & kMenuEnableMask) ? fSelGC : GetShadowGC()(),
                            tx, ty);
+            if (entry->fShortcut)
+               entry->fShortcut->Draw(fId, (entry->fStatus & kMenuEnableMask) ? fSelGC : GetShadowGC()(),
+                                      fMenuWidth - tw, ty);
          } else {
             gVirtualX->FillRectangle(fId, GetBckgndGC()(), entry->fEx+1, entry->fEy-1,
                                      fMenuWidth-6, entry->fEh);
@@ -1513,9 +1532,15 @@ void TGPopupMenu::DrawEntry(TGMenuEntry *entry)
                entry->fPic->Draw(fId, fNormGC, 8, entry->fEy+1);
             if (entry->fStatus & kMenuEnableMask) {
                entry->fLabel->Draw(fId, fNormGC, tx, ty);
+               if (entry->fShortcut)
+                  entry->fShortcut->Draw(fId, fNormGC, fMenuWidth - tw, ty);
             } else {
                entry->fLabel->Draw(fId, GetHilightGC()(), tx+1, ty+1);
                entry->fLabel->Draw(fId, GetShadowGC()(), tx, ty);
+               if (entry->fShortcut) {
+                  entry->fShortcut->Draw(fId, GetHilightGC()(), fMenuWidth - tw+1, ty+1);
+                  entry->fShortcut->Draw(fId, GetShadowGC()(), fMenuWidth - tw, ty);
+               }
             }
          }
          break;
@@ -2099,6 +2124,7 @@ void TGPopupMenu::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
    while ((mentry = (TGMenuEntry *) next())) {
       const char *text;
       Int_t i, lentext, hotpos;
+      char shortcut[80];
       char *outext;
 
       switch (mentry->GetType()) {
@@ -2117,9 +2143,16 @@ void TGPopupMenu::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
                i++; text++; lentext--;
             }
             outext[i]=0;
+            if (mentry->fShortcut) {
+               sprintf(shortcut, "\\t%s", mentry->GetShortcut());
+            }
+            else {
+               memset(shortcut, 0, 80);
+            }
 
             out << "   " << GetName() << "->AddEntry(" << quote
                 << gSystem->ExpandPathName(gSystem->UnixPathName(outext)) // can be a file name
+                << shortcut
                 << quote << "," << mentry->GetEntryId();
             if (mentry->fUserData) {
                out << "," << mentry->fUserData;
