--- branches/v5-27-06-patches/core/base/src/TBuffer.cxx	2011/12/06 20:59:50	42428
+++ branches/v5-27-06-patches/core/base/src/TBuffer.cxx	2011/12/06 21:10:55	42429
@@ -183,8 +183,14 @@
 void TBuffer::Expand(Int_t newsize)
 {
    // Expand the I/O buffer to newsize bytes.
+   //
+   // In order to avoid losing data, if the current length is greater than
+   // the requested size, we only shrink down to the current length.
 
    Int_t l  = Length();
+   if ( l > newsize ) {
+      newsize = l;
+   }
    fBuffer  = fReAllocFunc(fBuffer, newsize+kExtraSpace,
                            fBufSize+kExtraSpace);
    if (fBuffer == 0) {
--- branches/v5-27-06-patches/tree/tree/src/TBranch.cxx	2011/12/06 20:59:50	42428
+++ branches/v5-27-06-patches/tree/tree/src/TBranch.cxx	2011/12/06 21:10:55	42429
@@ -1892,7 +1892,8 @@
    // Set the basket size
    // The function makes sure that the basket size is greater than fEntryOffsetlen
 
-   if (buffsize < 100+fEntryOffsetLen) buffsize = 100+fEntryOffsetLen;
+   Int_t minsize = 100 + fName.Length();
+   if (buffsize < minsize+fEntryOffsetLen) buffsize = minsize+fEntryOffsetLen;
    fBasketSize = buffsize;
    TBasket *basket = (TBasket*)fBaskets[fWriteBasket];
    if (basket) {
--- branches/v5-27-06-patches/tree/tree/src/TTree.cxx	2011/12/06 20:59:50	42428
+++ branches/v5-27-06-patches/tree/tree/src/TTree.cxx	2011/12/06 21:10:55	42429
@@ -5505,9 +5505,19 @@
       }
       memFactor = Double_t(maxMemory)/Double_t(newMemsize);
       if (memFactor > 100) memFactor = 100;
-      bmin = Int_t(bmin*memFactor);
-      bmax = Int_t(bmax*memFactor);
-      if (bmax < bmin) bmax = bmin;  //this may happen when bmax is above 2 billions      
+
+      Double_t bmin_new = bmin*memFactor;
+      Double_t bmax_new = bmax*memFactor;
+      static const UInt_t hardmax = 1*1024*1024*1024; // Really, really never give more than 1Gb to a single buffer.
+
+      // Really, really never go lower than 8 bytes (we use this number
+      // so that the calculation of the number of basket is consistent
+      // but in fact SetBasketSize will not let the size go below
+      // TBranch::fEntryOffsetLen + (100 + strlen(branch->GetName())
+      // (The 2nd part being a slight over estimate of the key length.
+      static const UInt_t hardmin = 8;
+      bmin = (bmin_new > hardmax) ? hardmax : ( bmin_new < hardmin ? hardmin : (UInt_t)bmin_new );
+      bmax = (bmax_new > hardmax) ? bmin : (UInt_t)bmax_new;         
    }
    if (pDebug) {
       printf("oldMemsize = %d,  newMemsize = %d\n",oldMemsize, newMemsize);
