--- branches/v5-30-00-patches/core/base/src/TBuffer.cxx	2011/12/06 20:48:34	42425
+++ branches/v5-30-00-patches/core/base/src/TBuffer.cxx	2011/12/06 20:50:39	42426
@@ -204,8 +204,14 @@
    // Expand (or shrink) the I/O buffer to newsize bytes.
    // If copy is true (the default), the existing content of the
    // buffer is preserved, otherwise the buffer is returned zero-ed out.
+   //
+   // In order to avoid losing data, if the current length is greater than
+   // the requested size, we only shrink down to the current length.
 
    Int_t l  = Length();
+   if ( l > newsize ) {
+      newsize = l;
+   }
    if ( (fMode&kWrite)!=0 ) {
       fBuffer  = fReAllocFunc(fBuffer, newsize+kExtraSpace,
                               copy ? fBufSize+kExtraSpace : 0);
--- branches/v5-30-00-patches/tree/tree/src/TBranch.cxx	2011/12/06 20:48:34	42425
+++ branches/v5-30-00-patches/tree/tree/src/TBranch.cxx	2011/12/06 20:50:39	42426
@@ -2059,7 +2059,8 @@
    // Set the basket size
    // The function makes sure that the basket size is greater than fEntryOffsetlen
 
-   if (buffsize < 100+fEntryOffsetLen) buffsize = 100+fEntryOffsetLen;
+   Int_t minsize = 100 + fName.Length();
+   if (buffsize < minsize+fEntryOffsetLen) buffsize = minsize+fEntryOffsetLen;
    fBasketSize = buffsize;
    TBasket *basket = (TBasket*)fBaskets[fWriteBasket];
    if (basket) {
--- branches/v5-30-00-patches/tree/tree/src/TTree.cxx	2011/12/06 20:48:34	42425
+++ branches/v5-30-00-patches/tree/tree/src/TTree.cxx	2011/12/06 20:50:39	42426
@@ -5843,7 +5843,13 @@
       Double_t bmin_new = bmin*memFactor;
       Double_t bmax_new = bmax*memFactor;
       static const UInt_t hardmax = 1*1024*1024*1024; // Really, really never give more than 1Gb to a single buffer.
-      static const UInt_t hardmin = 8;                // Really, really never go lower than 8 bytes (we use this number so that the calculation of the number of basket is consistent but in fact SetBasketSize will not let the size go below 100+TBranch::fEntryOffsetLen)
+
+      // Really, really never go lower than 8 bytes (we use this number
+      // so that the calculation of the number of basket is consistent
+      // but in fact SetBasketSize will not let the size go below
+      // TBranch::fEntryOffsetLen + (100 + strlen(branch->GetName())
+      // (The 2nd part being a slight over estimate of the key length.
+      static const UInt_t hardmin = 8;
       bmin = (bmin_new > hardmax) ? hardmax : ( bmin_new < hardmin ? hardmin : (UInt_t)bmin_new );
       bmax = (bmax_new > hardmax) ? bmin : (UInt_t)bmax_new;         
    }
