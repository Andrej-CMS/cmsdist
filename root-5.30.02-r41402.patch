--- branches/v5-30-00-patches/proof/proof/src/TProofServ.cxx	2011/10/15 07:16:34	41401
+++ branches/v5-30-00-patches/proof/proof/src/TProofServ.cxx	2011/10/15 07:19:56	41402
@@ -2822,6 +2822,8 @@
    gSystem->Umask(022);
 
 #ifdef R__UNIX
+   // Add bindir to PATH
+   TString path(gSystem->Getenv("PATH"));
    TString bindir;
 # ifdef ROOTBINDIR
    bindir = ROOTBINDIR;
@@ -2829,19 +2831,47 @@
    bindir = gSystem->Getenv("ROOTSYS");
    if (!bindir.IsNull()) bindir += "/bin";
 # endif
+   // Augment PATH, if required
+   // ^<compiler>, <compiler>, ^<sysbin>, <sysbin>
+   TString paths = gEnv->GetValue("ProofServ.BinPaths", "");
+   if (paths.Length() > 0) {
+      Int_t icomp = 0;
+      if (paths.Contains("^<compiler>"))
+	 icomp = 1;
+      else if (paths.Contains("<compiler>"))
+	 icomp = -1;
+      if (icomp != 0) {
 # ifdef COMPILER
-   TString compiler = COMPILER;
-   if (compiler.Index("is ") != kNPOS)
-      compiler.Remove(0, compiler.Index("is ") + 3);
-   compiler = gSystem->DirName(compiler);
-   if (!bindir.IsNull()) bindir += ":";
-   bindir += compiler;
+         TString compiler = COMPILER;
+         if (compiler.Index("is ") != kNPOS)
+            compiler.Remove(0, compiler.Index("is ") + 3);
+         compiler = gSystem->DirName(compiler);
+         if (icomp == 1) {
+            if (!bindir.IsNull()) bindir += ":";
+            bindir += compiler;
+         } else if (icomp == -1) {
+            if (!path.IsNull()) path += ":";
+            path += compiler;
+         }
 #endif
+      }
+      Int_t isysb = 0;
+      if (paths.Contains("^<sysbin>"))
+	 isysb = 1;
+      else if (paths.Contains("<sysbin>"))
+	 isysb = -1;
+      if (isysb != 0) {
+         if (isysb == 1) {
+            if (!bindir.IsNull()) bindir += ":";
+            bindir += "/bin:/usr/bin:/usr/local/bin";
+         } else if (isysb == -1) {
+            if (!path.IsNull()) path += ":";
+            path += "/bin:/usr/bin:/usr/local/bin";
+         }
+      }
+   }
+   // Final insert
    if (!bindir.IsNull()) bindir += ":";
-   bindir += "/bin:/usr/bin:/usr/local/bin";
-   // Add bindir to PATH
-   TString path(gSystem->Getenv("PATH"));
-   if (!path.IsNull()) path.Insert(0, ":");
    path.Insert(0, bindir);
    gSystem->Setenv("PATH", path);
 #endif
--- branches/v5-30-00-patches/proof/proofd/src/XrdProofdManager.cxx	2011/10/15 07:16:34	41401
+++ branches/v5-30-00-patches/proof/proofd/src/XrdProofdManager.cxx	2011/10/15 07:19:56	41402
@@ -164,6 +164,11 @@
    // Proof admin path
    fAdminPath = pi->AdmPath;
    fAdminPath += "/.xproofd.";
+   
+   // Lib paths for proofserv
+   fBareLibPath = "";
+   fRemoveROOTLibPaths = 0;
+   fLibPathsToRemove.Purge();
 
    // Services
    fSched = pi->Sched;
@@ -867,38 +872,52 @@
          TRACE(ALL, msg);
       }
    }
-
+   
    // Bare lib path
    if (getenv(XPD_LIBPATH)) {
-      // Try to remove existing ROOT dirs in the path
-      XrdOucString paths = getenv(XPD_LIBPATH);
-      XrdOucString ldir;
-      int from = 0;
-      while ((from = paths.tokenize(ldir, from, ':')) != STR_NPOS) {
-         bool isROOT = 0;
-         if (ldir.length() > 0) {
-            // Check this dir
-            DIR *dir = opendir(ldir.c_str());
-            if (dir) {
-               // Scan the directory
-               struct dirent *ent = 0;
-               while ((ent = (struct dirent *)readdir(dir))) {
-                  if (!strncmp(ent->d_name, "libCore", 7)) {
-                     isROOT = 1;
-                     break;
+      XrdOucString ctrim;
+      if (fRemoveROOTLibPaths || fLibPathsToRemove.Num() > 0) {
+         // Try to remove existing ROOT dirs in the path
+         XrdOucString paths = getenv(XPD_LIBPATH);
+         XrdOucString ldir;
+         int from = 0;
+         while ((from = paths.tokenize(ldir, from, ':')) != STR_NPOS) {
+            bool remove = 0;
+            if (ldir.length() > 0) {
+               if (fLibPathsToRemove.Num() > 0 && fLibPathsToRemove.Find(ldir.c_str())) {
+                  remove = 1;
+               } else if (fRemoveROOTLibPaths) {
+                  // Check this dir
+                  DIR *dir = opendir(ldir.c_str());
+                  if (dir) {
+                     // Scan the directory
+                     struct dirent *ent = 0;
+                     while ((ent = (struct dirent *)readdir(dir))) {
+                        if (!strncmp(ent->d_name, "libCore", 7)) {
+                           remove = 1;
+                           break;
+                        }
+                     }
+                     // Close the directory
+                     closedir(dir);
                   }
                }
-               // Close the directory
-               closedir(dir);
             }
-            if (!isROOT) {
+            if (!remove) {
                if (fBareLibPath.length() > 0)
                   fBareLibPath += ":";
                fBareLibPath += ldir;
             }
          }
+         ctrim = " (lib paths filter applied)";
+      } else {
+         // Full path
+         ctrim = " (full ";
+         ctrim += XPD_LIBPATH;
+         ctrim += ")";
+         fBareLibPath = getenv(XPD_LIBPATH);
       }
-      TRACE(ALL, "bare lib path for proofserv: " << fBareLibPath);
+      TRACE(ALL, "bare lib path for proofserv" << ctrim <<": " << fBareLibPath);
    }
 
    // Groups
@@ -1125,6 +1144,7 @@
    Register("rootd", new XrdProofdDirective("rootd", this, &DoDirectiveClass));
    Register("rootdallow", new XrdProofdDirective("rootdallow", this, &DoDirectiveClass));
    Register("xrd.protocol", new XrdProofdDirective("xrd.protocol", this, &DoDirectiveClass));
+   Register("filterlibpaths", new XrdProofdDirective("filterlibpaths", this, &DoDirectiveClass));
    // Register config directives for strings
    Register("tmp", new XrdProofdDirective("tmp", (void *)&fTMPdir, &DoDirectiveString));
    Register("poolurl", new XrdProofdDirective("poolurl", (void *)&fPoolURL, &DoDirectiveString));
@@ -1244,6 +1264,8 @@
       return DoDirectiveRootdAllow(val, cfg, rcf);
    } else if (d->fName == "xrd.protocol") {
       return DoDirectivePort(val, cfg, rcf);
+   } else if (d->fName == "filterlibpaths") {
+      return DoDirectiveFilterLibPaths(val, cfg, rcf);
    }
    TRACE(XERR, "unknown directive: " << d->fName);
    return -1;
@@ -1738,6 +1760,44 @@
 }
 
 //______________________________________________________________________________
+int XrdProofdManager::DoDirectiveFilterLibPaths(char *val, XrdOucStream *cfg, bool)
+{
+   // Process 'filterlibpaths' directive
+   //  xpd.filterlibpaths 1|0 [path1,path2 path3 path4 ...]
+   XPDLOC(ALL, "Manager::DoDirectiveRemoveLibPaths")
+
+   if (!val)
+      // undefined inputs
+      return -1;
+
+   // Rebuild arguments list
+   fLibPathsToRemove.Purge();
+
+   TRACE(ALL, "val: "<< val);
+
+   // Whether to remove ROOT lib paths before adding the effective one
+   fRemoveROOTLibPaths = (!strcmp(val, "1") || !strcmp(val, "yes")) ? 1 : 0;
+   if (fRemoveROOTLibPaths)
+      TRACE(ALL, "Filtering out ROOT lib paths from "<<XPD_LIBPATH);
+
+   // Parse the rest, if any
+   char *nxt = 0;
+   while ((nxt = cfg->GetWord())) {
+      XrdOucString pps(nxt), p;
+      int from = 0;
+      while ((from = pps.tokenize(p, from, ',')) != -1) {
+         if (p.length() > 0) {
+            fLibPathsToRemove.Add(p.c_str(), 0, 0, Hash_data_is_key);
+            TRACE(ALL, "Filtering out from "<<XPD_LIBPATH<<" lib path '"<<p<<"'");
+         }
+      }
+   }
+
+   // Done
+   return 0;
+}
+
+//______________________________________________________________________________
 bool XrdProofdManager::IsRootdAllowed(const char *host)
 {
    // Check if 'host' is allowed to access files via rootd
--- branches/v5-30-00-patches/proof/proofd/inc/XrdProofdManager.h	2011/10/15 07:16:34	41401
+++ branches/v5-30-00-patches/proof/proofd/inc/XrdProofdManager.h	2011/10/15 07:19:56	41402
@@ -170,6 +170,10 @@
    bool              fMultiUser;      // Allow/disallow multi-user mode
    bool              fChangeOwn;      // TRUE is ownership has to be changed
 
+   // Lib paths for proofserv
+   bool              fRemoveROOTLibPaths; // If true the existing ROOT lib paths are removed
+   XrdOucHash<XrdOucString> fLibPathsToRemove;  // Additional paths to be removed
+
    //
    // Lists
    std::list<XrdOucString *> fMastersAllowed; // list of master (domains) allowed
@@ -180,6 +184,7 @@
    int               DoDirectiveAllowedUsers(char *, XrdOucStream *, bool);
    int               DoDirectiveDataDir(char *, XrdOucStream *, bool);
    int               DoDirectiveDataSetSrc(char *, XrdOucStream *, bool);
+   int               DoDirectiveFilterLibPaths(char *, XrdOucStream *, bool);
    int               DoDirectiveGroupfile(char *, XrdOucStream *, bool);
    int               DoDirectiveMaxOldLogs(char *, XrdOucStream *, bool);
    int               DoDirectiveMultiUser(char *, XrdOucStream *, bool);
