Index: histfactory/src/HistoToWorkspaceFactoryFast.cxx
===================================================================
--- histfactory/src/HistoToWorkspaceFactoryFast.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ histfactory/src/HistoToWorkspaceFactoryFast.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -209,11 +209,11 @@
         temp = (RooRealVar*) proto->factory(("alpha_"+sourceName.at(j)+range).c_str());
 
         // now add a constraint term for these parameters
-        string command=("Gaussian::alpha_"+sourceName.at(j)+"Constraint(alpha_"+sourceName.at(j)+",nom_"+sourceName.at(j)+"[0.,-10,10],1.)");
+        string command=("Gaussian::alpha_"+sourceName.at(j)+"Constraint(alpha_"+sourceName.at(j)+",nom_alpha_"+sourceName.at(j)+"[0.,-10,10],1.)");
         cout << command << endl;
         likelihoodTermNames.push_back(  proto->factory( command.c_str() )->GetName() );
-	proto->var(("nom_"+sourceName.at(j)).c_str())->setConstant();
-	const_cast<RooArgSet*>(proto->set("globalObservables"))->add(*proto->var(("nom_"+sourceName.at(j)).c_str()));
+	proto->var(("nom_alpha_"+sourceName.at(j)).c_str())->setConstant();
+	const_cast<RooArgSet*>(proto->set("globalObservables"))->add(*proto->var(("nom_alpha_"+sourceName.at(j)).c_str()));
 
       } 
 

Property changes on: histfactory
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /branches/dev/roostats/roofit/histfactory:r40238
   Merged /trunk/roofit/histfactory:r40244

Index: roofitcore/src/RooProdPdf.cxx
===================================================================
--- roofitcore/src/RooProdPdf.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooProdPdf.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -587,9 +587,12 @@
     Int_t n = cache._partList.getSize() ;
     
     Int_t i ;
+    RooLinkedListIter plIter = cache._partList.iterator() ;
+    RooLinkedListIter nlIter = cache._normList.iterator() ;
+
     for (i=0 ; i<n ; i++) {
-      partInt = ((RooAbsReal*)cache._partList.at(i)) ;
-      normSet = ((RooArgSet*)cache._normList.At(i)) ;    
+      partInt = (RooAbsReal*) plIter.Next() ; //((RooAbsReal*)cache._partList.at(i)) ;
+      normSet = (RooArgSet*) nlIter.Next() ; // ((RooArgSet*)cache._normList.At(i)) ;    
       Double_t piVal = partInt->getVal(normSet->getSize()>0 ? normSet : 0) ;
       //cout << "partInt " << partInt->GetName() << " is of type " << partInt->IsA()->GetName() << endl ;
       if (dynamic_cast<RooAbsPdf*>(partInt)) {
Index: roofitcore/src/RooDataSet.cxx
===================================================================
--- roofitcore/src/RooDataSet.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooDataSet.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -297,8 +297,8 @@
     // Make import mapping if index category is specified
     map<string,RooAbsData*> hmap ;  
     if (indexCat) {
-      char tmp[1024] ;
-      strlcpy(tmp,lnkSliceNames,1024) ;
+      char tmp[10240] ;
+      strlcpy(tmp,lnkSliceNames,10240) ;      
       char* token = strtok(tmp,",") ;
       TIterator* hiter = lnkSliceData.MakeIterator() ;
       while(token) {
Index: roofitcore/src/RooRealSumPdf.cxx
===================================================================
--- roofitcore/src/RooRealSumPdf.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooRealSumPdf.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -420,7 +420,12 @@
 //_____________________________________________________________________________
 Double_t RooRealSumPdf::expectedEvents(const RooArgSet* nset) const
 {
-  return getNorm(nset) ;
+  //  return getNorm(nset) ;
+  Double_t n = getNorm(nset) ;  
+  if (n<0) {
+    logEvalError("Expected number of events is negative") ;
+  }
+  return n ;
 }
 
 
Index: roofitcore/src/RooAbsData.cxx
===================================================================
--- roofitcore/src/RooAbsData.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooAbsData.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -192,7 +192,13 @@
 //_____________________________________________________________________________
 Bool_t RooAbsData::changeObservableName(const char* from, const char* to)
 {
-  return _dstore->changeObservableName(from,to) ;
+  Bool_t ret =  _dstore->changeObservableName(from,to) ;
+  
+  RooAbsArg* tmp = _vars.find(from) ;
+  if (tmp) {
+    tmp->SetName(to) ;
+  }
+  return ret ;
 }
 
 
Index: roofitcore/src/RooNLLVar.cxx
===================================================================
--- roofitcore/src/RooNLLVar.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooNLLVar.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -188,10 +188,10 @@
       }
       //cout << "weight squared extended mode: sumW2 = " << sumW2 << " sumentries = " << _dataClone->sumEntries() << endl ;
       
-      result+= pdfClone->extendedTerm((Int_t)sumW2 , _dataClone->get());
+      result+= pdfClone->extendedTerm(sumW2 , _dataClone->get());
 
     } else {
-      result+= pdfClone->extendedTerm((Int_t)_dataClone->sumEntries(),_dataClone->get());
+      result+= pdfClone->extendedTerm(_dataClone->sumEntries(),_dataClone->get());
     }
   }    
 
Index: roofitcore/src/RooAbsArg.cxx
===================================================================
--- roofitcore/src/RooAbsArg.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooAbsArg.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -905,9 +905,11 @@
   if (newSetOrig.getSize()==0) return kFALSE ;
 
   // Strip any non-matchin removal nodes from newSetOrig
-  RooArgSet newSet ;
+  RooAbsCollection* newSet ;
+
   if (nameChange) {
 
+    newSet = new RooArgSet ;
     TIterator* iter = newSetOrig.createIterator() ;
     RooAbsArg* arg ;
     while((arg=(RooAbsArg*)iter->Next())) {
@@ -916,23 +918,21 @@
 	
 	if (arg->getAttribute("REMOVE_ALL")) {
 // 	  cout << "RooAbsArg::redir including remove_all node " << arg->GetName() << endl ;
-	  newSet.add(*arg) ;
+	  newSet->add(*arg) ;
 	} else if (arg->getAttribute(Form("REMOVE_FROM_%s",getStringAttribute("ORIGNAME")))) {
 // 	  cout << "RooAbsArg::redir including remove_from_" << GetName() << " node " << arg->GetName() << endl ;
-	  newSet.add(*arg) ;
+	  newSet->add(*arg) ;
 	}
       } else {
-	newSet.add(*arg) ;
+	newSet->add(*arg) ;
       }
     }
-    delete iter ;
-    
+
 //     cout << "RooAbsArg::redirect with name change(" << GetName() << ") newSet = " << newSet << " origSet = " << newSetOrig << endl ;
 
   } else {
-    newSet.add(newSetOrig) ;
+    newSet = (RooAbsCollection*) &newSetOrig ;
   }
-  
 
   // Replace current servers with new servers with the same name from the given list
   Bool_t ret(kFALSE) ;
@@ -959,7 +959,7 @@
   Bool_t propValue, propShape ;
   while ((oldServer=(RooAbsArg*)sIter->Next())) {
 
-    newServer= oldServer->findNewServer(newSet, nameChange);
+    newServer= oldServer->findNewServer(*newSet, nameChange);
 
     if (newServer && _verboseDirty) {
       cxcoutD(LinkStateMgmt) << "RooAbsArg::redirectServers(" << (void*)this << "," << GetName() << "): server " << oldServer->GetName()
@@ -989,7 +989,7 @@
   setShapeDirty() ;
 
   // Take self out of newset disallowing cyclical dependencies
-  RooAbsCollection* newSet2 = (RooAbsCollection*) newSet.clone("newSet2") ;
+  RooAbsCollection* newSet2 = (RooAbsCollection*) newSet->clone("newSet2") ;
   newSet2->remove(*this,kTRUE,kTRUE) ;
 
   // Process the proxies
@@ -1010,10 +1010,14 @@
 
   // Optional subclass post-processing
   for (Int_t i=0 ;i<numCaches() ; i++) {
-    ret |= getCache(i)->redirectServersHook(newSet,mustReplaceAll,nameChange,isRecursionStep) ;
+    ret |= getCache(i)->redirectServersHook(*newSet,mustReplaceAll,nameChange,isRecursionStep) ;
   }
-  ret |= redirectServersHook(newSet,mustReplaceAll,nameChange,isRecursionStep) ;
+  ret |= redirectServersHook(*newSet,mustReplaceAll,nameChange,isRecursionStep) ;
 
+  if (nameChange) {
+    delete newSet ;
+  }
+
   return ret ;
 }
 
Index: roofitcore/src/RooAbsPdf.cxx
===================================================================
--- roofitcore/src/RooAbsPdf.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooAbsPdf.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -368,7 +368,6 @@
   if (_verboseEval>1) cxcoutD(Tracing) << IsA()->GetName() << "::getNorm(" << GetName() << "): norm(" << _norm << ") = " << _norm->getVal() << endl ;
 
   Double_t ret = _norm->getVal() ;
-//   cout << "RooAbsPdf::getNorm(" << GetName() << ") norm obj = " << _norm->GetName() << endl ;
   if (ret==0.) {
     if(++_errorCount <= 10) {
       coutW(Eval) << "RooAbsPdf::getNorm(" << GetName() << ":: WARNING normalization is zero, nset = " ;  nset->Print("1") ;
@@ -629,7 +628,7 @@
 
 
 //_____________________________________________________________________________
-Double_t RooAbsPdf::extendedTerm(UInt_t observed, const RooArgSet* nset) const 
+Double_t RooAbsPdf::extendedTerm(Double_t observed, const RooArgSet* nset) const 
 {
   // Returned the extended likelihood term (Nexpect - Nobserved*log(NExpected)
   // of this PDF for the given number of observed events
Index: roofitcore/src/RooBanner.cxx
===================================================================
--- roofitcore/src/RooBanner.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooBanner.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -11,7 +11,7 @@
 // END_HTML
 //
 
-const char* VTAG="3.16" ;
+const char* VTAG="3.17" ;
 
 Int_t doBanner()
 
Index: roofitcore/src/RooMinuit.cxx
===================================================================
--- roofitcore/src/RooMinuit.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooMinuit.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -121,6 +121,7 @@
   _printLevel = 1 ;
   _printEvalErrors = 10 ;
   _warnLevel = -999 ;
+  _maxEvalMult = 500 ;
   _doEvalErrorWall = kTRUE ;
 
   // Examine parameter list
@@ -158,7 +159,7 @@
   _initConstParamList = (RooArgList*) _constParamList->snapshot(kFALSE) ;
 
   // Initialize MINUIT
-  Int_t nPar= _floatParamList->getSize();
+  Int_t nPar= _floatParamList->getSize() + _constParamList->getSize() ;
   if (_theFitter) delete _theFitter ;
   _theFitter = new TFitter(nPar*2+1) ; //WVE Kludge, nPar*2 works around TMinuit memory allocation bug
   _theFitter->SetObjectFit(this) ;
@@ -300,7 +301,7 @@
   _theFitter->SetObjectFit(this) ;
 
   Double_t arglist[2];
-  arglist[0]= 500*_nPar; // maximum iterations
+  arglist[0]= _maxEvalMult*_nPar; // maximum iterations
   arglist[1]= 1.0;       // tolerance
 
   synchronize(_verbose) ;
@@ -331,7 +332,7 @@
   _theFitter->SetObjectFit(this) ;
 
   Double_t arglist[2];
-  arglist[0]= 500*_nPar; // maximum iterations
+  arglist[0]= _maxEvalMult*_nPar; // maximum iterations
 
   synchronize(_verbose) ;
   profileStart() ;
@@ -361,7 +362,7 @@
   _theFitter->SetObjectFit(this) ;
 
   Double_t arglist[2];
-  arglist[0]= 500*_nPar; // maximum iterations
+  arglist[0]= _maxEvalMult*_nPar; // maximum iterations
 
   synchronize(_verbose) ;
   profileStart() ;
@@ -407,7 +408,7 @@
     }
     delete aIter ;
   }
-  arglist[0]= 500*_nPar; // maximum iterations
+  arglist[0]= _maxEvalMult*_nPar; // maximum iterations
 
   synchronize(_verbose) ;
   profileStart() ;
@@ -439,7 +440,7 @@
   _theFitter->SetObjectFit(this) ;
 
   Double_t arglist[2];
-  arglist[0]= 500*_nPar; // maximum iterations
+  arglist[0]= _maxEvalMult*_nPar; // maximum iterations
 
   synchronize(_verbose) ;
   profileStart() ;
@@ -469,7 +470,7 @@
   _theFitter->SetObjectFit(this) ;
 
   Double_t arglist[2];
-  arglist[0]= 500*_nPar; // maximum iterations
+  arglist[0]= _maxEvalMult*_nPar; // maximum iterations
   arglist[1]= 1.0;       // tolerance
 
   synchronize(_verbose) ;
@@ -500,7 +501,7 @@
   _theFitter->SetObjectFit(this) ;
 
   Double_t arglist[2];
-  arglist[0]= 500*_nPar; // maximum iterations
+  arglist[0]= _maxEvalMult*_nPar; // maximum iterations
 
   synchronize(_verbose) ;
   profileStart() ;
Index: roofitcore/src/RooWorkspace.cxx
===================================================================
--- roofitcore/src/RooWorkspace.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooWorkspace.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -1440,6 +1440,13 @@
     return kTRUE ;
   }
 
+  // Check if class is listed in a ROOTMAP file - if so we can skip it because it is in the root distribtion
+  const char* mapEntry = gInterpreter->GetClassSharedLibs(tc->GetName()) ;
+  if (mapEntry && strlen(mapEntry)>0) {
+    oocxcoutD(_wspace,ObjectHandling) << "RooWorkspace::CodeRepo(" << _wspace->GetName() << ") code of class " << tc->GetName() << " is in ROOT distribution, skipping " << endl ;
+    return kTRUE ;
+  }
+
   // Retrieve file names through ROOT TClass interface
   string implfile = tc->GetImplFileName() ;
   string declfile = tc->GetDeclFileName() ;
Index: roofitcore/src/RooSimultaneous.cxx
===================================================================
--- roofitcore/src/RooSimultaneous.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/src/RooSimultaneous.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -1089,3 +1089,9 @@
   delete globClone ;
   return data ;
 }
+
+
+
+
+
+
Index: roofitcore/inc/RooMinuit.h
===================================================================
--- roofitcore/inc/RooMinuit.h	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/inc/RooMinuit.h	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -67,6 +67,7 @@
   void setPrintEvalErrors(Int_t numEvalErrors) { _printEvalErrors = numEvalErrors ; }
   void setVerbose(Bool_t flag=kTRUE) { _verbose = flag ; }
   void setProfile(Bool_t flag=kTRUE) { _profile = flag ; }
+  void setMaxEvalMultiplier(Int_t n) { _maxEvalMult = n ; }
   Bool_t setLogFile(const char* logfile=0) ;  
 
   static void cleanup() ;
@@ -111,6 +112,7 @@
   Int_t       _nPar ;
   Int_t       _printEvalErrors ;
   Bool_t      _doEvalErrorWall ;
+  Int_t       _maxEvalMult ;
   RooArgList* _floatParamList ;
   RooArgList* _initFloatParamList ;
   RooArgList* _constParamList ;
Index: roofitcore/inc/RooAbsPdf.h
===================================================================
--- roofitcore/inc/RooAbsPdf.h	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/inc/RooAbsPdf.h	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -237,7 +237,7 @@
   static void verboseEval(Int_t stat) ;
   static int verboseEval() ;
 
-  virtual Double_t extendedTerm(UInt_t observedEvents, const RooArgSet* nset=0) const ;
+  virtual Double_t extendedTerm(Double_t observedEvents, const RooArgSet* nset=0) const ;
 
   static void clearEvalError() ;
   static Bool_t evalError() ;
Index: roofitcore/inc/RooSimultaneous.h
===================================================================
--- roofitcore/inc/RooSimultaneous.h	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roofitcore/inc/RooSimultaneous.h	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -79,7 +79,7 @@
   const RooAbsCategoryLValue& indexCat() const { return (RooAbsCategoryLValue&) _indexCat.arg() ; }
 
   virtual RooDataSet* generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents) ;
-  
+
 protected:
 
   void initialize(RooAbsCategoryLValue& inIndexCat, std::map<std::string,RooAbsPdf*> pdfMap) ;
Index: roostats/src/HypoTestResult.cxx
===================================================================
--- roostats/src/HypoTestResult.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/src/HypoTestResult.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -172,7 +172,8 @@
    // unsigned const int n_b = fNullDistr->GetSamplingDistribution().size();
    // unsigned const int n_sb = fAltDistr->GetSamplingDistribution().size();
 
-   if (CLb() == 0 ) return numeric_limits<double>::infinity();
+   // if CLb() == 0 CLs = -1 so return a -1 error
+   if (CLb() == 0 ) return -1;
 
    double cl_b_err2 = pow(CLbError(),2);
    double cl_sb_err2 = pow(CLsplusbError(),2);
Index: roostats/src/FrequentistCalculator.cxx
===================================================================
--- roostats/src/FrequentistCalculator.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/src/FrequentistCalculator.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -38,6 +38,8 @@
    // create profile keeping everything but nuisance parameters fixed
    RooArgSet allButNuisance(*fNullModel->GetPdf()->getParameters(*fData));
    allButNuisance.remove(*fNullModel->GetNuisanceParameters());
+   // remove also the constant parameters otherwise RooProfileLL will float them
+   RemoveConstantParameters(&allButNuisance);
    RooAbsReal* nll = fNullModel->GetPdf()->createNLL(*const_cast<RooAbsData*>(fData), RooFit::CloneData(kFALSE));
    RooAbsReal* profile = nll->createProfile(allButNuisance);
    profile->getVal(); // this will do fit and set nuisance parameters to profiled values
@@ -98,6 +100,8 @@
    // create profile keeping everything but nuisance parameters fixed
    RooArgSet allButNuisance(*fAltModel->GetPdf()->getParameters(*fData));
    allButNuisance.remove(*fAltModel->GetNuisanceParameters());
+   // remove also the constant parameters otherwise RooProfileLL will float them
+   RemoveConstantParameters(&allButNuisance);
    RooAbsReal* nll = fAltModel->GetPdf()->createNLL(*const_cast<RooAbsData*>(fData), RooFit::CloneData(kFALSE));
    RooAbsReal* profile = nll->createProfile(allButNuisance);
    profile->getVal(); // this will do fit and set nuisance parameters to profiled values
Index: roostats/src/SimpleLikelihoodRatioTestStat.cxx
===================================================================
--- roostats/src/SimpleLikelihoodRatioTestStat.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/src/SimpleLikelihoodRatioTestStat.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -1,4 +1,4 @@
 
 #include "RooStats/SimpleLikelihoodRatioTestStat.h"
 
-Bool_t RooStats::SimpleLikelihoodRatioTestStat::fAlwaysReuseNll = kFALSE ;
+Bool_t RooStats::SimpleLikelihoodRatioTestStat::fAlwaysReuseNll = kTRUE ;
Index: roostats/src/HypoTestInverterResult.cxx
===================================================================
--- roostats/src/HypoTestInverterResult.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/src/HypoTestInverterResult.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -69,8 +69,14 @@
    fLowerLimitError(0),
    fUpperLimitError(0)
 {
-  // constructor 
+   // constructor 
    fYObjects.SetOwner();
+   // put a cloned copy of scanned variable to set in the interval
+   // to avoid I/O problem of the Result class - 
+   // make the set owning the cloned copy (use clone istead of Clone to not copying all links)
+   fParameters.removeAll();
+   fParameters.takeOwnership();
+   fParameters.addOwned(*((RooRealVar *) scannedVariable.clone(scannedVariable.GetName()) ));
 }
 
 
@@ -83,9 +89,17 @@
 
 bool HypoTestInverterResult::Add( const HypoTestInverterResult& otherResult   )
 {
-  /// Merge this HypoTestInverterResult with another
-  /// HypoTestInverterResult passed as argument
+   // Merge this HypoTestInverterResult with another
+   // HypoTestInverterResult passed as argument
+   // The merge is done by combining the HypoTestResult when the same point value exist in both results.
+   // If results exist at different points these are added in the new result
+   // NOTE: Merging of the expected p-values obtained with pseudo-data.
+   //  When expected p-values exist in the result (i.e. when rebuild option is used when getting the expected 
+   // limit distribuiton in the HYpoTestInverter) then the expected p-values are also merged. This is equivalent 
+   // at merging the pseudo-data. However there can be an inconsistency if the expected p-values have been 
+   // obtained with different toys. In this case the merge is done but a warning message is printed.
 
+
    int nThis = ArraySize();
    int nOther = otherResult.ArraySize();
    if (nOther == 0) return true;
@@ -102,6 +116,10 @@
    bool addExpPValues = (fExpPValues.GetSize() == 0 && otherResult.fExpPValues.GetSize() > 0);
    bool mergeExpPValues = (fExpPValues.GetSize() > 0 && otherResult.fExpPValues.GetSize() > 0);
 
+   if (addExpPValues || mergeExpPValues)
+      oocoutI(this,Eval) << "HypoTestInverterResult::Add - merging also the expected p-values from pseudo-data" << std::endl;
+
+
    if (nThis == 0) {
       fXValues = otherResult.fXValues;
       for (int i = 0; i < nOther; ++i) 
@@ -115,7 +133,7 @@
       HypoTestResult * otherHTR = (HypoTestResult*) otherResult.fYObjects.At(i);
       if (otherHTR == 0) continue;
       bool sameXFound = false;
-      for (int j = 0; j < nOther; ++j) {
+      for (int j = 0; j < nThis; ++j) {
          double thisVal = fXValues[j];
          
             // if same value merge the result 
@@ -126,7 +144,11 @@
                sameXFound = true;
                if (mergeExpPValues) { 
                   ((SamplingDistribution*) fExpPValues.At(j))->Add( (SamplingDistribution*)otherResult.fExpPValues.At(i) );
-                  std::cout << "adding expected p -values " << std::endl;
+                  // check if same toys have been used for the test statistic distribution
+                  int thisNToys = (thisHTR->GetNullDistribution() ) ? thisHTR->GetNullDistribution()->GetSize() : 0;
+                  int otherNToys = (otherHTR->GetNullDistribution() ) ? otherHTR->GetNullDistribution()->GetSize() : 0;
+                  if (thisNToys != otherNToys ) 
+                     oocoutW(this,Eval) << "HypoTestInverterResult::Add expexted p values have been generated with different toys " << thisNToys << " , " << otherNToys << std::endl;                  
                }
                break;
             }
@@ -140,6 +162,7 @@
       if (addExpPValues)  
          fExpPValues.Add( otherResult.fExpPValues.At(i)->Clone() );
 
+
    }
    
    if (ArraySize() > nThis) 
@@ -294,9 +317,11 @@
 
 double HypoTestInverterResult::GetGraphX(const TGraph & graph, double y0, bool lowSearch, double axmin, double axmax) const  {
    // return the X value of the given graph for the target value y0
-   // the graph is evaluated using linea rinterpolation by default. 
+   // the graph is evaluated using linear interpolation by default. 
    // if option = "S" a TSpline3 is used 
 
+
+
    TString opt = "";
    if (fInterpolOption == kSpline)  opt = "S";
 
@@ -307,24 +332,30 @@
    // find reasanable xmin and xmax if not given
    const double * y = graph.GetY(); 
    int n = graph.GetN();
+   if (n < 2) {
+      ooccoutE(this,Eval) << "HypoTestInverterResult::GetGraphX - need at least 2 points for interpolation (n=" << n << ")\n";
+      return (n>0) ?  y[0] : 0;
+   } 
+
    double xmin = axmin; 
    double xmax = axmax;
+   // case no range is given check if need to extrapolate to lower/upper values 
    if (axmin >= axmax) { 
       xmin = graph.GetX()[0];
       xmax = graph.GetX()[n-1];
-      // test if extrapolation is needed (only for case full range is given)
-      if (n > 1) { 
-         // do lower extrapolation 
-         if ( (y[0] < y0 && y[1] < y[0]) || (y[0] > y0 && y[1] > y[0])  ) {         
-            const RooRealVar* var = dynamic_cast<RooRealVar*>( fParameters.first() );
-            if (var) xmin = var->getMin();
-         }
-         // do upper extrapolation  
-         if ( (y[n-1] > y0 && y[n-2] > y[n-1]) || (y[n-1] < y0 && y[n-2] < y[n-1])  ) {         
-            const RooRealVar* var = dynamic_cast<RooRealVar*>( fParameters.first() );
-            if (var) xmax = var->getMax();
-         }
+      // find ymin and ymax  and corresponding values 
+      double ymin = TMath::MinElement(n,y);
+      double ymax = TMath::MaxElement(n,y);
+      // do lower extrapolation 
+      if ( (ymax < y0 && !lowSearch) || ( ymin > y0 && lowSearch) ) { 
+         const RooRealVar* var = dynamic_cast<RooRealVar*>( fParameters.first() );
+         if (var) xmin = var->getMin();
       }
+      // do upper extrapolation  
+      if ( (ymax < y0 && lowSearch) || ( ymin > y0 && !lowSearch) ) { 
+         const RooRealVar* var = dynamic_cast<RooRealVar*>( fParameters.first() );
+         if (var) xmax = var->getMax();
+      }
    }
 
    brf.SetFunction(wf,xmin,xmax);
@@ -363,9 +394,11 @@
 
 
    if (ArraySize()<2) {
-      std::cout << "Error: not enough points to get the inverted interval\n";
-      if (target<0.5) return ((RooRealVar*)fParameters.first())->getMax();
-      else return ((RooRealVar*)fParameters.first())->getMin();
+      double val =  (lowSearch) ? xmin : xmax;
+      oocoutW(this,Eval) << "HypoTestInverterResult::FindInterpolatedLimit" 
+                         << " - not enough points to get the inverted interval - return " 
+                         <<  val << std::endl;
+      return val;
    }
 
    // sort the values in x 
@@ -435,12 +468,15 @@
   // point.
    
   if (ArraySize()==0) {
-    std::cout << "Empty result \n";
+     oocoutW(this,Eval) << "HypoTestInverterResult::CalculateEstimateError" 
+                        << "Empty result \n";
     return 0;
   }
 
   if (ArraySize()<2) {
-    std::cout << "not enough points to get the inverted interval\n";
+     oocoutW(this,Eval) << "HypoTestInverterResult::CalculateEstimateError" 
+                        << " only  points - return its error\n"; 
+     return GetYError(0);
   }
  
   // The graph contains the points sorted by their x-value
@@ -538,12 +574,13 @@
 
 SamplingDistribution *  HypoTestInverterResult::GetLimitDistribution(bool lower ) const { 
    // get the limit distribution (lower/upper depending on the flag)
+   // by interpolating  the expected p values for each point
 
-   //std::cout << "Interpolate the upper limit between the 2 results closest to the target confidence level" << endl;
 
   if (ArraySize()<2) {
-    std::cout << "Error: not enough points to get the inverted interval\n";
-    return 0; 
+     oocoutE(this,Eval) << "HypoTestInverterResult::GetLimitDistribution" 
+                        << " not  enought points -  return a NULL pointer " << std::endl; 
+     return 0; 
   }
 
   ooccoutD(this,Eval) << "HypoTestInverterResult - computing  limit distribution...." << std::endl;
Index: roostats/src/ToyMCSampler.cxx
===================================================================
--- roostats/src/ToyMCSampler.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/src/ToyMCSampler.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -410,8 +410,19 @@
    const RooArgSet* saveVars = (const RooArgSet*)allVars->snapshot();
 
    if(fNuisanceParametersSampler) { // use nuisance parameters?
+      // Construct a set of nuisance parameters that has the parameters
+      // in the input paramPoint removed. Therefore, no parameter in
+      // paramPoint is randomized.
+      // Therefore when a parameter is given (should be held fixed),
+      // but is also in the list of nuisance parameters, the parameter
+      // will be held fixed. This is useful for debugging to hold single
+      // parameters fixed although under "normal" circumstances it is
+      // randomized.
+      RooArgSet allVarsMinusParamPoint(*allVars);
+      allVarsMinusParamPoint.remove(paramPoint, kFALSE, kTRUE); // match by name
+
       // get nuisance parameter point and weight
-      fNuisanceParametersSampler->NextPoint(*allVars, weight);
+      fNuisanceParametersSampler->NextPoint(allVarsMinusParamPoint, weight);
    }else{
       weight = -1.0;
    }
@@ -470,8 +481,19 @@
    const RooArgSet* saveVars = (const RooArgSet*)allVars->snapshot();
 
    if(fNuisanceParametersSampler) { // use nuisance parameters?
+      // Construct a set of nuisance parameters that has the parameters
+      // in the input paramPoint removed. Therefore, no parameter in
+      // paramPoint is randomized.
+      // Therefore when a parameter is given (should be held fixed),
+      // but is also in the list of nuisance parameters, the parameter
+      // will be held fixed. This is useful for debugging to hold single
+      // parameters fixed although under "normal" circumstances it is
+      // randomized.
+      RooArgSet allVarsMinusParamPoint(*allVars);
+      allVarsMinusParamPoint.remove(paramPoint, kFALSE, kTRUE); // match by name
+
       // get nuisance parameter point and weight
-      fNuisanceParametersSampler->NextPoint(*allVars, weight);
+      fNuisanceParametersSampler->NextPoint(allVarsMinusParamPoint, weight);
    }else{
       weight = -1.0;
    }
Index: roostats/src/HypoTestInverter.cxx
===================================================================
--- roostats/src/HypoTestInverter.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/src/HypoTestInverter.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -393,12 +393,12 @@
 
 HypoTestInverterResult* HypoTestInverter::GetInterval() const { 
    // Run a fixed scan or the automatic scan depending on the configuration
-   // Return a copy of the result object which will be managed by the user
+   // Return if needed a copy of the result object which will be managed by the user
 
-   // if having a result with more than one point return it
-   if (fResults && fResults->ArraySize() > 1) { 
+   // if having a result with at least  one point return it
+   if (fResults && fResults->ArraySize() >= 1) { 
       oocoutI((TObject*)0,Eval) << "HypoTestInverter::GetInterval - return an already existing interval " << std::endl;          
-      return (HypoTestInverterResult*)(fResults->Clone());
+      return  (HypoTestInverterResult*)(fResults->Clone());
    }
 
    if (fNBins > 0) {
@@ -417,7 +417,7 @@
 
    if (fgCloseProof) ProofConfig::CloseProof();
 
-   return (fResults) ? (HypoTestInverterResult*)(fResults->Clone()) : 0;
+   return (HypoTestInverterResult*) (fResults->Clone());
 }
 
 
@@ -506,35 +506,50 @@
    fResults->fFittedLowerLimit = false; 
    fResults->fFittedUpperLimit = false; 
 
-  // safety checks
-  if ( nBins<=0 ) {
-    std::cout << "Please provide nBins>0\n";
-    return false;
-  }
-  if ( nBins==1 && xMin!=xMax ) {
-    std::cout << "nBins==1 -> I will run for xMin (" << xMin << ")\n";
-  }
-  if ( xMin==xMax && nBins>1 ) { 
-    std::cout << "xMin==xMax -> I will enforce nBins==1\n";
-    nBins = 1;
-  }
-  if ( xMin>xMax ) {
-    std::cout << "Please provide xMin (" << xMin << ") smaller that xMax (" << xMax << ")\n";
-    return false;
-  } 
-  
-  for (int i=0; i<nBins; i++) {
-    double thisX = xMin+i*(xMax-xMin)/(nBins-1);
-    bool status = RunOnePoint(thisX);
-    
-    // check if failed status
-    if ( status==false ) {
-      std::cout << "\t\tLoop interupted because of failed status\n";
+   // safety checks
+   if ( nBins<=0 ) {
+      oocoutE((TObject*)0,InputArguments) << "HypoTestInverter::RunFixedScan - Please provide nBins>0\n";
       return false;
-    }
-  }
+   }
+   if ( nBins==1 && xMin!=xMax ) {
+      oocoutW((TObject*)0,InputArguments) << "HypoTestInverter::RunFixedScan - nBins==1 -> I will run for xMin (" << xMin << ")\n";
+   }
+   if ( xMin==xMax && nBins>1 ) { 
+      oocoutW((TObject*)0,InputArguments) << "HypoTestInverter::RunFixedScan - xMin==xMax -> I will enforce nBins==1\n";
+      nBins = 1;
+   }
+   if ( xMin>xMax ) {
+      oocoutE((TObject*)0,InputArguments) << "HypoTestInverter::RunFixedScan - Please provide xMin (" 
+                                          << xMin << ") smaller that xMax (" << xMax << ")\n";
+      return false;
+   } 
 
-  return true;
+   if (xMin < fScannedVariable->getMin()) {
+      xMin = fScannedVariable->getMin();
+      oocoutW((TObject*)0,InputArguments) << "HypoTestInverter::RunFixedScan - xMin < lower bound, use xmin = "
+                                          << xMin << std::endl; 
+   }
+   if (xMax > fScannedVariable->getMax()) { 
+      xMax = fScannedVariable->getMax();
+      oocoutW((TObject*)0,InputArguments) << "HypoTestInverter::RunFixedScan - xMax > upper bound, use xmax = "   
+                                          << xMax << std::endl; 
+   }         
+
+   
+   double thisX = xMin;
+   for (int i=0; i<nBins; i++) {
+      // for one bin scan at xMin
+      if (i>0) thisX += (xMax-xMin)/(nBins-1); 
+      bool status = RunOnePoint(thisX);
+  
+      // check if failed status
+      if ( status==false ) {
+         std::cout << "\t\tLoop interrupted because of failed status\n";
+         return false;
+      }
+   }
+
+   return true;
 }
 
 
@@ -545,16 +560,18 @@
    CreateResults();
 
    // check if rVal is in the range specified for fScannedVariable
-   if ( rVal<fScannedVariable->getMin() ) {
+   if ( rVal < fScannedVariable->getMin() ) {
       oocoutE((TObject*)0,InputArguments) << "HypoTestInverter::RunOnePoint - Out of range: using the lower bound " 
                                           << fScannedVariable->getMin() 
                                           << " on the scanned variable rather than " << rVal<< "\n";
      rVal = fScannedVariable->getMin();
    }
-   if ( rVal>fScannedVariable->getMax() ) {
-      oocoutE((TObject*)0,InputArguments) << "HypoTestInverter::RunOnePoint - Out of range: using the upper bound " 
-                                          << fScannedVariable->getMax() 
-                                          << " on the scanned variable rather than " << rVal<< "\n";
+   if ( rVal > fScannedVariable->getMax() ) {
+      // print a message when you have a significative difference since rval is computed
+      if ( rVal > fScannedVariable->getMax()*(1.+1.E-12) )
+         oocoutE((TObject*)0,InputArguments) << "HypoTestInverter::RunOnePoint - Out of range: using the upper bound " 
+                                             << fScannedVariable->getMax() 
+                                             << " on the scanned variable rather than " << rVal<< "\n";
      rVal = fScannedVariable->getMax();
    }
 
Index: roostats/src/ProfileLikelihoodTestStat.cxx
===================================================================
--- roostats/src/ProfileLikelihoodTestStat.cxx	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/src/ProfileLikelihoodTestStat.cxx	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -1,4 +1,4 @@
 
 #include "RooStats/ProfileLikelihoodTestStat.h"
 
-Bool_t RooStats::ProfileLikelihoodTestStat::fgAlwaysReuseNll = kFALSE ;
+Bool_t RooStats::ProfileLikelihoodTestStat::fgAlwaysReuseNll = kTRUE ;

Property changes on: roostats/src
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/roofit/roostats/src:r40092,40095,40132,40241,40249,40252,40254,40292-40294,40565,40718

Index: roostats/inc/RooStats/HypoTestInverter.h
===================================================================
--- roostats/inc/RooStats/HypoTestInverter.h	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/inc/RooStats/HypoTestInverter.h	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -134,6 +134,7 @@
 
    // set flag to close proof for every new run
    static void SetCloseProof(Bool_t flag);
+
   
 protected:
 
Index: roostats/inc/RooStats/ProfileLikelihoodTestStat.h
===================================================================
--- roostats/inc/RooStats/ProfileLikelihoodTestStat.h	(.../tags/v5-30-00/roofit)	(revision 40814)
+++ roostats/inc/RooStats/ProfileLikelihoodTestStat.h	(.../branches/v5-30-00-patches/roofit)	(revision 40814)
@@ -1,5 +1,6 @@
 // @(#)root/roostats:$Id: roofit-5.30.00-up-to-40810.patch,v 1.1 2011/09/08 21:08:26 eulisse Exp $
 // Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke
+// Additional Contributions: Giovanni Petrucciani 
 /*************************************************************************
  * Copyright (C) 1995-2008, Rene Brun and Fons Rademakers.               *
  * All rights reserved.                                                  *
@@ -47,6 +48,8 @@
 #include "RooNLLVar.h"
 
 #include "RooMinuit.h"
+#include "RooMinimizer.h"
+#include "Math/MinimizerOptions.h"
 
 namespace RooStats {
 
@@ -62,6 +65,10 @@
         fLastData = 0;
 	fOneSided = false;
         fReuseNll = false;
+	fMinimizer=ROOT::Math::MinimizerOptions::DefaultMinimizerType().c_str();
+	fStrategy=ROOT::Math::MinimizerOptions::DefaultStrategy();
+	fPrintLevel=ROOT::Math::MinimizerOptions::DefaultPrintLevel();
+
      }
      ProfileLikelihoodTestStat(RooAbsPdf& pdf) {
        fPdf = &pdf;
@@ -71,6 +78,9 @@
        fLastData = 0;
        fOneSided = false;
        fReuseNll = false;
+       fMinimizer=ROOT::Math::MinimizerOptions::DefaultMinimizerType();
+       fStrategy=ROOT::Math::MinimizerOptions::DefaultStrategy();
+       fPrintLevel=ROOT::Math::MinimizerOptions::DefaultPrintLevel();
      }
      virtual ~ProfileLikelihoodTestStat() {
        //       delete fRand;
@@ -83,6 +93,10 @@
 
      static void SetAlwaysReuseNLL(Bool_t flag) { fgAlwaysReuseNll = flag ; }
      void SetReuseNLL(Bool_t flag) { fReuseNll = flag ; }
+
+     void SetMinimizer(const char* minimizer){ fMinimizer=minimizer;}
+     void SetStrategy(Int_t strategy){fStrategy=strategy;}
+     void SetPrintLevel(Int_t printlevel){fPrintLevel=printlevel;}
     
      // Main interface to evaluate the test statistic on a dataset
      virtual Double_t Evaluate(RooAbsData& data, RooArgSet& paramsOfInterest) {
@@ -103,16 +117,22 @@
        
        Bool_t created(kFALSE) ;
        if (!reuse || fNll==0) {
-	 fNll = (RooNLLVar*) fPdf->createNLL(data, RooFit::CloneData(kFALSE));
-	 fProfile = (RooProfileLL*) fNll->createProfile(paramsOfInterest);
+	 RooArgSet* allParams = fPdf->getParameters(data);
+	 RooStats::RemoveConstantParameters(allParams);
+
+	 // need to call constrain for RooSimultaneous until stripDisconnected problem fixed
+	 fNll = (RooNLLVar*) fPdf->createNLL(data, RooFit::CloneData(kFALSE),RooFit::Constrain(*allParams));
+
+	 //	 fNll = (RooNLLVar*) fPdf->createNLL(data, RooFit::CloneData(kFALSE));
+	 //	 fProfile = (RooProfileLL*) fNll->createProfile(paramsOfInterest);
 	 created = kTRUE ;
 	 //cout << "creating profile LL " << fNll << " " << fProfile << " data = " << &data << endl ;
        }
        if (reuse && !created) {
 	 //cout << "reusing profile LL " << fNll << " new data = " << &data << endl ;
 	 fNll->setData(data,kFALSE) ;
- 	 if (fProfile) delete fProfile ; 
- 	 fProfile = (RooProfileLL*) fNll->createProfile(paramsOfInterest) ; 
+	 // 	 if (fProfile) delete fProfile ; 
+	 // 	 fProfile = (RooProfileLL*) fNll->createProfile(paramsOfInterest) ; 
 	 //fProfile->clearAbsMin() ;
        }
 
@@ -121,14 +141,18 @@
        RooArgSet* attachedSet = fNll->getVariables();
 
        *attachedSet = paramsOfInterest;
+       RooArgSet* origAttachedSet = (RooArgSet*) attachedSet->snapshot();
 
-
+       ///////////////////////////////////////////////////////////////////////
+       // Main profiling version as of 5.30
        //       fPdf->setEvalErrorLoggingMode(RooAbsReal::CountErrors);
        //       profile->setEvalErrorLoggingMode(RooAbsReal::CountErrors);
        //       ((RooProfileLL*)profile)->nll().setEvalErrorLoggingMode(RooAbsReal::CountErrors);
        //       nll->setEvalErrorLoggingMode(RooAbsReal::CountErrors);
        //cout << "evaluating profile LL" << endl ;
-       double ret = fProfile->getVal();
+
+       //      double ret = fProfile->getVal();  // previous main evaluation
+
        //       cout << "profile value = " << ret << endl ;
        //       cout <<"eval errors pdf = "<<fPdf->numEvalErrors() << endl;
        //       cout <<"eval errors profile = "<<profile->numEvalErrors() << endl;
@@ -138,193 +162,133 @@
        //       	 cout <<"eval errors = "<<profile->numEvalErrors() << endl;
        //       paramsOfInterest.Print("v");
        //       cout << "ret = " << ret << endl;
+       ///////////////////////////////////////////////////////////////////////
 
-       if(fOneSided){
-	 double fit_favored_mu = ((RooProfileLL*) fProfile)->bestFitObs().getRealValue(firstPOI->GetName()) ;
-       
-	 if( fit_favored_mu > initial_mu_value)
-	   // cout <<"fit-favored_mu, initial value" << fit_favored_mu << " " << initial_mu_value<<endl;
-	   ret = 0 ;
-       }
-       delete attachedSet;
 
-       if (!reuse) {
-	 //cout << "deleting ProfileLL " << fNll << " " << fProfile << endl ;
-	 delete fNll;
-	 fNll = 0; 
-	 delete fProfile;
-	 fProfile = 0 ;
-       }
+       ///////////////////////////////////////////////////////////////////////
+       // New profiling based on RooMinimizer (allows for Minuit2)
+       // based on major speed increases seen by CMS for complex problems
 
-       RooMsgService::instance().setGlobalKillBelow(msglevel);
-
-       //////////////////////////////////////////////////////
-       // return here and forget about the following code
-       return ret;
+       /*
+       // set the parameters of interest to be fixed for the conditional MLE
+       TIterator* it = paramsOfInterest.createIterator();
+       RooRealVar* tmpPar = NULL, *tmpParA=NULL;
+       while((tmpPar = (RooRealVar*)it->Next())){
+	 tmpParA =  ((RooRealVar*)attachedSet->find(tmpPar->GetName()));
+	 tmpParA->setConstant();
+       }
        
+       //       cout <<"using Minimizer: "<< fMinimizer<< " with strategy = " << fStrategy << endl;
 
+       // get the numerator
+       int statusN;
+       double condML = GetMinNLL(statusN);
 
-       //////////////////////////////////////////////////////////
-       // OLD version with some handling for local minima
-       // (not used right now)
-       /////////////////////////////////////////////////////////
 
+       // set the parameters of interest back to floating
+       it->Reset();
+       while((tmpPar = (RooRealVar*)it->Next())){
+	 tmpParA =  ((RooRealVar*)attachedSet->find(tmpPar->GetName()));
+	 tmpParA->setConstant(false);
+       }
+       delete it;
 
-         bool needToRebuild = true; // try to avoid rebuilding if possible
+       // get the denominator
+       int statusD;
+       double uncondML = GetMinNLL(statusD);
+       */
 
-         if (fLastData == &data) // simple pointer comparison for now (note NLL makes COPY of data)
-            needToRebuild = false;
-         else fLastData = &data; // keep a copy of pointer to original data
 
-         // pointer comparison causing problems.  See multiple datasets with same value of pointer
-         // but actually a new dataset
-         needToRebuild = true;
+       // other order
+       // get the numerator
+       RooArgSet* snap =  (RooArgSet*)paramsOfInterest.snapshot();
+       // get the denominator
+       int statusD;
+       double uncondML = GetMinNLL(statusD);
 
-         // check mem leak in NLL or Profile. Should remove.
-         // if(fProfile) needToRebuild = false;
+       // get best fit value for one-sided interval 
+       double fit_favored_mu = attachedSet->getRealValue(firstPOI->GetName()) ;
 
+       double ret = 0; 
+       int statusN = 0;
 
-         if (needToRebuild) {
-            if (fProfile) delete fProfile;
-            if (fNll) delete fNll;
+       // do the conditional ML (the numerator) only when fit value is smaller than test value
+       if (!fOneSided || fit_favored_mu <= initial_mu_value) {  
 
-            /*
-             RooNLLVar* nll = new RooNLLVar("nll","",*fPdf,data, RooFit::Extended());
-             fNll = nll;
-             fProfile = new RooProfileLL("pll","",*nll, paramsOfInterest);
-             */
-            RooArgSet* constrainedParams = fPdf->getParameters(data);
-            RemoveConstantParameters(constrainedParams);
-            //cout << "cons: " << endl;
-            //constrainedParams->Print("v");
+          //       cout <<" reestablish snapshot"<<endl;
+          *attachedSet = *snap;
 
-            RooNLLVar * nll2 = (RooNLLVar*) fPdf->createNLL(
-               data, RooFit::CloneData(kFALSE), RooFit::Constrain(*constrainedParams)
-            );
-            fNll = nll2;
-            fProfile = (RooProfileLL*) nll2->createProfile(paramsOfInterest);
-            delete constrainedParams;
+          // set the POI to constant
+          RooLinkedListIter it = paramsOfInterest.iterator();
+          RooRealVar* tmpPar = NULL, *tmpParA=NULL;
+          while((tmpPar = (RooRealVar*)it.Next())){
+             tmpParA =  ((RooRealVar*)attachedSet->find(tmpPar->GetName()));
+             tmpParA->setConstant();
+          }
 
-            //	 paramsOfInterest.Print("v");
+          double condML = GetMinNLL(statusN);
 
-            // set parameters to previous best fit params, to speed convergence
-            // and to avoid local minima
-            if (fCachedBestFitParams) {
-               // store original values, since minimization will change them.
-               RooArgSet* origParamVals = (RooArgSet*) paramsOfInterest.snapshot();
+          ret=condML-uncondML;
+       }
 
-               // these parameters are not guaranteed to be the best for this data
-               SetParameters(fCachedBestFitParams, fProfile->getParameters(data));
-               // now evaluate to force this profile to evaluate and store
-               // best fit parameters for this data
-               fProfile->getVal();
+       // need to restore the values ?
+       *attachedSet = *origAttachedSet;
 
-               // possibly store last MLE for reference
-               //	 Double mle = fNll->getVal();
+       delete attachedSet;
+       delete origAttachedSet;
+       delete snap;
 
-               // restore parameters
-               SetParameters(origParamVals, &paramsOfInterest);
+       if (!reuse) {
+	 delete fNll;
+	 fNll = 0; 
+	 //	 delete fProfile;
+	 fProfile = 0 ;
+       }
 
-               // cleanup
-               delete origParamVals;
+       RooMsgService::instance().setGlobalKillBelow(msglevel);
 
-            } else {
+       if(statusN!=0 || statusD!=0)
+	 ret= -1; // indicate failed fit
 
-               // store best fit parameters
-               // RooProfileLL::bestFitParams returns best fit of nuisance parameters only
-               //	   fCachedBestFitParams = (RooArgSet*) (fProfile->bestFitParams().clone("lastBestFit"));
-               // ProfileLL::getParameters returns current value of the parameters
-               //	   fCachedBestFitParams = (RooArgSet*) (fProfile->getParameters(data)->clone("lastBestFit"));
-               //cout << "making fCachedBestFitParams: " << fCachedBestFitParams << fCachedBestFitParams->getSize() << endl;
+       return ret;
+             
+     }     
 
-               // store original values, since minimization will change them.
-               RooArgSet* origParamVals = (RooArgSet*) paramsOfInterest.snapshot();
 
-               // find minimum
-               RooMinuit minuit(*fNll);
-               minuit.setPrintLevel(-999);
-               minuit.setNoWarn();
-               minuit.migrad();
 
-               // store the best fit values for future use
-               fCachedBestFitParams = (RooArgSet*) (fNll->getParameters(data)->snapshot());
-
-               // restore parameters
-               SetParameters(origParamVals, &paramsOfInterest);
-
-               // evaluate to force this profile to evaluate and store
-               // best fit parameters for this data
-               fProfile->getVal();
-
-               // cleanup
-               delete origParamVals;
-
-            }
-
-         }
-         // issue warning if problems
-         if (!fProfile) {
-            cout << "problem making profile" << endl;
-         }
-
-         // set parameters to point being requested
-         SetParameters(&paramsOfInterest, fProfile->getParameters(data));
-
-         Double_t value = fProfile->getVal();
-
-         /*
-          // for debugging caching
-          cout << "current value of input params: " << endl;
-          paramsOfInterest.Print("verbose");
-
-          cout << "current value of params in profile: " << endl;
-          fProfile->getParameters(data)->Print("verbose");
-
-          cout << "cached last best fit: " << endl;
-          fCachedBestFitParams->Print("verbose");
-          */
-
-         // catch false minimum
-         if (value < 0) {
-            //	 cout << "ProfileLikelihoodTestStat: problem that profileLL = " << value
-            //	      << " < 0, indicates false min.  Try again."<<endl;
-            delete fNll;
-            delete fProfile;
-            /*
-             RooNLLVar* nll = new RooNLLVar("nll","",*fPdf,data, RooFit::Extended());
-             fNll = nll;
-             fProfile = new RooProfileLL("pll","",*nll, paramsOfInterest);
-             */
-
-            RooArgSet* constrainedParams = fPdf->getParameters(data);
-            RemoveConstantParameters(constrainedParams);
-
-            RooNLLVar * nll2 = (RooNLLVar*) fPdf->createNLL(data, RooFit::CloneData(kFALSE), RooFit::Constrain(
-               *constrainedParams));
-            fNll = nll2;
-            fProfile = (RooProfileLL*) nll2->createProfile(paramsOfInterest);
-            delete constrainedParams;
-
-            // set parameters to point being requested
-            SetParameters(&paramsOfInterest, fProfile->getParameters(data));
-
-            value = fProfile->getVal();
-            //cout << "now profileLL = " << value << endl;
-         }
-         //       cout << "now profileLL = " << value << endl;
-         RooMsgService::instance().setGlobalKillBelow(RooFit::DEBUG);
-         return value;
-
-
-       
-      }
-
     
       virtual const TString GetVarName() const {return "Profile Likelihood Ratio";}
       
       //      const bool PValueIsRightTail(void) { return false; } // overwrites default
 
+  private:
+      double GetMinNLL(int& status) {
 
+	RooMinimizer minim(*fNll);
+	minim.setStrategy(fStrategy);
+        //LM: RooMinimizer.setPrintLevel has +1 offset - so subtruct  here -1
+	minim.setPrintLevel(fPrintLevel-1);
+	//	minim.optimizeConst(true);
+	for (int tries = 0, maxtries = 4; tries <= maxtries; ++tries) {
+	  //	 status = minim.minimize(fMinimizer, ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo().c_str());
+	  status = minim.minimize(fMinimizer, "Minimize");
+	  if (status == 0) {  
+            break;
+	  } else {
+	    if (tries > 1) {
+	      printf("    ----> Doing a re-scan first\n");
+	      minim.minimize(fMinimizer,"Scan");
+	    }
+	    if (tries > 2) {
+	      printf("    ----> trying with strategy = 1\n");
+	     minim.setStrategy(1);
+	    }
+	  }
+	}
+	//	cout <<"fNll = " <<  fNll->getVal()<<endl;
+	return fNll->getVal();
+      }
+
    private:
       RooProfileLL* fProfile; //!
       RooAbsPdf* fPdf;
@@ -336,9 +300,12 @@
 
       static Bool_t fgAlwaysReuseNll ;
       Bool_t fReuseNll ;
+      TString fMinimizer;
+      Int_t fStrategy;
+      Int_t fPrintLevel;
 
    protected:
-      ClassDef(ProfileLikelihoodTestStat,4)   // implements the profile likelihood ratio as a test statistic to be used with several tools
+      ClassDef(ProfileLikelihoodTestStat,5)   // implements the profile likelihood ratio as a test statistic to be used with several tools
    };
 }
 

Property changes on: roostats/inc/RooStats/ToyMCSamplerOld.h
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/roofit/roostats/inc/RooStats/ToyMCSamplerOld.h:r40092,40095,40241,40249,40252,40254,40292-40294,40565,40718


Property changes on: roostats/inc
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/roofit/roostats/inc:r40092,40095,40241,40249,40252,40254,40292-40294,40565,40718


Property changes on: roostats
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/roofit/roostats:r40092,40095,40241,40249,40252,40254,40292-40294,40565,40718

