Index: io/io/src/TFile.cxx
===================================================================
--- io/io/src/TFile.cxx	(revision 45246)
+++ io/io/src/TFile.cxx	(working copy)
@@ -154,6 +154,7 @@
    fArchive         = 0;
    fCacheRead       = 0;
    fCacheReadMap    = new TMap();
+   fCacheReadExternal = kFALSE;
    fCacheWrite      = 0;
    fArchiveOffset   = 0;
    fReadCalls       = 0;
@@ -341,6 +342,7 @@
    fOffset       = 0;
    fCacheRead    = 0;
    fCacheReadMap = new TMap();
+   fCacheReadExternal = kFALSE;
    fCacheWrite   = 0;
    fReadCalls    = 0;
    SetBit(kBinaryFile, kTRUE);
@@ -1132,6 +1134,10 @@
 {
    // Return a pointer to the current read cache.
 
+   if (fCacheReadExternal) {
+      return fCacheRead;
+   }
+
    if (!tree) {
       if (!fCacheRead && fCacheReadMap->GetSize() == 1) {
          TIter next(fCacheReadMap);
@@ -2079,6 +2085,11 @@
    // cache), you ought to retrieve (and delete it if needed) using:
    //    TFileCacheRead *older = myfile->GetCacheRead();
 
+   if (fCacheReadExternal) {
+      fCacheRead = cache;
+      return;
+   }
+
    if (tree) {
       if (cache) fCacheReadMap->Add(tree, cache);
       else {

Index: io/io/inc/TFile.h
===================================================================
--- io/io/inc/TFile.h	(revision 45246)
+++ io/io/inc/TFile.h	(working copy)
@@ -87,6 +87,7 @@
    Bool_t           fIsRootFile;     //!True is this is a ROOT file, raw file otherwise
    Bool_t           fInitDone;       //!True if the file has been initialized
    Bool_t           fMustFlush;      //!True if the file buffers must be flushed
+   Bool_t           fCacheReadExternal;//!True if read-cache is managed by the user
    TFileOpenHandle *fAsyncHandle;    //!For proper automatic cleanup
    EAsyncOpenStatus fAsyncOpenStatus; //!Status of an asynchronous open request
    TUrl             fUrl;            //!URL of file
@@ -177,6 +178,7 @@
    Int_t               GetBestBuffer() const;
    virtual Int_t       GetBytesToPrefetch() const;
    TFileCacheRead     *GetCacheRead(TObject* tree = 0) const;
+   Bool_t              GetCacheReadExternal() const { return fCacheReadExternal; }
    TFileCacheWrite    *GetCacheWrite() const;
    TArrayC            *GetClassIndex() const { return fClassIndex; }
    Int_t               GetCompressionAlgorithm() const;
@@ -233,6 +235,7 @@
    virtual Int_t       ReOpen(Option_t *mode);
    virtual void        Seek(Long64_t offset, ERelativeTo pos = kBeg);
    virtual void        SetCacheRead(TFileCacheRead *cache, TObject* tree = 0);
+   void                SetCacheReadExternal(Bool_t ecr) { fCacheReadExternal = ecr; }
    virtual void        SetCacheWrite(TFileCacheWrite *cache);
    virtual void        SetCompressionAlgorithm(Int_t algorithm=0);
    virtual void        SetCompressionLevel(Int_t level=1);
Index: tree/tree/src/TTreeCache.cxx
===================================================================
--- tree/tree/src/TTreeCache.cxx	(revision 45246)
+++ tree/tree/src/TTreeCache.cxx	(working copy)
@@ -319,8 +319,6 @@
    //add a branch to the list of branches to be stored in the cache
    //this function is called by TBranch::GetBasket
 
-   if (!fIsLearning) return;
-
    // Reject branch that are not from the cached tree.
    if (!b || fTree->GetTree() != b->GetTree()) return;
 

