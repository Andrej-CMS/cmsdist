commit e1bbd89b8a9b2c21832785f867826462eae3946c
Author: Giulio Eulisse <giulio.eulisse@cern.ch>
Date:   Sat Oct 9 11:15:47 2010 +0200

    ../CMSDIST/root-5.22-00d-fireworks7.patch

diff --git a/core/base/inc/GuiTypes.h b/core/base/inc/GuiTypes.h
index d011ab8..29f5655 100644
--- a/core/base/inc/GuiTypes.h
+++ b/core/base/inc/GuiTypes.h
@@ -204,12 +204,14 @@ const Mask_t kButton2Mask    = BIT(9);
 const Mask_t kButton3Mask    = BIT(10);
 const Mask_t kButton4Mask    = BIT(11);
 const Mask_t kButton5Mask    = BIT(12);
+const Mask_t kButton6Mask    = BIT(13);
+const Mask_t kButton7Mask    = BIT(14);
 const Mask_t kAnyModifier    = BIT(15);
 
 // Button names. Used as arguments to GrabButton and as Event_t::fCode
 // for button events. Maps to the X11 values.
 enum EMouseButton { kAnyButton, kButton1, kButton2, kButton3,
-                    kButton4, kButton5 };
+                    kButton4, kButton5, kButton6, kButton7 };
 
 // Some magic X notify modes used in TGTextEntry widget.
 // Values must match the ones in /usr/include/X11/X.h. Check when porting.
diff --git a/core/base/inc/TVirtualX.h b/core/base/inc/TVirtualX.h
index e1246d5..d559408 100644
--- a/core/base/inc/TVirtualX.h
+++ b/core/base/inc/TVirtualX.h
@@ -155,6 +155,7 @@ public:
    virtual Int_t     WriteGIF(char *name);
    virtual void      WritePixmap(Int_t wid, UInt_t w, UInt_t h, char *pxname);
    virtual Window_t  GetCurrentWindow() const;
+   virtual Int_t     SupportsExtension(const char *ext) const;
 
    //---- Methods used for GUI -----
    virtual void         GetWindowAttributes(Window_t id, WindowAttributes_t &attr);
@@ -325,6 +326,7 @@ public:
    virtual Bool_t       IsDNDAware(Window_t win, Atom_t *typelist);
 
    virtual Bool_t       IsCmdThread() const { return kTRUE; }
+
    static TVirtualX    *&Instance();
 
    ClassDef(TVirtualX,0)  //ABC defining a generic interface to graphics system
diff --git a/core/base/src/TVirtualX.cxx b/core/base/src/TVirtualX.cxx
index e7f03f0..b7c5823 100644
--- a/core/base/src/TVirtualX.cxx
+++ b/core/base/src/TVirtualX.cxx
@@ -2179,4 +2179,12 @@ Bool_t TVirtualX::IsDNDAware(Window_t, Atom_t *)
    return kFALSE;
 }
 
+//______________________________________________________________________________
+Int_t TVirtualX::SupportsExtension(const char *) const
+{
+   // Returns 1 if window system server supports extension given by the
+   // argument, returns 0 in case extension is not supported and returns -1
+   // in case of error (like server not initialized).
 
+   return -1;
+}
diff --git a/geom/geom/inc/TGeoBoolNode.h b/geom/geom/inc/TGeoBoolNode.h
index 3866254..9f6a1a0 100644
--- a/geom/geom/inc/TGeoBoolNode.h
+++ b/geom/geom/inc/TGeoBoolNode.h
@@ -48,6 +48,8 @@ protected:
    TGeoShape        *fRight;          // shape on the right branch
    TGeoMatrix       *fLeftMat;        // transformation that applies to the left branch
    TGeoMatrix       *fRightMat;       // transformation that applies to the right branch
+   Int_t             fNpoints;        //! number of points on the mesh
+   Double_t         *fPoints;         //! array of mesh points
 // methods
    Bool_t            MakeBranch(const char *expr, Bool_t left);
 public:
@@ -68,7 +70,7 @@ public:
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const = 0;
    virtual EGeoBoolType GetBooleanOperator() const = 0;
-   virtual Int_t     GetNpoints() const = 0;
+   virtual Int_t     GetNpoints() = 0;
    TGeoMatrix       *GetLeftMatrix() const {return fLeftMat;}
    TGeoMatrix       *GetRightMatrix() const {return fRightMat;}
    TGeoShape        *GetLeftShape() const {return fLeft;}
@@ -77,8 +79,8 @@ public:
    void              RegisterMatrices();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const = 0;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const = 0;
-   virtual void      SetPoints(Float_t *points)  const = 0;
+   virtual void      SetPoints(Double_t *points) const;
+   virtual void      SetPoints(Float_t *points)  const;
    void              SetSelected(Int_t sel) {fSelected = sel;}
    virtual void      Sizeof3D() const;
 
@@ -111,11 +113,9 @@ public:
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const;
    virtual EGeoBoolType GetBooleanOperator() const {return kGeoUnion;}
-   virtual Int_t     GetNpoints() const;
+   virtual Int_t     GetNpoints();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const;
-   virtual void      SetPoints(Float_t *points)  const;
    virtual void      Sizeof3D() const;
 
    //CS specific
@@ -151,11 +151,9 @@ public:
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const;
    virtual EGeoBoolType GetBooleanOperator() const {return kGeoIntersection;}
-   virtual Int_t     GetNpoints() const;
+   virtual Int_t     GetNpoints();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const;
-   virtual void      SetPoints(Float_t *points)  const;
    virtual void      Sizeof3D() const;
 
    //CS specific
@@ -190,11 +188,9 @@ public:
    virtual Double_t  DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1,
                                Double_t step=0, Double_t *safe=0) const;
    virtual EGeoBoolType GetBooleanOperator() const {return kGeoSubtraction;}
-   virtual Int_t     GetNpoints() const;
+   virtual Int_t     GetNpoints();
    virtual Double_t  Safety(Double_t *point, Bool_t in=kTRUE) const;
    virtual void      SavePrimitive(ostream &out, Option_t *option = "");
-   virtual void      SetPoints(Double_t *points) const;
-   virtual void      SetPoints(Float_t *points)  const;
    virtual void      Sizeof3D() const;
 
    //CS specific
diff --git a/geom/geom/inc/TGeoCompositeShape.h b/geom/geom/inc/TGeoCompositeShape.h
index d1e4667..4c09d01 100644
--- a/geom/geom/inc/TGeoCompositeShape.h
+++ b/geom/geom/inc/TGeoCompositeShape.h
@@ -51,6 +51,7 @@ public:
    virtual void          ComputeBBox();
    virtual void          ComputeNormal(Double_t *point, Double_t *dir, Double_t *norm);
    virtual Bool_t        Contains(Double_t *point) const;
+   virtual Int_t         DistancetoPrimitive(Int_t px, Int_t py);
    virtual Double_t      DistFromInside(Double_t *point, Double_t *dir, Int_t iact=1, 
                                    Double_t step=TGeoShape::Big(), Double_t *safe=0) const;
    virtual Double_t      DistFromOutside(Double_t *point, Double_t *dir, Int_t iact=1, 
diff --git a/geom/geom/src/TGeoBoolNode.cxx b/geom/geom/src/TGeoBoolNode.cxx
index 7b9cb89..5b064a8 100644
--- a/geom/geom/src/TGeoBoolNode.cxx
+++ b/geom/geom/src/TGeoBoolNode.cxx
@@ -50,7 +50,7 @@
 
 ClassImp(TGeoBoolNode)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoBoolNode::TGeoBoolNode()
 {
 // Default constructor
@@ -59,8 +59,11 @@ TGeoBoolNode::TGeoBoolNode()
    fLeftMat  = 0;
    fRightMat = 0;
    fSelected = 0;
+   fNpoints  = 0;
+   fPoints   = 0;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 TGeoBoolNode::TGeoBoolNode(const char *expr1, const char *expr2)
 {
 // Constructor called by TGeoCompositeShape providing 2 subexpressions for the 2 branches.
@@ -69,6 +72,8 @@ TGeoBoolNode::TGeoBoolNode(const char *expr1, const char *expr2)
    fLeftMat  = 0;
    fRightMat = 0;
    fSelected = 0;
+   fNpoints  = 0;
+   fPoints   = 0;
    if (!MakeBranch(expr1, kTRUE)) {
       return;
    }
@@ -77,7 +82,7 @@ TGeoBoolNode::TGeoBoolNode(const char *expr1, const char *expr2)
    }
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoBoolNode::TGeoBoolNode(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
 {
 // Constructor providing left and right shapes and matrices (in the Boolean operation).
@@ -85,6 +90,8 @@ TGeoBoolNode::TGeoBoolNode(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat,
    fLeft = left;
    fRight = right;
    fLeftMat = lmat;
+   fNpoints  = 0;
+   fPoints   = 0;
    if (!fLeftMat) fLeftMat = gGeoIdentity;
    else fLeftMat->RegisterYourself();
    fRightMat = rmat;
@@ -100,13 +107,15 @@ TGeoBoolNode::TGeoBoolNode(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat,
    }   
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoBoolNode::~TGeoBoolNode()
 {
 // Destructor.
 // --- deletion of components handled by TGeoManager class.
+   if (fPoints) delete [] fPoints;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Bool_t TGeoBoolNode::MakeBranch(const char *expr, Bool_t left)
 {
 // Expands the boolean expression either on left or right branch, creating
@@ -175,7 +184,8 @@ Bool_t TGeoBoolNode::MakeBranch(const char *expr, Bool_t left)
    }
    return kTRUE;                  
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoBoolNode::Paint(Option_t * option)
 {
 // Special schema for feeding the 3D buffers to the painter client.
@@ -216,6 +226,7 @@ void TGeoBoolNode::Paint(Option_t * option)
 
    *glmat = &mat;   
 }
+
 //_____________________________________________________________________________
 void TGeoBoolNode::RegisterMatrices()
 {
@@ -225,6 +236,7 @@ void TGeoBoolNode::RegisterMatrices()
    if (fLeft->IsComposite()) ((TGeoCompositeShape*)fLeft)->GetBoolNode()->RegisterMatrices();
    if (fRight->IsComposite()) ((TGeoCompositeShape*)fRight)->GetBoolNode()->RegisterMatrices();
 }
+
 //_____________________________________________________________________________
 void TGeoBoolNode::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 {
@@ -240,7 +252,26 @@ void TGeoBoolNode::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
       fRightMat->SavePrimitive(out,option);
    }      
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
+void TGeoBoolNode::SetPoints(Double_t *points) const
+{
+// Fill buffer with shape vertices.
+   TGeoBoolNode *bn = (TGeoBoolNode*)this;
+   Int_t npoints = bn->GetNpoints();
+   memcpy(points, fPoints, 3*npoints*sizeof(Double_t));
+}
+
+//______________________________________________________________________________
+void TGeoBoolNode::SetPoints(Float_t *points) const
+{
+// Fill buffer with shape vertices.
+   TGeoBoolNode *bn = (TGeoBoolNode*)this;
+   Int_t npoints = bn->GetNpoints();
+   for (Int_t i=0; i<3*npoints; i++) points[i] = fPoints[i];
+}
+
+//______________________________________________________________________________
 void TGeoBoolNode::Sizeof3D() const
 {
 // Register size of this 3D object
@@ -249,7 +280,7 @@ void TGeoBoolNode::Sizeof3D() const
 }
 ClassImp(TGeoUnion)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoUnion::Paint(Option_t *option)
 {
 // Paint method.
@@ -265,19 +296,20 @@ void TGeoUnion::Paint(Option_t *option)
    TGeoBoolNode::Paint(option);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoUnion::TGeoUnion()
 {
 // Default constructor
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 TGeoUnion::TGeoUnion(const char *expr1, const char *expr2)
           :TGeoBoolNode(expr1, expr2)
 {
 // Constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoUnion::TGeoUnion(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
           :TGeoBoolNode(left,right,lmat,rmat)
 {
@@ -287,13 +319,14 @@ TGeoUnion::TGeoUnion(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMa
    }
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoUnion::~TGeoUnion()
 {
 // Destructor
 // --- deletion of components handled by TGeoManager class.
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoUnion::ComputeBBox(Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin)
 {
 // Compute bounding box corresponding to a union of two shapes.
@@ -332,7 +365,8 @@ void TGeoUnion::ComputeBBox(Double_t &dx, Double_t &dy, Double_t &dz, Double_t *
    dz = 0.5*(zmax-zmin);
    origin[2] = 0.5*(zmin+zmax);
 }   
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Bool_t TGeoUnion::Contains(Double_t *point) const
 {
 // Find if a union of two shapes contains a given point
@@ -400,13 +434,14 @@ void TGeoUnion::ComputeNormal(Double_t *point, Double_t *dir, Double_t *norm)
    ComputeNormal(local,dir,norm);   
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Int_t TGeoUnion::DistanceToPrimitive(Int_t /*px*/, Int_t /*py*/)
 {
 // Compute minimum distance to shape vertices.
    return 9999;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoUnion::DistFromInside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -489,7 +524,8 @@ Double_t TGeoUnion::DistFromInside(Double_t *point, Double_t *dir, Int_t iact,
    }      
    return snxt;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoUnion::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -518,19 +554,46 @@ Double_t TGeoUnion::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
    }      
    return snxt;
 }
-//-----------------------------------------------------------------------------
-Int_t TGeoUnion::GetNpoints() const
+
+//______________________________________________________________________________
+Int_t TGeoUnion::GetNpoints()
 {
 // Returns number of vertices for the composite shape described by this union.
-   return 0;
-}
-//-----------------------------------------------------------------------------
-void TGeoUnion::SetPoints(Double_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
+   Int_t itot=0;
+   Double_t point[3];
+   Double_t tolerance = TGeoShape::Tolerance();
+   if (fNpoints) return fNpoints;
+   // Local points for the left shape
+   Int_t nleft = fLeft->GetNmeshVertices();
+   Double_t *points1 = new Double_t[3*nleft];
+   fLeft->SetPoints(points1);
+   // Local points for the right shape
+   Int_t nright = fRight->GetNmeshVertices();
+   Double_t *points2 = new Double_t[3*nright];
+   fRight->SetPoints(points2);
+   Double_t *points = new Double_t[3*(nleft+nright)];
+   for (Int_t i=0; i<nleft; i++) {
+      if (TMath::Abs(points1[3*i])<tolerance && TMath::Abs(points1[3*i+1])<tolerance) continue;
+      fLeftMat->LocalToMaster(&points1[3*i], &points[3*itot]);
+      fRightMat->MasterToLocal(&points[3*itot], point);
+      if (!fRight->Contains(point)) itot++;
+   }
+   for (Int_t i=0; i<nright; i++) {
+      if (TMath::Abs(points2[3*i])<tolerance && TMath::Abs(points2[3*i+1])<tolerance) continue;
+      fRightMat->LocalToMaster(&points2[3*i], &points[3*itot]);
+      fLeftMat->MasterToLocal(&points[3*itot], point);
+      if (!fLeft->Contains(point)) itot++;
+   }
+   fNpoints = itot;
+   fPoints = new Double_t[3*fNpoints];
+   memcpy(fPoints, points, 3*fNpoints*sizeof(Double_t));
+   delete [] points1;
+   delete [] points2;
+   delete [] points;
+   return fNpoints;         
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Double_t TGeoUnion::Safety(Double_t *point, Bool_t in) const
 {
 // Compute safety distance for a union node;
@@ -563,12 +626,7 @@ void TGeoUnion::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
    else                         out << "0);" << endl;
 }   
 
-//-----------------------------------------------------------------------------
-void TGeoUnion::SetPoints(Float_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoUnion::Sizeof3D() const
 {
 // Register 3D size of this shape.
@@ -578,7 +636,7 @@ void TGeoUnion::Sizeof3D() const
 
 ClassImp(TGeoSubtraction)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoSubtraction::Paint(Option_t *option)
 {
 // Paint method.
@@ -594,20 +652,20 @@ void TGeoSubtraction::Paint(Option_t *option)
    TGeoBoolNode::Paint(option);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::TGeoSubtraction()
 {
 // Default constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::TGeoSubtraction(const char *expr1, const char *expr2)
           :TGeoBoolNode(expr1, expr2)
 {
 // Constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::TGeoSubtraction(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
                 :TGeoBoolNode(left,right,lmat,rmat)
 {
@@ -617,14 +675,14 @@ TGeoSubtraction::TGeoSubtraction(TGeoShape *left, TGeoShape *right, TGeoMatrix *
    }
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoSubtraction::~TGeoSubtraction()
 {
 // Destructor
 // --- deletion of components handled by TGeoManager class.
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoSubtraction::ComputeBBox(Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin)
 {
 // Compute bounding box corresponding to a subtraction of two shapes.
@@ -702,7 +760,7 @@ void TGeoSubtraction::ComputeNormal(Double_t *point, Double_t *dir, Double_t *no
    ComputeNormal(local,dir,norm);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Bool_t TGeoSubtraction::Contains(Double_t *point) const
 {
 // Find if a subtraction of two shapes contains a given point
@@ -717,13 +775,15 @@ Bool_t TGeoSubtraction::Contains(Double_t *point) const
    if (!inside) node->SetSelected(2);
    return inside;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Int_t TGeoSubtraction::DistanceToPrimitive(Int_t /*px*/, Int_t /*py*/)
 {
 // Compute minimum distance to shape vertices
    return 9999;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoSubtraction::DistFromInside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -752,7 +812,8 @@ Double_t TGeoSubtraction::DistFromInside(Double_t *point, Double_t *dir, Int_t i
    }      
    return snxt;
 }   
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoSubtraction::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -807,13 +868,44 @@ Double_t TGeoSubtraction::DistFromOutside(Double_t *point, Double_t *dir, Int_t
       inside = kTRUE;
    }
 }
-//-----------------------------------------------------------------------------
-Int_t TGeoSubtraction::GetNpoints() const
+
+//______________________________________________________________________________
+Int_t TGeoSubtraction::GetNpoints()
 {
 // Returns number of vertices for the composite shape described by this subtraction.
-   return 0;
+   Int_t itot=0;
+   Double_t point[3];
+   Double_t tolerance = TGeoShape::Tolerance();
+   if (fNpoints) return fNpoints;
+   Int_t nleft = fLeft->GetNmeshVertices();
+   Int_t nright = fRight->GetNmeshVertices();
+   Double_t *points = new Double_t[3*(nleft+nright)];
+   Double_t *points1 = new Double_t[3*nleft];
+   fLeft->SetPoints(points1);
+   for (Int_t i=0; i<nleft; i++) {
+      if (TMath::Abs(points1[3*i])<tolerance && TMath::Abs(points1[3*i+1])<tolerance) continue;
+      fLeftMat->LocalToMaster(&points1[3*i], &points[3*itot]);
+      fRightMat->MasterToLocal(&points[3*itot], point);
+      if (!fRight->Contains(point)) itot++;
+   }
+   Double_t *points2 = new Double_t[3*nright];
+   fRight->SetPoints(points2);
+   for (Int_t i=0; i<nright; i++) {
+      if (TMath::Abs(points2[3*i])<tolerance && TMath::Abs(points2[3*i+1])<tolerance) continue;
+      fRightMat->LocalToMaster(&points2[3*i], &points[3*itot]);
+      fLeftMat->MasterToLocal(&points[3*itot], point);
+      if (fLeft->Contains(point)) itot++;
+   }
+   fNpoints = itot;
+   fPoints = new Double_t[3*fNpoints];
+   memcpy(fPoints, points, 3*fNpoints*sizeof(Double_t));
+   delete [] points1;
+   delete [] points2;
+   delete [] points;
+   return fNpoints;         
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoSubtraction::Safety(Double_t *point, Bool_t in) const
 {
 // Compute safety distance for a union node;
@@ -831,6 +923,7 @@ Double_t TGeoSubtraction::Safety(Double_t *point, Bool_t in) const
    if (in2)        return TMath::Max(saf1,saf2);
    return saf1;
 }   
+
 //_____________________________________________________________________________
 void TGeoSubtraction::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 {
@@ -844,28 +937,17 @@ void TGeoSubtraction::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
    if (!fRightMat->IsIdentity()) out << fRightMat->GetPointerName() << ");" << endl;
    else                         out << "0);" << endl;
 }   
-//-----------------------------------------------------------------------------
-void TGeoSubtraction::SetPoints(Double_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
-void TGeoSubtraction::SetPoints(Float_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoSubtraction::Sizeof3D() const
 {
 // Register 3D size of this shape.
    TGeoBoolNode::Sizeof3D();
 }
-   
-
 
 ClassImp(TGeoIntersection)
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoIntersection::Paint(Option_t *option)
 {
 // Paint method.
@@ -881,20 +963,20 @@ void TGeoIntersection::Paint(Option_t *option)
    TGeoBoolNode::Paint(option);
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::TGeoIntersection()
 {
 // Default constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::TGeoIntersection(const char *expr1, const char *expr2)
           :TGeoBoolNode(expr1, expr2)
 {
 // Constructor
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::TGeoIntersection(TGeoShape *left, TGeoShape *right, TGeoMatrix *lmat, TGeoMatrix *rmat)
                  :TGeoBoolNode(left,right,lmat,rmat)
 {
@@ -904,14 +986,14 @@ TGeoIntersection::TGeoIntersection(TGeoShape *left, TGeoShape *right, TGeoMatrix
    if (hs1 && hs2) Fatal("ctor", "cannot intersect two half-spaces: %s * %s", left->GetName(), right->GetName());
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 TGeoIntersection::~TGeoIntersection()
 {
 // Destructor
 // --- deletion of components handled by TGeoManager class.
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 void TGeoIntersection::ComputeBBox(Double_t &dx, Double_t &dy, Double_t &dz, Double_t *origin)
 {
 // Compute bounding box corresponding to a intersection of two shapes.
@@ -1059,7 +1141,7 @@ void TGeoIntersection::ComputeNormal(Double_t *point, Double_t *dir, Double_t *n
    ComputeNormal(local,dir,norm);   
 }
 
-//-----------------------------------------------------------------------------
+//______________________________________________________________________________
 Bool_t TGeoIntersection::Contains(Double_t *point) const
 {
 // Find if a intersection of two shapes contains a given point
@@ -1071,13 +1153,15 @@ Bool_t TGeoIntersection::Contains(Double_t *point) const
    inside = fRight->Contains(&local[0]);
    return inside;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Int_t TGeoIntersection::DistanceToPrimitive(Int_t /*px*/, Int_t /*py*/)
 {
 // Compute minimum distance to shape vertices
    return 9999;
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoIntersection::DistFromInside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -1106,7 +1190,8 @@ Double_t TGeoIntersection::DistFromInside(Double_t *point, Double_t *dir, Int_t
    }      
    return snxt;
 }   
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoIntersection::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                               Double_t step, Double_t *safe) const
 {
@@ -1171,13 +1256,43 @@ Double_t TGeoIntersection::DistFromOutside(Double_t *point, Double_t *dir, Int_t
    return snext;
 }      
 
-//-----------------------------------------------------------------------------
-Int_t TGeoIntersection::GetNpoints() const
+//______________________________________________________________________________
+Int_t TGeoIntersection::GetNpoints()
 {
 // Returns number of vertices for the composite shape described by this intersection.
-   return 0;
+   Int_t itot=0;
+   Double_t point[3];
+   Double_t tolerance = TGeoShape::Tolerance();
+   if (fNpoints) return fNpoints;
+   Int_t nleft = fLeft->GetNmeshVertices();
+   Int_t nright = fRight->GetNmeshVertices();
+   Double_t *points = new Double_t[3*(nleft+nright)];
+   Double_t *points1 = new Double_t[3*nleft];
+   fLeft->SetPoints(points1);
+   for (Int_t i=0; i<nleft; i++) {
+      if (TMath::Abs(points1[3*i])<tolerance && TMath::Abs(points1[3*i+1])<tolerance) continue;
+      fLeftMat->LocalToMaster(&points1[3*i], &points[3*itot]);
+      fRightMat->MasterToLocal(&points[3*itot], point);
+      if (fRight->Contains(point)) itot++;
+   }
+   Double_t *points2 = new Double_t[3*nright];
+   fRight->SetPoints(points2);
+   for (Int_t i=0; i<nright; i++) {
+      if (TMath::Abs(points2[3*i])<tolerance && TMath::Abs(points2[3*i+1])<tolerance) continue;
+      fRightMat->LocalToMaster(&points2[3*i], &points[3*itot]);
+      fLeftMat->MasterToLocal(&points[3*itot], point);
+      if (fLeft->Contains(point)) itot++;
+   }
+   fNpoints = itot;
+   fPoints = new Double_t[3*fNpoints];
+   memcpy(fPoints, points, 3*fNpoints*sizeof(Double_t));
+   delete [] points1;
+   delete [] points2;
+   delete [] points;
+   return fNpoints;         
 }
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 Double_t TGeoIntersection::Safety(Double_t *point, Bool_t in) const
 {
 // Compute safety distance for a union node;
@@ -1195,6 +1310,7 @@ Double_t TGeoIntersection::Safety(Double_t *point, Bool_t in) const
    if (in2)        return saf1;
    return TMath::Max(saf1,saf2);
 }   
+
 //_____________________________________________________________________________
 void TGeoIntersection::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 {
@@ -1208,17 +1324,8 @@ void TGeoIntersection::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
    if (!fRightMat->IsIdentity()) out << fRightMat->GetPointerName() << ");" << endl;
    else                         out << "0);" << endl;
 }   
-//-----------------------------------------------------------------------------
-void TGeoIntersection::SetPoints(Double_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
-void TGeoIntersection::SetPoints(Float_t * /*points*/) const
-{
-// Fill buffer with shape vertices.
-}
-//-----------------------------------------------------------------------------
+
+//______________________________________________________________________________
 void TGeoIntersection::Sizeof3D() const
 {
 // Register 3D size of this shape.
diff --git a/geom/geom/src/TGeoCompositeShape.cxx b/geom/geom/src/TGeoCompositeShape.cxx
index 9930662..bfba179 100644
--- a/geom/geom/src/TGeoCompositeShape.cxx
+++ b/geom/geom/src/TGeoCompositeShape.cxx
@@ -265,6 +265,14 @@ Bool_t TGeoCompositeShape::Contains(Double_t *point) const
 }
 
 //_____________________________________________________________________________
+Int_t TGeoCompositeShape::DistancetoPrimitive(Int_t px, Int_t py)
+{
+// Compute closest distance from point px,py to each corner.
+   const Int_t numPoints = GetNmeshVertices();
+   return ShapeDistancetoPrimitive(numPoints, px, py);
+}
+
+//_____________________________________________________________________________
 Double_t TGeoCompositeShape::DistFromOutside(Double_t *point, Double_t *dir, Int_t iact,
                                       Double_t step, Double_t *safe) const
 {
@@ -298,7 +306,7 @@ TGeoVolume *TGeoCompositeShape::Divide(TGeoVolume  * /*voldiv*/, const char * /*
 void TGeoCompositeShape::GetMeshNumbers(Int_t &nvert, Int_t &nsegs, Int_t &npols) const
 {
 // Returns numbers of vertices, segments and polygons composing the shape mesh.
-   nvert = 0;
+   nvert = GetNmeshVertices();
    nsegs = 0;
    npols = 0;
 }
@@ -456,14 +464,14 @@ void TGeoCompositeShape::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
 void TGeoCompositeShape::SetPoints(Double_t *points) const
 {
 // create points for a composite shape
-   TGeoBBox::SetPoints(points);
+   if (fNode) fNode->SetPoints(points);
 }
 
 //_____________________________________________________________________________
 void TGeoCompositeShape::SetPoints(Float_t *points) const
 {
 // create points for a composite shape
-   TGeoBBox::SetPoints(points);
+   if (fNode) fNode->SetPoints(points);
 }
 
 //_____________________________________________________________________________
@@ -478,6 +486,6 @@ Int_t TGeoCompositeShape::GetNmeshVertices() const
 {
 // Return number of vertices of the mesh representation
    if (!fNode) return 0;
-   return 8;
+   return fNode->GetNpoints();
 }      
 
diff --git a/geom/geom/src/TGeoMaterial.cxx b/geom/geom/src/TGeoMaterial.cxx
index 70aac5f..05adf57 100644
--- a/geom/geom/src/TGeoMaterial.cxx
+++ b/geom/geom/src/TGeoMaterial.cxx
@@ -621,7 +621,7 @@ void TGeoMixture::AddElement(TGeoElement *elem, Double_t weight)
 // add an element to the mixture using fraction by weight
    TGeoElement *elemold;
    TGeoElementTable *table = gGeoManager->GetElementTable();
-   if (!fElements) fElements = new TObjArray(10);
+   if (!fElements) fElements = new TObjArray(128);
    Bool_t exist = kFALSE;
    // If previous elements were defined by A/Z, add corresponding TGeoElements
    for (Int_t i=0; i<fNelements; i++) {
@@ -641,7 +641,7 @@ void TGeoMixture::AddElement(TGeoElement *elem, Int_t natoms)
    Double_t amol;
    TGeoElement *elemold;
    TGeoElementTable *table = gGeoManager->GetElementTable();
-   if (!fElements) fElements = new TObjArray(10);
+   if (!fElements) fElements = new TObjArray(128);
    // Check if the element is already defined
    for (i=0; i<fNelements; i++) {
       elemold = (TGeoElement*)fElements->At(i);
diff --git a/geom/geombuilder/inc/TGeoMaterialEditor.h b/geom/geombuilder/inc/TGeoMaterialEditor.h
index 82be0c1..95290c4 100644
--- a/geom/geombuilder/inc/TGeoMaterialEditor.h
+++ b/geom/geombuilder/inc/TGeoMaterialEditor.h
@@ -115,7 +115,7 @@ protected:
    TGCheckButton       *fChkNatoms;         // Check button for number of atoms
    TGNumberEntry       *fNENatoms;          // Number entry for number of atoms
    TGTextButton        *fBAddElem;          // Buttom for adding element as component
-   TGCanvas            *fCan;               // Canvas with components
+   TGCompositeFrame    *fComps;             // Frame with components
 
    virtual void ConnectSignals2Slots();     // Connect the signals to the slots
 
diff --git a/geom/geombuilder/src/TGeoMaterialEditor.cxx b/geom/geombuilder/src/TGeoMaterialEditor.cxx
index dac4c95..20749f4 100644
--- a/geom/geombuilder/src/TGeoMaterialEditor.cxx
+++ b/geom/geombuilder/src/TGeoMaterialEditor.cxx
@@ -64,27 +64,27 @@ TGeoMaterialEditor::TGeoMaterialEditor(const TGWindow *p, Int_t width,
    // TextEntry for material name
    MakeTitle("Name");
    fMaterialName = new TGTextEntry(this, new TGTextBuffer(50), kMATERIAL_NAME);
-   fMaterialName->Resize(135, fMaterialName->GetDefaultHeight());
+   fMaterialName->SetDefaultSize(135, fMaterialName->GetDefaultHeight());
    fMaterialName->SetToolTipText("Enter the material name");
    fMaterialName->Associate(this);
-   AddFrame(fMaterialName, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 5));
+   AddFrame(fMaterialName, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 1, 1, 2, 5));
 
    TGTextEntry *nef;
    MakeTitle("Material properties");
    TGCompositeFrame *f1 = new TGCompositeFrame(this, 118, 10, kHorizontalFrame |
                                  kFixedWidth | kOwnBackground);
    f1->AddFrame(new TGLabel(f1, "A"), new TGLayoutHints(kLHintsLeft, 1, 1, 6, 0));
-   fMatA = new TGNumberEntry(f1, 0., 5, kMATERIAL_A, TGNumberFormat::kNESRealThree);
+   fMatA = new TGNumberEntry(f1, 0., 6, kMATERIAL_A, TGNumberFormat::kNESRealThree);
    nef = (TGTextEntry*)fMatA->GetNumberEntry();
    nef->SetToolTipText("Enter the atomic mass");
    fMatA->Associate(this);
-   f1->AddFrame(fMatA, new TGLayoutHints(kLHintsLeft , 2, 2, 4, 4));
+   f1->AddFrame(fMatA, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 4));
    f1->AddFrame(new TGLabel(f1, "Z"), new TGLayoutHints(kLHintsLeft, 1, 1, 6, 0));
-   fMatZ = new TGNumberEntry(f1, 0., 5, kMATERIAL_Z, TGNumberFormat::kNESInteger);
+   fMatZ = new TGNumberEntry(f1, 0., 4, kMATERIAL_Z, TGNumberFormat::kNESInteger);
    nef = (TGTextEntry*)fMatZ->GetNumberEntry();
    nef->SetToolTipText("Enter the atomic charge");
    fMatZ->Associate(this);
-   f1->AddFrame(fMatZ, new TGLayoutHints(kLHintsLeft , 2, 2, 4, 4));
+   f1->AddFrame(fMatZ, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 4));
    f1->Resize(150,30);
    AddFrame(f1, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
    
@@ -428,7 +428,7 @@ TGeoMixtureEditor::TGeoMixtureEditor(const TGWindow *p, Int_t width,
                              kLHintsExpandX | kFixedWidth | kOwnBackground);
    fChkNatoms = new TGCheckButton(f1, "N. atoms");
    fChkNatoms->SetDown(kFALSE);
-   f1->AddFrame(fChkNatoms, new TGLayoutHints(kLHintsLeft , 2, 2, 6, 1));
+   f1->AddFrame(fChkNatoms, new TGLayoutHints(kLHintsLeft, 2, 2, 6, 1));
    fNENatoms = new TGNumberEntry(f1, 0., 5, kMIX_NATOMS);
    fNENatoms->SetFormat(TGNumberFormat::kNESInteger, TGNumberFormat::kNEANonNegative);
    fNENatoms->Resize(65, fMaterialName->GetDefaultHeight());
@@ -442,16 +442,14 @@ TGeoMixtureEditor::TGeoMixtureEditor(const TGWindow *p, Int_t width,
    // Button for adding the element
    fBAddElem = new TGTextButton(compxyz, "Add component");
    fBAddElem->Associate(this);
-   compxyz->AddFrame(fBAddElem, new TGLayoutHints(kLHintsRight , 2, 2, 1, 1));
+   compxyz->AddFrame(fBAddElem, new TGLayoutHints(kLHintsRight , 2, 2, 2, 0));
 
    compxyz->Resize(150,30);
    AddFrame(compxyz, new TGLayoutHints(kLHintsLeft, 0, 0, 1, 1));
    
    // List view with all components
-   fCan = new TGCanvas(this, 145, 100);
-   TGCompositeFrame *cont = new TGCompositeFrame(fCan->GetViewPort(), 100, 100, kVerticalFrame | kLHintsExpandX);
-   fCan->SetContainer(cont);
-   AddFrame(fCan, new TGLayoutHints(kLHintsLeft, 2, 2, 1, 1));
+   fComps = new TGCompositeFrame(this, 150, 100, kVerticalFrame | kSunkenFrame);
+   AddFrame(fComps, new TGLayoutHints(kLHintsLeft | kLHintsExpandX | kLHintsExpandY, 0, 2, 1, 2));
 
    TGeoTabManager::MoveFrame(f23, this);
 }   
@@ -561,13 +559,7 @@ void TGeoMixtureEditor::DoAddElem()
    if (!el) return;
    if (byfraction) fMixture->AddElement(el, frac);
    else            fMixture->AddElement(el, natoms);   
-   fMatA->SetNumber(fMaterial->GetA());
-   fMatZ->SetNumber(fMaterial->GetZ());
-   fMatRadLen->SetNumber(fMaterial->GetRadLen());
-   fMatAbsLen->SetNumber(fMaterial->GetIntLen());
-   TString nelem = Form("Number of elements: %d", fMixture->GetNelements());
-   fNelem->SetText(nelem.Data());
-   UpdateElements();
+   fTabMgr->GetMaterialEditor(fMixture);
 }
 
 //______________________________________________________________________________
@@ -612,31 +604,21 @@ void TGeoMixtureEditor::DoUndo1()
 void TGeoMixtureEditor::UpdateElements()
 {
 // Update the list of elements in the TGCanvas.
+   fComps->RemoveAll();
    Int_t nelem = fMixture->GetNelements();
-   if (!nelem) return;
-   TGCompositeFrame *cont = (TGCompositeFrame*)fCan->GetContainer();
-   TList *list = cont->GetList();
-   TGLabel *label;
-   TGFrameElement *el;
-   TString s;
    for (Int_t i=0; i<nelem; i++) {
+      TString s;
       Bool_t byfrac = (fMixture->GetNmixt())?kFALSE:kTRUE;
       if (byfrac) 
-         s = Form("%d-%s-%d: Wmass = %g %%", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
-                  (Int_t)fMixture->GetAmixt()[i],fMixture->GetWmixt()[i]);
+         s.Form("%d-%s-%d: Wmass = %g %%", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
+                (Int_t)fMixture->GetAmixt()[i],fMixture->GetWmixt()[i]);
       else
-         s = Form("%d-%s-%d: Natoms = %d", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
-                  (Int_t)fMixture->GetAmixt()[i],fMixture->GetNmixt()[i]);
+         s.Form("%d-%s-%d: Natoms = %d", (Int_t)fMixture->GetZmixt()[i], fMixture->GetElement(i)->GetName(), 
+                (Int_t)fMixture->GetAmixt()[i],fMixture->GetNmixt()[i]);
                      
-      el = (TGFrameElement*)list->At(i);
-      if (el) {
-         label = (TGLabel*)el->fFrame;
-         label->SetText(s.Data());
-      } else {
-         label = new TGLabel(cont, s.Data());
-         cont->AddFrame(label, new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
-         fCan->MapSubwindows();
-      }   
+      TGLabel *label = new TGLabel(fComps, s);
+      label->SetTextJustify(kTextLeft | kTextCenterY);
+      fComps->AddFrame(label, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 1, 1, 0, 0));
    }   
-//   fCan->Layout();
+   fComps->MapSubwindows();
 }
diff --git a/geom/geombuilder/src/TGeoMediumEditor.cxx b/geom/geombuilder/src/TGeoMediumEditor.cxx
index 65cef39..bc87409 100644
--- a/geom/geombuilder/src/TGeoMediumEditor.cxx
+++ b/geom/geombuilder/src/TGeoMediumEditor.cxx
@@ -53,50 +53,50 @@ TGeoMediumEditor::TGeoMediumEditor(const TGWindow *p, Int_t width,
       
    // TextEntry for medium name
    MakeTitle("Name");
-   fMedName = new TGTextEntry(this, new TGTextBuffer(50), kMED_NAME);
-   fMedName->Resize(135, fMedName->GetDefaultHeight());
+   fMedName = new TGTextEntry(this, "", kMED_NAME);
+   fMedName->SetDefaultSize(135, fMedName->GetDefaultHeight());
    fMedName->SetToolTipText("Enter the medium name");
    fMedName->Associate(this);
-   AddFrame(fMedName, new TGLayoutHints(kLHintsLeft, 3, 1, 2, 2));
+   AddFrame(fMedName, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 3, 1, 2, 2));
 
    TGTextEntry *nef;
 
 // Composite frame for medium ID and sensitivity
    TGCompositeFrame *f1 = new TGCompositeFrame(this, 120, 30, kHorizontalFrame | kRaisedFrame);
-   f1->AddFrame(new TGLabel(f1, "ID"), new TGLayoutHints(kLHintsLeft, 1, 1, 6, 0));
+   f1->AddFrame(new TGLabel(f1, "ID"), new TGLayoutHints(kLHintsLeft, 4, 1, 6, 0));
    fMedId = new TGNumberEntry(f1, 0., 1, kMED_ID);
    nef = (TGTextEntry*)fMedId->GetNumberEntry();
    nef->SetToolTipText("Enter the medium ID");
    fMedId->Associate(this);
-   f1->AddFrame(fMedId, new TGLayoutHints(kLHintsLeft | kLHintsExpandX , 2, 2, 4, 4));
+   f1->AddFrame(fMedId, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 4, 4));
    fMedSensitive = new TGCheckButton(f1, "&Sens", kMED_SENS);
    fMedSensitive->Associate(this);
-   f1->AddFrame(fMedSensitive, new TGLayoutHints(kLHintsRight | kLHintsExpandX , 2, 2, 4, 4));
+   f1->AddFrame(fMedSensitive, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 4));
    AddFrame(f1, new TGLayoutHints(kLHintsLeft, 3, 3, 2, 2));
 
    // Current material
-   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
+   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kFixedWidth | kOwnBackground);
    f1->AddFrame(label = new TGLabel(f1, "Current material"), new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
    f1->AddFrame(new TGHorizontal3DLine(f1), new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 7));
    gClient->GetColorByName("#ff0000", color);
    label->SetTextColor(color);
    AddFrame(f1, new TGLayoutHints(kLHintsTop, 0, 0, 2, 0));
-   f1 = new TGCompositeFrame(this, 155, 30, kHorizontalFrame | kFixedWidth);
+   f1 = new TGCompositeFrame(this, 155, 30, kHorizontalFrame);
    fSelectedMaterial = 0;
    fLSelMaterial = new TGLabel(f1, "Select material");
    gClient->GetColorByName("#0000ff", color);
    fLSelMaterial->SetTextColor(color);
-   fLSelMaterial->ChangeOptions(kSunkenFrame | kDoubleBorder);
+   fLSelMaterial->ChangeOptions(kChildFrame | kSunkenFrame | kDoubleBorder);
    f1->AddFrame(fLSelMaterial, new TGLayoutHints(kLHintsLeft | kLHintsExpandX | kLHintsExpandY, 1, 1, 2, 2));
    fBSelMaterial = new TGPictureButton(f1, fClient->GetPicture("rootdb_t.xpm"), kMED_MATSEL);
    fBSelMaterial->SetToolTipText("Replace with one of the existing materials");
    fBSelMaterial->Associate(this);
    f1->AddFrame(fBSelMaterial, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMaterial = new TGTextButton(f1, "Edit");
-   f1->AddFrame(fEditMaterial, new TGLayoutHints(kLHintsRight, 1, 1, 2, 2));
+   f1->AddFrame(fEditMaterial, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMaterial->SetToolTipText("Edit selected material");
    fEditMaterial->Associate(this);   
-   AddFrame(f1, new TGLayoutHints(kLHintsLeft, 2, 2, 0, 0));
+   AddFrame(f1, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 0, 0));
    
 // Combo box for magnetic field option
    f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
@@ -111,7 +111,7 @@ TGeoMediumEditor::TGeoMediumEditor(const TGWindow *p, Int_t width,
 
 
 // Number entries for other settings
-   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kLHintsExpandX | kFixedWidth | kOwnBackground);
+   f1 = new TGCompositeFrame(this, 145, 10, kHorizontalFrame | kFixedWidth | kOwnBackground);
    f1->AddFrame(label = new TGLabel(f1, "Medium cuts"), new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
    f1->AddFrame(new TGHorizontal3DLine(f1), new TGLayoutHints(kLHintsExpandX, 5, 5, 7, 7));
    gClient->GetColorByName("#ff0000", color);
diff --git a/geom/geombuilder/src/TGeoTabManager.cxx b/geom/geombuilder/src/TGeoTabManager.cxx
index 03e83f1..4babe1d 100644
--- a/geom/geombuilder/src/TGeoTabManager.cxx
+++ b/geom/geombuilder/src/TGeoTabManager.cxx
@@ -139,6 +139,7 @@ void TGeoTabManager::GetMediumEditor(TGeoMedium *medium)
    else {
       fMediumPanel->SetModel(medium);
       fMediumPanel->Show();
+      fMediumPanel->RaiseWindow();
    }   
 }
 
@@ -153,6 +154,7 @@ void TGeoTabManager::GetMaterialEditor(TGeoMaterial *material)
    else {
       fMaterialPanel->SetModel(material);
       fMaterialPanel->Show();
+      fMaterialPanel->RaiseWindow();
    }   
 }
 
diff --git a/geom/geombuilder/src/TGeoVolumeEditor.cxx b/geom/geombuilder/src/TGeoVolumeEditor.cxx
index af02005..44b16f1 100644
--- a/geom/geombuilder/src/TGeoVolumeEditor.cxx
+++ b/geom/geombuilder/src/TGeoVolumeEditor.cxx
@@ -82,7 +82,7 @@ TGeoVolumeEditor::TGeoVolumeEditor(const TGWindow *p, Int_t width,
    fIsDivided = kFALSE;
    
    // TGShutter for categories
-   fCategories = new TGShutter(this, kSunkenFrame | kFixedHeight);
+   fCategories = new TGShutter(this, kSunkenFrame);
    TGCompositeFrame *container, *f1;
    Pixel_t color;
    TGLabel *label;
@@ -92,7 +92,7 @@ TGeoVolumeEditor::TGeoVolumeEditor(const TGWindow *p, Int_t width,
    container = (TGCompositeFrame*)si->GetContainer();
    container->SetBackgroundColor(GetDefaultFrameBackground());
    fCategories->AddItem(si);
-   
+
    // TextEntry for volume name
    f1 = new TGCompositeFrame(container, 155, 10, kHorizontalFrame | kFixedWidth);
    f1->AddFrame(label = new TGLabel(f1, "Volume name"), new TGLayoutHints(kLHintsLeft, 1, 1, 0, 0));
@@ -100,10 +100,10 @@ TGeoVolumeEditor::TGeoVolumeEditor(const TGWindow *p, Int_t width,
    gClient->GetColorByName("#ff0000", color);
    label->SetTextColor(color);
    container->AddFrame(f1, new TGLayoutHints(kLHintsTop, 0, 0, 2, 0));
-   fVolumeName = new TGTextEntry(container, new TGTextBuffer(50), kVOL_NAME);
-   fVolumeName->Resize(135, fVolumeName->GetDefaultHeight());
+   fVolumeName = new TGTextEntry(container, "", kVOL_NAME);
+   fVolumeName->SetDefaultSize(135, fVolumeName->GetDefaultHeight());
    fVolumeName->SetToolTipText("Enter the volume name");
-   container->AddFrame(fVolumeName, new TGLayoutHints(kLHintsLeft, 3, 1, 2, 5));
+   container->AddFrame(fVolumeName, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 3, 1, 2, 5));
 
    // Current shape
    f1 = new TGCompositeFrame(container, 155, 10, kHorizontalFrame | kFixedWidth);
@@ -112,7 +112,7 @@ TGeoVolumeEditor::TGeoVolumeEditor(const TGWindow *p, Int_t width,
    gClient->GetColorByName("#ff0000", color);
    label->SetTextColor(color);
    container->AddFrame(f1, new TGLayoutHints(kLHintsTop, 0, 0, 10, 0));
-   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame | kFixedWidth);
+   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame);
    fSelectedShape = 0;
    fLSelShape = new TGLabel(f1, "Select shape");
    gClient->GetColorByName("#0000ff", color);
@@ -124,13 +124,13 @@ TGeoVolumeEditor::TGeoVolumeEditor(const TGWindow *p, Int_t width,
    fBSelShape->Associate(this);
    f1->AddFrame(fBSelShape, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditShape = new TGTextButton(f1, "Edit");
-   f1->AddFrame(fEditShape, new TGLayoutHints(kLHintsRight, 1, 1, 2, 2));
+   f1->AddFrame(fEditShape, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditShape->SetToolTipText("Edit selected shape");
    fEditShape->Associate(this);   
-   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft, 2, 2, 0, 0));
+   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 0, 0));
    
    // Current medium
-   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame | kFixedWidth);
+   f1 = new TGCompositeFrame(container, 155, 30, kHorizontalFrame);
    fSelectedMedium = 0;
    fLSelMedium = new TGLabel(f1, "Select medium");
    gClient->GetColorByName("#0000ff", color);
@@ -142,11 +142,11 @@ TGeoVolumeEditor::TGeoVolumeEditor(const TGWindow *p, Int_t width,
    fBSelMedium->Associate(this);
    f1->AddFrame(fBSelMedium, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMedium = new TGTextButton(f1, "Edit");
-   f1->AddFrame(fEditMedium, new TGLayoutHints(kLHintsRight, 1, 1, 2, 2));
+   f1->AddFrame(fEditMedium, new TGLayoutHints(kLHintsLeft, 1, 1, 2, 2));
    fEditMedium->SetToolTipText("Edit selected medium");
    fEditMedium->Associate(this);
-   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft, 2, 2, 0, 0));
-   
+   container->AddFrame(f1, new TGLayoutHints(kLHintsLeft | kLHintsExpandX, 2, 2, 0, 0));
+
    // List of daughters
    si = new TGShutterItem(fCategories, new TGHotString("Daughters"),kCAT_DAUGHTERS);
    container = (TGCompositeFrame*)si->GetContainer();
@@ -365,7 +365,10 @@ TGeoVolumeEditor::TGeoVolumeEditor(const TGWindow *p, Int_t width,
 
 
    fCategories->Resize(163,340);
-   AddFrame(fCategories, new TGLayoutHints(kLHintsLeft, 0, 0, 4, 4));
+   AddFrame(fCategories, new TGLayoutHints(kLHintsLeft | kLHintsExpandX | kLHintsExpandY, 0, 0, 4, 4));
+
+   fCategories->Layout();
+   fCategories->SetDefaultSize(GetDefaultWidth(), GetDefaultHeight());
 }
 
 //______________________________________________________________________________
diff --git a/geom/geompainter/src/TGeoChecker.cxx b/geom/geompainter/src/TGeoChecker.cxx
index 8eba1b4..88b7815 100644
--- a/geom/geompainter/src/TGeoChecker.cxx
+++ b/geom/geompainter/src/TGeoChecker.cxx
@@ -752,13 +752,13 @@ TGeoOverlap *TGeoChecker::MakeCheckOverlap(const char *name, TGeoVolume *vol1, T
    Double_t local[3], local1[3];
    Double_t point[3];
    Double_t safety = TGeoShape::Big();
+   Double_t tolerance = TGeoShape::Tolerance();
    if (vol1->IsAssembly() || vol2->IsAssembly()) return nodeovlp;
    TGeoShape *shape1 = vol1->GetShape();
    TGeoShape *shape2 = vol2->GetShape();
    OpProgress("refresh", 0,0,NULL,kFALSE,kTRUE);   
    shape1->GetMeshNumbers(numPoints1, numSegs1, numPols1);
-   if (!shape1->IsComposite() && 
-       fBuff1->fID != (TObject*)shape1) {
+   if (fBuff1->fID != (TObject*)shape1) {
       // Fill first buffer.
       fBuff1->SetRawSizes(TMath::Max(numPoints1,fNmeshPoints), 3*TMath::Max(numPoints1,fNmeshPoints), 0, 0, 0, 0);
       points1 = fBuff1->fPnts;
@@ -774,8 +774,7 @@ TGeoOverlap *TGeoChecker::MakeCheckOverlap(const char *name, TGeoVolume *vol1, T
       fBuff1->fID = shape1;
    }   
    shape2->GetMeshNumbers(numPoints2, numSegs2, numPols2);
-   if (!shape2->IsComposite() && 
-       fBuff2->fID != (TObject*)shape2) {
+   if (fBuff2->fID != (TObject*)shape2) {
       // Fill second buffer.
       fBuff2->SetRawSizes(TMath::Max(numPoints2,fNmeshPoints), 3*TMath::Max(numPoints2,fNmeshPoints), 0, 0, 0,0);
       points2 = fBuff2->fPnts;
@@ -795,117 +794,109 @@ TGeoOverlap *TGeoChecker::MakeCheckOverlap(const char *name, TGeoVolume *vol1, T
    // Extrusion case. Test vol2 extrude vol1.
       isextrusion=kFALSE;
       // loop all points of the daughter
-      if (!shape2->IsComposite()) {
-         for (ip=0; ip<numPoints2; ip++) {
-            memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
-            if (local[0]<1e-10 && local[1]<1e-10) continue;
-            mat2->LocalToMaster(local, point);
-            mat1->MasterToLocal(point, local);
-            extrude = !shape1->Contains(local);
-            if (extrude) {
-               safety = shape1->Safety(local, kFALSE);
-               if (safety<ovlp) extrude=kFALSE;
-            }    
-            if (extrude) {
-               if (!isextrusion) {
-                  isextrusion = kTRUE;
-                  nodeovlp = new TGeoOverlap(name, vol1, vol2, mat1,mat2,kFALSE,safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-                  fGeoManager->AddOverlap(nodeovlp);
-               } else {
-                  if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-               }   
-            }
-         }
-      }                
-      // loop all points of the mother
-      if (!shape1->IsComposite()) {
-         for (ip=0; ip<numPoints1; ip++) {
-            memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
-            if (local[0]<1e-10 && local[1]<1e-10) continue;
-            mat1->LocalToMaster(local, point);
-            mat2->MasterToLocal(point, local1);
-            extrude = shape2->Contains(local1);
-            if (extrude) {
-               // skip points on mother mesh that have no neghbourhood ouside mother
-               safety = shape1->Safety(local,kTRUE);
-               if (safety>1E-6) {
-                  extrude = kFALSE;
-               } else {   
-                  safety = shape2->Safety(local1,kTRUE);
-                  if (safety<ovlp) extrude=kFALSE;
-               }   
-            }   
-            if (extrude) {
-               if (!isextrusion) {
-                  isextrusion = kTRUE;
-                  nodeovlp = new TGeoOverlap(name, vol1,vol2,mat1,mat2,kFALSE,safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-                  fGeoManager->AddOverlap(nodeovlp);
-               } else {
-                  if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
-                  nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-               }   
-            }
-         }
-      }
-      return nodeovlp;
-   }            
-   // Check overlap
-   Bool_t overlap;
-   overlap = kFALSE;
-   isoverlapping = kFALSE;
-   if (!shape1->IsComposite()) {
-      // loop all points of first candidate
-      for (ip=0; ip<numPoints1; ip++) {
-         memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
-         if (local[0]<1e-10 && local[1]<1e-10) continue;
-         mat1->LocalToMaster(local, point);
-         mat2->MasterToLocal(point, local); // now point in local reference of second
-         overlap = shape2->Contains(local);
-         if (overlap) {
-            safety = shape2->Safety(local, kTRUE);
-            if (safety<ovlp) overlap=kFALSE;
+      for (ip=0; ip<numPoints2; ip++) {
+         memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
+         if (TMath::Abs(local[0])<tolerance && TMath::Abs(local[1])<tolerance) continue;
+         mat2->LocalToMaster(local, point);
+         mat1->MasterToLocal(point, local);
+         extrude = !shape1->Contains(local);
+         if (extrude) {
+            safety = shape1->Safety(local, kFALSE);
+            if (safety<ovlp) extrude=kFALSE;
          }    
-         if (overlap) {
-            if (!isoverlapping) {
-               isoverlapping = kTRUE;
-               nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+         if (extrude) {
+            if (!isextrusion) {
+               isextrusion = kTRUE;
+               nodeovlp = new TGeoOverlap(name, vol1, vol2, mat1,mat2,kFALSE,safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
                fGeoManager->AddOverlap(nodeovlp);
             } else {
                if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-            }     
+           }   
          }
       }
-   }   
-   // loop all points of second candidate
-   if (!shape2->IsComposite()) {
-      for (ip=0; ip<numPoints2; ip++) {
-         memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
+      // loop all points of the mother
+      for (ip=0; ip<numPoints1; ip++) {
+         memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
          if (local[0]<1e-10 && local[1]<1e-10) continue;
-         mat2->LocalToMaster(local, point);
-         mat1->MasterToLocal(point, local); // now point in local reference of first
-         overlap = shape1->Contains(local);
-         if (overlap) {
-            safety = shape1->Safety(local, kTRUE);
-            if (safety<ovlp) overlap=kFALSE;
-         }    
-         if (overlap) {
-            if (!isoverlapping) {
-               isoverlapping = kTRUE;
-               nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+         mat1->LocalToMaster(local, point);
+         mat2->MasterToLocal(point, local1);
+         extrude = shape2->Contains(local1);
+         if (extrude) {
+            // skip points on mother mesh that have no neghbourhood ouside mother
+            safety = shape1->Safety(local,kTRUE);
+            if (safety>1E-6) {
+               extrude = kFALSE;
+            } else {   
+               safety = shape2->Safety(local1,kTRUE);
+               if (safety<ovlp) extrude=kFALSE;
+            }   
+         }   
+         if (extrude) {
+            if (!isextrusion) {
+               isextrusion = kTRUE;
+               nodeovlp = new TGeoOverlap(name, vol1,vol2,mat1,mat2,kFALSE,safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
                fGeoManager->AddOverlap(nodeovlp);
             } else {
                if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
                nodeovlp->SetNextPoint(point[0],point[1],point[2]);
-            }     
+            }   
          }
       }
-   } 
+      return nodeovlp;
+   }            
+   // Check overlap
+   Bool_t overlap;
+   overlap = kFALSE;
+   isoverlapping = kFALSE;
+   // loop all points of first candidate
+   for (ip=0; ip<numPoints1; ip++) {
+      memcpy(local, &points1[3*ip], 3*sizeof(Double_t));
+      if (local[0]<1e-10 && local[1]<1e-10) continue;
+      mat1->LocalToMaster(local, point);
+      mat2->MasterToLocal(point, local); // now point in local reference of second
+      overlap = shape2->Contains(local);
+      if (overlap) {
+         safety = shape2->Safety(local, kTRUE);
+         if (safety<ovlp) overlap=kFALSE;
+      }    
+      if (overlap) {
+         if (!isoverlapping) {
+            isoverlapping = kTRUE;
+            nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+            fGeoManager->AddOverlap(nodeovlp);
+         } else {
+            if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+         }     
+      }
+   }
+   // loop all points of second candidate
+   for (ip=0; ip<numPoints2; ip++) {
+      memcpy(local, &points2[3*ip], 3*sizeof(Double_t));
+      if (local[0]<1e-10 && local[1]<1e-10) continue;
+      mat2->LocalToMaster(local, point);
+      mat1->MasterToLocal(point, local); // now point in local reference of first
+      overlap = shape1->Contains(local);
+      if (overlap) {
+         safety = shape1->Safety(local, kTRUE);
+         if (safety<ovlp) overlap=kFALSE;
+      }    
+      if (overlap) {
+         if (!isoverlapping) {
+            isoverlapping = kTRUE;
+            nodeovlp = new TGeoOverlap(name,vol1,vol2,mat1,mat2,kTRUE,safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+            fGeoManager->AddOverlap(nodeovlp);
+         } else {
+            if (safety>nodeovlp->GetOverlap()) nodeovlp->SetOverlap(safety);
+            nodeovlp->SetNextPoint(point[0],point[1],point[2]);
+         }     
+      }
+   }
    return nodeovlp;  
 }
 
diff --git a/graf2d/x11/inc/TGX11.h b/graf2d/x11/inc/TGX11.h
index 2c59fd4..f625b0e 100644
--- a/graf2d/x11/inc/TGX11.h
+++ b/graf2d/x11/inc/TGX11.h
@@ -237,6 +237,7 @@ public:
    Int_t     WriteGIF(char *name);
    void      WritePixmap(Int_t wid, UInt_t w, UInt_t h, char *pxname);
    Window_t  GetCurrentWindow() const;
+   Int_t     SupportsExtension(const char *ext) const;
 
    //---- Methods used for GUI -----
    void         GetWindowAttributes(Window_t id, WindowAttributes_t &attr);
@@ -408,4 +409,3 @@ public:
 };
 
 #endif
-
diff --git a/graf2d/x11/src/TGX11.cxx b/graf2d/x11/src/TGX11.cxx
index c934b0b..d7c9da7 100644
--- a/graf2d/x11/src/TGX11.cxx
+++ b/graf2d/x11/src/TGX11.cxx
@@ -3281,3 +3281,20 @@ Int_t TGX11::AddPixmap(ULong_t pixid, UInt_t w, UInt_t h)
       
    return wid;
 }
+
+//______________________________________________________________________________
+Int_t TGX11::SupportsExtension(const char *ext) const
+{
+   // Returns 1 if window system server supports extension given by the
+   // argument, returns 0 in case extension is not supported and returns -1
+   // in case of error (like server not initialized).
+   // Examples:
+   //   "Apple-WM" - does server run on MacOS X;
+   //   "XINERAMA" - does server support Xinerama.
+   // See also the output of xdpyinfo.
+
+   Int_t major_opcode, first_event, first_error;
+   if (!fDisplay)
+      return -1;
+   return XQueryExtension(fDisplay, ext, &major_opcode, &first_event, &first_error);
+}
diff --git a/graf3d/eve/Module.mk b/graf3d/eve/Module.mk
index 2b98f8b..dea4ff7 100644
--- a/graf3d/eve/Module.mk
+++ b/graf3d/eve/Module.mk
@@ -30,11 +30,11 @@ EVEH1     := TEveBrowser TEveChunkManager TEveCompound \
              TEveGedEditor TEveMacro TEveManager TEvePad TEveParamList \
              TEveProjectionAxes TEveProjectionBases TEveProjectionManager \
              TEveProjections TEveScene TEveSelection TEveTrans TEveTreeTools \
-             TEveUtil TEveVSD TEveViewer TEveWindow
+             TEveUtil TEveVector TEveVSD TEveViewer TEveWindow
 
-EVEH2     := TEveArrow TEveBoxSet TEveCalo \
+EVEH2     := TEveArrow TEveBox TEveCalo \
              TEveDigitSet TEveFrameBox TEveGeo \
-             TEveGridStepper TEveLegoEventHandler \
+             TEveGridStepper TEveLegoEventHandler TEveShape \
              TEveLine TEvePointSet TEvePolygonSetProjected TEveQuadSet \
              TEveRGBAPalette TEveScalableStraightLineSet TEveStraightLineSet \
              TEveText TEveTrack TEveTriangleSet TEveJetCone \
diff --git a/graf3d/eve/inc/LinkDef1.h b/graf3d/eve/inc/LinkDef1.h
index e893391..c829a7f 100644
--- a/graf3d/eve/inc/LinkDef1.h
+++ b/graf3d/eve/inc/LinkDef1.h
@@ -33,9 +33,6 @@
 
 // TEveVSD
 #pragma link C++ class TEveVSD+;
-#pragma link C++ class TEveVector+;
-#pragma link C++ class TEveVector4+;
-#pragma link C++ class TEvePathMark+;
 #pragma link C++ class TEveMCTrack+;
 #pragma link C++ class TEveHit+;
 #pragma link C++ class TEveCluster+;
@@ -45,6 +42,12 @@
 #pragma link C++ class TEveRecCascade+;
 #pragma link C++ class TEveMCRecCrossRef+;
 
+// TEveVector
+#pragma link C++ class TEveVector+;
+#pragma link C++ class TEveVector4+;
+#pragma link C++ class TEvePoint+;
+#pragma link C++ class TEvePathMark+;
+
 // TEveTrans
 #pragma link C++ class TEveTrans-;
 #pragma link C++ class TEveTransSubEditor+;
@@ -120,6 +123,8 @@
 
 // TEveGedEditor
 #pragma link C++ class TEveGedEditor+;
+#pragma link C++ class TEveGedNameFrame+;
+#pragma link C++ class TEveGedNameTextButton+;
 
 // TEveMacro
 #pragma link C++ class TEveMacro+;
diff --git a/graf3d/eve/inc/LinkDef2.h b/graf3d/eve/inc/LinkDef2.h
index fa572a5..7568489 100644
--- a/graf3d/eve/inc/LinkDef2.h
+++ b/graf3d/eve/inc/LinkDef2.h
@@ -84,9 +84,16 @@
 // Arbitrary-tesselation TGeoShape.
 #pragma link C++ class TEveGeoPolyShape+;
 
+// Various shapes
+#pragma link C++ class TEveShape+;
+#pragma link C++ class TEveShapeEditor+;
+#pragma link C++ class TEveBox+;
+#pragma link C++ class TEveBoxGL+;
+#pragma link C++ class TEveBoxProjected+;
+#pragma link C++ class TEveBoxProjectedGL+;
+
 // TEvePolygonSetProjected
 #pragma link C++ class TEvePolygonSetProjected+;
-#pragma link C++ class TEvePolygonSetProjectedEditor+;
 #pragma link C++ class TEvePolygonSetProjectedGL+;
 
 // TEveTrianlgeSet
diff --git a/graf3d/eve/inc/TEveArrow.h b/graf3d/eve/inc/TEveArrow.h
index 817ad30..a8b486e 100644
--- a/graf3d/eve/inc/TEveArrow.h
+++ b/graf3d/eve/inc/TEveArrow.h
@@ -13,10 +13,10 @@
 #define ROOT_TEveArrow
 
 #include "TEveElement.h"
+#include "TEveVector.h"
 #include "TNamed.h"
 #include "TAtt3D.h"
 #include "TAttBBox.h"
-#include "TEveVSDStructs.h"
 
 class TEveArrow : public TEveElement,
                   public TNamed,
diff --git a/graf3d/eve/inc/TEveBox.h b/graf3d/eve/inc/TEveBox.h
new file mode 100644
index 0000000..bdfd548
--- /dev/null
+++ b/graf3d/eve/inc/TEveBox.h
@@ -0,0 +1,86 @@
+// @(#)root/eve:$Id: TEveBox.h 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveBox
+#define ROOT_TEveBox
+
+#include "TEveShape.h"
+
+//------------------------------------------------------------------------------
+// TEveBox
+//------------------------------------------------------------------------------
+
+class TEveBox : public TEveShape
+{
+   friend class TEveBoxGL;
+
+private:
+   TEveBox(const TEveBox&);            // Not implemented
+   TEveBox& operator=(const TEveBox&); // Not implemented
+
+protected:
+   Float_t fVertices[8][3];
+
+public:
+   TEveBox(const char* n="TEveBox", const char* t="");
+   virtual ~TEveBox();
+
+   void SetVertex(Int_t i, Float_t x, Float_t y, Float_t z);
+   void SetVertex(Int_t i, const Float_t* v);
+   void SetVertices(const Float_t* vs);
+
+   const Float_t* GetVertex(Int_t i) const { return fVertices[i]; }
+
+   // For TAttBBox:
+   virtual void ComputeBBox();
+
+   // Projectable:
+   virtual TClass* ProjectedClass(const TEveProjection* p) const;
+
+   ClassDef(TEveBox, 0); // 3D box with arbitrary vertices.
+};
+
+
+//------------------------------------------------------------------------------
+// TEveBoxProjected
+//------------------------------------------------------------------------------
+
+class TEveBoxProjected : public TEveShape,
+                         public TEveProjected
+{
+   friend class TEveBoxProjectedGL;
+
+private:
+   TEveBoxProjected(const TEveBoxProjected&);            // Not implemented
+   TEveBoxProjected& operator=(const TEveBoxProjected&); // Not implemented
+
+protected:
+   vPoint_t     fPoints;
+   Int_t        fBreakIdx;
+   vPoint_t     fDebugPoints;
+
+   virtual void SetDepthLocal(Float_t d);
+
+public:
+   TEveBoxProjected(const char* n="TEveBoxProjected", const char* t="");
+   virtual ~TEveBoxProjected();
+
+   // For TAttBBox:
+   virtual void ComputeBBox();
+
+   // Projected:
+   virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
+   virtual void UpdateProjection();
+
+   ClassDef(TEveBoxProjected, 0); // 3D box with arbitrary vertices.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveBoxGL.h b/graf3d/eve/inc/TEveBoxGL.h
new file mode 100644
index 0000000..6e2c9aa
--- /dev/null
+++ b/graf3d/eve/inc/TEveBoxGL.h
@@ -0,0 +1,90 @@
+// @(#)root/eve:$Id: TEveBoxGL.h 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveBoxGL
+#define ROOT_TEveBoxGL
+
+#include "TGLObject.h"
+
+class TGLViewer;
+class TGLScene;
+
+class TEveBox;
+class TEveBoxProjected;
+
+//------------------------------------------------------------------------------
+// TEveBoxGL
+//------------------------------------------------------------------------------
+
+class TEveBoxGL : public TGLObject
+{
+private:
+   TEveBoxGL(const TEveBoxGL&);            // Not implemented
+   TEveBoxGL& operator=(const TEveBoxGL&); // Not implemented
+
+protected:
+   TEveBox             *fM;  // Model object.
+
+   void RenderOutline    (const Float_t p[8][3]) const;
+   void RenderBoxStdNorm (const Float_t p[8][3]) const;
+   void RenderBoxAutoNorm(const Float_t p[8][3]) const;
+
+public:
+   TEveBoxGL();
+   virtual ~TEveBoxGL() {}
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void Draw(TGLRnrCtx& rnrCtx) const;
+   virtual void DirectDraw(TGLRnrCtx& rnrCtx) const;
+
+   // To support two-level selection
+   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+
+   ClassDef(TEveBoxGL, 0); // GL renderer class for TEveBox.
+};
+
+
+//------------------------------------------------------------------------------
+// TEveBoxProjectedGL
+//------------------------------------------------------------------------------
+
+class TEveBoxProjectedGL : public TGLObject
+{
+private:
+   TEveBoxProjectedGL(const TEveBoxProjectedGL&);            // Not implemented
+   TEveBoxProjectedGL& operator=(const TEveBoxProjectedGL&); // Not implemented
+
+protected:
+   TEveBoxProjected             *fM;  // Model object.
+
+   void RenderPoints(Int_t mode) const;
+
+public:
+   TEveBoxProjectedGL();
+   virtual ~TEveBoxProjectedGL() {}
+
+   virtual Bool_t SetModel(TObject* obj, const Option_t* opt=0);
+   virtual void   SetBBox();
+
+   virtual void Draw(TGLRnrCtx& rnrCtx) const;
+   virtual void DirectDraw(TGLRnrCtx& rnrCtx) const;
+
+   // To support two-level selection
+   // virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
+   // virtual void ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+
+   ClassDef(TEveBoxProjectedGL, 0); // GL renderer class for TEveBoxProjected.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveBoxSet.h b/graf3d/eve/inc/TEveBoxSet.h
index 8440fe6..f81e8ed 100644
--- a/graf3d/eve/inc/TEveBoxSet.h
+++ b/graf3d/eve/inc/TEveBoxSet.h
@@ -13,7 +13,7 @@
 #define ROOT_TEveBoxSet
 
 #include "TEveDigitSet.h"
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
 
 class TGeoMatrix;
 class TRandom;
diff --git a/graf3d/eve/inc/TEveBoxSetGL.h b/graf3d/eve/inc/TEveBoxSetGL.h
index 66193eb..64af0f9 100644
--- a/graf3d/eve/inc/TEveBoxSetGL.h
+++ b/graf3d/eve/inc/TEveBoxSetGL.h
@@ -31,6 +31,8 @@ protected:
    void   RenderBox(const Float_t p[24]) const;
    void   MakeDisplayList() const;
 
+   void   RenderBoxes(TGLRnrCtx & rnrCtx) const;
+
 public:
    TEveBoxSetGL();
    virtual ~TEveBoxSetGL();
diff --git a/graf3d/eve/inc/TEveBrowser.h b/graf3d/eve/inc/TEveBrowser.h
index 17ceab3..f6e0be7 100644
--- a/graf3d/eve/inc/TEveBrowser.h
+++ b/graf3d/eve/inc/TEveBrowser.h
@@ -98,6 +98,8 @@ protected:
 
    Bool_t            fSignalsConnected;
 
+   static TString    fgEditorClass;
+
 public:
    TEveGListTreeEditorFrame(const TGWindow* p=0, Int_t width=250, Int_t height=700);
    virtual ~TEveGListTreeEditorFrame();
@@ -116,6 +118,8 @@ public:
    void ItemDblClicked(TGListTreeItem* item, Int_t btn);
    void ItemKeyPress(TGListTreeItem *entry, UInt_t keysym, UInt_t mask);
 
+   static void SetEditorClass(const char* edclass);
+
    ClassDef(TEveGListTreeEditorFrame, 0); // Composite GUI frame for parallel display of a TGListTree and TEveGedEditor.
 };
 
@@ -148,6 +152,10 @@ public:
 
    void EveMenu(Int_t id);
 
+   // Some getters missing in TRootBrowser
+   TGMenuBar*         GetMenuBar()      const { return fMenuBar; }
+   TGHorizontalFrame* GetTopMenuFrame() const { return fTopMenuFrame; }
+
    ClassDef(TEveBrowser, 0); // Specialization of TRootBrowser for Eve.
 };
 
diff --git a/graf3d/eve/inc/TEveCalo.h b/graf3d/eve/inc/TEveCalo.h
index bcbcf89..781650c 100644
--- a/graf3d/eve/inc/TEveCalo.h
+++ b/graf3d/eve/inc/TEveCalo.h
@@ -82,9 +82,10 @@ public:
 
    TEveCaloData* GetData() const { return fData; }
    void    SetData(TEveCaloData* d);
-   void    DataChanged();   Float_t GetMaxVal() const;
+   void    DataChanged();
+   Float_t GetMaxVal() const;
 
-   void    AssertCellIdCache() const;
+   Bool_t  AssertCellIdCache() const;
    void    InvalidateCellIdCache() { fCellIdCacheOK=kFALSE; ResetBBox(); };
 
    Float_t GetDataSliceThreshold(Int_t slice) const;
diff --git a/graf3d/eve/inc/TEveCaloData.h b/graf3d/eve/inc/TEveCaloData.h
index ee1c2a5..2b156d5 100644
--- a/graf3d/eve/inc/TEveCaloData.h
+++ b/graf3d/eve/inc/TEveCaloData.h
@@ -118,6 +118,12 @@ public:
       std::vector<Int_t>   fBinData;
 
       Float_t* GetSliceVals(Int_t bin);
+
+      void Clear()
+      {
+         fSliceData.clear();
+         fBinData.clear();
+      }
    };
 
    /**************************************************************************/
diff --git a/graf3d/eve/inc/TEveCaloLegoGL.h b/graf3d/eve/inc/TEveCaloLegoGL.h
index f4a9614..4fa26ed 100644
--- a/graf3d/eve/inc/TEveCaloLegoGL.h
+++ b/graf3d/eve/inc/TEveCaloLegoGL.h
@@ -16,7 +16,7 @@
 #include "TGLAxisPainter.h"
 
 #include "TEveCaloData.h"
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
 #include "TEveCalo.h"
 
 #include <map>
@@ -80,7 +80,7 @@ private:
    mutable vCell2D_t                 fCells2D;
 
    mutable TEveCaloData::RebinData_t fRebinData;
-   mutable Float_t                   fMaxValRebin;
+   mutable Float_t                   fMaxVal;
    mutable Float_t                   fValToPixel; // top logaritmic viewview
    mutable Int_t                     fCurrentPixelsPerBin;
 
diff --git a/graf3d/eve/inc/TEveDigitSet.h b/graf3d/eve/inc/TEveDigitSet.h
index 489d3d0..45ac02c 100644
--- a/graf3d/eve/inc/TEveDigitSet.h
+++ b/graf3d/eve/inc/TEveDigitSet.h
@@ -54,10 +54,12 @@ protected:
 
    Int_t             fDefaultValue;   //  Default signal value.
    Bool_t            fValueIsColor;   //  Interpret signal value as RGBA color.
-   Bool_t            fOwnIds;         //  Flag specifying if id-objects are owned by the TEveDigitSet
+   Bool_t            fSingleColor;    //  Use the same color for all digits.
+   Bool_t            fOwnIds;         //  Flag specifying if id-objects are owned by the TEveDigitSet.
    TEveChunkManager  fPlex;           //  Container of digit data.
    DigitBase_t*      fLastDigit;      //! The last digit added to collection.
 
+   Color_t           fColor;          //  Color used for frame
    TEveFrameBox*     fFrame;          //  Pointer to frame structure.
    TEveRGBAPalette*  fPalette;        //  Pointer to signal-color palette.
    ERenderMode_e     fRenderMode;     //  Render mode: as-is / line / filled.
@@ -74,6 +76,8 @@ public:
    TEveDigitSet(const char* n="TEveDigitSet", const char* t="");
    virtual ~TEveDigitSet();
 
+   void UseSingleColor();
+
    virtual Bool_t CanEditMainColor() const { return kTRUE; }
    virtual void   SetMainColor(Color_t color);
 
diff --git a/graf3d/eve/inc/TEveElement.h b/graf3d/eve/inc/TEveElement.h
index e772fe7..49f527c 100644
--- a/graf3d/eve/inc/TEveElement.h
+++ b/graf3d/eve/inc/TEveElement.h
@@ -60,7 +60,7 @@ public:
    };
 
    static const TGPicture*                      fgRnrIcons[4];
-   static const TGPicture*                      fgListTreeIcons[8];
+   static const TGPicture*                      fgListTreeIcons[9];
 
    typedef std::set<TEveListTreeInfo>           sLTI_t;
    typedef sLTI_t::iterator                     sLTI_i;
@@ -102,13 +102,15 @@ protected:
    virtual void PreDeleteElement();
    virtual void RemoveElementsInternal();
 
+   static const char* ToString(Bool_t b);
+
 public:
    TEveElement();
    TEveElement(Color_t& main_color);
    TEveElement(const TEveElement& e);
    virtual ~TEveElement();
 
-   virtual TEveElement* CloneElement() const { return new TEveElement(*this); }
+   virtual TEveElement* CloneElement() const;
    virtual TEveElement* CloneElementRecurse(Int_t level=0) const;
    virtual void         CloneChildrenRecurse(TEveElement* dest, Int_t level=0) const;
 
@@ -165,24 +167,25 @@ public:
    TEveElement* FindChild(TPRegexp& regexp, const TClass* cls=0);
    Int_t        FindChildren(List_t& matches, const TString&  name, const TClass* cls=0);
    Int_t        FindChildren(List_t& matches, TPRegexp& regexp, const TClass* cls=0);
-   TEveElement* FirstChild() const { return fChildren.empty() ? 0 : fChildren.front(); }
-   TEveElement* LastChild () const { return fChildren.empty() ? 0 : fChildren.back();  }
+   TEveElement* FirstChild() const;
+   TEveElement* LastChild () const;
 
    void EnableListElements (Bool_t rnr_self=kTRUE,  Bool_t rnr_children=kTRUE);  // *MENU*
    void DisableListElements(Bool_t rnr_self=kFALSE, Bool_t rnr_children=kFALSE); // *MENU*
 
-   Bool_t GetDestroyOnZeroRefCnt() const   { return fDestroyOnZeroRefCnt; }
-   void   SetDestroyOnZeroRefCnt(Bool_t d) { fDestroyOnZeroRefCnt = d; }
+   Bool_t GetDestroyOnZeroRefCnt() const;
+   void   SetDestroyOnZeroRefCnt(Bool_t d);
 
-   Int_t  GetDenyDestroy() const { return fDenyDestroy; }
-   void   IncDenyDestroy()       { ++fDenyDestroy; }
-   void   DecDenyDestroy()       { if (--fDenyDestroy <= 0) CheckReferenceCount("TEveElement::DecDenyDestroy "); }
+   Int_t  GetDenyDestroy() const;
+   void   IncDenyDestroy();
+   void   DecDenyDestroy();
 
-   Int_t  GetParentIgnoreCnt() const { return fParentIgnoreCnt; }
-   void   IncParentIgnoreCnt()       { ++fParentIgnoreCnt; }
-   void   DecParentIgnoreCnt()       { if (--fParentIgnoreCnt <= 0) CheckReferenceCount("TEveElement::DecParentIgnoreCnt "); }
+   Int_t  GetParentIgnoreCnt() const;
+   void   IncParentIgnoreCnt();
+   void   DecParentIgnoreCnt();
 
    virtual void PadPaint(Option_t* option);
+   virtual void PaintStandard(TObject* id);
 
    virtual TObject* GetObject      (const TEveException& eh="TEveElement::GetObject ") const;
    virtual TObject* GetEditorObject(const TEveException& eh="TEveElement::GetEditorObject ") const { return GetObject(eh); }
@@ -227,6 +230,8 @@ public:
    virtual void RemoveElements();
    virtual void RemoveElementsLocal();
 
+   virtual void ProjectChild(TEveElement* el, Bool_t same_depth=kTRUE);
+
    virtual void Destroy();                      // *MENU*
    virtual void DestroyOrWarn();
    virtual void DestroyElements();              // *MENU*
@@ -265,7 +270,7 @@ public:
 
    virtual Bool_t     CanEditMainTrans() const { return fCanEditMainTrans; }
    virtual Bool_t     HasMainTrans()     const { return fMainTrans != 0;   }
-   virtual TEveTrans* PtrMainTrans();
+   virtual TEveTrans* PtrMainTrans(Bool_t create=kTRUE);
    virtual TEveTrans& RefMainTrans();
    virtual void       InitMainTrans(Bool_t can_edit=kTRUE);
    virtual void       DestroyMainTrans();
@@ -315,6 +320,8 @@ public:
 
    virtual UChar_t GetSelectedLevel() const;
 
+   void RecheckImpliedSelections();
+
    // Change-stamping and change bits
    //---------------------------------
 
@@ -383,7 +390,7 @@ public:
    TEveElementObjectPtr(const TEveElementObjectPtr& e);
    virtual ~TEveElementObjectPtr();
 
-   virtual TEveElementObjectPtr* CloneElement() const { return new TEveElementObjectPtr(*this); }
+   virtual TEveElementObjectPtr* CloneElement() const;
 
    virtual TObject* GetObject(const TEveException& eh="TEveElementObjectPtr::GetObject ") const;
    virtual void     ExportToCINT(char* var_name);
@@ -417,7 +424,7 @@ public:
    TEveElementList(const TEveElementList& e);
    virtual ~TEveElementList() {}
 
-   virtual TEveElementList* CloneElement() const { return new TEveElementList(*this); }
+   virtual TEveElementList* CloneElement() const;
 
    virtual const char* GetElementName()  const { return GetName();  }
    virtual const char* GetElementTitle() const { return GetTitle(); }
@@ -434,9 +441,9 @@ public:
    virtual Bool_t CanEditMainColor() const { return fDoColor; }
 
    TClass* GetChildClass() const { return fChildClass; }
-   void SetChildClass(TClass* c) { fChildClass = c; }
+   void    SetChildClass(TClass* c) { fChildClass = c; }
 
-   virtual Bool_t AcceptElement(TEveElement* el);
+   virtual Bool_t  AcceptElement(TEveElement* el);
 
    virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
diff --git a/graf3d/eve/inc/TEveGedEditor.h b/graf3d/eve/inc/TEveGedEditor.h
index a3626b4..706d1dd 100644
--- a/graf3d/eve/inc/TEveGedEditor.h
+++ b/graf3d/eve/inc/TEveGedEditor.h
@@ -13,21 +13,41 @@
 #define ROOT_TEveGedEditor
 
 #include "TGedEditor.h"
+#include "TGedFrame.h"
+#include "TGButton.h"
 
 class TEveElement;
+class TContextMenu;
+
+//==============================================================================
+// TEveGedEditor
+//==============================================================================
 
 class TEveGedEditor : public TGedEditor
 {
    TEveGedEditor(const TEveGedEditor&);            // Not implemented
    TEveGedEditor& operator=(const TEveGedEditor&); // Not implemented
 
+public:
+   typedef TGedFrame* (*NameFrameCreator_t)(TEveGedEditor*, const TGWindow* parent, const char* tab_name);
+
 protected:
    TEveElement   *fElement;    // Cached eve-element pointer.
    TObject       *fObject;     // Cached tobj pointer.
 
+   virtual TGedFrame* CreateNameFrame(const TGWindow* parent, const char* tab_name); 
+
+   static Int_t   fgMaxExtraEditors;
+   static TList  *fgExtraEditors;
+
+   static TContextMenu *fgContextMenu;
+
 public:
-   TEveGedEditor(TCanvas* canvas=0, Int_t width=250, Int_t height=400);
-   virtual ~TEveGedEditor() {}
+   TEveGedEditor(TCanvas* canvas=0, UInt_t width=250, UInt_t height=400);
+   virtual ~TEveGedEditor();
+
+   virtual void CloseWindow();
+   virtual void DeleteWindow();
 
    TEveElement* GetEveElement() const;
 
@@ -37,9 +57,65 @@ public:
    virtual void SetModel(TVirtualPad* pad, TObject* obj, Int_t event);
    virtual void Update(TGedFrame* gframe=0);
 
-   // virtual Bool_t HandleButton(Event_t *event);
+   // --- Statics for extra editors. ---
+
+   static void SpawnNewEditor(TObject* obj);
+   static void ElementChanged(TEveElement* el);
+   static void ElementDeleted(TEveElement* el);
+
+   static void DestroyEditors();
+
+   static TContextMenu* GetContextMenu();
 
    ClassDef(TEveGedEditor, 0); // Specialization of TGedEditor for proper update propagation to TEveManager.
 };
 
+
+//==============================================================================
+// TEveGedNameFrame
+//==============================================================================
+
+class TEveGedNameFrame : public TGedFrame
+{
+private:
+   TEveGedNameFrame(const TEveGedNameFrame&);            // Not implemented
+   TEveGedNameFrame& operator=(const TEveGedNameFrame&); // Not implemented
+
+protected:
+   TGTextButton   *fNCButton; // Name/Class button.
+
+public:
+   TEveGedNameFrame(const TGWindow *p=0, Int_t width=140, Int_t height=30,
+                    UInt_t options=kChildFrame | kHorizontalFrame);
+   virtual ~TEveGedNameFrame();
+
+   virtual void SetModel(TObject* obj);
+
+   void SpawnEditorClone();
+
+   ClassDef(TEveGedNameFrame, 0); // Top name-frame used in EVE.
+};
+
+
+//==============================================================================
+// TEveGedNameTextButton
+//==============================================================================
+
+class TEveGedNameTextButton : public TGTextButton
+{
+private:
+   TEveGedNameTextButton(const TEveGedNameTextButton&);            // Not implemented
+   TEveGedNameTextButton& operator=(const TEveGedNameTextButton&); // Not implemented
+
+   TEveGedNameFrame *fFrame;
+
+public:
+   TEveGedNameTextButton(TEveGedNameFrame* p);
+   virtual ~TEveGedNameTextButton();
+
+   virtual Bool_t HandleButton(Event_t* event);
+
+   ClassDef(TEveGedNameTextButton, 0); // Button for GED name-frame.
+};
+
 #endif
diff --git a/graf3d/eve/inc/TEveGeoShape.h b/graf3d/eve/inc/TEveGeoShape.h
index ca52623..2701061 100644
--- a/graf3d/eve/inc/TEveGeoShape.h
+++ b/graf3d/eve/inc/TEveGeoShape.h
@@ -17,6 +17,7 @@
 
 class TGeoShape;
 class TEveGeoShapeExtract;
+class TBuffer3D;
 
 class TEveGeoShape : public TEveElement,
                      public TNamed,
diff --git a/graf3d/eve/inc/TEveJetCone.h b/graf3d/eve/inc/TEveJetCone.h
index b88d96c..b42f07c 100644
--- a/graf3d/eve/inc/TEveJetCone.h
+++ b/graf3d/eve/inc/TEveJetCone.h
@@ -13,7 +13,7 @@
 #define ROOT_TEveJetCone
 
 #include "TEveElement.h"
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
 #include "TAttBBox.h"
 
 class TEveJetCone : public TEveElementList,
diff --git a/graf3d/eve/inc/TEveLine.h b/graf3d/eve/inc/TEveLine.h
index 2018ac9..dd31d10 100644
--- a/graf3d/eve/inc/TEveLine.h
+++ b/graf3d/eve/inc/TEveLine.h
@@ -12,8 +12,8 @@
 #ifndef ROOT_TEveLine
 #define ROOT_TEveLine
 
-#include "TEveUtil.h"
 #include "TEvePointSet.h"
+#include "TEveVector.h"
 
 #include "TAttLine.h"
 
@@ -43,9 +43,12 @@ public:
    TEveLine(const char* name, Int_t n_points=0, ETreeVarType_e tv_type=kTVT_XYZ);
    virtual ~TEveLine() {}
 
-   virtual void SetLineColor(Color_t col)   { SetMainColor(col); }
    virtual void SetMarkerColor(Color_t col);
 
+   virtual void SetLineColor(Color_t col)   { SetMainColor(col); }
+   virtual void SetLineStyle(Style_t lstyle);
+   virtual void SetLineWidth(Width_t lwidth);
+
    Bool_t GetRnrLine() const     { return fRnrLine;   }
    Bool_t GetRnrPoints() const   { return fRnrPoints; }
    Bool_t GetSmooth() const      { return fSmooth;    }
@@ -58,13 +61,15 @@ public:
    TEveVector GetLineStart() const;
    TEveVector GetLineEnd()   const;
 
+   virtual const TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
+
    virtual void CopyVizParams(const TEveElement* el);
    virtual void WriteVizParams(ostream& out, const TString& var);
 
    virtual TClass* ProjectedClass(const TEveProjection* p) const;
 
-   static Bool_t GetDefaultSmooth()       { return fgDefaultSmooth; }
-   static void SetDefaultSmooth(Bool_t r) { fgDefaultSmooth = r;    }
+   static Bool_t GetDefaultSmooth();
+   static void   SetDefaultSmooth(Bool_t r);
 
    ClassDef(TEveLine, 0); // An arbitrary polyline with fixed line and marker attributes.
 };
diff --git a/graf3d/eve/inc/TEveManager.h b/graf3d/eve/inc/TEveManager.h
index be021a9..e7251e5 100644
--- a/graf3d/eve/inc/TEveManager.h
+++ b/graf3d/eve/inc/TEveManager.h
@@ -90,8 +90,6 @@ private:
 
    TEveBrowser              *fBrowser;
    TEveGListTreeEditorFrame *fLTEFrame;
-   TEveGedEditor            *fEditor;
-   TGStatusBar              *fStatusBar;
 
    TFolder                  *fMacroFolder;
 
@@ -138,8 +136,8 @@ public:
 
    TEveBrowser*      GetBrowser()   const { return fBrowser;   }
    TEveGListTreeEditorFrame* GetLTEFrame()  const { return fLTEFrame;  }
-   TEveGedEditor*    GetEditor()    const { return fEditor;    }
-   TGStatusBar*      GetStatusBar() const { return fStatusBar; }
+   TEveGedEditor*    GetEditor()    const;
+   TGStatusBar*      GetStatusBar() const;
 
    TEveWindowManager* GetWindowManager() const { return fWindowManager; }
 
diff --git a/graf3d/eve/inc/TEvePlot3D.h b/graf3d/eve/inc/TEvePlot3D.h
index d5a0a4b..78662a2 100644
--- a/graf3d/eve/inc/TEvePlot3D.h
+++ b/graf3d/eve/inc/TEvePlot3D.h
@@ -15,7 +15,7 @@
 #include "TEveElement.h"
 #include "TAttBBox.h"
 
-class TEvePlot3D : public TEveElementList // , public TAttBBox
+class TEvePlot3D : public TEveElementList
 {
    friend class TEvePlot3DGL;
 
@@ -35,9 +35,6 @@ public:
    TEvePlot3D(const char* n="TEvePlot3D", const char* t="");
    virtual ~TEvePlot3D() {}
 
-   // For TAttBBox:
-   // virtual void ComputeBBox();
-
    void SetPlot(TObject* obj, const TString& opt) { fPlot = obj; fPlotOption = opt; }
 
    TObject* GetPlot()       const { return fPlot;   }
diff --git a/graf3d/eve/inc/TEvePointSet.h b/graf3d/eve/inc/TEvePointSet.h
index 08d6684..38e35bd 100644
--- a/graf3d/eve/inc/TEvePointSet.h
+++ b/graf3d/eve/inc/TEvePointSet.h
@@ -12,7 +12,6 @@
 #ifndef ROOT_TEvePointSet
 #define ROOT_TEvePointSet
 
-#include "TEveVSDStructs.h"
 #include "TEveElement.h"
 #include "TEveProjectionBases.h"
 #include "TEveTreeTools.h"
@@ -79,6 +78,8 @@ public:
    void   SetPointIntIds(Int_t n, Int_t* ids);
 
    virtual void SetMarkerColor(Color_t col) { SetMainColor(col); }
+   virtual void SetMarkerStyle(Style_t mstyle=1);
+   virtual void SetMarkerSize(Size_t msize=1);
 
    virtual void Paint(Option_t* option="");
 
@@ -182,6 +183,8 @@ public:
    virtual void SetProjection(TEveProjectionManager* proj, TEveProjectable* model);
    virtual void UpdateProjection();
 
+   virtual void PointSelected(Int_t id);
+
    ClassDef(TEvePointSetProjected, 1); // Projected copy of a TEvePointSet.
 };
 
diff --git a/graf3d/eve/inc/TEvePolygonSetProjected.h b/graf3d/eve/inc/TEvePolygonSetProjected.h
index 01d4ec3..adc83cd 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjected.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjected.h
@@ -12,26 +12,19 @@
 #ifndef ROOT_TEvePolygonSetProjected
 #define ROOT_TEvePolygonSetProjected
 
-#include "TEveElement.h"
+#include "TEveShape.h"
 #include "TEveProjectionBases.h"
 
-#include "TNamed.h"
-#include "TAtt3D.h"
-#include "TAttBBox.h"
-#include "TColor.h"
-#include "TEveVSDStructs.h"
-
 class TBuffer3D;
 
 class TEveVector;
 
-class TEvePolygonSetProjected :  public TEveElementList,
-                                 public TEveProjected,
-                                 public TAtt3D,
-                                 public TAttBBox
+class TEvePolygonSetProjected : public TEveShape,
+                                public TEveProjected
 {
    friend class TEvePolygonSetProjectedGL;
    friend class TEvePolygonSetProjectedEditor;
+
 private:
    TEvePolygonSetProjected(const TEvePolygonSetProjected&);            // Not implemented
    TEvePolygonSetProjected& operator=(const TEvePolygonSetProjected&); // Not implemented
@@ -43,7 +36,7 @@ protected:
       Int_t*    fPnts;   // point indices
 
       Polygon_t() : fNPnts(0), fPnts(0) {}
-     virtual ~Polygon_t() { delete [] fPnts; fNPnts=0; fPnts=0;}
+      virtual ~Polygon_t() { delete [] fPnts; fNPnts=0; fPnts=0; }
 
       Polygon_t& operator=(const Polygon_t& x)
       { fNPnts = x.fNPnts; fPnts = x.fPnts; return *this; }
@@ -74,45 +67,22 @@ protected:
    Int_t        fNPnts;    // number of reduced and projected points
    TEveVector*  fPnts;     // reduced and projected points
 
-   Color_t      fFillColor; // fill color of polygons
-   Color_t      fLineColor; // outline color of polygons
-   Float_t      fLineWidth; // outline width of polygons
-
-   Bool_t       fHighlightFrame; // higlight mode
-
    virtual void SetDepthLocal(Float_t d);
 
 public:
    TEvePolygonSetProjected(const char* n="TEvePolygonSetProjected", const char* t="");
    virtual ~TEvePolygonSetProjected();
 
+   virtual void    ComputeBBox();
+
    virtual void    SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void    UpdateProjection();
 
    void            ProjectBuffer3D();
 
-   virtual void    ComputeBBox();
-   virtual void    Paint(Option_t* option = "");
-
    virtual void    DumpPolys() const;
    void            DumpBuffer3D();
 
-   // Rendering parameters.
-   virtual Bool_t  CanEditMainColor() const { return kTRUE; }
-   virtual void    SetMainColor(Color_t color);
-
-   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
-
-   virtual Color_t GetFillColor() const { return fFillColor; }
-   virtual Color_t GetLineColor() const { return fLineColor; }
-   virtual Float_t GetLineWidth() const { return fLineWidth;}
-   virtual Bool_t  GetHighlightFrame() const { return fHighlightFrame; }
-
-   virtual void    SetFillColor(Color_t c)  { fFillColor = c; }
-   virtual void    SetLineColor(Color_t c)  { fLineColor = c; }
-   virtual void    SetLineWidth(Float_t lw) { fLineWidth = lw;}
-   virtual void    SetHighlightFrame(Bool_t f) { fHighlightFrame = f; }
-
    ClassDef(TEvePolygonSetProjected,0); // Set of projected polygons with outline; typically produced from a TBuffer3D.
 
 };
diff --git a/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h b/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h
index c347724..e69de29 100644
--- a/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h
+++ b/graf3d/eve/inc/TEvePolygonSetProjectedEditor.h
@@ -1,46 +0,0 @@
-// @(#)root/eve:$Id: TEvePolygonSetProjectedEditor.h 21312 2007-12-10 19:42:53Z matevz $
-// Authors: Matevz Tadel & Alja Mrak-Tadel: 2006, 2007
-
-/*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
-
-#ifndef ROOT_TEvePolygonSetProjectedEditor
-#define ROOT_TEvePolygonSetProjectedEditor
-
-#include "TGedFrame.h"
-
-class TGNumberEntry;
-class TGColorSelect;
-
-class TEvePolygonSetProjected;
-
-class TEvePolygonSetProjectedEditor : public TGedFrame
-{
-   TEvePolygonSetProjectedEditor(const TEvePolygonSetProjectedEditor&);            // Not implemented
-   TEvePolygonSetProjectedEditor& operator=(const TEvePolygonSetProjectedEditor&); // Not implemented
-
-protected:
-   TEvePolygonSetProjected *fPS;         // Model object.
-
-   TGNumberEntry           *fLineWidth;  // TEveLine width widget.
-   TGColorSelect           *fLineColor;  // TEveLine color widget.
-
-public:
-   TEvePolygonSetProjectedEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30,
-                                 UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());
-   ~TEvePolygonSetProjectedEditor() {}
-
-   virtual void SetModel(TObject* obj);
-
-   virtual void DoLineWidth();
-   virtual void DoLineColor(Pixel_t color);
-
-   ClassDef(TEvePolygonSetProjectedEditor, 0); // Editor for TEvePolygonSetProjected class.
-};
-
-#endif
diff --git a/graf3d/eve/inc/TEveProjectionAxes.h b/graf3d/eve/inc/TEveProjectionAxes.h
index a75e97c..e351cbf 100644
--- a/graf3d/eve/inc/TEveProjectionAxes.h
+++ b/graf3d/eve/inc/TEveProjectionAxes.h
@@ -53,9 +53,7 @@ public:
    TEveProjectionAxes(TEveProjectionManager* m, Bool_t useColorSet = kTRUE);
    virtual ~TEveProjectionAxes();
 
-   TEveProjectionManager* GetManager(){
-      return fManager;
-   }
+   TEveProjectionManager* GetManager()      { return fManager; }
 
    void            SetLabMode(ELabMode x)   { fLabMode = x; }
    ELabMode        GetLabMode()   const     { return fLabMode;}
@@ -69,6 +67,7 @@ public:
 
    virtual void    Paint(Option_t* option="");
    virtual void    ComputeBBox();
+
    virtual const   TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
 
    ClassDef(TEveProjectionAxes, 1); // Class to draw scales in non-linear projections.
diff --git a/graf3d/eve/inc/TEveProjectionBases.h b/graf3d/eve/inc/TEveProjectionBases.h
index 993c22b..4ff10e2 100644
--- a/graf3d/eve/inc/TEveProjectionBases.h
+++ b/graf3d/eve/inc/TEveProjectionBases.h
@@ -12,16 +12,17 @@
 #ifndef ROOT_TEveProjectionBases
 #define ROOT_TEveProjectionBases
 
-#include "TEveUtil.h"
-
-class TBuffer3D;
+#include "Rtypes.h"
+#include <list>
+#include <set>
 
 class TEveElement;
-
 class TEveProjection;
 class TEveProjected;
 class TEveProjectionManager;
 
+class TClass;
+
 ////////////////////////////////////////////////////////////////
 //                                                            //
 // TEveProjectable                                            //
@@ -36,10 +37,11 @@ private:
    TEveProjectable(const TEveProjectable&);            // Not implemented
    TEveProjectable& operator=(const TEveProjectable&); // Not implemented
 
-protected:
+public:
    typedef std::list<TEveProjected*>            ProjList_t;
    typedef std::list<TEveProjected*>::iterator  ProjList_i;
 
+protected:
    ProjList_t       fProjectedList; // references to projected instances.
 
 public:
@@ -50,6 +52,9 @@ public:
 
    virtual Bool_t HasProjecteds() const { return ! fProjectedList.empty(); }
 
+   ProjList_i   BeginProjecteds()       { return  fProjectedList.begin(); }
+   ProjList_i   EndProjecteds()         { return  fProjectedList.end();   }
+
    virtual void AddProjected(TEveProjected* p)    { fProjectedList.push_back(p); }
    virtual void RemoveProjected(TEveProjected* p) { fProjectedList.remove(p);    }
 
@@ -89,7 +94,11 @@ public:
    TEveProjected();
    virtual ~TEveProjected();
 
-   TEveProjectable* GetProjectable() const { return fProjectable; }
+   TEveProjectionManager* GetManager()     const { return fManager; }
+   TEveProjectable*       GetProjectable() const { return fProjectable; }
+   Float_t                GetDepth()       const { return fDepth; }
+
+   TEveElement*           GetProjectableAsElement() const;
 
    virtual void SetProjection(TEveProjectionManager* mng, TEveProjectable* model);
    virtual void UnRefProjectable(TEveProjectable* assumed_parent);
diff --git a/graf3d/eve/inc/TEveProjectionManager.h b/graf3d/eve/inc/TEveProjectionManager.h
index 8fb99c6..7bfd15b 100644
--- a/graf3d/eve/inc/TEveProjectionManager.h
+++ b/graf3d/eve/inc/TEveProjectionManager.h
@@ -15,7 +15,6 @@
 #include "TEveElement.h"
 #include "TAttBBox.h"
 #include "TEveProjections.h"
-#include "TEveVSDStructs.h"
 
 
 class TEveProjectionManager : public TEveElementList,
@@ -67,6 +66,8 @@ public:
    virtual TEveElement* ImportElements(TEveElement* el,
                                        TEveElement* ext_list=0);
 
+   virtual TEveElement* SubImportElements(TEveElement* el, TEveElement* proj_parent);
+
    virtual void    ProjectChildren();
    virtual void    ProjectChildrenRecurse(TEveElement* el);
 
diff --git a/graf3d/eve/inc/TEveProjections.h b/graf3d/eve/inc/TEveProjections.h
index c0b17bd..4df31f0 100644
--- a/graf3d/eve/inc/TEveProjections.h
+++ b/graf3d/eve/inc/TEveProjections.h
@@ -12,10 +12,12 @@
 #ifndef ROOT_TEveProjections
 #define ROOT_TEveProjections
 
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
+#include "TString.h"
 
 #include <vector>
 
+class TEveTrans;
 
 //==============================================================================
 // TEveProjection
@@ -82,9 +84,14 @@ public:
    virtual Bool_t      Is3D() const = 0;
 
    virtual void        ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e p = kPP_Full) = 0;
-   virtual void        ProjectPointfv(Float_t* v, Float_t d);
-   virtual void        ProjectPointdv(Double_t* v, Float_t d);
-   virtual void        ProjectVector(TEveVector& v, Float_t d);
+
+   void                ProjectPointfv(Float_t* v, Float_t d);
+   void                ProjectPointdv(Double_t* v, Float_t d);
+   void                ProjectVector(TEveVector& v, Float_t d);
+
+   void                ProjectPointfv(const TEveTrans* t, const Float_t*  p, Float_t* v, Float_t d);
+   void                ProjectPointdv(const TEveTrans* t, const Double_t* p, Double_t* v, Float_t d);
+   void                ProjectVector(const TEveTrans* t, TEveVector& v, Float_t d);
 
    const   Char_t*     GetName() const            { return fName.Data(); }
    void                SetName(const Char_t* txt) { fName = txt; }
@@ -122,7 +129,8 @@ public:
    Float_t  GetMaxTrackStep() const    { return fMaxTrackStep; }
    void     SetMaxTrackStep(Float_t x) { fMaxTrackStep = TMath::Max(x, 1.0f); }
 
-   virtual   Bool_t    AcceptSegment(TEveVector&, TEveVector&, Float_t /*tolerance*/) { return kTRUE; }
+   virtual   Bool_t    AcceptSegment(TEveVector&, TEveVector&, Float_t /*tolerance*/) const { return kTRUE; }
+   virtual   Int_t     SubSpaceId(const TEveVector&) const { return 0; }
    virtual   void      SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
 
    // utils to draw axis
@@ -130,7 +138,8 @@ public:
    virtual Float_t     GetScreenVal(Int_t ax, Float_t value);
    Float_t             GetLimit(Int_t i, Bool_t pos) { return pos ? fUpLimit[i] : fLowLimit[i]; }
 
-   static   Float_t    fgEps;  // resolution of projected points
+   static   Float_t    fgEps;    // resolution of projected points
+   static   Float_t    fgEpsSqr; // square of resolution of projected points
 
    ClassDef(TEveProjection, 0); // Base for specific classes that implement non-linear projections.
 };
@@ -152,14 +161,15 @@ public:
    virtual Bool_t      Is2D() const { return kTRUE;  }
    virtual Bool_t      Is3D() const { return kFALSE; }
 
-   virtual   void      ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
+   virtual void        ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, EPProc_e proc = kPP_Full);
 
-   virtual   void      SetCenter(TEveVector& center);
-   virtual   Float_t*  GetProjectedCenter() { return fProjectedCenter.Arr(); }
+   virtual void        SetCenter(TEveVector& center);
+   virtual Float_t*    GetProjectedCenter() { return fProjectedCenter.Arr(); }
 
    virtual   void      UpdateLimit();
 
-   virtual   Bool_t    AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance);
+   virtual   Bool_t    AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance) const;
+   virtual   Int_t     SubSpaceId(const TEveVector& v) const;
    virtual   void      SetDirectionalVector(Int_t screenAxis, TEveVector& vec);
 
    ClassDef(TEveRhoZProjection, 0); // Rho/Z non-linear projection.
diff --git a/graf3d/eve/inc/TEveSelection.h b/graf3d/eve/inc/TEveSelection.h
index f330063..080f4b4 100644
--- a/graf3d/eve/inc/TEveSelection.h
+++ b/graf3d/eve/inc/TEveSelection.h
@@ -53,6 +53,8 @@ protected:
    void DoElementSelect  (SelMap_i entry);
    void DoElementUnselect(SelMap_i entry);
 
+   void RecheckImpliedSet(SelMap_i smi);
+
 public:
    TEveSelection(const char* n="TEveSelection", const char* t="");
    virtual ~TEveSelection() {}
@@ -75,6 +77,8 @@ public:
 
    virtual void RemoveImpliedSelected(TEveElement* el);
 
+   void RecheckImpliedSetForElement(TEveElement* el);
+
    void SelectionAdded(TEveElement* el);    // *SIGNAL*
    void SelectionRemoved(TEveElement* el);  // *SIGNAL*
    void SelectionCleared();                 // *SIGNAL*
@@ -82,7 +86,6 @@ public:
 
    // ----------------------------------------------------------------
    // Interface to make selection active/non-active.
-   // Not used yet, assumed to be active all the time.
 
    virtual void ActivateSelection();
    virtual void DeactivateSelection();
diff --git a/graf3d/eve/inc/TEveShape.h b/graf3d/eve/inc/TEveShape.h
new file mode 100644
index 0000000..0258459
--- /dev/null
+++ b/graf3d/eve/inc/TEveShape.h
@@ -0,0 +1,89 @@
+// @(#)root/eve:$Id: TEveShape.h 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveShape
+#define ROOT_TEveShape
+
+#include "TEveElement.h"
+#include "TEveVector.h"
+
+#include "TAtt3D.h"
+#include "TAttBBox.h"
+#include "TColor.h"
+
+class TEveShape : public TEveElementList,
+                  public TAtt3D,
+                  public TAttBBox
+{
+   friend class TEveShapeEditor;
+
+private:
+   TEveShape(const TEveShape&);            // Not implemented
+   TEveShape& operator=(const TEveShape&); // Not implemented
+
+public:
+   typedef std::vector<TEvePoint>           vPoint_t;
+   typedef std::vector<TEvePoint>::iterator vPoint_i;
+
+protected:
+   Color_t      fFillColor; // fill color of polygons
+   Color_t      fLineColor; // outline color of polygons
+   Float_t      fLineWidth; // outline width of polygons
+
+   Bool_t       fDrawFrame;      // draw frame
+   Bool_t       fHighlightFrame; // highlight frame / all shape
+
+public:
+   TEveShape(const char* n="TEveShape", const char* t="");
+   virtual ~TEveShape();
+
+   // Rendering parameters.
+   virtual Bool_t  CanEditMainColor() const { return kTRUE; }
+   virtual void    SetMainColor(Color_t color);
+
+   virtual Bool_t  CanEditMainTransparency() const { return kTRUE; }
+
+   virtual Color_t GetFillColor() const { return fFillColor; }
+   virtual Color_t GetLineColor() const { return fLineColor; }
+   virtual Float_t GetLineWidth() const { return fLineWidth;}
+   virtual Bool_t  GetDrawFrame()      const { return fDrawFrame; }
+   virtual Bool_t  GetHighlightFrame() const { return fHighlightFrame; }
+
+   virtual void    SetFillColor(Color_t c)  { fFillColor = c; }
+   virtual void    SetLineColor(Color_t c)  { fLineColor = c; }
+   virtual void    SetLineWidth(Float_t lw) { fLineWidth = lw;}
+   virtual void    SetDrawFrame(Bool_t f)      { fDrawFrame = f; }
+   virtual void    SetHighlightFrame(Bool_t f) { fHighlightFrame = f; }
+
+   // ----------------------------------------------------------------
+
+   virtual void CopyVizParams(const TEveElement* el);
+   virtual void WriteVizParams(ostream& out, const TString& var);
+
+   // ----------------------------------------------------------------
+
+   // Virtual from TObject
+   virtual void Paint(Option_t* option="");
+
+   // Abstract function from TAttBBox:
+   // virtual void ComputeBBox();
+
+   // Abstract from TEveProjectable, overriden in TEveElementList:
+   // virtual TClass* ProjectedClass(const TEveProjection* p) const;
+
+   // ----------------------------------------------------------------
+
+   static Int_t FindConvexHull(const vPoint_t& pin, vPoint_t& pout, TEveElement* caller=0);
+
+   ClassDef(TEveShape, 0); // Abstract base-class for 2D/3D shapes.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveShapeEditor.h b/graf3d/eve/inc/TEveShapeEditor.h
new file mode 100644
index 0000000..cbcfb11
--- /dev/null
+++ b/graf3d/eve/inc/TEveShapeEditor.h
@@ -0,0 +1,53 @@
+// @(#)root/eve:$Id: TEveShapeEditor.h 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveShapeEditor
+#define ROOT_TEveShapeEditor
+
+#include "TGedFrame.h"
+
+class TGButton;
+class TGCheckButton;
+class TGNumberEntry;
+class TGColorSelect;
+
+class TEveShape;
+
+class TEveShapeEditor : public TGedFrame
+{
+private:
+   TEveShapeEditor(const TEveShapeEditor&);            // Not implemented
+   TEveShapeEditor& operator=(const TEveShapeEditor&); // Not implemented
+
+protected:
+   TEveShape        *fM; // Model object.
+
+   TGNumberEntry    *fLineWidth;  // Line width widget.
+   TGColorSelect    *fLineColor;  // Line color widget.
+   TGCheckButton    *fDrawFrame;       // Checkbox for frame rendering.
+   TGCheckButton    *fHighlightFrame;  // Checkbox for frame rendering.
+
+public:
+   TEveShapeEditor(const TGWindow* p=0, Int_t width=170, Int_t height=30,
+         UInt_t options=kChildFrame, Pixel_t back=GetDefaultFrameBackground());
+   virtual ~TEveShapeEditor() {}
+
+   virtual void SetModel(TObject* obj);
+
+   void DoLineWidth();
+   void DoLineColor(Pixel_t color);
+   void DoDrawFrame();
+   void DoHighlightFrame();
+
+   ClassDef(TEveShapeEditor, 0); // GUI editor for TEveShape.
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveTrack.h b/graf3d/eve/inc/TEveTrack.h
index c79517c..00a68fd 100644
--- a/graf3d/eve/inc/TEveTrack.h
+++ b/graf3d/eve/inc/TEveTrack.h
@@ -14,7 +14,7 @@
 
 #include <vector>
 
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
 #include "TEveElement.h"
 #include "TEveLine.h"
 
@@ -24,6 +24,10 @@
 class TEveTrackPropagator;
 class TEveTrackList;
 
+class TEveRecTrack;
+class TEveMCTrack;
+class TParticle;
+
 class TEveTrack : public TEveLine
 {
    friend class TEveTrackPropagator;
@@ -52,6 +56,7 @@ protected:
    Int_t              fStatus;     // Status-word, user-defined.
    Bool_t             fLockPoints; // Lock points that are currently in - do nothing in MakeTrack().
    vPathMark_t        fPathMarks;  // TEveVector of known points along the track
+   Int_t              fLastPMIdx;  //!Last path-mark index tried in track-propagation.
 
    TEveTrackPropagator *fPropagator;   // Pointer to shared render-style
 
@@ -75,8 +80,9 @@ public:
    virtual void MakeTrack(Bool_t recurse=kTRUE);
 
    TEveTrackPropagator* GetPropagator() const  { return fPropagator; }
-   void SetPropagator(TEveTrackPropagator* prop);
-   void SetAttLineAttMarker(TEveTrackList* tl);
+   Int_t GetLastPMIdx() const { return fLastPMIdx; }
+   void  SetPropagator(TEveTrackPropagator* prop);
+   void  SetAttLineAttMarker(TEveTrackList* tl);
 
    const TEveVector& GetVertex()      const { return fV;    }
    const TEveVector& GetMomentum()    const { return fP;    }
@@ -106,7 +112,6 @@ public:
    //-------------------------------------------------------------------
 
    virtual void SecSelected(TEveTrack*); // *SIGNAL*
-   virtual void SetLineStyle(Style_t lstyle);
 
    virtual const TGPicture* GetListTreeIcon(Bool_t open=kFALSE);
 
@@ -120,8 +125,8 @@ public:
    UChar_t GetBreakProjectedTracks() const     { return fBreakProjectedTracks; }
    void    SetBreakProjectedTracks(UChar_t bt) { fBreakProjectedTracks = bt;   }
 
-   static Bool_t GetDefaultBreakProjectedTracks()          { return fgDefaultBreakProjectedTracks; }
-   static void   SetDefaultBreakProjectedTracks(Bool_t bt) { fgDefaultBreakProjectedTracks = bt;   }
+   static Bool_t GetDefaultBreakProjectedTracks();
+   static void   SetDefaultBreakProjectedTracks(Bool_t bt);
 
    ClassDef(TEveTrack, 1); // Track with given vertex, momentum and optional referece-points (path-marks) along its path.
 };
diff --git a/graf3d/eve/inc/TEveTrackGL.h b/graf3d/eve/inc/TEveTrackGL.h
index 6563e2e..139e6fd 100644
--- a/graf3d/eve/inc/TEveTrackGL.h
+++ b/graf3d/eve/inc/TEveTrackGL.h
@@ -28,6 +28,8 @@ private:
 protected:
    TEveTrack* fTrack; // Model object.
 
+   void RenderPathMarksAndFirstVertex(TGLRnrCtx& rnrCtx) const;
+
 public:
    TEveTrackGL();
    virtual ~TEveTrackGL() {}
@@ -36,7 +38,7 @@ public:
    virtual void   DirectDraw(TGLRnrCtx & rnrCtx) const;
 
    virtual Bool_t SupportsSecondarySelect() const { return kTRUE; }
-   virtual void   ProcessSelection(TGLRnrCtx & rnrCtx, TGLSelectRecord & rec);
+   virtual void   ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec);
 
    ClassDef(TEveTrackGL, 0); // GL-renderer for TEveTrack class.
 };
diff --git a/graf3d/eve/inc/TEveTrackProjected.h b/graf3d/eve/inc/TEveTrackProjected.h
index dbfeb04..869e3d6 100644
--- a/graf3d/eve/inc/TEveTrackProjected.h
+++ b/graf3d/eve/inc/TEveTrackProjected.h
@@ -15,7 +15,6 @@
 #include "TEveTrack.h"
 #include "TEveProjectionBases.h"
 
-class TEveProjection;
 
 class TEveTrackProjected : public TEveTrack,
                            public TEveProjected
@@ -33,7 +32,6 @@ private:
 
 protected:
    std::vector<Int_t>   fBreakPoints; // indices of track break-points
-   TEveProjection      *fProjection;  // projection
 
    virtual void SetDepthLocal(Float_t d);
 
diff --git a/graf3d/eve/inc/TEveTrackPropagator.h b/graf3d/eve/inc/TEveTrackPropagator.h
index 2886cb0..8b2c7b9 100644
--- a/graf3d/eve/inc/TEveTrackPropagator.h
+++ b/graf3d/eve/inc/TEveTrackPropagator.h
@@ -12,7 +12,7 @@
 #ifndef ROOT_TEveTrackPropagator
 #define ROOT_TEveTrackPropagator
 
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
 #include "TEveUtil.h"
 #include "TEveElement.h"
 #include "TMarker.h"
@@ -45,6 +45,7 @@ public:
 
    virtual TEveVector GetField(const TEveVector &v) const { return GetField(v.fX, v.fY, v.fZ);}
    virtual TEveVector GetField(Float_t x, Float_t y, Float_t z) const = 0;
+   virtual Float_t GetMaxFieldMag() const { return 4; } // not abstract because of backward compatibility
 
    ClassDef(TEveMagField, 0); // Abstract interface to magnetic field
 };
@@ -66,6 +67,7 @@ public:
 
    using   TEveMagField::GetField;
    virtual TEveVector GetField(Float_t /*x*/, Float_t /*y*/, Float_t /*z*/) const { return fB; }
+   virtual Float_t GetMaxFieldMag() const { return fB.Mag(); };
 
    ClassDef(TEveMagFieldConst, 0); // Interface to constant magnetic field.
 };
@@ -93,6 +95,8 @@ public:
    using   TEveMagField::GetField;
    virtual TEveVector GetField(Float_t x, Float_t y, Float_t /*z*/) const
    { return  ((x*x+y*y)<fR2) ? fBIn : fBOut; }
+   virtual Float_t GetMaxFieldMag() const
+   { Float_t b1 = fBIn.Mag(), b2 = fBOut.Mag(); return b1 > b2 ? b1 : b2; }
 
    ClassDef(TEveMagFieldDuo, 0); // Interface to magnetic field with two different values depending of radius.
 };
@@ -111,10 +115,9 @@ public:
    struct Helix_t
    {
       Int_t   fCharge;   // Charge of tracked particle.
-      Float_t fMinAng;   // Minimal angular step between two helix points.
-      Float_t fDelta;    // Maximal error at the mid-point of the line connecting two helix points.
+      Float_t fMaxAng;   // Maximum step angle.
       Float_t fMaxStep;  // Maximum allowed step size.
-      Float_t fCurrentStep;
+      Float_t fDelta;    // Maximum error in the middle of the step.
 
       Float_t fPhi;      // Accumulated angle to check fMaxOrbs by propagator.
       Bool_t  fValid;    // Corner case pT~0 or B~0, possible in variable mag field.
@@ -127,6 +130,9 @@ public:
       Float_t fPhiStep;     // Caluclated from fMinAng and fDelta.
       Float_t fSin, fCos;   // Current sin/cos(phistep).
 
+      // Runge-Kutta parameters
+      Float_t fRKStep;      // Step for Runge-Kutta.
+
       // cached
       TEveVector fB;        // Current magnetic field, cached.
       TEveVector fE1, fE2, fE3; // Base vectors: E1 -> B dir, E2->pT dir, E3 = E1xE2.
@@ -140,7 +146,7 @@ public:
       Helix_t();
 
       void UpdateCommon(const TEveVector & p, const TEveVector& b);
-      void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t fullUpdate);
+      void UpdateHelix(const TEveVector & p, const TEveVector& b, Bool_t full_update, Bool_t enforce_max_step);
       void UpdateRK   (const TEveVector & p, const TEveVector& b);
 
       void Step(const TEveVector4& v, const TEveVector& p, TEveVector4& vOut, TEveVector& pOut);
@@ -162,7 +168,7 @@ protected:
    // Track extrapolation limits
    Float_t                  fMaxR;          // Max radius for track extrapolation
    Float_t                  fMaxZ;          // Max z-coordinate for track extrapolation.
-   Int_t                    fNMax;          // max steps
+   Int_t                    fNMax;          // Max steps
    // Helix limits
    Float_t                  fMaxOrbs;       // Maximal angular path of tracks' orbits (1 ~ 2Pi).
 
@@ -188,7 +194,7 @@ protected:
    Helix_t                  fH;             // Helix.
 
    void    RebuildTracks();
-   void    Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update=kFALSE);
+   void    Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update=kFALSE, Bool_t enforce_max_step=kFALSE);
    void    Step(const TEveVector4 &v, const TEveVector &p, TEveVector4 &vOut, TEveVector &pOut);
 
    Bool_t  LoopToVertex(TEveVector& v, TEveVector& p);
@@ -197,7 +203,7 @@ protected:
    Bool_t  LineToVertex (TEveVector& v);
    void    LineToBounds (TEveVector& p);
 
-   void    OneStepRungeKutta(Double_t charge, Double_t step, Double_t* vect, Double_t* vout);
+   void    StepRungeKutta(Double_t step, Double_t* vect, Double_t* vout);
 
    Bool_t  HelixIntersectPlane(const TEveVector& p, const TEveVector& point, const TEveVector& normal,
                                TEveVector& itsect);
@@ -238,8 +244,9 @@ public:
    void   SetMaxZ(Float_t x);
    void   SetMaxOrbs(Float_t x);
    void   SetMinAng(Float_t x);
-   void   SetDelta(Float_t x);
+   void   SetMaxAng(Float_t x);
    void   SetMaxStep(Float_t x);
+   void   SetDelta(Float_t x);
 
    void   SetEditPathMarks(Bool_t x) { fEditPathMarks = x; }
    void   SetRnrDaughters(Bool_t x);
@@ -260,9 +267,10 @@ public:
    Float_t GetMaxR()     const { return fMaxR;     }
    Float_t GetMaxZ()     const { return fMaxZ;     }
    Float_t GetMaxOrbs()  const { return fMaxOrbs;  }
-   Float_t GetMinAng()   const { return fH.fMinAng;   }
-   Float_t GetDelta()    const { return fH.fDelta;    }
+   Float_t GetMinAng()   const;
+   Float_t GetMaxAng()   const { return fH.fMaxAng;   }
    Float_t GetMaxStep()  const { return fH.fMaxStep;  }
+   Float_t GetDelta()    const { return fH.fDelta;    }
 
    Bool_t  GetEditPathMarks() const { return fEditPathMarks; }
    Bool_t  GetRnrDaughters()  const { return fRnrDaughters;  }
@@ -284,6 +292,9 @@ public:
    static const Float_t       fgkB2C;        // Constant for conversion of momentum to curvature.
    static TEveTrackPropagator fgDefault;     // Default track propagator.
 
+   static Float_t             fgEditorMaxR;  // Max R that can be set in GUI editor.
+   static Float_t             fgEditorMaxZ;  // Max Z that can be set in GUI editor.
+
    ClassDef(TEveTrackPropagator, 0); // Calculates path of a particle taking into account special path-marks and imposed boundaries.
 };
 
diff --git a/graf3d/eve/inc/TEveTrackPropagatorEditor.h b/graf3d/eve/inc/TEveTrackPropagatorEditor.h
index d7e389d..582c6fa 100644
--- a/graf3d/eve/inc/TEveTrackPropagatorEditor.h
+++ b/graf3d/eve/inc/TEveTrackPropagatorEditor.h
@@ -45,7 +45,7 @@ protected:
    TEveGValuator      *fMaxR;
    TEveGValuator      *fMaxZ;
    TEveGValuator      *fMaxOrbits;
-   TEveGValuator      *fMinAng;
+   TEveGValuator      *fMaxAng;
    TEveGValuator      *fDelta;
 
    TGCheckButton      *fRnrFV;
@@ -76,7 +76,7 @@ public:
    void DoMaxR();
    void DoMaxZ();
    void DoMaxOrbits();
-   void DoMinAng();
+   void DoMaxAng();
    void DoDelta();
 
    void DoFitPM();
diff --git a/graf3d/eve/inc/TEveTrans.h b/graf3d/eve/inc/TEveTrans.h
index a089957..686d009 100644
--- a/graf3d/eve/inc/TEveTrans.h
+++ b/graf3d/eve/inc/TEveTrans.h
@@ -154,7 +154,7 @@ public:
    void     Multiply(const Double_t *vin, Double_t* vout, Double_t w=1) const;
    void     RotateIP(TVector3& v) const;
    void     RotateIP(Double_t* v) const;
-   void     RotateIP(TEveVector& v) const;
+   void     RotateIP(Float_t*  v) const;
    TVector3 Rotate(const TVector3& v) const;
 
    virtual void Print(Option_t* option = "") const;
diff --git a/graf3d/eve/inc/TEveTriangleSet.h b/graf3d/eve/inc/TEveTriangleSet.h
index 4a4ef00..5d05980 100644
--- a/graf3d/eve/inc/TEveTriangleSet.h
+++ b/graf3d/eve/inc/TEveTriangleSet.h
@@ -21,10 +21,9 @@
 
 class TGeoMatrix;
 
-class TEveTriangleSet : public TEveElement,
-                        public TNamed,
-                        public TAttBBox,
-                        public TAtt3D
+class TEveTriangleSet : public TEveElementList,
+                        public TAtt3D,
+                        public TAttBBox
 {
    friend class TEveTriangleSetEditor;
    friend class TEveTriangleSetGL;
@@ -43,16 +42,10 @@ protected:
    Float_t* fTringNorms;   //[3*fNTrings]
    UChar_t* fTringCols;    //[3*fNTrings]
 
-   // --------------------------------------------------------------
-
-   Color_t  fColor;
-   UShort_t fTransp;
-
 public:
    TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms=kFALSE, Bool_t cols=kFALSE);
    ~TEveTriangleSet();
 
-   virtual Bool_t CanEditMainColor()        const { return kTRUE; }
    virtual Bool_t CanEditMainTransparency() const { return kTRUE; }
 
    Int_t GetNVerts()  const { return fNVerts;  }
@@ -76,7 +69,7 @@ public:
                               Bool_t interp=kFALSE, Bool_t wrap=kFALSE);
 
    virtual void ComputeBBox();
-   virtual void Paint(Option_t* = "");
+   virtual void Paint(Option_t* option="");
 
    void SetTransparency(UChar_t tr) { SetMainTransparency(tr); } // *MENU*
 
diff --git a/graf3d/eve/inc/TEveVSD.h b/graf3d/eve/inc/TEveVSD.h
index 482d1fc..6b1d271 100644
--- a/graf3d/eve/inc/TEveVSD.h
+++ b/graf3d/eve/inc/TEveVSD.h
@@ -22,10 +22,11 @@ class TEveVSD : public TObject
    TEveVSD& operator=(const TEveVSD&); // Not implemented
 
 protected:
-   Int_t        fBuffSize;
+   TFile             *fFile;        //!
+   TDirectory        *fDirectory;   //!
 
-   TFile*       fFile;        //!
-   TDirectory*  fDirectory;   //!
+   Int_t              fBuffSize;    //!
+   Int_t              fVerbose;     //!
 
 public:
    TTree*             fTreeK;       //! Kinematics.
@@ -48,6 +49,7 @@ public:
 
 public:
    TEveVSD(const char* name="TEveVSD", const char* title="");
+   virtual ~TEveVSD();
 
    virtual void SetDirectory(TDirectory* dir);
 
@@ -55,13 +57,10 @@ public:
    virtual void DeleteTrees();
 
    virtual void CreateBranches();
-   virtual void SetBranchAddresses();
-
    virtual void WriteTrees();
-   virtual void LoadTrees();
 
-   virtual void LoadVSD(const char* vsd_file_name,
-                        const char* dir_name="Event0");
+   virtual void LoadTrees();
+   virtual void SetBranchAddresses();
 
    static void DisableTObjectStreamersForVSDStruct();
 
diff --git a/graf3d/eve/inc/TEveVSDStructs.h b/graf3d/eve/inc/TEveVSDStructs.h
index 3816995..a061f9b 100644
--- a/graf3d/eve/inc/TEveVSDStructs.h
+++ b/graf3d/eve/inc/TEveVSDStructs.h
@@ -13,9 +13,8 @@
 #define ROOT_TEveVSDStructs
 
 #include "TObject.h"
-#include "TMath.h"
-
 #include "TParticle.h"
+#include "TEveVector.h"
 
 /******************************************************************************/
 // VSD Structures
@@ -37,227 +36,6 @@
 
 
 /******************************************************************************/
-// TEveVector
-/******************************************************************************/
-
-class TEveVector
-{
-public:
-   Float_t fX, fY, fZ; // Components of the vector.
-
-   TEveVector() : fX(0), fY(0), fZ(0) {}
-   TEveVector(const Float_t* v)  : fX(v[0]), fY(v[1]), fZ(v[2]) {}
-   TEveVector(const Double_t* v) : fX(v[0]), fY(v[1]), fZ(v[2]) {}
-   TEveVector(Float_t x, Float_t y, Float_t z) : fX(x), fY(y), fZ(z) {}
-   virtual ~TEveVector() {}
-
-   void Dump() const;
-
-   operator const Float_t*() const { return &fX; }
-   operator       Float_t*()       { return &fX; }
-
-   TEveVector& operator *=(Float_t s)           { fX *= s;    fY *= s;    fZ *= s;    return *this; }
-   TEveVector& operator +=(const TEveVector& v) { fX += v.fX; fY += v.fY; fZ += v.fZ; return *this; }
-   TEveVector& operator -=(const TEveVector& v) { fX -= v.fX; fY -= v.fY; fZ -= v.fZ; return *this; }
-
-   TEveVector operator + (const TEveVector &) const;
-   TEveVector operator - (const TEveVector &) const;
-   TEveVector operator * (Float_t a) const;
-
-   Float_t& operator [] (Int_t indx);
-   Float_t  operator [] (Int_t indx) const;
-
-   const Float_t* Arr() const { return &fX; }
-   Float_t* Arr()       { return &fX; }
-
-   void Set(const Float_t*  v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
-   void Set(const Double_t* v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
-   void Set(Float_t  x, Float_t  y, Float_t  z) { fX = x; fY = y; fZ = z; }
-   void Set(Double_t x, Double_t y, Double_t z) { fX = x; fY = y; fZ = z; }
-   void Set(const TVector3& v)   { fX = v.x(); fY = v.y(); fZ = v.z(); }
-   void Set(const TEveVector& v) { fX = v.fX;  fY = v.fY;  fZ = v.fZ;  }
-
-   void NegateXYZ() { fX = - fX; fY = -fY; fZ = -fZ; }
-   void Normalize(Float_t length=1);
-
-   Float_t Phi()      const;
-   Float_t Theta()    const;
-   Float_t CosTheta() const;
-   Float_t Eta()      const;
-
-   Float_t Mag()  const { return TMath::Sqrt(fX*fX + fY*fY + fZ*fZ);}
-   Float_t Mag2() const { return fX*fX + fY*fY + fZ*fZ;}
-
-   Float_t Perp()  const { return TMath::Sqrt(fX*fX + fY*fY);}
-   Float_t Perp2() const { return fX*fX + fY*fY;}
-   Float_t R()     const { return Perp(); }
-
-   Float_t Distance(const TEveVector& v) const;
-   Float_t SquareDistance(const TEveVector& v) const;
-
-   Float_t    Dot(const TEveVector& a) const;
-   TEveVector Cross(const TEveVector& a) const;
-
-   TEveVector& Sub(const TEveVector& p, const TEveVector& q);
-
-   TEveVector& Mult(const TEveVector& a, Float_t af);
-
-   TEveVector Orthogonal() const;
-   void       OrthoNormBase(TEveVector& a, TEveVector& b) const;
-
-   ClassDef(TEveVector, 1); // Float three-vector; a minimal Float_t copy of TVector3 used to represent points and momenta (also used in VSD).
-};
-
-//______________________________________________________________________________
-inline Float_t TEveVector::Phi() const
-{
-   return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX);
-}
-
-//______________________________________________________________________________
-inline Float_t TEveVector::Theta() const
-{
-   return fX == 0.0 && fY == 0.0 && fZ == 0.0 ? 0.0 : TMath::ATan2(Perp(), fZ);
-}
-
-//______________________________________________________________________________
-inline Float_t TEveVector::CosTheta() const
-{
-   Float_t ptot = Mag(); return ptot == 0.0 ? 1.0 : fZ/ptot;
-}
-
-//______________________________________________________________________________
-inline Float_t TEveVector::Distance( const TEveVector& b) const
-{
-   return TMath::Sqrt((fX - b.fX)*(fX - b.fX) +
-                      (fY - b.fY)*(fY - b.fY) +
-                      (fZ - b.fZ)*(fZ - b.fZ));
-}
-
-//______________________________________________________________________________
-inline Float_t TEveVector::SquareDistance(const TEveVector& b) const
-{
-   return ((fX - b.fX) * (fX - b.fX) +
-           (fY - b.fY) * (fY - b.fY) +
-           (fZ - b.fZ) * (fZ - b.fZ));
-}
-
-//______________________________________________________________________________
-inline Float_t TEveVector::Dot(const TEveVector& a) const
-{
-   return a.fX*fX + a.fY*fY + a.fZ*fZ;
-}
-
-//______________________________________________________________________________
-inline TEveVector TEveVector::Cross(const TEveVector& a) const
-{
-   TEveVector r;
-   r.fX = fY * a.fZ - fZ * a.fY;
-   r.fY = fZ * a.fX - fX * a.fZ;
-   r.fZ = fX * a.fY - fY * a.fX;
-   return r;
-}
-
-//______________________________________________________________________________
-inline TEveVector& TEveVector::Sub(const TEveVector& p, const TEveVector& q)
-{
-   fX = p.fX - q.fX;
-   fY = p.fY - q.fY;
-   fZ = p.fZ - q.fZ;
-   return *this;
-}
-
-//______________________________________________________________________________
-inline TEveVector& TEveVector::Mult(const TEveVector& a, Float_t af)
-{
-   fX = a.fX * af;
-   fY = a.fY * af;
-   fZ = a.fZ * af;
-   return *this;
-}
-
-//______________________________________________________________________________
-inline Float_t& TEveVector::operator [] (Int_t idx)
-{
-   return (&fX)[idx];
-}
-
-//______________________________________________________________________________
-inline Float_t TEveVector::operator [] (Int_t idx) const
-{
-   return (&fX)[idx];
-}
-
-
-/******************************************************************************/
-// TEveVector4
-/******************************************************************************/
-
-class TEveVector4 : public TEveVector
-{
-public:
-   Float_t fT;
-
-   TEveVector4()                    : TEveVector(),  fT(0) {}
-   TEveVector4(const TEveVector& v) : TEveVector(v), fT(0) {}
-   TEveVector4(Float_t x, Float_t y, Float_t z, Float_t t=0) :
-      TEveVector(x, y, z), fT(t) {}
-   virtual ~TEveVector4() {}
-
-   void Dump() const;
-
-   TEveVector4 operator + (const TEveVector4 & b) const
-   { return TEveVector4(fX + b.fX, fY + b.fY, fZ + b.fZ, fT + b.fT); }
-
-   TEveVector4 operator - (const TEveVector4 & b) const
-   { return TEveVector4(fX - b.fX, fY - b.fY, fZ - b.fZ, fT - b.fT); }
-
-   TEveVector4 operator * (Float_t a) const
-   { return TEveVector4(a*fX, a*fY, a*fZ, a*fT); }
-
-   TEveVector4& operator += (const TEveVector4 & b)
-   { fX += b.fX; fY += b.fY; fZ += b.fZ; fT += b.fT; return *this; }
-
-   ClassDef(TEveVector4, 1); // Float four-vector.
-};
-
-
-
-/******************************************************************************/
-// TEvePathMark
-/******************************************************************************/
-
-class TEvePathMark
-{
-public:
-   enum EType_e   { kReference, kDaughter, kDecay, kCluster2D };
-
-   EType_e     fType; // Mark-type.
-   TEveVector  fV;    // Vertex.
-   TEveVector  fP;    // Momentum.
-   TEveVector  fE;    // Extra, meaning depends on fType.
-   Float_t     fTime; // Time.
-
-   TEvePathMark(EType_e type=kReference) :
-      fType(type), fV(), fP(), fE(), fTime(0) {}
-
-   TEvePathMark(EType_e type, const TEveVector& v, Float_t time=0) :
-      fType(type), fV(v), fP(), fE(), fTime(time) {}
-
-   TEvePathMark(EType_e type, const TEveVector& v, const TEveVector& p, Float_t time=0) :
-      fType(type), fV(v), fP(p), fE(), fTime(time) {}
-
-   TEvePathMark(EType_e type, const TEveVector& v, const TEveVector& p, const TEveVector& e, Float_t time=0) :
-      fType(type), fV(v), fP(p), fE(e), fTime(time) {}
-
-   virtual ~TEvePathMark() {}
-
-   const char* TypeName();
-
-   ClassDef(TEvePathMark, 1); // Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).
-};
-
-/******************************************************************************/
 // TEveMCTrack
 /******************************************************************************/
 
diff --git a/graf3d/eve/inc/TEveVector.h b/graf3d/eve/inc/TEveVector.h
new file mode 100644
index 0000000..a06a73b
--- /dev/null
+++ b/graf3d/eve/inc/TEveVector.h
@@ -0,0 +1,361 @@
+// @(#)root/eve:$Id: TEveVector.h 32598 2010-03-12 18:17:06Z matevz $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#ifndef ROOT_TEveVector
+#define ROOT_TEveVector
+
+#include "TMath.h"
+
+class TVector3;
+
+//==============================================================================
+// TEveVector
+//==============================================================================
+
+class TEveVector
+{
+public:
+   Float_t fX, fY, fZ; // Components of the vector.
+
+   TEveVector() : fX(0), fY(0), fZ(0) {}
+   TEveVector(const Float_t* v)  : fX(v[0]), fY(v[1]), fZ(v[2]) {}
+   TEveVector(const Double_t* v) : fX(v[0]), fY(v[1]), fZ(v[2]) {}
+   TEveVector(Float_t x, Float_t y, Float_t z) : fX(x), fY(y), fZ(z) {}
+   virtual ~TEveVector() {}
+
+   void Dump() const;
+
+   operator const Float_t*() const { return &fX; }
+   operator       Float_t*()       { return &fX; }
+
+   TEveVector& operator *=(Float_t s)           { fX *= s;    fY *= s;    fZ *= s;    return *this; }
+   TEveVector& operator +=(const TEveVector& v) { fX += v.fX; fY += v.fY; fZ += v.fZ; return *this; }
+   TEveVector& operator -=(const TEveVector& v) { fX -= v.fX; fY -= v.fY; fZ -= v.fZ; return *this; }
+
+   TEveVector operator + (const TEveVector &) const;
+   TEveVector operator - (const TEveVector &) const;
+   TEveVector operator * (Float_t a) const;
+
+   Float_t& operator [] (Int_t indx);
+   Float_t  operator [] (Int_t indx) const;
+
+   const Float_t* Arr() const { return &fX; }
+   Float_t* Arr()       { return &fX; }
+
+   void Set(const Float_t*  v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
+   void Set(const Double_t* v) { fX = v[0]; fY = v[1]; fZ = v[2]; }
+   void Set(Float_t  x, Float_t  y, Float_t  z) { fX = x; fY = y; fZ = z; }
+   void Set(Double_t x, Double_t y, Double_t z) { fX = x; fY = y; fZ = z; }
+   void Set(const TEveVector& v) { fX = v.fX;  fY = v.fY;  fZ = v.fZ;  }
+   void Set(const TVector3& v);
+
+   void NegateXYZ() { fX = - fX; fY = -fY; fZ = -fZ; }
+   void Normalize(Float_t length=1);
+
+   Float_t Phi()      const;
+   Float_t Theta()    const;
+   Float_t CosTheta() const;
+   Float_t Eta()      const;
+
+   Float_t Mag()  const { return TMath::Sqrt(fX*fX + fY*fY + fZ*fZ);}
+   Float_t Mag2() const { return fX*fX + fY*fY + fZ*fZ;}
+
+   Float_t Perp()  const { return TMath::Sqrt(fX*fX + fY*fY);}
+   Float_t Perp2() const { return fX*fX + fY*fY;}
+   Float_t R()     const { return Perp(); }
+
+   Float_t Distance(const TEveVector& v) const;
+   Float_t SquareDistance(const TEveVector& v) const;
+
+   Float_t    Dot(const TEveVector& a) const;
+   TEveVector Cross(const TEveVector& a) const;
+
+   TEveVector& Sub(const TEveVector& p, const TEveVector& q);
+
+   TEveVector& Mult(const TEveVector& a, Float_t af);
+
+   TEveVector Orthogonal() const;
+   void       OrthoNormBase(TEveVector& a, TEveVector& b) const;
+
+   ClassDef(TEveVector, 1); // Float three-vector; a minimal Float_t copy of TVector3 used to represent points and momenta (also used in VSD).
+};
+
+//______________________________________________________________________________
+inline Float_t TEveVector::Phi() const
+{
+   return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX);
+}
+
+//______________________________________________________________________________
+inline Float_t TEveVector::Theta() const
+{
+   return fX == 0.0 && fY == 0.0 && fZ == 0.0 ? 0.0 : TMath::ATan2(Perp(), fZ);
+}
+
+//______________________________________________________________________________
+inline Float_t TEveVector::CosTheta() const
+{
+   Float_t ptot = Mag(); return ptot == 0.0 ? 1.0 : fZ/ptot;
+}
+
+//______________________________________________________________________________
+inline Float_t TEveVector::Distance( const TEveVector& b) const
+{
+   return TMath::Sqrt((fX - b.fX)*(fX - b.fX) +
+                      (fY - b.fY)*(fY - b.fY) +
+                      (fZ - b.fZ)*(fZ - b.fZ));
+}
+
+//______________________________________________________________________________
+inline Float_t TEveVector::SquareDistance(const TEveVector& b) const
+{
+   return ((fX - b.fX) * (fX - b.fX) +
+           (fY - b.fY) * (fY - b.fY) +
+           (fZ - b.fZ) * (fZ - b.fZ));
+}
+
+//______________________________________________________________________________
+inline Float_t TEveVector::Dot(const TEveVector& a) const
+{
+   return a.fX*fX + a.fY*fY + a.fZ*fZ;
+}
+
+//______________________________________________________________________________
+inline TEveVector TEveVector::Cross(const TEveVector& a) const
+{
+   TEveVector r;
+   r.fX = fY * a.fZ - fZ * a.fY;
+   r.fY = fZ * a.fX - fX * a.fZ;
+   r.fZ = fX * a.fY - fY * a.fX;
+   return r;
+}
+
+//______________________________________________________________________________
+inline TEveVector& TEveVector::Sub(const TEveVector& p, const TEveVector& q)
+{
+   fX = p.fX - q.fX;
+   fY = p.fY - q.fY;
+   fZ = p.fZ - q.fZ;
+   return *this;
+}
+
+//______________________________________________________________________________
+inline TEveVector& TEveVector::Mult(const TEveVector& a, Float_t af)
+{
+   fX = a.fX * af;
+   fY = a.fY * af;
+   fZ = a.fZ * af;
+   return *this;
+}
+
+//______________________________________________________________________________
+inline Float_t& TEveVector::operator [] (Int_t idx)
+{
+   return (&fX)[idx];
+}
+
+//______________________________________________________________________________
+inline Float_t TEveVector::operator [] (Int_t idx) const
+{
+   return (&fX)[idx];
+}
+
+
+//==============================================================================
+// TEveVector4
+//==============================================================================
+
+class TEveVector4 : public TEveVector
+{
+public:
+   Float_t fT;
+
+   TEveVector4()                    : TEveVector(),  fT(0) {}
+   TEveVector4(const TEveVector& v) : TEveVector(v), fT(0) {}
+   TEveVector4(Float_t x, Float_t y, Float_t z, Float_t t=0) :
+      TEveVector(x, y, z), fT(t) {}
+   virtual ~TEveVector4() {}
+
+   void Dump() const;
+
+   TEveVector4 operator + (const TEveVector4 & b) const
+   { return TEveVector4(fX + b.fX, fY + b.fY, fZ + b.fZ, fT + b.fT); }
+
+   TEveVector4 operator - (const TEveVector4 & b) const
+   { return TEveVector4(fX - b.fX, fY - b.fY, fZ - b.fZ, fT - b.fT); }
+
+   TEveVector4 operator * (Float_t a) const
+   { return TEveVector4(a*fX, a*fY, a*fZ, a*fT); }
+
+   TEveVector4& operator += (const TEveVector4 & b)
+   { fX += b.fX; fY += b.fY; fZ += b.fZ; fT += b.fT; return *this; }
+
+   ClassDef(TEveVector4, 1); // Float four-vector.
+};
+
+
+//==============================================================================
+// TEvePoint
+//==============================================================================
+
+class TEvePoint
+{
+public:
+   Float_t fX, fY; // Components of the point.
+
+   TEvePoint() : fX(0), fY(0) {}
+   TEvePoint(const Float_t* v)  : fX(v[0]), fY(v[1]) {}
+   TEvePoint(const Double_t* v) : fX(v[0]), fY(v[1]) {}
+   TEvePoint(Float_t x, Float_t y) : fX(x), fY(y)    {}
+   virtual ~TEvePoint() {}
+
+   void Dump() const;
+
+   operator const Float_t*() const { return &fX; }
+   operator       Float_t*()       { return &fX; }
+
+   TEvePoint& operator *=(Float_t s)          { fX *= s;    fY *= s;    return *this; }
+   TEvePoint& operator +=(const TEvePoint& v) { fX += v.fX; fY += v.fY; return *this; }
+   TEvePoint& operator -=(const TEvePoint& v) { fX -= v.fX; fY -= v.fY; return *this; }
+
+   TEvePoint operator + (const TEvePoint &) const;
+   TEvePoint operator - (const TEvePoint &) const;
+   TEvePoint operator * (Float_t a) const;
+
+   Float_t& operator [] (Int_t indx);
+   Float_t  operator [] (Int_t indx) const;
+
+   const Float_t* Arr() const { return &fX; }
+   Float_t* Arr()       { return &fX; }
+
+   void Set(const Float_t*  v) { fX = v[0]; fY = v[1]; }
+   void Set(const Double_t* v) { fX = v[0]; fY = v[1]; }
+   void Set(Float_t  x, Float_t  y) { fX = x; fY = y; }
+   void Set(Double_t x, Double_t y) { fX = x; fY = y; }
+   void Set(const TEvePoint& v) { fX = v.fX;  fY = v.fY;  }
+
+   void NegateXY() { fX = - fX; fY = -fY; }
+   void Normalize(Float_t length=1);
+
+   Float_t Phi()  const;
+
+   Float_t Mag()  const { return TMath::Sqrt(fX*fX + fY*fY);}
+   Float_t Mag2() const { return fX*fX + fY*fY;}
+
+   Float_t Distance(const TEvePoint& v) const;
+   Float_t SquareDistance(const TEvePoint& v) const;
+
+   Float_t    Dot(const TEvePoint& a) const;
+   Float_t    Cross(const TEvePoint& a) const;
+
+   TEvePoint& Sub(const TEvePoint& p, const TEvePoint& q);
+
+   TEvePoint& Mult(const TEvePoint& a, Float_t af);
+
+   ClassDef(TEvePoint, 1); // Float two-vector.
+};
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Phi() const
+{
+   return fX == 0.0 && fY == 0.0 ? 0.0 : TMath::ATan2(fY, fX);
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Distance( const TEvePoint& b) const
+{
+   return TMath::Sqrt((fX - b.fX)*(fX - b.fX) +
+                      (fY - b.fY)*(fY - b.fY));
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::SquareDistance(const TEvePoint& b) const
+{
+   return ((fX - b.fX) * (fX - b.fX) +
+           (fY - b.fY) * (fY - b.fY));
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Dot(const TEvePoint& a) const
+{
+   return a.fX*fX + a.fY*fY;
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::Cross(const TEvePoint& a) const
+{
+   return fX * a.fY - fY * a.fX;
+}
+
+//______________________________________________________________________________
+inline TEvePoint& TEvePoint::Sub(const TEvePoint& p, const TEvePoint& q)
+{
+   fX = p.fX - q.fX;
+   fY = p.fY - q.fY;
+   return *this;
+}
+
+//______________________________________________________________________________
+inline TEvePoint& TEvePoint::Mult(const TEvePoint& a, Float_t af)
+{
+   fX = a.fX * af;
+   fY = a.fY * af;
+   return *this;
+}
+
+//______________________________________________________________________________
+inline Float_t& TEvePoint::operator [] (Int_t idx)
+{
+   return (&fX)[idx];
+}
+
+//______________________________________________________________________________
+inline Float_t TEvePoint::operator [] (Int_t idx) const
+{
+   return (&fX)[idx];
+}
+
+
+//==============================================================================
+// TEvePathMark
+//==============================================================================
+
+class TEvePathMark
+{
+public:
+   enum EType_e   { kReference, kDaughter, kDecay, kCluster2D };
+
+   EType_e     fType; // Mark-type.
+   TEveVector  fV;    // Vertex.
+   TEveVector  fP;    // Momentum.
+   TEveVector  fE;    // Extra, meaning depends on fType.
+   Float_t     fTime; // Time.
+
+   TEvePathMark(EType_e type=kReference) :
+      fType(type), fV(), fP(), fE(), fTime(0) {}
+
+   TEvePathMark(EType_e type, const TEveVector& v, Float_t time=0) :
+      fType(type), fV(v), fP(), fE(), fTime(time) {}
+
+   TEvePathMark(EType_e type, const TEveVector& v, const TEveVector& p, Float_t time=0) :
+      fType(type), fV(v), fP(p), fE(), fTime(time) {}
+
+   TEvePathMark(EType_e type, const TEveVector& v, const TEveVector& p, const TEveVector& e, Float_t time=0) :
+      fType(type), fV(v), fP(p), fE(e), fTime(time) {}
+
+   virtual ~TEvePathMark() {}
+
+   const char* TypeName();
+
+   ClassDef(TEvePathMark, 1); // Special-point on track: position/momentum reference, daughter creation or decay (also used in VSD).
+};
+
+#endif
diff --git a/graf3d/eve/inc/TEveViewer.h b/graf3d/eve/inc/TEveViewer.h
index 5702261..336bdfa 100644
--- a/graf3d/eve/inc/TEveViewer.h
+++ b/graf3d/eve/inc/TEveViewer.h
@@ -52,10 +52,11 @@ public:
    TGLViewer* GetGLViewer() const { return fGLViewer; }
    void SetGLViewer(TGLViewer* viewer, TGFrame* frame);
 
-   TGLSAViewer*       SpawnGLViewer(TGedEditor* ged);
-   TGLEmbeddedViewer* SpawnGLEmbeddedViewer(Int_t border=0);
+   TGLSAViewer*       SpawnGLViewer(TGedEditor* ged=0, Bool_t stereo=kFALSE);
+   TGLEmbeddedViewer* SpawnGLEmbeddedViewer(TGedEditor* ged=0, Int_t border=0);
 
    void Redraw(Bool_t resetCameras=kFALSE);
+   void SwitchStereo();
 
    virtual void AddScene(TEveScene* scene);
 
diff --git a/graf3d/eve/inc/TEveWindow.h b/graf3d/eve/inc/TEveWindow.h
index 1ea6038..9fb0eec 100644
--- a/graf3d/eve/inc/TEveWindow.h
+++ b/graf3d/eve/inc/TEveWindow.h
@@ -241,7 +241,7 @@ public:
    virtual Bool_t          CanMakeNewSlots() const { return kFALSE; }
    virtual TEveWindowSlot* NewSlot() { return 0; }
 
-   void PopulateEmptyFrame(TEveCompositeFrame* ef); 
+   void PopulateEmptyFrame(TEveCompositeFrame* ef);
 
    void SwapWindow(TEveWindow* w);
    void SwapWindowWithCurrent();        // *MENU*
@@ -280,15 +280,15 @@ public:
 
    // Access to static data-members.
 
-   static UInt_t  GetMainFrameDefWidth()  { return fgMainFrameDefWidth;  }
-   static UInt_t  GetMainFrameDefHeight() { return fgMainFrameDefHeight; }
-   static void SetMainFrameDefWidth (UInt_t x) { fgMainFrameDefWidth  = x; }
-   static void SetMainFrameDefHeight(UInt_t x) { fgMainFrameDefHeight = x; }
+   static UInt_t  GetMainFrameDefWidth();
+   static UInt_t  GetMainFrameDefHeight();
+   static void    SetMainFrameDefWidth (UInt_t x);
+   static void    SetMainFrameDefHeight(UInt_t x);
 
-   static Pixel_t GetCurrentBackgroundColor() { return fgCurrentBackgroundColor; }
-   static Pixel_t GetMiniBarBackgroundColor() { return fgMiniBarBackgroundColor; }
-   static void SetCurrentBackgroundColor(Pixel_t p) { fgCurrentBackgroundColor = p; }
-   static void SetMiniBarBackgroundColor(Pixel_t p) { fgMiniBarBackgroundColor = p; }
+   static Pixel_t GetCurrentBackgroundColor();
+   static Pixel_t GetMiniBarBackgroundColor();
+   static void    SetCurrentBackgroundColor(Pixel_t p);
+   static void    SetMiniBarBackgroundColor(Pixel_t p);
 
    ClassDef(TEveWindow, 0); // Abstract base-class for eve-windows.
 };
diff --git a/graf3d/eve/src/TEveArrow.cxx b/graf3d/eve/src/TEveArrow.cxx
index 31539dc..8a8da9f 100644
--- a/graf3d/eve/src/TEveArrow.cxx
+++ b/graf3d/eve/src/TEveArrow.cxx
@@ -12,10 +12,6 @@
 #include "TEveArrow.h"
 #include "TEveTrans.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 
 //______________________________________________________________________________
 //
@@ -63,26 +59,10 @@ void TEveArrow::ComputeBBox()
 }
 
 //______________________________________________________________________________
-void TEveArrow::Paint(Option_t* /*option*/)
+void TEveArrow::Paint(Option_t*)
 {
    // Paint object.
    // This is for direct rendering (using TEveArrowGL class).
 
-   static const TEveException eh("TEveArrow::Paint ");
-
-   if (fRnrSelf == kFALSE) return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
diff --git a/graf3d/eve/src/TEveBox.cxx b/graf3d/eve/src/TEveBox.cxx
new file mode 100644
index 0000000..d0443a4
--- /dev/null
+++ b/graf3d/eve/src/TEveBox.cxx
@@ -0,0 +1,203 @@
+// @(#)root/eve:$Id: TEveBox.cxx 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveBox.h"
+#include "TEveProjectionManager.h"
+
+//==============================================================================
+// TEveBox
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// 3D box with arbitrary vertices (cuboid).
+// Vertices 0-3 specify the "bottom" rectangle in clockwise direction and
+// vertices 4-7 the "top" rectangle so that 4 is above 0, 5 above 1 and so on.
+//
+// If vertices are provided some local coordinates the transformation matrix
+// of the element should also be set (but then the memory usage is increased
+// by the size of the TEveTrans object).
+//
+// Currently only supports 3D -> 2D projections.
+
+ClassImp(TEveBox);
+
+//______________________________________________________________________________
+TEveBox::TEveBox(const char* n, const char* t) :
+   TEveShape(n, t)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+TEveBox::~TEveBox()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TEveBox::SetVertex(Int_t i, Float_t x, Float_t y, Float_t z)
+{
+   // Set vertex 'i'.
+
+   fVertices[i][0] = x;
+   fVertices[i][1] = y;
+   fVertices[i][2] = z;
+}
+
+//______________________________________________________________________________
+void TEveBox::SetVertex(Int_t i, const Float_t* v)
+{
+   // Set vertex 'i'.
+
+   fVertices[i][0] = v[0];
+   fVertices[i][1] = v[1];
+   fVertices[i][2] = v[2];
+}
+
+//______________________________________________________________________________
+void TEveBox::SetVertices(const Float_t* vs)
+{
+   // Set vertices.
+
+   memcpy(fVertices, vs, sizeof(fVertices));
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveBox::ComputeBBox()
+{
+   // Compute bounding-box of the data.
+
+   BBoxInit();
+   for (Int_t i=0; i<8; ++i)
+   {
+      BBoxCheckPoint(fVertices[i]);
+   }
+}
+
+//______________________________________________________________________________
+TClass* TEveBox::ProjectedClass(const TEveProjection*) const
+{
+   // Virtual from TEveProjectable, return TEveBoxProjected class.
+
+   return TEveBoxProjected::Class();
+}
+
+
+//==============================================================================
+// TEveBoxProjected
+//==============================================================================
+
+ClassImp(TEveBoxProjected);
+
+//______________________________________________________________________________
+TEveBoxProjected::TEveBoxProjected(const char* n, const char* t) :
+   TEveShape(n, t)
+{
+   // Constructor.
+}
+
+//______________________________________________________________________________
+TEveBoxProjected::~TEveBoxProjected()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::ComputeBBox()
+{
+   // Compute bounding-box, virtual from TAttBBox.
+
+   BBoxInit();
+   for (vPoint_i i = fPoints.begin(); i != fPoints.end(); ++i)
+   {
+      BBoxCheckPoint(i->fX, i->fY, fDepth);
+   }
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::SetDepthLocal(Float_t)
+{
+   // This is virtual method from base-class TEveProjected.
+   // Does nothing, must be implemented as it is abstract.
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::SetProjection(TEveProjectionManager* mng, TEveProjectable* model)
+{
+   // This is virtual method from base-class TEveProjected.
+
+   TEveProjected::SetProjection(mng, model);
+   CopyVizParams(dynamic_cast<TEveElement*>(model));
+}
+
+//______________________________________________________________________________
+void TEveBoxProjected::UpdateProjection()
+{
+   // Re-project the box. Projects all points and finds 2D convex-hull.
+   //
+   // The convex-hull calculation code could be extracted and put into
+   // TEveShape or TEveUtil. Maybe projection / hull-search could be put into
+   // two functions.
+   //
+   // The only issue is with making sure that initial conditions for
+   // hull-search are reasonable -- that is, there are no overlaps with the
+   // first point.
+
+   TEveBox *box = dynamic_cast<TEveBox*>(fProjectable);
+
+   fDebugPoints.clear();
+
+   // Project points in global CS, remove overlaps.
+   vPoint_t pp[2];
+   {
+      TEveProjection *projection = fManager->GetProjection();
+      TEveTrans      *trans      = box->PtrMainTrans(kFALSE);
+
+      TEveVector pbuf;
+      for (Int_t i = 0; i < 8; ++i)
+      {
+         projection->ProjectPointfv(trans, box->GetVertex(i), pbuf, fDepth);
+         vPoint_t& ppv = pp[projection->SubSpaceId(pbuf)];
+
+         TEvePoint p(pbuf);
+         Bool_t    overlap = kFALSE;
+         for (vPoint_i j = ppv.begin(); j != ppv.end(); ++j)
+         {
+            if (p.SquareDistance(*j) < TEveProjection::fgEpsSqr)
+            {
+               overlap = kTRUE;
+               break;
+            }
+         }
+         if (! overlap)
+         {
+            ppv.push_back(p);
+            fDebugPoints.push_back(p);
+         }
+      }
+   }
+
+   fPoints.clear();
+   fBreakIdx = 0;
+
+   if ( ! pp[0].empty())
+   {
+      FindConvexHull(pp[0], fPoints, this);
+   }
+   if ( ! pp[1].empty())
+   {
+      fBreakIdx = fPoints.size();
+      FindConvexHull(pp[1], fPoints, this);
+   }
+}
diff --git a/graf3d/eve/src/TEveBoxGL.cxx b/graf3d/eve/src/TEveBoxGL.cxx
new file mode 100644
index 0000000..678275a
--- /dev/null
+++ b/graf3d/eve/src/TEveBoxGL.cxx
@@ -0,0 +1,364 @@
+// @(#)root/eve:$Id: TEveBoxGL.cxx 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveBoxGL.h"
+#include "TEveBox.h"
+
+#include "TGLRnrCtx.h"
+#include "TGLIncludes.h"
+
+#include "TMath.h"
+
+//==============================================================================
+// TEveBoxGL
+//==============================================================================
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEveBox.
+//
+
+ClassImp(TEveBoxGL);
+
+//______________________________________________________________________________
+TEveBoxGL::TEveBoxGL() :
+   TGLObject(), fM(0)
+{
+   // Constructor.
+
+   // fDLCache = kFALSE; // Disable display list.
+}
+
+//______________________________________________________________________________
+Bool_t TEveBoxGL::SetModel(TObject* obj, const Option_t* /*opt*/)
+{
+   // Set model object.
+
+   if (SetModelCheckClass(obj, TEveBox::Class())) {
+      fM = dynamic_cast<TEveBox*>(obj);
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::SetBBox()
+{
+   // Set bounding box.
+
+   // !! This ok if master sub-classed from TAttBBox
+   SetAxisAlignedBBox(((TEveBox*)fExternalObj)->AssertBBox());
+}
+
+//==============================================================================
+
+namespace
+{
+   void subtract_and_normalize(const Float_t a[3], const Float_t b[3],
+                               Float_t o[3])
+   {
+      // Calculate a - b and normalize the result.
+      o[0] = a[0] - b[0];
+      o[1] = a[1] - b[1];
+      o[2] = a[2] - b[2];
+      Float_t d = sqrtf(o[0]*o[0] + o[1]*o[1] + o[2]*o[2]);
+      if (d != 0)
+      {
+         d = 1.0f / d;
+         o[0] *= d;
+         o[1] *= d;
+         o[2] *= d;
+      }
+   }
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::RenderOutline(const Float_t p[8][3]) const
+{
+   // Render box with without normals.
+   // To be used with lightning off, for outline.
+
+   glBegin(GL_LINE_STRIP);
+   glVertex3fv(p[0]); glVertex3fv(p[1]);
+   glVertex3fv(p[5]); glVertex3fv(p[6]);
+   glVertex3fv(p[2]); glVertex3fv(p[3]);
+   glVertex3fv(p[7]); glVertex3fv(p[4]);
+   glVertex3fv(p[0]); glVertex3fv(p[3]);
+   glEnd();
+
+   glBegin(GL_LINES);
+   glVertex3fv(p[1]); glVertex3fv(p[2]);
+   glVertex3fv(p[4]); glVertex3fv(p[5]);
+   glVertex3fv(p[6]); glVertex3fv(p[7]);
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::RenderBoxStdNorm(const Float_t p[8][3]) const
+{
+   // Render box with "standard" normals.
+
+   glBegin(GL_QUADS);
+
+   // bottom: 0123
+   glNormal3f(0, 0, -1);
+   glVertex3fv(p[0]);  glVertex3fv(p[1]);
+   glVertex3fv(p[2]);  glVertex3fv(p[3]);
+   // top:    7654
+   glNormal3f(0, 0, 1);
+   glVertex3fv(p[7]); glVertex3fv(p[6]);
+   glVertex3fv(p[5]); glVertex3fv(p[4]);
+   // back:  0451
+   glNormal3f(0, 1, 0);
+   glVertex3fv(p[0]); glVertex3fv(p[4]);
+   glVertex3fv(p[5]); glVertex3fv(p[1]);
+   // front:   3267
+   glNormal3f(0, -1, 0);
+   glVertex3fv(p[3]); glVertex3fv(p[2]);
+   glVertex3fv(p[6]); glVertex3fv(p[7]);
+   // left:    0374
+   glNormal3f(-1, 0, 0);
+   glVertex3fv(p[0]); glVertex3fv(p[3]);
+   glVertex3fv(p[7]); glVertex3fv(p[4]);
+   // right:   1562
+   glNormal3f(1, 0, 0);
+   glVertex3fv(p[1]); glVertex3fv(p[5]);
+   glVertex3fv(p[6]); glVertex3fv(p[2]);
+
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::RenderBoxAutoNorm(const Float_t p[8][3]) const
+{
+   // Render box, calculate normals on the fly from first three points.
+
+   Float_t e[6][3], n[3];
+   subtract_and_normalize(p[1], p[0], e[0]);
+   subtract_and_normalize(p[3], p[0], e[1]);
+   subtract_and_normalize(p[4], p[0], e[2]);
+   subtract_and_normalize(p[5], p[6], e[3]);
+   subtract_and_normalize(p[4], p[6], e[4]);
+   subtract_and_normalize(p[2], p[6], e[5]);
+
+   glBegin(GL_QUADS);
+
+   // bottom: 0123
+   glNormal3fv(TMath::Cross(e[0], e[1], n));
+   glVertex3fv(p[0]); glVertex3fv(p[1]);
+   glVertex3fv(p[2]); glVertex3fv(p[3]);
+   // top:    7654
+   glNormal3fv(TMath::Cross(e[3], e[4], n));
+   glVertex3fv(p[7]); glVertex3fv(p[6]);
+   glVertex3fv(p[5]); glVertex3fv(p[4]);
+   // back:  0451
+   glNormal3fv(TMath::Cross(e[2], e[1], n));
+   glVertex3fv(p[0]); glVertex3fv(p[4]);
+   glVertex3fv(p[5]); glVertex3fv(p[1]);
+   // front:   3267
+   glNormal3fv(TMath::Cross(e[4], e[5], n));
+   glVertex3fv(p[3]); glVertex3fv(p[2]);
+   glVertex3fv(p[6]); glVertex3fv(p[7]);
+   // left:    0374
+   glNormal3fv(TMath::Cross(e[1], e[2], n));
+   glVertex3fv(p[0]); glVertex3fv(p[3]);
+   glVertex3fv(p[7]); glVertex3fv(p[4]);
+   // right:   1562
+   glNormal3fv(TMath::Cross(e[5], e[3], n));
+   glVertex3fv(p[1]); glVertex3fv(p[5]);
+   glVertex3fv(p[6]); glVertex3fv(p[2]);
+
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::Draw(TGLRnrCtx& rnrCtx) const
+{
+   // Render with OpenGL.
+
+   if (rnrCtx.IsDrawPassOutlineLine())
+      return;
+
+   if (fM->fHighlightFrame && rnrCtx.Highlight())
+   {
+      if (fM->fDrawFrame)
+      {
+         TGLUtil::LineWidth(fM->fLineWidth);
+         TGLUtil::Color(fM->fLineColor);
+      }
+      RenderOutline(fM->fVertices);
+   }
+   else
+   {
+      TGLObject::Draw(rnrCtx);
+   }
+}
+
+//______________________________________________________________________________
+void TEveBoxGL::DirectDraw(TGLRnrCtx&) const
+{
+   // Render with OpenGL, create display-list.
+
+   fMultiColor = (fM->fDrawFrame && fM->fFillColor != fM->fLineColor);
+
+   glPushAttrib(GL_ENABLE_BIT);
+
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(1.0f, 1.0f);
+   RenderBoxAutoNorm(fM->fVertices);
+   glDisable(GL_POLYGON_OFFSET_FILL);
+
+   // Frame
+   if (fM->fDrawFrame)
+   {
+      TGLUtil::Color(fM->fLineColor);
+      TGLUtil::LineWidth(fM->fLineWidth);
+      glEnable(GL_LINE_SMOOTH);
+      RenderOutline(fM->fVertices);
+   }
+
+   glPopAttrib();
+}
+
+
+//==============================================================================
+// TEveBoxProjectedGL
+//==============================================================================
+
+//______________________________________________________________________________
+// OpenGL renderer class for TEveBoxProjected.
+//
+
+ClassImp(TEveBoxProjectedGL);
+
+//______________________________________________________________________________
+TEveBoxProjectedGL::TEveBoxProjectedGL() :
+   TGLObject(), fM(0)
+{
+   // Constructor.
+
+   // fDLCache = kFALSE; // Disable display list.
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+Bool_t TEveBoxProjectedGL::SetModel(TObject* obj, const Option_t* /*opt*/)
+{
+   // Set model object.
+
+   if (SetModelCheckClass(obj, TEveBoxProjected::Class())) {
+      fM = dynamic_cast<TEveBoxProjected*>(obj);
+      return kTRUE;
+   }
+   return kFALSE;
+}
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::SetBBox()
+{
+   // Set bounding box.
+
+   SetAxisAlignedBBox(((TEveBoxProjected*)fExternalObj)->AssertBBox());
+}
+
+//------------------------------------------------------------------------------
+
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::RenderPoints(Int_t mode) const
+{
+   // Render points with given GL mode.
+   // This is used for polygon and outline drawing.
+
+   Int_t B = fM->fBreakIdx;
+   Int_t N = fM->fPoints.size();
+   if (B != 0)
+   {
+      glBegin(mode);
+      for (Int_t i = 0; i < B; ++i)
+      {
+         glVertex2fv(fM->fPoints[i]);
+      }
+      glEnd();
+   }
+   glBegin(mode);
+   for (Int_t i = B; i < N; ++i)
+   {
+      glVertex2fv(fM->fPoints[i]);
+   }
+   glEnd();
+}
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::Draw(TGLRnrCtx& rnrCtx) const
+{
+   // Render with OpenGL.
+
+   if (rnrCtx.IsDrawPassOutlineLine())
+      return;
+
+   glPushMatrix();
+   glTranslatef(0.0f, 0.0f, fM->fDepth);
+
+   if (fM->fHighlightFrame && rnrCtx.Highlight())
+   {
+      if (fM->fDrawFrame)
+      {
+         TGLUtil::LineWidth(fM->fLineWidth);
+         TGLUtil::Color(fM->fLineColor);
+      }
+      RenderPoints(GL_LINE_LOOP);
+   }
+   else
+   {
+      TGLObject::Draw(rnrCtx);
+   }
+
+   {
+      glColor3f(1,0,0);
+      Int_t N = fM->fDebugPoints.size();
+      glPointSize(4);
+      glBegin(GL_POINTS);
+      for (Int_t i = 0; i < N; ++i)
+      {
+         glVertex2fv(fM->fDebugPoints[i]);
+      }
+      glEnd();
+   }
+
+   glPopMatrix();
+}
+
+//______________________________________________________________________________
+void TEveBoxProjectedGL::DirectDraw(TGLRnrCtx&) const
+{
+   // Render with OpenGL, create display-list.
+
+   fMultiColor = (fM->fDrawFrame && fM->fFillColor != fM->fLineColor);
+
+   glPushAttrib(GL_ENABLE_BIT);
+
+   glEnable(GL_POLYGON_OFFSET_FILL);
+   glPolygonOffset(1.0f, 1.0f);
+   RenderPoints(GL_POLYGON);
+   glDisable(GL_POLYGON_OFFSET_FILL);
+
+   // Frame
+   if (fM->fDrawFrame)
+   {
+      TGLUtil::Color(fM->fLineColor);
+      TGLUtil::LineWidth(fM->fLineWidth);
+      glEnable(GL_LINE_SMOOTH);
+      RenderPoints(GL_LINE_LOOP);
+   }
+
+   glPopAttrib();
+}
diff --git a/graf3d/eve/src/TEveBoxSetGL.cxx b/graf3d/eve/src/TEveBoxSetGL.cxx
index 49b101f..634035b 100644
--- a/graf3d/eve/src/TEveBoxSetGL.cxx
+++ b/graf3d/eve/src/TEveBoxSetGL.cxx
@@ -65,7 +65,11 @@ inline Bool_t TEveBoxSetGL::SetupColor(const TEveDigitSet::DigitBase_t& q) const
 {
    // Set GL color for given primitive.
 
-   if (fM->fValueIsColor)
+   if (fM->fSingleColor)
+   {
+      return kTRUE;
+   }
+   else if (fM->fValueIsColor)
    {
       TGLUtil::Color4ubv((UChar_t*) & q.fValue);
       return kTRUE;
@@ -75,7 +79,7 @@ inline Bool_t TEveBoxSetGL::SetupColor(const TEveDigitSet::DigitBase_t& q) const
       UChar_t c[4];
       Bool_t visible = fM->fPalette->ColorFromValue(q.fValue, fM->fDefaultValue, c);
       if (visible)
-         TGLUtil::Color3ubv(c);
+         TGLUtil::Color4ubv(c);
       return visible;
    }
 }
@@ -169,7 +173,6 @@ void TEveBoxSetGL::MakeDisplayList() const
             glTranslatef(0, 0, 1);
             gluDisk(quad.Get(), 0, 1, nt, 1);
             glPopMatrix();
-
          }
       }
 
@@ -240,37 +243,11 @@ void TEveBoxSetGL::SetBBox()
 }
 
 //______________________________________________________________________________
-void TEveBoxSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
+void TEveBoxSetGL::RenderBoxes(TGLRnrCtx & rnrCtx) const
 {
-   // Actual rendering code.
-   // Virtual from TGLLogicalShape.
+   // GL rendering for all box-types.
 
-   static const TEveException eH("TEveBoxSetGL::DirectDraw ");
-
-   TEveBoxSet& mB = * fM;
-   // printf("TEveBoxSetGL::DirectDraw N boxes %d\n", mB.fPlex.Size());
-
-   if(mB.fPlex.Size() == 0)
-      return;
-   if ( ! mB.fValueIsColor && mB.fPalette == 0)
-   {
-      mB.AssertPalette();
-   }
-
-   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
-
-   if (mB.fRenderMode == TEveDigitSet::kRM_Fill)
-      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-   else if (mB.fRenderMode == TEveDigitSet::kRM_Line)
-      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
-
-   if (mB.fBoxType == TEveBoxSet::kBT_Cone ||
-       mB.fBoxType == TEveBoxSet::kBT_EllipticCone)
-   {
-      glDisable(GL_CULL_FACE);
-   }
-
-   if (mB.fDisableLigting) glDisable(GL_LIGHTING);
+   static const TEveException eH("TEveBoxSetGL::RenderBoxes ");
 
    if (rnrCtx.SecSelection()) glPushName(0);
 
@@ -278,9 +255,9 @@ void TEveBoxSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    if (rnrCtx.ShapeLOD() < 50)
       boxSkip = 6 - (rnrCtx.ShapeLOD()+1)/10;
 
-   TEveChunkManager::iterator bi(mB.fPlex);
+   TEveChunkManager::iterator bi(fM->fPlex);
 
-   switch (mB.fBoxType)
+   switch (fM->fBoxType)
    {
 
       case TEveBoxSet::kBT_FreeBox:
@@ -403,8 +380,43 @@ void TEveBoxSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    } // end switch box-type
 
    if (rnrCtx.SecSelection()) glPopName();
+}
 
-   glPopAttrib();
+//______________________________________________________________________________
+void TEveBoxSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
+{
+   // Actual rendering code.
+   // Virtual from TGLLogicalShape.
+
+   TEveBoxSet& mB = * fM;
+   // printf("TEveBoxSetGL::DirectDraw N boxes %d\n", mB.fPlex.Size());
+
+   if (mB.fPlex.Size() > 0)
+   {
+      if (! mB.fSingleColor && ! mB.fValueIsColor && mB.fPalette == 0)
+      {
+         mB.AssertPalette();
+      }
+
+      glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
+
+      if (mB.fRenderMode == TEveDigitSet::kRM_Fill)
+         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+      else if (mB.fRenderMode == TEveDigitSet::kRM_Line)
+         glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+
+      if (mB.fBoxType == TEveBoxSet::kBT_Cone ||
+          mB.fBoxType == TEveBoxSet::kBT_EllipticCone)
+      {
+         glDisable(GL_CULL_FACE);
+      }
+
+      if (mB.fDisableLigting) glDisable(GL_LIGHTING);
+
+      RenderBoxes(rnrCtx);
+
+      glPopAttrib();
+   }
 
    if (mB.fFrame != 0 && ! rnrCtx.SecSelection())
    {
diff --git a/graf3d/eve/src/TEveBrowser.cxx b/graf3d/eve/src/TEveBrowser.cxx
index a1621ac..2fa6edf 100644
--- a/graf3d/eve/src/TEveBrowser.cxx
+++ b/graf3d/eve/src/TEveBrowser.cxx
@@ -121,6 +121,8 @@ void TEveListTreeItem::Toggle()
 
 ClassImp(TEveGListTreeEditorFrame);
 
+TString TEveGListTreeEditorFrame::fgEditorClass("TEveGedEditor");
+
 //______________________________________________________________________________
 TEveGListTreeEditorFrame::TEveGListTreeEditorFrame(const TGWindow* p, Int_t width, Int_t height) :
    TGMainFrame (p ? p : gClient->GetRoot(), width, height),
@@ -160,7 +162,7 @@ TEveGListTreeEditorFrame::TEveGListTreeEditorFrame(const TGWindow* p, Int_t widt
    // Editor
    fFrame->SetEditDisabled(kEditEnable);
    fFrame->SetEditable();
-   fEditor = new TEveGedEditor(0, width, 4*height/7);
+   fEditor = (TEveGedEditor*) gROOT->GetClass(fgEditorClass)->New();
    fEditor->SetGlobal(kFALSE);
    fEditor->ChangeOptions(fEditor->GetOptions() | kFixedHeight);
    fFrame->SetEditable(kEditDisable);
@@ -209,6 +211,14 @@ TEveGListTreeEditorFrame::~TEveGListTreeEditorFrame()
 }
 
 //______________________________________________________________________________
+void TEveGListTreeEditorFrame::SetEditorClass(const char* edclass)
+{
+   // Set GED editor class.
+
+   fgEditorClass = edclass;
+}
+
+//______________________________________________________________________________
 void TEveGListTreeEditorFrame::ConnectSignals()
 {
    // Connect list-tree signals.
@@ -283,10 +293,6 @@ void TEveGListTreeEditorFrame::ReconfToHorizontal()
    fSplitter->SetFrame(fEditor, kFALSE);
 
    Layout();
-   //fFrame->Layout();
-   //fLTFrame->Layout();
-   //fLTCanvas->Layout();
-   //fListTree->ClearViewPort();
    MapSubwindows();
    MapWindow();
 }
@@ -328,15 +334,11 @@ void TEveGListTreeEditorFrame::ReconfToVertical()
    fSplitter->SetFrame(fEditor, kFALSE);
 
    Layout();
-   //fFrame->Layout();
-   //fLTFrame->Layout();
-   //fLTCanvas->Layout();
-   //fListTree->ClearViewPort();
    MapSubwindows();
    MapWindow();
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveGListTreeEditorFrame::ItemBelowMouse(TGListTreeItem *entry, UInt_t /*mask*/)
diff --git a/graf3d/eve/src/TEveCalo.cxx b/graf3d/eve/src/TEveCalo.cxx
index 47c2b48..0181422 100644
--- a/graf3d/eve/src/TEveCalo.cxx
+++ b/graf3d/eve/src/TEveCalo.cxx
@@ -20,10 +20,6 @@
 #include "TClass.h"
 #include "TMathBase.h"
 #include "TMath.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 #include "TAxis.h"
 
 #include "TGLUtil.h"
@@ -154,7 +150,7 @@ void TEveCaloViz::SetPlotEt(Bool_t isEt)
 
    fPlotEt=isEt;
    if (fPalette)
-      fPalette->SetLimits(0, TMath::CeilNint(fData->GetMaxVal(fPlotEt)));
+      fPalette->SetLimits(0, TMath::CeilNint(GetMaxVal()));
 
    InvalidateCellIdCache();
 }
@@ -247,7 +243,7 @@ void TEveCaloViz::DataChanged()
 
    if (fPalette)
    {
-      Int_t hlimit = TMath::CeilNint(fScaleAbs ? fMaxValAbs : fData->GetMaxVal(fPlotEt));
+      Int_t hlimit = TMath::CeilNint(GetMaxVal());
       fPalette->SetLimits(0, hlimit);
       fPalette->SetMin(0);
       fPalette->SetMax(hlimit);
@@ -257,13 +253,18 @@ void TEveCaloViz::DataChanged()
 }
 
 //______________________________________________________________________________
-void TEveCaloViz::AssertCellIdCache() const
+Bool_t TEveCaloViz::AssertCellIdCache() const
 {
    // Assert cell id cache is ok.
+   // Returns true if the cache has been updated.
  
    TEveCaloViz* cv = const_cast<TEveCaloViz*>(this);
-   if (!fCellIdCacheOK)
+   if (!fCellIdCacheOK) {
       cv->BuildCellIdCache();
+      return kTRUE;
+   } else {
+      return kFALSE;
+   }
 }
 
 //______________________________________________________________________________
@@ -345,7 +346,7 @@ TEveRGBAPalette* TEveCaloViz::AssertPalette()
       fPalette = new TEveRGBAPalette;
       fPalette->SetDefaultColor((Color_t)4);
 
-      Int_t hlimit = TMath::CeilNint(fScaleAbs ? fMaxValAbs : fData->GetMaxVal(fPlotEt));
+      Int_t hlimit = TMath::CeilNint(GetMaxVal());
       fPalette->SetLimits(0, hlimit);
       fPalette->SetMin(0);
       fPalette->SetMax(hlimit);
@@ -359,24 +360,10 @@ void TEveCaloViz::Paint(Option_t* /*option*/)
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEvecaloViz::Paint ");
-
-   if (!fData)
-      return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   if (fData)
+   {
+      PaintStandard(this);
+   }
 }
 
 //______________________________________________________________________________
@@ -762,7 +749,7 @@ TEveCaloLego::TEveCaloLego(TEveCaloData* d, const char* n, const char* t):
    fAutoRebin(kTRUE),
 
    fPixelsPerBin(12),
-   fNormalizeRebin(kTRUE),
+   fNormalizeRebin(kFALSE),
 
    fProjection(kAuto),
    f2DMode(kValSize),
@@ -809,7 +796,7 @@ void TEveCaloLego::ComputeBBox()
 
    BBoxZero();
 
-   Float_t ex = 1.2;
+   Float_t ex = 1.2*fMaxTowerH;
 
    Float_t a = 0.5*ex;
 
diff --git a/graf3d/eve/src/TEveCalo3DGL.cxx b/graf3d/eve/src/TEveCalo3DGL.cxx
index e984ee5..37661c3 100644
--- a/graf3d/eve/src/TEveCalo3DGL.cxx
+++ b/graf3d/eve/src/TEveCalo3DGL.cxx
@@ -265,13 +265,13 @@ void TEveCalo3DGL::RenderGrid(TGLRnrCtx & rnrCtx) const
 
    if (transparent_p)
    {
-      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fFrameTransparency);
-
       glPushAttrib(GL_ENABLE_BIT | GL_DEPTH_BUFFER_BIT);
 
       glDepthMask(GL_FALSE);
       glEnable(GL_BLEND);
       glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fFrameTransparency);
    }
 
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
@@ -297,8 +297,6 @@ void TEveCalo3DGL::RenderGrid(TGLRnrCtx & rnrCtx) const
    if (transparent_p)
    {
       glPopAttrib();
-
-      TGLUtil::ColorTransparency(fM->fFrameColor, fM->fMainTransparency);
    }
 }
 
@@ -533,8 +531,6 @@ void TEveCalo3DGL::DirectDraw(TGLRnrCtx &rnrCtx) const
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
    glEnable(GL_NORMALIZE);
 
-   RenderGrid(rnrCtx);
-
    TEveCaloData::CellData_t cellData;
    Float_t towerH;
    Int_t   tower = 0;
@@ -568,6 +564,9 @@ void TEveCalo3DGL::DirectDraw(TGLRnrCtx &rnrCtx) const
    }
 
    if (rnrCtx.SecSelection()) glPopName();
+
+   RenderGrid(rnrCtx);
+
    glPopAttrib();
 }
 
diff --git a/graf3d/eve/src/TEveCaloData.cxx b/graf3d/eve/src/TEveCaloData.cxx
index a12b060..84ceec5 100644
--- a/graf3d/eve/src/TEveCaloData.cxx
+++ b/graf3d/eve/src/TEveCaloData.cxx
@@ -395,7 +395,6 @@ void TEveCaloDataVec::Rebin(TAxis* ax, TAxis* ay, vCellId_t &ids, Bool_t et, Reb
    rdata.fBinData.assign((ax->GetNbins()+2)*(ay->GetNbins()+2), -1);
 
    CellData_t cd;
-   Float_t left, right, up, down; // cell corners
    for (vCellId_i it = ids.begin(); it != ids.end(); ++it)
    {
       GetCellData(*it, cd);
@@ -406,20 +405,17 @@ void TEveCaloDataVec::Rebin(TAxis* ax, TAxis* ay, vCellId_t &ids, Bool_t et, Reb
       for (Int_t i = iMin; i <= iMax; ++i)
       {
          if (i < 0 || i > ax->GetNbins()) continue;
-         left  = (i == iMin) ? cd.EtaMin() : ax->GetBinLowEdge(i);
-         right = (i == iMax) ? cd.EtaMax() : ax->GetBinUpEdge(i);
-
          for (Int_t j = jMin; j <= jMax; ++j)
          {
             if (j < 0 || j > ay->GetNbins()) continue;
-            down = (j == jMin) ? cd.PhiMin() : ay->GetBinLowEdge(j);
-            up   = (j == jMax) ? cd.PhiMax() : ay->GetBinUpEdge(j);
 
-            Float_t ratio = ((right-left)*(up-down))/(ax->GetBinWidth(i)*ay->GetBinWidth(j));
-            if (ratio > 1e-6)
+            Double_t ratio = TEveUtil::GetFraction(ax->GetBinLowEdge(i), ax->GetBinUpEdge(i), cd.EtaMin(), cd.EtaMax())
+                           * TEveUtil::GetFraction(ay->GetBinLowEdge(j), ay->GetBinUpEdge(j), cd.PhiMin(), cd.PhiMax());
+            
+            if (ratio > 1e-6f)
             {
-               Float_t* slices = rdata.GetSliceVals(i+j*(ax->GetNbins()+2));
-               slices[(*it).fSlice] += ratio* cd.Value(et);
+               Float_t* slices = rdata.GetSliceVals(i + j*(ax->GetNbins()+2));
+               slices[(*it).fSlice] += ratio * cd.Value(et);
             }
          }
       }
@@ -696,7 +692,9 @@ void TEveCaloDataHist::Rebin(TAxis* ax, TAxis* ay, TEveCaloData::vCellId_t &ids,
       biny = ay->FindBin(fPhiAxis->GetBinCenter(j));
       bin = biny*(ax->GetNbins()+2)+binx;
       val = rdata.GetSliceVals(bin);
-      Double_t ratio = (fEtaAxis->GetBinWidth(i)*fPhiAxis->GetBinWidth(j))/(ax->GetBinWidth(binx)*ay->GetBinWidth(biny));
+      Double_t ratio = TEveUtil::GetFraction(ax->GetBinLowEdge(binx), ax->GetBinUpEdge(binx), cd.EtaMin(), cd.EtaMax())
+                     * TEveUtil::GetFraction(ay->GetBinLowEdge(biny), ay->GetBinUpEdge(biny), cd.PhiMin(), cd.PhiMax());
+      
       val[(*it).fSlice] += cd.Value(et)*ratio;
    }
 }
diff --git a/graf3d/eve/src/TEveCaloLegoGL.cxx b/graf3d/eve/src/TEveCaloLegoGL.cxx
index 95d1a50..098e308 100644
--- a/graf3d/eve/src/TEveCaloLegoGL.cxx
+++ b/graf3d/eve/src/TEveCaloLegoGL.cxx
@@ -322,7 +322,7 @@ void TEveCaloLegoGL::SetAxis3DTitlePos(TGLRnrCtx &rnrCtx, Float_t x0, Float_t x1
          idxLeft = i;
       }
    }
-   fZAxisTitlePos.Set(cornerX[idxLeft], cornerY[idxLeft], fDataMax* 1.05);
+   fZAxisTitlePos.Set(cornerX[idxLeft], cornerY[idxLeft], 1.05 * fDataMax);
 
 
    // XY axis location (closest to eye) first
@@ -573,6 +573,8 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
 {
    // Draw XY axis.
 
+   TGLCamera& cam  = rnrCtx.RefCamera();
+
    TAxis ax;
    ax.SetAxisColor(fGridColor);
    ax.SetLabelColor(fFontColor);
@@ -600,6 +602,10 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
                               + (up[1] - dn[1]) * (up[1] - dn[1])
                               + (up[2] - dn[2]) * (up[2] - dn[2]));
 
+   // lock upper limit to of relative font size relative to viewport diagonal
+   Double_t vpLimit = cam.RefViewport().Diagonal()*0.5/TMath::Sqrt2();
+   len = TMath::Min(len, vpLimit);
+
    // eta
    fAxisPainter.SetLabelPixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetLabelSize()));
    fAxisPainter.SetTitlePixelFontSize(TMath::Nint(len*fM->GetData()->GetEtaBins()->GetTitleSize()));
@@ -608,7 +614,9 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
    ax.SetTitle(fM->GetData()->GetEtaBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(fM->GetEtaMax(), -fM->GetPhiRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), 0 );
    fAxisPainter.RefDir().Set(1, 0, 0);
-   fAxisPainter.RefTMOff(0).Set(0,  -fM->GetPhiRng(), 0);
+
+   Float_t tmOffFrustX = cam.FrustumPlane(TGLCamera::kRight).D() + cam.FrustumPlane(TGLCamera::kLeft).D();
+   fAxisPainter.RefTMOff(0).Set(0,  -TMath::Min(fM->GetPhiRng(), tmOffFrustX), 0);
    fAxisPainter.SetLabelAlign(TGLFont::kCenterH, TGLFont::kBottom);
 
    glPushMatrix();
@@ -622,7 +630,8 @@ void TEveCaloLegoGL::DrawAxis2D(TGLRnrCtx & rnrCtx) const
    ax.SetTitle(fM->GetData()->GetPhiBins()->GetTitle());
    fAxisPainter.RefTitlePos().Set(-fM->GetEtaRng()*(ax.GetTickLength()+ ax.GetLabelOffset()), fM->GetPhiMax(), 0);
    fAxisPainter.RefDir().Set(0, 1, 0);
-   fAxisPainter.RefTMOff(0).Set(-fM->GetEtaRng(), 0, 0);
+   Float_t tmOffFrustY = cam.FrustumPlane(TGLCamera::kTop).D() + cam.FrustumPlane(TGLCamera::kBottom).D();
+   fAxisPainter.RefTMOff(0).Set(-TMath::Min(fM->GetEtaRng(), tmOffFrustY), 0, 0);
    fAxisPainter.SetLabelAlign(TGLFont::kRight, TGLFont::kCenterV);
 
    glPushMatrix();
@@ -679,18 +688,18 @@ void TEveCaloLegoGL::RebinAxis(TAxis *orig, TAxis *curr) const
    // Rebin eta, phi axis.
 
    Double_t center = 0.5 * (orig->GetXmin() + orig->GetXmax());
-   Int_t idx0 = orig->FindBin(center);
-   Double_t bc = orig->GetBinCenter(idx0);
-   if (bc > center) idx0--;
+   Int_t    idx0   = orig->FindBin(center);
+   Double_t bc     = orig->GetBinCenter(idx0);
+   if (bc > center) --idx0;
 
    Int_t nbR = TMath::FloorNint(idx0/fM->fBinStep) + TMath::FloorNint((orig->GetNbins() - idx0)/fM->fBinStep);
-   Double_t *bins = new Double_t[nbR+1];
    Int_t off = idx0 - TMath::FloorNint(idx0/fM->fBinStep)*fM->fBinStep;
-   for(Int_t i = 0; i <= nbR; i++)
+   std::vector<Double_t> bins(nbR + 1);
+   for (Int_t i = 0; i <= nbR; ++i)
+   {
       bins[i] = orig->GetBinUpEdge(off + i*fM->fBinStep);
-
-   curr->Set(nbR, bins);
-   delete [] bins;
+   }
+   curr->Set(nbR, &bins[0]);
 }
 
 //______________________________________________________________________________
@@ -796,18 +805,21 @@ void TEveCaloLegoGL::PrepareCell2DData(TEveCaloData::vCellId_t& cellList, vCell2
    TEveCaloData::vCellId_t::iterator nextCell    = currentCell;
    ++nextCell;
 
-   while (currentCell != cellList.end()) {
+   while (true)
+   {
       TEveCaloData::CellData_t currentCellData;
       TEveCaloData::CellData_t nextCellData;
 
       fM->fData->GetCellData(*currentCell, currentCellData);
       sum = max_energy = currentCellData.Value(fM->fPlotEt);
       max_energy_slice = currentCell->fSlice;
-      while (nextCell != cellList.end() && currentCell->fTower == nextCell->fTower) {
+      while (nextCell != cellList.end() && currentCell->fTower == nextCell->fTower)
+      {
          fM->fData->GetCellData(*nextCell, nextCellData);
          Float_t energy = nextCellData.Value(fM->fPlotEt);
          sum += energy;
-         if (energy > max_energy) {
+         if (energy > max_energy)
+         {
             max_energy       = energy;
             max_energy_slice = nextCell->fSlice;
          }
@@ -819,6 +831,10 @@ void TEveCaloLegoGL::PrepareCell2DData(TEveCaloData::vCellId_t& cellList, vCell2
       cells2D.push_back(Cell2D_t(cellID, sum, max_energy_slice));
       cells2D.back().SetGeom(currentCellData.fEtaMin, currentCellData.fEtaMax,
                              currentCellData.fPhiMin, currentCellData.fPhiMax);
+
+      if (nextCell == cellList.end())
+         break;
+
       currentCell = nextCell;
       ++nextCell;
       ++cellID;
@@ -882,12 +898,13 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
    Float_t bws    = -1; //smallest bin
    Float_t logMax = -1;
 
-   if (fM->f2DMode == TEveCaloLego::kValColor ) {
+   if (fM->f2DMode == TEveCaloLego::kValColor)
+   {
       fM->AssertPalette();
       UChar_t col[4];
 
-
-      for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+      for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i)
+      {
          if (rnrCtx.SecSelection()) glLoadName(i->fId);
          glBegin(GL_POLYGON);
          Float_t val = i->fSumVal;
@@ -900,16 +917,19 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
          glEnd();
       }
    }
-   else {
+   else
+   {
       Float_t x, y;
-      if (!rnrCtx.HighlightOutline()) {
+      if (!rnrCtx.HighlightOutline())
+      {
          Float_t maxv = 0;
          bws = 1e5;
-         for ( vCell2D_i i = fCells2D.begin(); i != fCells2D.end(); ++i) {
-            if ( i->MinSize() < bws)   bws = i->MinSize();
-            if ( i->fSumVal > maxv)   maxv = i->fSumVal;
+         for (vCell2D_i i = fCells2D.begin(); i != fCells2D.end(); ++i)
+         {
+            if (i->MinSize() < bws)   bws  = i->MinSize();
+            if (i->fSumVal   > maxv)  maxv = i->fSumVal;
          }
-         bws   *= 0.5;
+         bws   *= 0.5f;
          logMax = TMath::Log10(maxv + 1);
          fValToPixel =  bws/logMax;
       }
@@ -917,7 +937,8 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
       // special draw for name stack
       if (rnrCtx.SecSelection())
       {
-         for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+         for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i)
+         {
             // point
             glLoadName(i->fMaxSlice);
             glPushName(i->fId);
@@ -947,7 +968,8 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
          if (!rnrCtx.HighlightOutline())
          {
             glBegin(GL_POINTS);
-            for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+            for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i)
+            {
                TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
                glVertex3f(i->X(), i->Y() , i->fSumVal);
             }
@@ -955,7 +977,8 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
          }
 
          glBegin(GL_QUADS);
-         for ( vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i) {
+         for (vCell2D_i i = cells2D.begin(); i != cells2D.end(); ++i)
+         {
             TGLUtil::Color(fM->fData->GetSliceColor(i->fMaxSlice));
             Float_t bw = fValToPixel*TMath::Log10(i->fSumVal+1);
             x = i->X();
@@ -1000,8 +1023,8 @@ void TEveCaloLegoGL::DrawCells2D(TGLRnrCtx &rnrCtx, vCell2D_t& cells2D) const
    }
 
    // text
-   if ( fCurrentPixelsPerBin >  fM->fDrawNumberCellPixels && 
-        (rnrCtx.Selection() || rnrCtx.Highlight() || rnrCtx.HighlightOutline()) == kFALSE) 
+   if (fCurrentPixelsPerBin > fM->fDrawNumberCellPixels &&
+       (rnrCtx.Selection() || rnrCtx.Highlight() || rnrCtx.HighlightOutline()) == kFALSE)
    {
       TGLUtil::Color(rnrCtx.ColorSet().Markup().GetColorIndex());
       TGLFont font;
@@ -1049,7 +1072,7 @@ void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps
    Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
    Float_t sx = (eM - em) / fM->GetEtaRng();
    Float_t sy = (pM - pm) / fM->GetPhiRng();
-   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetValToHeight());
+   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetMaxTowerH() / fDataMax);
    glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
 
    // check eta&phi range of selected cells
@@ -1067,14 +1090,13 @@ void TEveCaloLegoGL::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* ps
    if (fM->fBinStep > 1)
    {
       fM->fData->Rebin(fEtaAxis, fPhiAxis, cellsSelected, fM->fPlotEt, rebinDataSelected);
-      Float_t scale = fM->GetMaxVal() / fMaxValRebin;
       if (fM->fNormalizeRebin) {
+         Float_t scale = 1.f / (fM->fBinStep * fM->fBinStep);
          for (std::vector<Float_t>::iterator it = rebinDataSelected.fSliceData.begin(); it != rebinDataSelected.fSliceData.end(); it++)
             (*it) *= scale;
       }
    }
 
-
    if (fCells3D)
    {
       Int_t   prevTower = 0;
@@ -1190,60 +1212,65 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    else if (fM->fProjection == TEveCaloLego::k3D)
       fCells3D = kTRUE;
 
-   // cache max val
-   fDataMax = fM->GetMaxVal();
-
-   // modelview matrix
-   Double_t em, eM, pm, pM;
-   fM->fData->GetEtaLimits(em, eM);
-   fM->fData->GetPhiLimits(pm, pM);
-   Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
-   glPushMatrix();
-   Float_t sx = (eM - em) / fM->GetEtaRng();
-   Float_t sy = (pM - pm) / fM->GetPhiRng();
-   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetValToHeight());
-   glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
-
    // rebin axsis , check limits, fix TwoPi cycling
-   Int_t oldBinStep = fM->fBinStep;
-   fM->fBinStep = GetGridStep(rnrCtx);
-   if (oldBinStep != fM->fBinStep) fDLCacheOK=kFALSE;
-
-   RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
-   RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
-
-   // cache ids
-   Bool_t idCacheChanged = kFALSE;
-   if (fM->fCellIdCacheOK == kFALSE) {
-      fM->BuildCellIdCache();
-      idCacheChanged = kTRUE;
-   }
+   Int_t new_bin_step = GetGridStep(rnrCtx);
 
    // rebin data
-   if (fDLCacheOK==kFALSE || idCacheChanged ) {
-      fRebinData.fSliceData.clear();
-      fRebinData.fSliceData.clear();
+   if (fM->AssertCellIdCache() || fM->fBinStep != new_bin_step)
+   {
+      fM->fBinStep = new_bin_step;
+      fDLCacheOK   = kFALSE;
+      fRebinData.Clear();
 
-      if (fM->fBinStep > 1) {
+      RebinAxis(fM->fData->GetEtaBins(), fEtaAxis);
+      RebinAxis(fM->fData->GetPhiBins(), fPhiAxis);
+
+      if (fM->fBinStep > 1)
+      {
          fM->fData->Rebin(fEtaAxis, fPhiAxis, fM->fCellList, fM->fPlotEt, fRebinData);
-         if (fM->fNormalizeRebin) {
-            //  Double_t maxVal = 0;
-            fMaxValRebin = 0;
-            for (UInt_t i = 0; i < fRebinData.fSliceData.size(); i += fRebinData.fNSlices) {
-               Double_t sum = 0;
-               for (Int_t s = 0; s < fRebinData.fNSlices; s++)
-                  sum += fRebinData.fSliceData[i+s];
-
-               if (sum > fMaxValRebin) fMaxValRebin = sum;
+
+         fMaxVal = 0;
+         for (UInt_t i = 0; i < fRebinData.fSliceData.size(); i += fRebinData.fNSlices)
+         {
+            Double_t sum = 0;
+            for (Int_t s = 0; s < fRebinData.fNSlices; s++)
+            {
+               sum += fRebinData.fSliceData[i+s];
             }
+            if (sum > fMaxVal) fMaxVal = sum;
+         }
 
-            Float_t scale = fM->GetMaxVal() / fMaxValRebin;
+         if (fM->fNormalizeRebin)
+         {
+            Float_t scale = 1.f / (fM->fBinStep * fM->fBinStep);
             for (std::vector<Float_t>::iterator it = fRebinData.fSliceData.begin(); it != fRebinData.fSliceData.end(); it++)
+            {
                (*it) *= scale;
+            }
+            fMaxVal *= scale;
          }
       }
+      else
+      {
+         fMaxVal = fM->GetMaxVal();
+      }
    }
 
+   // cache max val
+   fDataMax = (fM->fScaleAbs) ? fM->fMaxValAbs : fMaxVal;
+
+   // modelview matrix
+   Double_t em, eM, pm, pM;
+   fM->fData->GetEtaLimits(em, eM);
+   fM->fData->GetPhiLimits(pm, pM);
+   Double_t unit = ((eM - em) < (pM - pm)) ? (eM - em) : (pM - pm);
+   glPushMatrix();
+   Float_t sx = (eM - em) / fM->GetEtaRng();
+   Float_t sy = (pM - pm) / fM->GetPhiRng();
+   glScalef(sx / unit, sy / unit, fM->fData->Empty() ? 1 : fM->GetMaxTowerH() / fDataMax);
+   glTranslatef(-fM->GetEta(), -fM->fPhi, 0);
+
+
    fFontColor = fM->fFontColor;
    fGridColor = fM->fGridColor;
    if (fGridColor < 0 || fFontColor < 0)
@@ -1269,11 +1296,13 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    TGLUtil::LineWidth(1);
    glEnable(GL_BLEND);
 
-   if (!fM->fData->Empty()){
+   if (!fM->fData->Empty())
+   {
       glPushName(0);
       glLoadName(0);
-      if (fCells3D) {
-         if (fDLCacheOK == kFALSE || idCacheChanged )
+      if (fCells3D)
+      {
+         if (fDLCacheOK == kFALSE)
          {
             if (fM->fBinStep == 1)
                Make3DDisplayList(fM->fCellList, fDLMap, kTRUE);
@@ -1302,8 +1331,9 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
    glPopAttrib();
 
    // draw histogram base
-   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
-   if (rnrCtx.Selection() == kFALSE) {
+   if (rnrCtx.Selection() == kFALSE && rnrCtx.IsDrawPassFilled())
+   {
+      glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
       glDisable(GL_LIGHTING);
       DrawHistBase(rnrCtx);
       if (fM->fDrawHPlane) {
@@ -1319,10 +1349,10 @@ void TEveCaloLegoGL::DirectDraw(TGLRnrCtx & rnrCtx) const
          glVertex3f(fM->fEtaMin, fM->GetPhiMax(), zhp);
          glEnd();
       }
+      glPopAttrib();
    }
-   glPopAttrib();
-   glPopMatrix();
 
+   glPopMatrix();
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveCaloLegoOverlay.cxx b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
index b46349f..45f6072 100644
--- a/graf3d/eve/src/TEveCaloLegoOverlay.cxx
+++ b/graf3d/eve/src/TEveCaloLegoOverlay.cxx
@@ -624,7 +624,7 @@ void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
 
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    TGLCamera& cam = rnrCtx.RefCamera();
-   Bool_t drawOverlayAxis = kFALSE;
+   Bool_t drawOverlayAxis = kTRUE;
 
    if (cam.IsOrthographic())
    {
@@ -678,8 +678,10 @@ void TEveCaloLegoOverlay::Render(TGLRnrCtx& rnrCtx)
       }
 
       // draw camera overlay if projected lego bbox to large
-      if (res.X() > cam.RefViewport().Width()*0.8 || res.Y() > cam.RefViewport().Height()*0.8)
-         drawOverlayAxis = kTRUE;
+      SetFrustum(cam);
+      if (   fCalo->GetEtaMin() > fFrustum[0] && fCalo->GetEtaMax() < fFrustum[2]
+          && fCalo->GetPhiMin() > fFrustum[1] && fCalo->GetPhiMax() < fFrustum[3])
+            drawOverlayAxis = kFALSE;
    }
 
    if (cam.IsPerspective() && fShowPlane)
diff --git a/graf3d/eve/src/TEveCompound.cxx b/graf3d/eve/src/TEveCompound.cxx
index 480a131..eea62de 100644
--- a/graf3d/eve/src/TEveCompound.cxx
+++ b/graf3d/eve/src/TEveCompound.cxx
@@ -57,6 +57,7 @@ void TEveCompound::AddElement(TEveElement* el)
    // Call base-class implementation.
    // If compund is open and compound of the new element is not set,
    // the el's compound is set to this.
+   // You might also want to call RecheckImpliedSelections().
 
    TEveElementList::AddElement(el);
    if (IsCompoundOpen() && el->GetCompound() == 0)
diff --git a/graf3d/eve/src/TEveDigitSet.cxx b/graf3d/eve/src/TEveDigitSet.cxx
index 5b2595a..46bddd9 100644
--- a/graf3d/eve/src/TEveDigitSet.cxx
+++ b/graf3d/eve/src/TEveDigitSet.cxx
@@ -13,13 +13,8 @@
 #include "TEveManager.h"
 #include "TEveTrans.h"
 
-
 #include "TColor.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 
 //______________________________________________________________________________
 //
@@ -29,17 +24,31 @@
 //
 // Base-class for displaying a digit collection.
 // Provdies common services for:
-// - specifying signal / color per digit
-// - specifying object reference per digit
-// - controlling palette and thresholds (external object TEveRGBAPalette)
-// - showing a frame around the digits (external object TEveFrameBox)
-// - specifying transformation matrix for the whole collection
+// - specifying signal / color per digit;
+// - specifying object reference per digit;
+// - controlling palette and thresholds (external object TEveRGBAPalette);
+// - showing a frame around the digits (external object TEveFrameBox);
+// - specifying transformation matrix for the whole collection;
 //   by data-member of class TEveTrans.
 //
+// Use method DigitId(TObject* id) to assign additional identification
+// to the last created digit. By calling SetOwnIds(kTRUE) tje
+// digit-set becomes the owner of the assigned objects and deletes
+// them on destruction.
+// Note that TRef is used for referencing the objects and if you
+// instantiate the objects just to pass them to digit-set you should
+// also call  TProcessID::Get/SetObjectCount() at the beginning / end
+// of processing of an event. See documentation for class TRef, in
+// particular section 'ObjectNumber'.
+//
 // If you use value-is-color mode and want to use transparency, set
 // the transparency to non-zero value so that GL-renderer will be
 // properly informed.
 //
+// If you want to use single color for all elements call:
+//   UseSingleColor()
+// Palette controls will not work in this case.
+//
 // See also:
 //   TEveQuadSet: rectangle, hexagon or line per digit
 //   TEveBoxSet   a 3D box per digit
@@ -48,7 +57,7 @@ ClassImp(TEveDigitSet);
 
 //______________________________________________________________________________
 TEveDigitSet::TEveDigitSet(const char* n, const char* t) :
-   TEveElement     (),
+   TEveElement     (fColor),
    TNamed          (n, t),
 
    fDefaultValue   (kMinInt),
@@ -57,6 +66,7 @@ TEveDigitSet::TEveDigitSet(const char* n, const char* t) :
    fPlex           (),
    fLastDigit      (0),
 
+   fColor          (kWhite),
    fFrame          (0),
    fPalette        (0),
    fRenderMode     (kRM_AsIs),
@@ -114,11 +124,25 @@ void TEveDigitSet::ReleaseIds()
 /******************************************************************************/
 
 //______________________________________________________________________________
+void TEveDigitSet::UseSingleColor()
+{
+   // Instruct digit-set to use single color for its digits.
+   // Call SetMainColor/Transparency to initialize it.
+
+   fSingleColor = kTRUE;
+}
+
+//______________________________________________________________________________
 void TEveDigitSet::SetMainColor(Color_t color)
 {
    // Override from TEveElement, forward to Frame.
 
-   if (fFrame) {
+   if (fSingleColor)
+   {
+      TEveElement::SetMainColor(color);
+   }
+   else if (fFrame)
+   {
       fFrame->SetFrameColor(color);
       fFrame->StampBackPtrElements(kCBColorSelection);
    }
@@ -218,24 +242,11 @@ void TEveDigitSet::DigitId(TObject* id)
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveDigitSet::Paint(Option_t* /*option*/)
+void TEveDigitSet::Paint(Option_t*)
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEveDigitSet::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = fFrame ? fFrame->GetFrameColor() : 1;
-   buff.fTransparency = GetMainTransparency();
-   RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
@@ -285,9 +296,11 @@ void TEveDigitSet::SetFrame(TEveFrameBox* b)
    fFrame = b;
    if (fFrame) {
       fFrame->IncRefCount(this);
-      SetMainColorPtr(fFrame->PtrFrameColor());
+      if (!fSingleColor) {
+         SetMainColorPtr(fFrame->PtrFrameColor());
+      }
    } else {
-      SetMainColorPtr(0);
+      SetMainColorPtr(&fColor);
    }
 }
 
diff --git a/graf3d/eve/src/TEveElement.cxx b/graf3d/eve/src/TEveElement.cxx
index 4d04f08..391f491 100644
--- a/graf3d/eve/src/TEveElement.cxx
+++ b/graf3d/eve/src/TEveElement.cxx
@@ -15,6 +15,12 @@
 #include "TEveManager.h"
 #include "TEveSelection.h"
 #include "TEveProjectionBases.h"
+#include "TEveProjectionManager.h"
+
+#include "TBuffer3D.h"
+#include "TBuffer3DTypes.h"
+#include "TVirtualPad.h"
+#include "TVirtualViewer3D.h"
 
 #include "TGeoMatrix.h"
 
@@ -57,7 +63,7 @@ ClassImp(TEveElement);
 
 //______________________________________________________________________________
 const TGPicture* TEveElement::fgRnrIcons[4]      = { 0 };
-const TGPicture* TEveElement::fgListTreeIcons[8] = { 0 };
+const TGPicture* TEveElement::fgListTreeIcons[9] = { 0 };
 
 //______________________________________________________________________________
 TEveElement::TEveElement() :
@@ -201,6 +207,15 @@ void TEveElement::PreDeleteElement()
 }
 
 //______________________________________________________________________________
+TEveElement* TEveElement::CloneElement() const
+{
+   // Clone the element via copy constructor.
+   // Should be implemented for all classes that require cloning support.
+
+   return new TEveElement(*this);
+}
+
+//______________________________________________________________________________
 TEveElement* TEveElement::CloneElementRecurse(Int_t level) const
 {
    // Clone elements and recurse 'level' deep over children.
@@ -228,7 +243,11 @@ void TEveElement::CloneChildrenRecurse(TEveElement* dest, Int_t level) const
    }
 }
 
-/******************************************************************************/
+//==============================================================================
+
+
+
+//==============================================================================
 
 //______________________________________________________________________________
 const char* TEveElement::GetElementName() const
@@ -328,13 +347,13 @@ void TEveElement::SetVizModel(TEveElement* model)
    // viz-model.
 
    if (fVizModel) {
-      fVizModel->RemoveElement(this);
       --fParentIgnoreCnt;
+      fVizModel->RemoveElement(this);
    }
    fVizModel = model;
    if (fVizModel) {
-      ++fParentIgnoreCnt;
       fVizModel->AddElement(this);
+      ++fParentIgnoreCnt;
    }
 }
 
@@ -497,8 +516,11 @@ void TEveElement::VizDB_Apply(const char* tag)
 {
    // Set visual parameters for this object for given tag.
 
-   ApplyVizTag(tag);
-   gEve->Redraw3D();
+   if (ApplyVizTag(tag))
+   {
+      PropagateVizParamsToProjecteds();
+      gEve->Redraw3D();
+   }
 }
 
 //______________________________________________________________________________
@@ -507,8 +529,12 @@ void TEveElement::VizDB_Reapply()
    // Reset visual parameters for this object from VizDB.
    // The model object must be already set.
 
-   CopyVizParamsFromDB();
-   gEve->Redraw3D();
+   if (fVizModel)
+   {
+      CopyVizParamsFromDB();
+      PropagateVizParamsToProjecteds();
+      gEve->Redraw3D();
+   }
 }
 
 //______________________________________________________________________________
@@ -706,7 +732,8 @@ TGListTreeItem* TEveElement::AddIntoListTree(TGListTree* ltree,
                                              TGListTreeItem* parent_lti)
 {
    // Add this element into ltree to an already existing item
-   // parent_lti.
+   // parent_lti. Children, if any, are added as below the newly created item.
+   // Returns the newly created list-tree-item.
 
    static const TEveException eh("TEveElement::AddIntoListTree ");
 
@@ -717,6 +744,11 @@ TGListTreeItem* TEveElement::AddIntoListTree(TGListTree* ltree,
    if (parent_lti == 0)
       ++fTopItemCnt;
 
+   for (List_i i=fChildren.begin(); i!=fChildren.end(); ++i)
+   {
+      (*i)->AddIntoListTree(ltree, item);
+   }
+
    ltree->ClearViewPort();
 
    return item;
@@ -975,6 +1007,34 @@ void TEveElement::PadPaint(Option_t* option)
    }
 }
 
+//______________________________________________________________________________
+void TEveElement::PaintStandard(TObject* id)
+{
+   // Paint object -- a generic implementation for EVE elements.
+   // This supports direct rendering using a dedicated GL class.
+   // Override TObject::Paint() in sub-classes if different behaviour
+   // is required.
+
+   static const TEveException eh("TEveElement::PaintStandard ");
+
+   TBuffer3D buff(TBuffer3DTypes::kGeneric);
+
+   // Section kCore
+   buff.fID           = id;
+   buff.fColor        = GetMainColor();
+   buff.fTransparency = GetMainTransparency();
+   if (HasMainTrans())  RefMainTrans().SetBuffer3D(buff);
+
+   buff.SetSectionsValid(TBuffer3D::kCore);
+
+   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
+   if (reqSections != TBuffer3D::kNone)
+   {
+      Warning(eh, "IsA='%s'. Viewer3D requires more sections (%d). Only direct-rendering supported.",
+              id->ClassName(), reqSections);
+   }
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
@@ -1153,12 +1213,12 @@ void TEveElement::SetMainAlpha(Float_t alpha)
 /******************************************************************************/
 
 //______________________________________________________________________________
-TEveTrans* TEveElement::PtrMainTrans()
+TEveTrans* TEveElement::PtrMainTrans(Bool_t create)
 {
-   // Return pointer to main transformation. It is created if not yet
-   // existing.
+   // Return pointer to main transformation. If 'create' flag is set (default)
+   // it is created if not yet existing.
 
-   if (!fMainTrans)
+   if (!fMainTrans && create)
       InitMainTrans();
 
    return fMainTrans;
@@ -1314,7 +1374,41 @@ void TEveElement::RemoveElementsLocal()
    // See comment to RemoveElementlocal(TEveElement*).
 }
 
-/******************************************************************************/
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveElement::ProjectChild(TEveElement* el, Bool_t same_depth)
+{
+   // If this is a projectable, loop over all projected replicas and
+   // add the projected image of child 'el' there. This is supposed to
+   // be called after you add a child to a projectable after it has
+   // already been projected.
+   // You might also want to call RecheckImpliedSelections() on this
+   // element or 'el'.
+   //
+   // If 'same_depth' flag is true, the same depth as for parent object
+   // is used in every projection. Otherwise current depth of each
+   // relevant projection-manager is used.
+
+   TEveProjectable* pable = dynamic_cast<TEveProjectable*>(this);
+   if (pable && HasChild(el))
+   {
+      for (TEveProjectable::ProjList_i i = pable->BeginProjecteds(); i != pable->EndProjecteds(); ++i)
+      {
+         TEveProjectionManager *pmgr = (*i)->GetManager();
+         Float_t cd = pmgr->GetCurrentDepth();
+         if (same_depth) pmgr->SetCurrentDepth((*i)->GetDepth());
+
+         pmgr->SubImportElements(el, dynamic_cast<TEveElement*>(*i));
+
+         if (same_depth) pmgr->SetCurrentDepth(cd);
+      }
+
+      
+   }
+}
+
+//==============================================================================
 
 //______________________________________________________________________________
 Bool_t TEveElement::HasChild(TEveElement* el)
@@ -1410,7 +1504,24 @@ Int_t TEveElement::FindChildren(List_t& matches,
    return count;
 }
 
-/******************************************************************************/
+//______________________________________________________________________________
+TEveElement* TEveElement::FirstChild() const
+{
+   // Returns the first child element or 0 if the list is empty.
+
+   return fChildren.empty() ? 0 : fChildren.front();
+}
+
+//______________________________________________________________________________
+TEveElement* TEveElement::LastChild () const
+{
+   // Returns the last child element or 0 if the list is empty.
+
+   return fChildren.empty() ? 0 : fChildren.back();
+}
+
+
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveElement::EnableListElements(Bool_t rnr_self,  Bool_t rnr_children)
@@ -1511,7 +1622,85 @@ void TEveElement::DestroyElements()
    gEve->Redraw3D();
 }
 
-/******************************************************************************/
+//______________________________________________________________________________
+Bool_t TEveElement::GetDestroyOnZeroRefCnt() const
+{
+   // Returns state of flag determining if the element will be
+   // destroyed when reference count reaches zero.
+   // This is true by default.
+
+   return fDestroyOnZeroRefCnt;
+}
+
+//______________________________________________________________________________
+void TEveElement::SetDestroyOnZeroRefCnt(Bool_t d)
+{
+   // Sets the state of flag determining if the element will be
+   // destroyed when reference count reaches zero.
+   // This is true by default.
+
+   fDestroyOnZeroRefCnt = d;
+}
+
+//______________________________________________________________________________
+Int_t TEveElement::GetDenyDestroy() const
+{
+   // Returns the number of times deny-destroy has been requested on
+   // the element.
+
+   return fDenyDestroy;
+}
+
+//______________________________________________________________________________
+void TEveElement::IncDenyDestroy()
+{
+   // Increases the deny-destroy count of the element.
+   // Call this if you store an external pointer to the element.
+
+   ++fDenyDestroy;
+}
+
+//______________________________________________________________________________
+void TEveElement::DecDenyDestroy()
+{
+   // Decreases the deny-destroy count of the element.
+   // Call this after releasing an external pointer to the element.
+
+   if (--fDenyDestroy <= 0)
+      CheckReferenceCount("TEveElement::DecDenyDestroy ");
+}
+
+//______________________________________________________________________________
+Int_t TEveElement::GetParentIgnoreCnt() const
+{
+   // Get number of parents that should be ignored in doing
+   // reference-counting.
+   //
+   // For example, this is used when subscribing an element to a
+   // visualization-database model object.
+
+   return fParentIgnoreCnt;
+}
+
+//______________________________________________________________________________
+void TEveElement::IncParentIgnoreCnt()
+{
+   // Increase number of parents ignored in reference-counting.
+
+   ++fParentIgnoreCnt;
+}
+
+//______________________________________________________________________________
+void TEveElement::DecParentIgnoreCnt()
+{
+   // Decrease number of parents ignored in reference-counting.
+
+   if (--fParentIgnoreCnt <= 0)
+      CheckReferenceCount("TEveElement::DecParentIgnoreCnt ");
+}
+
+
+//==============================================================================
 
 //______________________________________________________________________________
 Bool_t TEveElement::HandleElementPaste(TEveElement* el)
@@ -1649,6 +1838,24 @@ UChar_t TEveElement::GetSelectedLevel() const
    return 0;
 }
 
+//______________________________________________________________________________
+void TEveElement::RecheckImpliedSelections()
+{
+   // Call this if it is possible that implied-selection or highlight
+   // has changed for this element or for implied-selection this
+   // element is member of and you want to maintain consistent
+   // selection state.
+   // This can happen if you add elements into compounds in response
+   // to user-interaction.
+
+   if (fSelected || fImpliedSelected)
+      gEve->GetSelection()->RecheckImpliedSetForElement(this);
+
+   if (fHighlighted || fImpliedHighlighted)
+      gEve->GetHighlight()->RecheckImpliedSetForElement(this);
+}
+
+
 /******************************************************************************/
 // Stamping
 /******************************************************************************/
@@ -1691,6 +1898,15 @@ const TGPicture* TEveElement::GetListTreeCheckBoxIcon()
    return fgRnrIcons[idx];
 }
 
+//______________________________________________________________________________
+const char* TEveElement::ToString(Bool_t b)
+{
+   // Convert Bool_t to string - kTRUE or kFALSE.
+   // Needed in WriteVizParams().
+
+   return b ? "kTRUE" : "kFALSE";
+}
+
 
 /******************************************************************************/
 /******************************************************************************/
@@ -1747,6 +1963,15 @@ TEveElementObjectPtr::TEveElementObjectPtr(const TEveElementObjectPtr& e) :
 }
 
 //______________________________________________________________________________
+TEveElementObjectPtr* TEveElementObjectPtr::CloneElement() const
+{
+   // Clone the element via copy constructor.
+   // Virtual from TEveElement.
+
+   return new TEveElementObjectPtr(*this);
+}
+
+//______________________________________________________________________________
 TObject* TEveElementObjectPtr::GetObject(const TEveException& eh) const
 {
    // Return external object.
@@ -1827,6 +2052,15 @@ TEveElementList::TEveElementList(const TEveElementList& e) :
 }
 
 //______________________________________________________________________________
+TEveElementList* TEveElementList::CloneElement() const
+{
+   // Clone the element via copy constructor.
+   // Virtual from TEveElement.
+
+   return new TEveElementList(*this);
+}
+
+//______________________________________________________________________________
 Bool_t TEveElementList::AcceptElement(TEveElement* el)
 {
    // Check if TEveElement el is inherited from fChildClass.
diff --git a/graf3d/eve/src/TEveGedEditor.cxx b/graf3d/eve/src/TEveGedEditor.cxx
index 3cd12cb..e500bf1 100644
--- a/graf3d/eve/src/TEveGedEditor.cxx
+++ b/graf3d/eve/src/TEveGedEditor.cxx
@@ -13,9 +13,14 @@
 #include "TEveElement.h"
 #include "TEveManager.h"
 
-#include "TGedFrame.h"
+#include "TGButton.h"
+#include "TGLabel.h"
+#include "TGToolTip.h"
+#include "TGDNDManager.h"
+#include "TGMsgBox.h"
 
 #include "TClass.h"
+#include "TContextMenu.h"
 
 //==============================================================================
 // TEveGedEditor
@@ -28,15 +33,26 @@
 
 ClassImp(TEveGedEditor);
 
+Int_t   TEveGedEditor::fgMaxExtraEditors = 10;
+TList  *TEveGedEditor::fgExtraEditors    = new TList;
+
+TContextMenu *TEveGedEditor::fgContextMenu = 0;
+
 //______________________________________________________________________________
-TEveGedEditor::TEveGedEditor(TCanvas* canvas, Int_t width, Int_t height) :
-   TGedEditor(canvas),
+TEveGedEditor::TEveGedEditor(TCanvas* canvas, UInt_t width, UInt_t height) :
+   TGedEditor(canvas, width, height),
    fElement  (0),
    fObject   (0)
 {
    // Constructor.
 
-   Resize(width, height);
+   // Remove old name-frame -- it is created in TGedEditor constructor
+   // so virtuals are not active yet.
+   fTabContainer->RemoveAll();
+   TGedFrame* nf = CreateNameFrame(fTabContainer, "Style");
+   nf->SetGedEditor(this);
+   nf->SetModelClass(0);
+   fTabContainer->AddFrame(nf, nf->GetLayoutHints());
 
    // Fix priority for TAttMarkerEditor.
    TClass* amClass = TClass::GetClass("TAttMarker");
@@ -59,6 +75,58 @@ TEveGedEditor::TEveGedEditor(TCanvas* canvas, Int_t width, Int_t height) :
 }
 
 //______________________________________________________________________________
+TEveGedEditor::~TEveGedEditor()
+{
+   // Destructor.
+
+   if (gDebug > 0)
+      Info("TEveGedEditor::~TEveGedEditor", "%p going down.", this);
+}
+
+//______________________________________________________________________________
+void TEveGedEditor::CloseWindow()
+{
+   // Called from window-manger close button.
+   // Unregister from global list and delete the window.
+
+   if (gDebug > 0)
+      Info("TEveGedEditor::CloseWindow", "%p closing.", this);
+
+   fgExtraEditors->Remove(this);
+
+   DeleteWindow();
+}
+
+//______________________________________________________________________________
+void TEveGedEditor::DeleteWindow()
+{
+   // This is exact clone of TGFrame::DeleteWindow().
+   // Needs to be overriden together with CloseWindow() otherwise CINT
+   // goes kaboom in timer execution.
+
+   if (gDebug > 0)
+      Info("TEveGedEditor::DeleteWindow", "%p shooting timer.", this);
+
+   DisplayElement(0);
+
+   if (gDNDManager) {
+      if (gDNDManager->GetMainFrame() == this)
+         gDNDManager->SetMainFrame(0);
+   }
+   if (!TestBit(kDeleteWindowCalled))
+      TTimer::SingleShot(150, IsA()->GetName(), this, "ReallyDelete()");
+   SetBit(kDeleteWindowCalled);
+}
+
+//______________________________________________________________________________
+TGedFrame* TEveGedEditor::CreateNameFrame(const TGWindow* parent, const char* /*tab_name*/)
+{
+   // Create name-frame for a tab.
+
+   return new TEveGedNameFrame(parent);
+}
+
+//______________________________________________________________________________
 TEveElement* TEveGedEditor::GetEveElement() const
 {
    // Return eve-element if it is the model object.
@@ -88,16 +156,13 @@ void TEveGedEditor::DisplayObject(TObject* obj)
    TGedEditor::SetModel(fPad, obj, kButton1Down);
 }
 
-/******************************************************************************/
+//==============================================================================
 
 //______________________________________________________________________________
 void TEveGedEditor::SetModel(TVirtualPad* pad, TObject* obj, Int_t event)
 {
    // Set model object.
 
-   // !!!! do something so that such calls from elswhere will also
-   // now the render element
-
    fElement = dynamic_cast<TEveElement*>(obj);
    fObject  = obj;
    TGedEditor::SetModel(pad, obj, event);
@@ -109,7 +174,8 @@ void TEveGedEditor::Update(TGedFrame* /*gframe*/)
    // Virtual method from TGedEditor, called on every change.
    // Propagates changes to TEveElement and TEveManager.
 
-   if (fElement) {
+   if (fElement)
+   {
       fElement->ElementChanged();
       fElement->PropagateVizParamsToProjecteds();
    }
@@ -117,19 +183,209 @@ void TEveGedEditor::Update(TGedFrame* /*gframe*/)
    gEve->Redraw3D();
 }
 
-/******************************************************************************/
+//------------------------------------------------------------------------------
+// Static functions for management of extra editors.
+//------------------------------------------------------------------------------
+
+//______________________________________________________________________________
+void TEveGedEditor::SpawnNewEditor(TObject* obj)
+{
+   // Static function to create a new extra editor.
+
+   if (fgExtraEditors->GetSize() >= fgMaxExtraEditors)
+   {
+      new TGMsgBox(gClient->GetDefaultRoot(), gEve->GetMainWindow(),
+                   "Clutter warning", 
+                   "Maximum number of extra editors reached.",
+                   kMBIconStop, kMBOk);
+   }
+
+   if (obj)
+   {
+      TEveGedEditor *ed = new TEveGedEditor();
+      ed->DisplayObject(obj);
+      ed->SetWindowName(Form("GED %s", obj->GetName()));
+
+      fgExtraEditors->Add(ed);
+   }
+}
+
+//______________________________________________________________________________
+void TEveGedEditor::ElementChanged(TEveElement* el)
+{
+   // Element was changed. Update editors showing it.
+
+   TObject *eobj = el->GetEditorObject("TEveGedEditor::ElementChanged ");
+   TObjLink *lnk = fgExtraEditors->FirstLink();
+   while (lnk)
+   {
+      TEveGedEditor *ed = (TEveGedEditor*) lnk->GetObject();
+      if (ed->GetModel() == eobj)
+         ed->DisplayElement(el);
+      lnk = lnk->Next();
+   }
+}
+
+//______________________________________________________________________________
+void TEveGedEditor::ElementDeleted(TEveElement* el)
+{
+   // Element is being deleted. Close editors showing it.
+
+   TObject *eobj = el->GetEditorObject("TEveGedEditor::ElementChanged ");
+   TObjLink *lnk = fgExtraEditors->FirstLink();
+   while (lnk)
+   {
+      TEveGedEditor *ed = (TEveGedEditor*) lnk->GetObject();
+      if (ed->GetModel() == eobj)
+      {
+         TObjLink *next = lnk->Next();
+         ed->DeleteWindow();
+         fgExtraEditors->Remove(lnk);
+         lnk = next;
+      }
+      else
+      {
+         lnk = lnk->Next();
+      }
+   }
+}
+
+//______________________________________________________________________________
+void TEveGedEditor::DestroyEditors()
+{
+   // Destroys all editors. Called from EVE termination.
+
+   while ( ! fgExtraEditors->IsEmpty())
+   {
+      TEveGedEditor *ed = (TEveGedEditor*) fgExtraEditors->First();
+      ed->DeleteWindow();
+      fgExtraEditors->RemoveFirst();
+   }
+}
+
+//______________________________________________________________________________
+TContextMenu* TEveGedEditor::GetContextMenu()
+{
+   // Return context menu object shared among eve-ged-editors.
+
+   if (fgContextMenu == 0)
+      fgContextMenu = new TContextMenu("", "");
+   return fgContextMenu;
+}
+
+
+//==============================================================================
+// TEveGedNameFrame
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Specialization of TGedNameFrame used in EVE.
+// It provides the ability to undock given editor for easier use.
+// Support for that is also provided from the TEveManager.
+
+ClassImp(TEveGedNameFrame);
+
+//______________________________________________________________________________
+TEveGedNameFrame::TEveGedNameFrame(const TGWindow *p, Int_t width, Int_t height,
+                                   UInt_t options) :
+   TGedFrame(p, width, height, options),
+   fNCButton(0)
+{
+   // Constructor.
+
+   fNCButton = new TEveGedNameTextButton(this);
+   fNCButton->SetTextColor(0x0020a0);
+   AddFrame(fNCButton, new TGLayoutHints(kLHintsNormal | kLHintsExpandX));
+   fNCButton->Connect("Clicked()", "TEveGedNameFrame", this, "SpawnEditorClone()");
+}
+
+//______________________________________________________________________________
+TEveGedNameFrame::~TEveGedNameFrame()
+{
+   // Destructor.
+}
 
-/*
-// Attempt to enable mouse-wheel in geditor -- failed.
-Bool_t TEveGedEditor::HandleButton(Event_t *event)
+//______________________________________________________________________________
+void TEveGedNameFrame::SetModel(TObject* obj)
 {
-// Handle mouse button event in container.
+   // Set model object.
 
-printf("odfjgsf\n");
-if (event->fCode == kButton4 || event->fCode == kButton5) {
-return fCan->GetContainer()->HandleButton(event);
-} else {
-return TGedEditor::HandleButton(event);
+   if (obj)
+   {
+      fNCButton->SetText(Form("%s [%s]", obj->GetName(), obj->ClassName()));
+      fNCButton->SetToolTipText(obj->GetTitle());
+      fNCButton->SetEnabled(kTRUE);
+   }
+   else
+   {
+      fNCButton->SetText("No object selected.");
+      fNCButton->SetToolTipText(0);
+      fNCButton->SetEnabled(kFALSE);
+   }
 }
+
+//______________________________________________________________________________
+void TEveGedNameFrame::SpawnEditorClone()
+{
+   // Create a new floating editor with current object.
+
+   TEveGedEditor::SpawnNewEditor(fGedEditor->GetModel());
+}
+
+
+//==============================================================================
+// TEveGedNameTextButton
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Specialization of TGTextButton for EVE name frame.
+// It opens a context-menu on right-click.
+
+ClassImp(TEveGedNameTextButton);
+
+//______________________________________________________________________________
+TEveGedNameTextButton::TEveGedNameTextButton(TEveGedNameFrame* p) :
+   TGTextButton(p, ""),
+   fFrame(p)
+{
+   // Constructor.
+
+   gVirtualX->GrabButton(fId, kAnyButton, kAnyModifier,
+                         kButtonPressMask | kButtonReleaseMask,
+                         kNone, kNone);
+}
+
+//______________________________________________________________________________
+TEveGedNameTextButton::~TEveGedNameTextButton()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+Bool_t TEveGedNameTextButton::HandleButton(Event_t* event)
+{
+   // Handle button.
+
+   if (fTip) fTip->Hide();
+   if (fState == kButtonDisabled) return kTRUE;
+
+   if (event->fCode == kButton3 && event->fType == kButtonPress)
+   {
+      TEveGedEditor *eged = (TEveGedEditor*) fFrame->GetGedEditor();
+      TEveElement   *el   = eged->GetEveElement();
+      if (el)
+         TEveGedEditor::GetContextMenu()->Popup(event->fXRoot, event->fYRoot,
+                                                el->GetObject());
+      return 1;
+   }
+   else if (event->fCode == kButton1)
+   {
+      return TGTextButton::HandleButton(event);
+   }
+   else
+   {
+      return 0;
+   }
 }
-*/
diff --git a/graf3d/eve/src/TEveGeoNode.cxx b/graf3d/eve/src/TEveGeoNode.cxx
index 0a839b7..c211756 100644
--- a/graf3d/eve/src/TEveGeoNode.cxx
+++ b/graf3d/eve/src/TEveGeoNode.cxx
@@ -395,16 +395,20 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode*         geon,
 
    // transformation
    TEveTrans trans;
-   if (parent) if (parent) trans.SetFromArray(parent->GetTrans());
-   TGeoMatrix* gm =  tnode->GetMatrix();
-   const Double_t* rm = gm->GetRotationMatrix();
-   const Double_t* tv = gm->GetTranslation();
-   TEveTrans t;
-   t(1,1) = rm[0]; t(1,2) = rm[1]; t(1,3) = rm[2];
-   t(2,1) = rm[3]; t(2,2) = rm[4]; t(2,3) = rm[5];
-   t(3,1) = rm[6]; t(3,2) = rm[7]; t(3,3) = rm[8];
-   t(1,4) = tv[0]; t(2,4) = tv[1]; t(3,4) = tv[2];
-   trans *= t;
+   if (parent)
+      trans.SetFromArray(parent->GetTrans());
+   if (tnode)
+   {
+      TGeoMatrix     *gm = tnode->GetMatrix();
+      const Double_t *rm = gm->GetRotationMatrix();
+      const Double_t *tv = gm->GetTranslation();
+      TEveTrans t;
+      t(1,1) = rm[0]; t(1,2) = rm[1]; t(1,3) = rm[2];
+      t(2,1) = rm[3]; t(2,2) = rm[4]; t(2,3) = rm[5];
+      t(3,1) = rm[6]; t(3,2) = rm[7]; t(3,3) = rm[8];
+      t(1,4) = tv[0]; t(2,4) = tv[1]; t(3,4) = tv[2];
+      trans *= t;
+   }
 
    TEveGeoShapeExtract* gse = new TEveGeoShapeExtract(geon->GetName(), geon->GetTitle());
    gse->SetTrans(trans.Array());
@@ -418,8 +422,8 @@ TEveGeoShapeExtract* TEveGeoNode::DumpShapeTree(TEveGeoNode*         geon,
       rgba[2] = c->GetBlue();
    }
    gse->SetRGBA(rgba);
-   Bool_t rnr     = tnode->IsVisible();
-   Bool_t rnr_els = tnode->IsVisDaughters();
+   Bool_t rnr     = tnode ? tnode->IsVisible()      : geon->GetRnrSelf();
+   Bool_t rnr_els = tnode ? tnode->IsVisDaughters() : geon->GetRnrChildren();
    if (tvolume) {
       rnr     = rnr     && tvolume->IsVisible();
       rnr_els = rnr_els && tvolume->IsVisDaughters();
diff --git a/graf3d/eve/src/TEveJetCone.cxx b/graf3d/eve/src/TEveJetCone.cxx
index 43e4849..1cf9c5c 100644
--- a/graf3d/eve/src/TEveJetCone.cxx
+++ b/graf3d/eve/src/TEveJetCone.cxx
@@ -12,11 +12,6 @@
 #include "TEveJetCone.h"
 #include "TEveTrans.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-
 #include "TMath.h"
 
 //______________________________________________________________________________
@@ -76,23 +71,7 @@ void TEveJetCone::Paint(Option_t*)
    // Paint object.
    // This is for direct rendering (using TEveJetConeGL class).
 
-   static const TEveException eh("TEveJetCone::Paint ");
-
-   if (fRnrSelf == kFALSE) return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveLine.cxx b/graf3d/eve/src/TEveLine.cxx
index 5afc224..54f2a49 100644
--- a/graf3d/eve/src/TEveLine.cxx
+++ b/graf3d/eve/src/TEveLine.cxx
@@ -52,6 +52,14 @@ TEveLine::TEveLine(const char* name, Int_t n_points, ETreeVarType_e tv_type) :
 }
 
 //______________________________________________________________________________
+const TGPicture* TEveLine::GetListTreeIcon(Bool_t)
+{
+   // Returns list-tree icon for TEveLine.
+
+   return fgListTreeIcons[8];
+}
+
+//______________________________________________________________________________
 void TEveLine::SetMarkerColor(Color_t col)
 {
    // Set marker color. Propagate to projected lines.
@@ -63,7 +71,7 @@ void TEveLine::SetMarkerColor(Color_t col)
       if (l && fMarkerColor == l->GetMarkerColor())
       {
          l->SetMarkerColor(col);
-         l->ElementChanged();
+         l->StampObjProps();
       }
       ++pi;
    }
@@ -71,6 +79,46 @@ void TEveLine::SetMarkerColor(Color_t col)
 }
 
 //______________________________________________________________________________
+void TEveLine::SetLineStyle(Style_t lstyle)
+{
+   // Set line-style of the line.
+   // The style is propagated to projecteds.
+
+   std::list<TEveProjected*>::iterator pi = fProjectedList.begin();
+   while (pi != fProjectedList.end())
+   {
+      TEveLine* pt = dynamic_cast<TEveLine*>(*pi);
+      if (pt)
+      {
+         pt->SetLineStyle(lstyle);
+         pt->StampObjProps();
+      }
+      ++pi;
+   }
+   TAttLine::SetLineStyle(lstyle);
+}
+
+//______________________________________________________________________________
+void TEveLine::SetLineWidth(Width_t lwidth)
+{
+   // Set line-style of the line.
+   // The style is propagated to projecteds.
+
+   std::list<TEveProjected*>::iterator pi = fProjectedList.begin();
+   while (pi != fProjectedList.end())
+   {
+      TEveLine* pt = dynamic_cast<TEveLine*>(*pi);
+      if (pt)
+      {
+         pt->SetLineWidth(lwidth);
+         pt->StampObjProps();
+      }
+      ++pi;
+   }
+   TAttLine::SetLineWidth(lwidth);
+}
+
+//______________________________________________________________________________
 void TEveLine::SetRnrLine(Bool_t r)
 {
    // Set rendering of line. Propagate to projected lines.
@@ -112,6 +160,7 @@ void TEveLine::SetRnrPoints(Bool_t r)
 void TEveLine::SetSmooth(Bool_t r)
 {
    // Set smooth rendering. Propagate to projected lines.
+
    fSmooth = r;
    std::list<TEveProjected*>::iterator pi = fProjectedList.begin();
    while (pi != fProjectedList.end())
@@ -218,9 +267,9 @@ void TEveLine::WriteVizParams(ostream& out, const TString& var)
 
    TString t = "   " + var + "->";
    TAttLine::SaveLineAttributes(out, var);
-   out << t << "SetRnrLine("   << fRnrLine   << ");\n";
-   out << t << "SetRnrPoints(" << fRnrPoints << ");\n";
-   out << t << "SetSmooth("    << fSmooth    << ");\n";
+   out << t << "SetRnrLine("   << ToString(fRnrLine)   << ");\n";
+   out << t << "SetRnrPoints(" << ToString(fRnrPoints) << ");\n";
+   out << t << "SetSmooth("    << ToString(fSmooth)    << ");\n";
 }
 
 //______________________________________________________________________________
@@ -231,6 +280,28 @@ TClass* TEveLine::ProjectedClass(const TEveProjection*) const
    return TEveLineProjected::Class();
 }
 
+//------------------------------------------------------------------------------
+
+//______________________________________________________________________________
+Bool_t TEveLine::GetDefaultSmooth()
+{
+   // Get default value for smooth-line drawing flag.
+   // Static function.
+
+   return fgDefaultSmooth;
+}
+
+//______________________________________________________________________________
+void TEveLine::SetDefaultSmooth(Bool_t r)
+{
+   // Set default value for smooth-line drawing flag (default kFALSE).
+   // Static function.
+
+   fgDefaultSmooth = r;
+}
+
+
+
 //==============================================================================
 //==============================================================================
 // TEveLineProjected
@@ -282,7 +353,8 @@ void TEveLineProjected::UpdateProjection()
    // Virtual from TEveProjected.
 
    TEveProjection& proj = * fManager->GetProjection();
-   TEveLine      & als   = * dynamic_cast<TEveLine*>(fProjectable);
+   TEveLine      & als  = * dynamic_cast<TEveLine*>(fProjectable);
+   TEveTrans      *tr   =   als.PtrMainTrans(kFALSE);
 
    Int_t n = als.Size();
    Reset(n);
@@ -290,7 +362,6 @@ void TEveLineProjected::UpdateProjection()
    Float_t *o = als.GetP(), *p = GetP();
    for (Int_t i = 0; i < n; ++i, o+=3, p+=3)
    {
-      p[0] = o[0]; p[1] = o[1]; p[2] = o[2];
-      proj.ProjectPointfv(p, fDepth);
+      proj.ProjectPointfv(tr, o, p, fDepth);
    }
 }
diff --git a/graf3d/eve/src/TEveManager.cxx b/graf3d/eve/src/TEveManager.cxx
index beac964..d07ac0f 100644
--- a/graf3d/eve/src/TEveManager.cxx
+++ b/graf3d/eve/src/TEveManager.cxx
@@ -62,8 +62,6 @@ TEveManager::TEveManager(UInt_t w, UInt_t h, Bool_t map_window, Option_t* opt) :
    fGeometries  (0),
    fGeometryAliases (0),
    fBrowser     (0),
-   fEditor      (0),
-   fStatusBar   (0),
 
    fMacroFolder (0),
 
@@ -131,7 +129,6 @@ TEveManager::TEveManager(UInt_t w, UInt_t h, Bool_t map_window, Option_t* opt) :
 
    // Build GUI
    fBrowser   = new TEveBrowser(w, h);
-   fStatusBar = fBrowser->GetStatusBar();
    fBrowser->Connect("CloseWindow()", "TEveManager", this, "CloseEveWindow()");
 
    // ListTreeEditor
@@ -139,7 +136,6 @@ TEveManager::TEveManager(UInt_t w, UInt_t h, Bool_t map_window, Option_t* opt) :
    fLTEFrame = new TEveGListTreeEditorFrame;
    fBrowser->StopEmbedding("Eve");
    fLTEFrame->ConnectSignals();
-   fEditor = fLTEFrame->fEditor;
 
    // See how many GL viewers are requested, remove from options.
    TString str_opt(opt);
@@ -242,24 +238,12 @@ void TEveManager::ClearOrphanage()
    fUseOrphanage = old_state;
 }
 
-/******************************************************************************/
-
-//______________________________________________________________________________
-TCanvas* TEveManager::AddCanvasTab(const char* name)
-{
-   // Add a new canvas tab.
-
-   fBrowser->StartEmbedding(1, -1);
-   TCanvas* c = new TCanvas;
-   fBrowser->StopEmbedding(name);
-
-   return c;
-}
+//==============================================================================
 
 //______________________________________________________________________________
 TGWindow* TEveManager::GetMainWindow() const
 {
-   // Get the main window, i.e. the first created reve-browser.
+   // Get the main window, i.e. EVE-browser.
 
    return fBrowser;
 }
@@ -282,6 +266,36 @@ TGLViewer* TEveManager::GetDefaultGLViewer() const
 }
 
 //______________________________________________________________________________
+TEveGedEditor* TEveManager::GetEditor() const
+{
+   // Returns main object editor.
+
+   return fLTEFrame->GetEditor();
+}
+
+//______________________________________________________________________________
+TGStatusBar* TEveManager::GetStatusBar() const
+{
+   // Returns main window status bar.
+
+   return fBrowser->GetStatusBar();
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+TCanvas* TEveManager::AddCanvasTab(const char* name)
+{
+   // Add a new canvas tab.
+
+   fBrowser->StartEmbedding(1, -1);
+   TCanvas* c = new TCanvas;
+   fBrowser->StopEmbedding(name);
+
+   return c;
+}
+
+//______________________________________________________________________________
 TEveViewer* TEveManager::SpawnNewViewer(const char* name, const char* title,
                                         Bool_t embed)
 {
@@ -305,7 +319,7 @@ TEveViewer* TEveManager::SpawnNewViewer(const char* name, const char* title,
    }
 
    TEveViewer* v = new TEveViewer(name, title);
-   v->SpawnGLViewer(embed ? fEditor : 0);
+   v->SpawnGLViewer(embed ? GetEditor() : 0);
 
    slot->ReplaceWindow(v);
 
@@ -347,7 +361,7 @@ void TEveManager::EditElement(TEveElement* element)
 
    static const TEveException eh("TEveManager::EditElement ");
 
-   fEditor->DisplayElement(element);
+   GetEditor()->DisplayElement(element);
 }
 
 /******************************************************************************/
@@ -394,8 +408,9 @@ void TEveManager::DoRedraw3D()
    // but more can come).
    for (TEveElement::Set_i i = fStampedElements.begin(); i != fStampedElements.end(); ++i)
    {
-      if (fEditor->GetModel() == (*i)->GetEditorObject(eh))
-         EditElement((*i));
+      if (GetEditor()->GetModel() == (*i)->GetEditorObject(eh))
+         EditElement(*i);
+      TEveGedEditor::ElementChanged(*i);
 
       (*i)->ClearStamps();
    }
@@ -427,8 +442,9 @@ void TEveManager::ElementChanged(TEveElement* element, Bool_t update_scenes, Boo
 
    static const TEveException eh("TEveElement::ElementChanged ");
 
-   if (fEditor->GetModel() == element->GetEditorObject(eh))
+   if (GetEditor()->GetModel() == element->GetEditorObject(eh))
       EditElement(element);
+   TEveGedEditor::ElementChanged(element);
 
    if (update_scenes) {
       TEveElement::List_t scenes;
@@ -548,8 +564,9 @@ void TEveManager::PreDeleteElement(TEveElement* element)
    // Called from TEveElement prior to its destruction so the
    // framework components (like object editor) can unreference it.
 
-   if (fEditor->GetEveElement() == element)
+   if (GetEditor()->GetEveElement() == element)
       EditElement(0);
+   TEveGedEditor::ElementDeleted(element);
 
    if (fScenes)
       fScenes->DestroyElementRenderers(element);
@@ -584,7 +601,7 @@ Bool_t TEveManager::ElementPaste(TEveElement* element)
    // The object to paste is taken from the editor (this is not
    // exactly right) and handed to 'element' for pasting.
 
-   TEveElement* src = fEditor->GetEveElement();
+   TEveElement* src = GetEditor()->GetEveElement();
    if (src)
       return element->HandleElementPaste(src);
    return kFALSE;
@@ -617,17 +634,22 @@ Bool_t TEveManager::InsertVizDBEntry(const TString& tag, TEveElement* model,
    {
       if (replace)
       {
+         model->IncDenyDestroy();
+         model->SetRnrChildren(kFALSE);
+
          TEveElement* old_model = dynamic_cast<TEveElement*>(pair->Value());
-         for (TEveElement::List_i i = old_model->BeginChildren(); i != old_model->EndChildren(); ++i)
+         while (old_model->HasChildren())
          {
-            (*i)->SetVizModel(model);
+            TEveElement *el = old_model->FirstChild();
+            el->SetVizModel(model);
             if (update)
-               (*i)->CopyVizParams(model);
+            {
+               el->CopyVizParams(model);
+               el->PropagateVizParamsToProjecteds();
+            }
          }
          old_model->DecDenyDestroy();
-         old_model->Destroy();
-         model->IncDenyDestroy();
-         model->SetRnrChildren(kFALSE);
+
          pair->SetValue(dynamic_cast<TObject*>(model));
          return kTRUE;
       }
@@ -692,6 +714,7 @@ void TEveManager::LoadVizDB(const TString& filename)
    // how the registered entries are handled.
 
    TEveUtil::Macro(filename);
+   Redraw3D();
 }
 
 //______________________________________________________________________________
@@ -705,7 +728,10 @@ void TEveManager::SaveVizDB(const TString& filename)
       return;
    }
 
-   ofstream out(filename, ios::out | ios::trunc);
+   TString exp_filename(filename);
+   gSystem->ExpandPathName(exp_filename);
+
+   ofstream out(exp_filename, ios::out | ios::trunc);
    out << "void " << re[1] << "()\n";
    out << "{\n";
    out << "   TEveManager::Create();\n";
@@ -911,6 +937,8 @@ void TEveManager::Terminate()
 
    if (!gEve) return;
 
+   TEveGedEditor::DestroyEditors();
+
    TEveGListTreeEditorFrame *lf = gEve->fLTEFrame;
    TEveBrowser              *b  = gEve->GetBrowser();
 
diff --git a/graf3d/eve/src/TEvePlot3D.cxx b/graf3d/eve/src/TEvePlot3D.cxx
index e6c6dd7..874d763 100644
--- a/graf3d/eve/src/TEvePlot3D.cxx
+++ b/graf3d/eve/src/TEvePlot3D.cxx
@@ -12,11 +12,6 @@
 #include "TEvePlot3D.h"
 #include "TEveTrans.h"
 
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-
 
 //______________________________________________________________________________
 // Description of TEvePlot3D
@@ -35,44 +30,10 @@ TEvePlot3D::TEvePlot3D(const char* n, const char* t) :
    InitMainTrans();
 }
 
-
-/******************************************************************************/
-
-/*
-// For now use true sizes of plots.
-//______________________________________________________________________________
-void TEvePlot3D::ComputeBBox()
-{
-   // Compute bounding-box of the data.
-
-   if (fPlot)
-      BBoxZero(); // should be BBoxZero(0.5); once the plots are stuffed into unit box.
-   else
-      BBoxZero();
-}
-*/
-
 //______________________________________________________________________________
-void TEvePlot3D::Paint(Option_t*)
+void TEvePlot3D::Paint(Option_t* )
 {
-   // Paint object.
-   // This is for direct rendering (using TEvePlot3DGL class).
-
-   static const TEveException eh("TEvePlot3D::Paint ");
-
-   if (fRnrSelf == kFALSE) return;
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
+   // Paint this object. Only direct rendering is supported.
 
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
diff --git a/graf3d/eve/src/TEvePointSet.cxx b/graf3d/eve/src/TEvePointSet.cxx
index d1cca9b..286686c 100644
--- a/graf3d/eve/src/TEvePointSet.cxx
+++ b/graf3d/eve/src/TEvePointSet.cxx
@@ -20,9 +20,7 @@
 #include "TF3.h"
 
 #include "TColor.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualViewer3D.h"
+
 
 //==============================================================================
 //==============================================================================
@@ -167,8 +165,10 @@ void TEvePointSet::Reset(Int_t n_points, Int_t n_int_ids)
 
    delete [] fP; fP = 0;
    fN = n_points;
-   if (fN) fP = new Float_t [3*fN];
-   memset(fP, 0, 3*fN*sizeof(Float_t));
+   if (fN) {
+      fP = new Float_t [3*fN];
+      memset(fP, 0, 3*fN*sizeof(Float_t));
+   }
    fLastPoint = -1;
    ClearIds();
    delete fIntIds; fIntIds = 0;
@@ -256,27 +256,55 @@ void TEvePointSet::SetPointIntIds(Int_t n, Int_t* ids)
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEvePointSet::Paint(Option_t* /*option*/)
+void TEvePointSet::SetMarkerStyle(Style_t mstyle)
 {
-   // Paint point-set.
+   // Set marker style, propagate to projecteds.
 
-   static const TEveException eh("TEvePointSet::Paint ");
+   static const TEveException eh("TEvePointSet::SetMarkerStyle ");
 
-   if (fRnrSelf == kFALSE) return;
+   std::list<TEveProjected*>::iterator pi = fProjectedList.begin();
+   while (pi != fProjectedList.end())
+   {
+      TEvePointSet* pt = dynamic_cast<TEvePointSet*>(*pi);
+      if (pt)
+      {
+         pt->SetMarkerStyle(mstyle);
+         pt->StampObjProps();
+      }
+      ++pi;
+   }
+   TAttMarker::SetMarkerStyle(mstyle);
+}
 
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
+//______________________________________________________________________________
+void TEvePointSet::SetMarkerSize(Size_t msize)
+{
+   // Set marker size, propagate to projecteds.
 
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
+   static const TEveException eh("TEvePointSet::SetMarkerSize ");
 
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eh, "only direct GL rendering supported.");
+   std::list<TEveProjected*>::iterator pi = fProjectedList.begin();
+   while (pi != fProjectedList.end())
+   {
+      TEvePointSet* pt = dynamic_cast<TEvePointSet*>(*pi);
+      if (pt)
+      {
+         pt->SetMarkerSize(msize);
+         pt->StampObjProps();
+      }
+      ++pi;
+   }
+   TAttMarker::SetMarkerSize(msize);
+}
+
+/******************************************************************************/
+
+//______________________________________________________________________________
+void TEvePointSet::Paint(Option_t*)
+{
+   // Paint point-set.
+
+   PaintStandard(this);
 }
 
 /******************************************************************************/
@@ -782,8 +810,9 @@ void TEvePointSetProjected::UpdateProjection()
    // Re-apply the projection.
    // Virtual from TEveProjected.
 
-   TEveProjection& proj = * fManager->GetProjection();
-   TEvePointSet  & ps   = * dynamic_cast<TEvePointSet*>(fProjectable);
+   TEveProjection &proj = * fManager->GetProjection();
+   TEvePointSet   &ps   = * dynamic_cast<TEvePointSet*>(fProjectable);
+   TEveTrans      *tr   =   ps.PtrMainTrans(kFALSE);
 
    Int_t n = ps.Size();
    Reset(n);
@@ -791,7 +820,16 @@ void TEvePointSetProjected::UpdateProjection()
    Float_t *o = ps.GetP(), *p = GetP();
    for (Int_t i = 0; i < n; ++i, o+=3, p+=3)
    {
-      p[0] = o[0]; p[1] = o[1]; p[2] = o[2];
-      proj.ProjectPoint(p[0], p[1], p[2], fDepth);
+      proj.ProjectPointfv(tr, o, p, fDepth);
    }
 }
+
+//______________________________________________________________________________
+void TEvePointSetProjected::PointSelected(Int_t id)
+{
+   // Virtual method of base class TPointSet3D.
+   // Forward to projectable.
+
+   TEvePointSet *ps = dynamic_cast<TEvePointSet*>(fProjectable);
+   ps->PointSelected(id);
+}
diff --git a/graf3d/eve/src/TEvePolygonSetProjected.cxx b/graf3d/eve/src/TEvePolygonSetProjected.cxx
index b39d8e7..0e8e349 100644
--- a/graf3d/eve/src/TEvePolygonSetProjected.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjected.cxx
@@ -10,7 +10,6 @@
  *************************************************************************/
 
 #include "TEvePolygonSetProjected.h"
-#include "TEveVSDStructs.h"
 #include "TEveGeoShape.h"
 #include "TEveProjectionManager.h"
 
@@ -29,8 +28,10 @@ struct Seg_t
 
    Seg_t(Int_t i1=-1, Int_t i2=-1) : fV1(i1), fV2(i2) {}
 };
+
 typedef std::list<Seg_t>           LSeg_t;
 typedef std::list<Seg_t>::iterator LSegIt_t;
+
 }
 
 //==============================================================================
@@ -50,22 +51,12 @@ ClassImp(TEvePolygonSetProjected);
 
 //______________________________________________________________________________
 TEvePolygonSetProjected::TEvePolygonSetProjected(const char* n, const char* t) :
-   TEveElementList(n, t),
-
+   TEveShape(n, t),
    fBuff(0),
-
    fNPnts(0),
-   fPnts(0),
-
-   fFillColor(5),
-   fLineColor(3),
-   fLineWidth(1),
-
-   fHighlightFrame(kTRUE)
+   fPnts(0)
 {
    // Constructor.
-
-   SetMainColorPtr(&fFillColor);
 }
 
 //______________________________________________________________________________
@@ -79,6 +70,23 @@ TEvePolygonSetProjected::~TEvePolygonSetProjected()
 }
 
 //______________________________________________________________________________
+void TEvePolygonSetProjected::ComputeBBox()
+{
+   // Override of virtual method from TAttBBox.
+
+   if (fNPnts > 0) {
+      BBoxInit();
+      for (Int_t pi = 0; pi < fNPnts; ++pi)
+         BBoxCheckPoint(fPnts[pi].fX, fPnts[pi].fY, fPnts[pi].fZ);
+   } else {
+      BBoxZero();
+   }
+}
+
+
+//==============================================================================
+
+//______________________________________________________________________________
 void TEvePolygonSetProjected::SetProjection(TEveProjectionManager* mng,
                                             TEveProjectable* model)
 {
@@ -158,7 +166,7 @@ Int_t* TEvePolygonSetProjected::ProjectAndReducePoints()
       idxMap[v] = -1;
       for (Int_t k = 0; k < fNPnts; ++k)
       {
-         if(pnts[v].SquareDistance(pnts[ra[k]]) < TEveProjection::fgEps*TEveProjection::fgEps)
+         if (pnts[v].SquareDistance(pnts[ra[k]]) < TEveProjection::fgEpsSqr)
          {
             idxMap[v] = k;
             break;
@@ -284,12 +292,12 @@ Float_t TEvePolygonSetProjected::MakePolygonsFromBP(Int_t* idxMap)
          Int_t mv2 = idxMap[(*it).fV2];
          accepted = projection->AcceptSegment(fPnts[mv1], fPnts[mv2], TEveProjection::fgEps);
 
-         if(accepted == kFALSE)
+         if (accepted == kFALSE)
          {
             pp.clear();
             break;
          }
-         if(tail != pp.back()) pp.push_back(tail);
+         if (tail != pp.back()) pp.push_back(tail);
          tail = (mv1 == tail) ? mv2 :mv1;
       }
       // DirectDraw() implementation: last and first vertices should not be equal
@@ -373,8 +381,6 @@ Float_t TEvePolygonSetProjected::MakePolygonsFromBS(Int_t* idxMap)
    return surf;
 }
 
-/******************************************************************************/
-
 //______________________________________________________________________________
 void  TEvePolygonSetProjected::ProjectBuffer3D()
 {
@@ -423,60 +429,6 @@ void  TEvePolygonSetProjected::ProjectBuffer3D()
 }
 
 //______________________________________________________________________________
-void TEvePolygonSetProjected::ComputeBBox()
-{
-   // Override of virtual method from TAttBBox.
-
-   if (fNPnts > 0) {
-      BBoxInit();
-      for (Int_t pi = 0; pi < fNPnts; ++pi)
-         BBoxCheckPoint(fPnts[pi].fX, fPnts[pi].fY, fPnts[pi].fZ);
-   } else {
-      BBoxZero();
-   }
-}
-
-//______________________________________________________________________________
-void TEvePolygonSetProjected::SetMainColor(Color_t color)
-{
-   // Set main color.
-   // Override so that line-color can also be changed if it is equal
-   // to fill color (which is treated as main color).
-
-   if (fFillColor == fLineColor) {
-      fLineColor = color;
-      StampObjProps();
-   }
-   TEveElementList::SetMainColor(color);
-}
-
-//______________________________________________________________________________
-void TEvePolygonSetProjected::Paint(Option_t* )
-{
-   // Paint this object. Only direct rendering is supported.
-
-   static const TEveException eh("TEvePolygonSetProjected::Paint ");
-
-   if (fNPnts == 0) return;
-   TBuffer3D buffer(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buffer.fID           = this;
-   buffer.fColor        = GetMainColor();
-   buffer.fTransparency = GetMainTransparency();
-   buffer.fLocalFrame   = false;
-
-   buffer.SetSectionsValid(TBuffer3D::kCore);
-
-   // We fill kCore on first pass and try with viewer
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buffer);
-   if (reqSections != TBuffer3D::kNone)
-      Warning(eh, "Viewer3D requires more (%d).", reqSections);
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
 void TEvePolygonSetProjected::DumpPolys() const
 {
    // Dump information about built polygons.
diff --git a/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx b/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx
index 9d57ec6..e69de29 100644
--- a/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjectedEditor.cxx
@@ -1,96 +0,0 @@
-// @(#)root/eve:$Id: TEvePolygonSetProjectedEditor.cxx 24047 2008-05-28 23:22:54Z matevz $
-// Authors: Matevz Tadel & Alja Mrak-Tadel: 2006, 2007
-
-/*************************************************************************
- * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
- * All rights reserved.                                                  *
- *                                                                       *
- * For the licensing terms see $ROOTSYS/LICENSE.                         *
- * For the list of contributors see $ROOTSYS/README/CREDITS.             *
- *************************************************************************/
-
-#include "TEvePolygonSetProjectedEditor.h"
-#include "TEvePolygonSetProjected.h"
-
-#include "TColor.h"
-
-#include "TGLabel.h"
-#include "TGNumberEntry.h"
-#include "TGColorSelect.h"
-#include "TGColorDialog.h"
-
-//==============================================================================
-//==============================================================================
-// TEvePolygonSetProjectedEditor
-//==============================================================================
-
-//______________________________________________________________________________
-//
-// GUI editor for class TEvePolygonSetProjected.
-
-ClassImp(TEvePolygonSetProjectedEditor);
-
-//______________________________________________________________________________
-TEvePolygonSetProjectedEditor::TEvePolygonSetProjectedEditor(const TGWindow *p,
-                                                             Int_t width, Int_t height,
-                                                             UInt_t options, Pixel_t back) :
-   TGedFrame(p, width, height, options | kVerticalFrame, back),
-   fPS(0),
-   fLineWidth(0),
-   fLineColor(0)
-{
-   // Constructor.
-
-   MakeTitle("TEvePolygonSetProjected");
-
-   {
-      TGCompositeFrame *f = new TGCompositeFrame(this, 80, 20, kHorizontalFrame);
-
-      TGLabel *l = new TGLabel(f, "LineColor:");
-      f->AddFrame(l, new TGLayoutHints(kLHintsLeft, 2, 2, 1, 1));
-      fLineColor = new TGColorSelect(f, 0, -1);
-      fLineColor->Connect("ColorSelected(Pixel_t)", "TEvePolygonSetProjectedEditor", this, "DoLineColor(Pixel_t)");
-      f->AddFrame(fLineColor, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
-
-      fLineWidth = new TGNumberEntry(f, 0., 4, -1,
-                                     TGNumberFormat::kNESRealOne, TGNumberFormat::kNEAPositive,
-                                     TGNumberFormat::kNELLimitMinMax, 0.1, 20.0);
-      fLineWidth->GetNumberEntry()->SetToolTipText("Line width of outline.");
-      fLineWidth->Connect("ValueSet(Long_t)", "TEvePolygonSetProjectedEditor", this, "DoLineWidth()");
-      f->AddFrame(fLineWidth, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
-
-      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 0, 0));
-   }
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEvePolygonSetProjectedEditor::SetModel(TObject* obj)
-{
-   // Set model object.
-
-   fPS = dynamic_cast<TEvePolygonSetProjected*>(obj);
-   fLineWidth->SetNumber(fPS->fLineWidth);
-   fLineColor->SetColor(TColor::Number2Pixel(fPS->GetLineColor()), kFALSE);
-}
-
-/******************************************************************************/
-
-//______________________________________________________________________________
-void TEvePolygonSetProjectedEditor::DoLineWidth()
-{
-   // Slot for setting line with of polygon outline.
-
-   fPS->fLineWidth = fLineWidth->GetNumber();
-   Update();
-}
-
-//______________________________________________________________________________
-void TEvePolygonSetProjectedEditor::DoLineColor(Pixel_t pixel)
-{
-   // Slot for setting line color of polygon outline.
-
-   fPS->SetLineColor(TColor::GetColor(pixel));
-   Update();
-}
diff --git a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
index 4fc6fea..f5a5453 100644
--- a/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
+++ b/graf3d/eve/src/TEvePolygonSetProjectedGL.cxx
@@ -11,7 +11,7 @@
 
 #include "TEvePolygonSetProjectedGL.h"
 #include "TEvePolygonSetProjected.h"
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
 
 #include "TGLRnrCtx.h"
 #include "TGLCamera.h"
@@ -108,11 +108,11 @@ void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glDisable(GL_CULL_FACE);
 
-   fMultiColor = (refPS.fFillColor != refPS.fLineColor);
+   fMultiColor = (refPS.fDrawFrame && refPS.fFillColor != refPS.fLineColor);
 
    // polygons
    glEnable(GL_POLYGON_OFFSET_FILL);
-   glPolygonOffset(1.,1.);
+   glPolygonOffset(1.0f,1.0f);
    GLUtesselator *tessObj = TGLUtil::GetDrawTesselator3fv();
 
    TEveVector* pnts = refPS.fPnts;
@@ -150,11 +150,14 @@ void TEvePolygonSetProjectedGL::DirectDraw(TGLRnrCtx& /*rnrCtx*/) const
    }
    glDisable(GL_POLYGON_OFFSET_FILL);
 
-   // outline
-   TGLUtil::Color(refPS.fLineColor);
-   glEnable(GL_LINE_SMOOTH);
-   TGLUtil::LineWidth(refPS.fLineWidth);
-   DrawOutline();
+   // Outline
+   if (refPS.fDrawFrame)
+   {
+      TGLUtil::Color(refPS.fLineColor);
+      glEnable(GL_LINE_SMOOTH);
+      TGLUtil::LineWidth(refPS.fLineWidth);
+      DrawOutline();
+   }
 
    glPopAttrib();
 }
diff --git a/graf3d/eve/src/TEveProjectionAxes.cxx b/graf3d/eve/src/TEveProjectionAxes.cxx
index 262ed9e..c7d5c02 100644
--- a/graf3d/eve/src/TEveProjectionAxes.cxx
+++ b/graf3d/eve/src/TEveProjectionAxes.cxx
@@ -13,13 +13,9 @@
 #include "TEveProjectionManager.h"
 #include "TMath.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-#include "TEveTrans.h"
-
 
+//______________________________________________________________________________
+//
 // Axes for non-linear projections. Show scale of TEveProjectionManager
 // children. With different step mode tick-marks can positioned
 // equidistant or placed with value monotonically increasing from lower left corner
@@ -64,26 +60,11 @@ TEveProjectionAxes::~TEveProjectionAxes()
 }
 
 //______________________________________________________________________________
-void TEveProjectionAxes::Paint(Option_t* )
+void TEveProjectionAxes::Paint(Option_t*)
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEveProjectionAxes::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveProjectionAxesGL.cxx b/graf3d/eve/src/TEveProjectionAxesGL.cxx
index eb05b32..deadc0d 100644
--- a/graf3d/eve/src/TEveProjectionAxesGL.cxx
+++ b/graf3d/eve/src/TEveProjectionAxesGL.cxx
@@ -231,8 +231,8 @@ void TEveProjectionAxesGL::SplitIntervalByVal(Float_t p1, Float_t p2, Int_t ax)
    Int_t n1a = TMath::FloorNint(fM->GetNdivisions() / 100);
    Int_t n2a = fM->GetNdivisions() - n1a * 100;
    Int_t bn1, bn2;
-   Double_t bw1, bw2; // bin with first second order
-   Double_t bl1, bh1, bl2, bh2; // bin low, high first second order
+   Double_t bw1, bw2;           // bin width first / second order
+   Double_t bl1, bh1, bl2, bh2; // bin low, high first / second order
    THLimitsFinder::Optimize(v1, v2, n1a, bl1, bh1, bn1, bw1);
    THLimitsFinder::Optimize(bl1, bl1+bw1, n2a, bl2, bh2, bn2, bw2);
 
diff --git a/graf3d/eve/src/TEveProjectionBases.cxx b/graf3d/eve/src/TEveProjectionBases.cxx
index e99f69b..5822ea2 100644
--- a/graf3d/eve/src/TEveProjectionBases.cxx
+++ b/graf3d/eve/src/TEveProjectionBases.cxx
@@ -153,6 +153,14 @@ TEveProjected::~TEveProjected()
 }
 
 //______________________________________________________________________________
+TEveElement* TEveProjected::GetProjectableAsElement() const
+{
+   // Returns fProjectable dynamic-casted to TEveElement.
+
+   return dynamic_cast<TEveElement*>(fProjectable);
+}
+
+//______________________________________________________________________________
 void TEveProjected::SetProjection(TEveProjectionManager* mng, TEveProjectable* model)
 {
    // Sets projection manager and reference in the projectable object. Method called
diff --git a/graf3d/eve/src/TEveProjectionManager.cxx b/graf3d/eve/src/TEveProjectionManager.cxx
index 2e88e1a..2136d50 100644
--- a/graf3d/eve/src/TEveProjectionManager.cxx
+++ b/graf3d/eve/src/TEveProjectionManager.cxx
@@ -282,6 +282,35 @@ TEveElement* TEveProjectionManager::ImportElements(TEveElement* el,
 }
 
 //______________________________________________________________________________
+TEveElement* TEveProjectionManager::SubImportElements(TEveElement* el,
+                                                      TEveElement* proj_parent)
+{
+   // Recursively import elements and apply projection to the newly
+   // imported objects.
+   //
+   // The proj_parent argument should be a projected replica of parent
+   // of element 'el'. This allows to insert projected children of
+   // a given element when they are added after the projection has
+   // been already performed on the parent.
+   // This is called from TEveElement::ProjectChild().
+   //
+   // Returns the projected replica of el. Can be 0, if el and none of
+   // its children are projectable.
+
+   TEveElement* new_el = ImportElementsRecurse(el, proj_parent);
+   if (new_el)
+   {
+      AssertBBox();
+      ProjectChildrenRecurse(new_el);
+      AssertBBoxExtents(0.1);
+      StampTransBBox();
+
+      UpdateDependentElsAndScenes(new_el);
+   }
+   return new_el;
+}
+
+//______________________________________________________________________________
 void TEveProjectionManager::ProjectChildrenRecurse(TEveElement* el)
 {
    // Project el (via TEveProjected::UpdateProjection()) and recurse
diff --git a/graf3d/eve/src/TEveProjections.cxx b/graf3d/eve/src/TEveProjections.cxx
index 680a554..e9d9ebd 100644
--- a/graf3d/eve/src/TEveProjections.cxx
+++ b/graf3d/eve/src/TEveProjections.cxx
@@ -10,8 +10,11 @@
  *************************************************************************/
 
 #include "TEveProjections.h"
+#include "TEveTrans.h"
 #include "TEveUtil.h"
 
+#include <limits>
+
 //==============================================================================
 //==============================================================================
 // TEveProjection
@@ -26,7 +29,8 @@
 
 ClassImp(TEveProjection);
 
-Float_t TEveProjection::fgEps = 0.005f;
+Float_t TEveProjection::fgEps    = 0.005f;
+Float_t TEveProjection::fgEpsSqr = 0.000025f;
 
 //______________________________________________________________________________
 TEveProjection::TEveProjection() :
@@ -80,6 +84,54 @@ void TEveProjection::ProjectVector(TEveVector& v, Float_t d)
 }
 
 //______________________________________________________________________________
+void TEveProjection::ProjectPointfv(const TEveTrans* t, const Float_t* p, Float_t* v, Float_t d)
+{
+   // Project float array, converting it to global coordinate system first if
+   // transformation matrix is set.
+
+   v[0] = p[0]; v[1] = p[1]; v[2] = p[2];
+   if (t)
+   {
+      t->MultiplyIP(v);
+   }
+   ProjectPoint(v[0], v[1], v[2], d);
+}
+
+//______________________________________________________________________________
+void TEveProjection::ProjectPointdv(const TEveTrans* t, const Double_t* p, Double_t* v, Float_t d)
+{
+   // Project double array, converting it to global coordinate system first if
+   // transformation matrix is set.
+   // This is a bit piggish as we convert the doubles to floats and back.
+
+   Float_t x, y, z;
+   if (t)
+   {
+      t->Multiply(p, v);
+      x = v[0]; y = v[1]; z = v[2];
+   }
+   else
+   {
+      x = p[0]; y = p[1]; z = p[2];
+   }
+   ProjectPoint(x, y, z, d);
+   v[0] = x; v[1] = y; v[2] = z;
+}
+
+//______________________________________________________________________________
+void TEveProjection::ProjectVector(const TEveTrans* t, TEveVector& v, Float_t d)
+{
+   // Project TEveVector, converting it to global coordinate system first if
+   // transformation matrix is set.
+
+   if (t)
+   {
+      t->MultiplyIP(v);
+   }
+   ProjectPoint(v.fX, v.fY, v.fZ, d);
+}
+
+//______________________________________________________________________________
 void TEveProjection::PreScaleVariable(Int_t dim, Float_t& v)
 {
    // Pre-scale single variable with pre-scale entry dim.
@@ -466,9 +518,12 @@ void TEveRhoZProjection::SetDirectionalVector(Int_t screenAxis, TEveVector& vec)
 }
 //______________________________________________________________________________
 Bool_t TEveRhoZProjection::AcceptSegment(TEveVector& v1, TEveVector& v2,
-                                         Float_t tolerance)
+                                         Float_t tolerance) const
 {
    // Check if segment of two projected points is valid.
+   //
+   // Move slightly one of the points if by shifting it by no more than
+   // tolearance the segment can become acceptable.
 
    Float_t a = fProjectedCenter.fY;
    Bool_t val = kTRUE;
@@ -491,6 +546,16 @@ Bool_t TEveRhoZProjection::AcceptSegment(TEveVector& v1, TEveVector& v2,
    return val;
 }
 
+//______________________________________________________________________________
+Int_t TEveRhoZProjection::SubSpaceId(const TEveVector& v) const
+{
+   // Return sub-space id for the point.
+   // 0 - upper half-space
+   // 1 - lowwer half-space
+
+   return v.fY > fProjectedCenter.fY ? 0 : 1;
+}
+
 
 //==============================================================================
 //==============================================================================
diff --git a/graf3d/eve/src/TEveQuadSetGL.cxx b/graf3d/eve/src/TEveQuadSetGL.cxx
index 6016527..1cc1328 100644
--- a/graf3d/eve/src/TEveQuadSetGL.cxx
+++ b/graf3d/eve/src/TEveQuadSetGL.cxx
@@ -66,7 +66,11 @@ inline Bool_t TEveQuadSetGL::SetupColor(const TEveDigitSet::DigitBase_t& q) cons
 {
    // Set color for rendering of the specified quad.
 
-   if (fM->fValueIsColor)
+   if (fM->fSingleColor)
+   {
+      return kTRUE;
+   }
+   else if (fM->fValueIsColor)
    {
       TGLUtil::Color4ubv((UChar_t*) & q.fValue);
       return kTRUE;
@@ -105,30 +109,31 @@ void TEveQuadSetGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    TEveQuadSet& mQ = * fM;
 
-   if (mQ.fPlex.Size() == 0)
-      return;
-   if ( ! mQ.fValueIsColor && mQ.fPalette == 0)
+   if (mQ.fPlex.Size() > 0)
    {
-      mQ.AssertPalette();
-   }
+      if (! mQ.fSingleColor && ! mQ.fValueIsColor && mQ.fPalette == 0)
+      {
+         mQ.AssertPalette();
+      }
 
-   glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
-   glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
-   glEnable(GL_COLOR_MATERIAL);
-   glDisable(GL_CULL_FACE);
+      glPushAttrib(GL_ENABLE_BIT | GL_POLYGON_BIT);
+      glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
+      glEnable(GL_COLOR_MATERIAL);
+      glDisable(GL_CULL_FACE);
 
-   if (mQ.fRenderMode == TEveDigitSet::kRM_Fill)
-      glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
-   else if (mQ.fRenderMode == TEveDigitSet::kRM_Line)
-      glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+      if (mQ.fRenderMode == TEveDigitSet::kRM_Fill)
+         glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+      else if (mQ.fRenderMode == TEveDigitSet::kRM_Line)
+         glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 
-   if (mQ.fDisableLigting)  glDisable(GL_LIGHTING);
+      if (mQ.fDisableLigting)  glDisable(GL_LIGHTING);
 
-   if (mQ.fQuadType < TEveQuadSet::kQT_Rectangle_End)    RenderQuads(rnrCtx);
-   else if (mQ.fQuadType < TEveQuadSet::kQT_Line_End)    RenderLines(rnrCtx);
-   else if (mQ.fQuadType < TEveQuadSet::kQT_Hexagon_End) RenderHexagons(rnrCtx);
+      if (mQ.fQuadType < TEveQuadSet::kQT_Rectangle_End)    RenderQuads(rnrCtx);
+      else if (mQ.fQuadType < TEveQuadSet::kQT_Line_End)    RenderLines(rnrCtx);
+      else if (mQ.fQuadType < TEveQuadSet::kQT_Hexagon_End) RenderHexagons(rnrCtx);
 
-   glPopAttrib();
+      glPopAttrib();
+   }
 
    if (mQ.fFrame != 0 && ! rnrCtx.SecSelection())
    {
diff --git a/graf3d/eve/src/TEveSelection.cxx b/graf3d/eve/src/TEveSelection.cxx
index f2501cb..5269b19 100644
--- a/graf3d/eve/src/TEveSelection.cxx
+++ b/graf3d/eve/src/TEveSelection.cxx
@@ -37,6 +37,7 @@ TEveSelection::TEveSelection(const char* n, const char* t) :
    fDecImpSelElement = &TEveElement::DecImpliedSelected;
 }
 
+//______________________________________________________________________________
 void TEveSelection::SetHighlightMode()
 {
    // Set to 'highlight' mode.
@@ -189,6 +190,48 @@ void TEveSelection::RemoveImpliedSelected(TEveElement* el)
    }
 }
 
+//______________________________________________________________________________
+void TEveSelection::RecheckImpliedSet(SelMap_i smi)
+{
+   // Recalculate implied-selected state for given selection entry.
+   // Add new elements to implied-selected set and increase their
+   // implied-selected count.
+
+   Set_t set;
+   smi->first->FillImpliedSelectedSet(set);
+   for (Set_i i = set.begin(); i != set.end(); ++i)
+   {
+      if (smi->second.find(*i) == smi->second.end())
+      {
+         smi->second.insert(*i);
+         ((*i)->*fIncImpSelElement)();
+      }
+   }
+}
+
+//______________________________________________________________________________
+void TEveSelection::RecheckImpliedSetForElement(TEveElement* el)
+{
+   // If given element is selected or implied-selected with this
+   // selection and recheck implied-set for given selection entry.
+
+   // Top-level selected.
+   {
+      SelMap_i i = fImpliedSelected.find(el);
+      if (i != fImpliedSelected.end())
+         RecheckImpliedSet(i);
+   }
+
+   // Implied selected, need to loop over all.
+   {
+      for (SelMap_i i = fImpliedSelected.begin(); i != fImpliedSelected.end(); ++ i)
+      {
+         if (i->second.find(el) != i->second.end())
+            RecheckImpliedSet(i);
+      }
+   }
+}
+
 
 //******************************************************************************
 // Signals
diff --git a/graf3d/eve/src/TEveShape.cxx b/graf3d/eve/src/TEveShape.cxx
new file mode 100644
index 0000000..eddbb74
--- /dev/null
+++ b/graf3d/eve/src/TEveShape.cxx
@@ -0,0 +1,210 @@
+// @(#)root/eve:$Id: TEveShape.cxx 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel, 2010
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveShape.h"
+#include "Riostream.h"
+
+//______________________________________________________________________________
+//
+// Abstract base-class for 2D/3D shapes.
+// It provides:
+// - fill color / transparency, accessible via Get/SetMainColor/Transparency;
+// - frame line color / width;
+// - flag if frame should be drawn;
+// - flag specifying whether frame or whole shape should be emphasised for
+//   highlight.
+
+ClassImp(TEveShape);
+
+//______________________________________________________________________________
+TEveShape::TEveShape(const char* n, const char* t) :
+   TEveElementList(n, t),
+   fFillColor(5),
+   fLineColor(3),
+   fLineWidth(1),
+   fDrawFrame(kTRUE),
+   fHighlightFrame(kTRUE)
+{
+   // Constructor.
+
+   SetMainColorPtr(&fFillColor);
+}
+
+//______________________________________________________________________________
+TEveShape::~TEveShape()
+{
+   // Destructor.
+}
+
+//______________________________________________________________________________
+void TEveShape::SetMainColor(Color_t color)
+{
+   // Set main color.
+   // Override so that line-color can also be changed if it is equal
+   // to fill color (which is treated as main color).
+
+   if (fFillColor == fLineColor) {
+      fLineColor = color;
+      StampObjProps();
+   }
+   TEveElementList::SetMainColor(color);
+}
+
+//______________________________________________________________________________
+void TEveShape::CopyVizParams(const TEveElement* el)
+{
+   // Copy visualization parameters from element el.
+
+   const TEveShape* m = dynamic_cast<const TEveShape*>(el);
+   if (m)
+   {
+      fFillColor = m->fFillColor;
+      fLineColor = m->fLineColor;
+      fLineWidth = m->fLineWidth;
+      fDrawFrame      = m->fDrawFrame;
+      fHighlightFrame = m->fHighlightFrame;
+   }
+
+   TEveElementList::CopyVizParams(el);
+}
+
+//______________________________________________________________________________
+void TEveShape::WriteVizParams(ostream& out, const TString& var)
+{
+   // Write visualization parameters.
+
+   TEveElementList::WriteVizParams(out, var);
+
+   TString t = "   " + var + "->";
+   out << t << "SetFillColor(" << fFillColor << ");\n";
+   out << t << "SetLineColor(" << fLineColor << ");\n";
+   out << t << "SetLineWidth(" << fLineWidth << ");\n";
+   out << t << "SetDrawFrame("      << ToString(fDrawFrame) << ");\n";
+   out << t << "SetHighlightFrame(" << ToString(fHighlightFrame) << ");\n";
+}
+
+//______________________________________________________________________________
+void TEveShape::Paint(Option_t*)
+{
+   // Paint this object. Only direct rendering is supported.
+
+   PaintStandard(this);
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+Int_t TEveShape::FindConvexHull(const vPoint_t& pin, vPoint_t& pout, TEveElement* caller)
+{
+   // Determines the convex-hull of points in pin.
+   //
+   // Adds the hull points to pout and returns the number of added points.
+   // If size of pout is less then 3 then either the number of input points
+   // was too low or they were degenerate so that the hull is actually a line
+   // segment or even a point.
+
+   Int_t N = pin.size();
+
+   // Find the minimum (bottom-left) point.
+   Int_t min_point = 0;
+   for (Int_t i = 1; i < N; ++i)
+   {
+      if (pin[i].fY < pin[min_point].fY || (pin[i].fY == pin[min_point].fY && pin[i].fX < pin[min_point].fX))
+         min_point = i;
+   }
+
+   // Calculate angles and sort.
+   std::vector<Float_t> angles(N);
+   for (Int_t i = 0; i < N; ++i)
+   {
+      angles[i] = (pin[i] - pin[min_point]).Phi();
+   }
+   std::vector<Int_t> idcs(N);
+   TMath::Sort(N, &angles[0], &idcs[0], kFALSE);
+
+   // Weed out points with the same angle -- keep the furthest only.
+   // The first point must stay.
+   if (N > 2)
+   {
+      std::vector<Int_t> new_idcs;
+      new_idcs.push_back(idcs[0]);
+      std::vector<Int_t>::iterator a, b;
+      a = idcs.begin(); ++a;
+      b = a; ++b;
+      while (b != idcs.end())
+      {
+         if (TMath::Abs(angles[*a] - angles[*b]) < 1e-5f)
+         {
+            if (pin[idcs[0]].SquareDistance(pin[*a]) < pin[idcs[0]].SquareDistance(pin[*b]))
+               a = b;
+         }
+         else
+         {
+            new_idcs.push_back(*a);
+            a = b;
+         }
+         ++b;
+      }
+      new_idcs.push_back(*a);
+      idcs.swap(new_idcs);
+   }
+
+   N = idcs.size();
+
+   // Find hull.
+   std::vector<Int_t> hull;
+   if (N > 2)
+   {
+      hull.push_back(idcs[0]);
+      hull.push_back(idcs[1]);
+      hull.push_back(idcs[2]);
+      {
+         Int_t i = 3;
+         while (i < N)
+         {
+            Int_t n = hull.size() - 1;
+            if ((pin[hull[n]] - pin[hull[n-1]]).Cross(pin[idcs[i]] - pin[hull[n]]) > 0)
+            {
+               hull.push_back(idcs[i]);
+               ++i;
+            }
+            else
+            {
+               hull.pop_back();
+            }
+         }
+      }
+   }
+   else
+   {
+      ::Warning("TEveShape::FindConvexHull()", "Polygon reduced to %d points. for '%s'.",
+              N, caller ? caller->GetElementName() : "unknown");
+      hull.swap(idcs);
+   }
+
+   // Add hull points into the output vector.
+   N = hull.size();
+   Int_t Nold = pout.size();
+   pout.resize(Nold + N);
+   for (Int_t i = 0; i < N; ++i)
+   {
+      pout[Nold + i] = pin[hull[i]];
+   }
+
+   // Print the hull.
+   // for (Int_t i = 0; i < N; ++i)
+   // {
+   //    const TEvePoint &p = pin[hull[i]];
+   //    printf("%d [%d] (%5.1f, %5.1f) %f\n", i, hull[i], p.fX, p.fY, angles[hull[i]]);
+   // }
+
+   return N;
+}
diff --git a/graf3d/eve/src/TEveShapeEditor.cxx b/graf3d/eve/src/TEveShapeEditor.cxx
new file mode 100644
index 0000000..f76a913
--- /dev/null
+++ b/graf3d/eve/src/TEveShapeEditor.cxx
@@ -0,0 +1,129 @@
+// @(#)root/eve:$Id: TEveShapeEditor.cxx 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveShapeEditor.h"
+#include "TEveShape.h"
+
+#include "TColor.h"
+
+// Cleanup these includes:
+#include "TGLabel.h"
+#include "TGButton.h"
+#include "TGNumberEntry.h"
+#include "TGColorSelect.h"
+#include "TGColorDialog.h"
+
+
+//______________________________________________________________________________
+// GUI editor for TEveShape.
+//
+
+ClassImp(TEveShapeEditor);
+
+//______________________________________________________________________________
+TEveShapeEditor::TEveShapeEditor(const TGWindow *p, Int_t width, Int_t height,
+             UInt_t options, Pixel_t back) :
+   TGedFrame(p, width, height, options | kVerticalFrame, back),
+   fM(0),
+   fLineWidth(0),
+   fLineColor(0),
+   fDrawFrame(0),
+   fHighlightFrame(0)
+{
+   // Constructor.
+
+   MakeTitle("TEveShape");
+
+   {
+      TGCompositeFrame *f = new TGCompositeFrame(this, 80, 20, kHorizontalFrame);
+
+      TGLabel *l = new TGLabel(f, "LineColor:");
+      f->AddFrame(l, new TGLayoutHints(kLHintsLeft, 2, 2, 4, 0));
+      fLineColor = new TGColorSelect(f, 0, -1);
+      fLineColor->Connect("ColorSelected(Pixel_t)", "TEveShapeEditor", this, "DoLineColor(Pixel_t)");
+      f->AddFrame(fLineColor, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
+
+      fLineWidth = new TGNumberEntry(f, 0., 4, -1,
+                                     TGNumberFormat::kNESRealOne, TGNumberFormat::kNEAPositive,
+                                     TGNumberFormat::kNELLimitMinMax, 0.1, 20.0);
+      fLineWidth->GetNumberEntry()->SetToolTipText("Line width of outline.");
+      fLineWidth->Connect("ValueSet(Long_t)", "TEveShapeEditor", this, "DoLineWidth()");
+      f->AddFrame(fLineWidth, new TGLayoutHints(kLHintsLeft, 1, 1, 1, 1));
+
+      AddFrame(f, new TGLayoutHints(kLHintsTop, 1, 1, 0, 0));
+   }
+   {
+      TGHorizontalFrame* f = new TGHorizontalFrame(this);
+
+      fDrawFrame  = new TGCheckButton(f, "Draw Frame");
+      f->AddFrame(fDrawFrame, new TGLayoutHints(kLHintsLeft, 1,2,0,0));
+      fDrawFrame->Connect("Toggled(Bool_t)", "TEveShapeEditor", this, "DoDrawFrame()");
+
+      fHighlightFrame = new TGCheckButton(f, "Highlight Frame");
+      f->AddFrame(fHighlightFrame, new TGLayoutHints(kLHintsLeft, 2,1,0,0));
+      fHighlightFrame->Connect("Toggled(Bool_t)"," TEveShapeEditor", this, "DoHighlightFrame()");
+
+      AddFrame(f, new TGLayoutHints(kLHintsTop, 0,0,2,1));
+   }
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveShapeEditor::SetModel(TObject* obj)
+{
+   // Set model object.
+
+   fM = dynamic_cast<TEveShape*>(obj);
+
+   fLineWidth->SetNumber(fM->fLineWidth);
+   fLineColor->SetColor(TColor::Number2Pixel(fM->fLineColor), kFALSE);
+   fDrawFrame     ->SetState(fM->fDrawFrame      ? kButtonDown : kButtonUp);
+   fHighlightFrame->SetState(fM->fHighlightFrame ? kButtonDown : kButtonUp);
+}
+
+//==============================================================================
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoLineWidth()
+{
+   // Slot for setting line with of polygon outline.
+
+   fM->SetLineWidth(fLineWidth->GetNumber());
+   Update();
+}
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoLineColor(Pixel_t pixel)
+{
+   // Slot for setting line color of polygon outline.
+
+   fM->SetLineColor(TColor::GetColor(pixel));
+   Update();
+}
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoDrawFrame()
+{
+   // Slot for DrawFrame.
+
+   fM->SetDrawFrame(fDrawFrame->IsOn());
+   Update();
+}
+
+//______________________________________________________________________________
+void TEveShapeEditor::DoHighlightFrame()
+{
+   // Slot for HighlightFrame.
+
+   fM->SetHighlightFrame(fHighlightFrame->IsOn());
+   Update();
+}
diff --git a/graf3d/eve/src/TEveStraightLineSet.cxx b/graf3d/eve/src/TEveStraightLineSet.cxx
index f853d4b..43be6c7 100644
--- a/graf3d/eve/src/TEveStraightLineSet.cxx
+++ b/graf3d/eve/src/TEveStraightLineSet.cxx
@@ -11,11 +11,6 @@
 
 #include "TEveStraightLineSet.h"
 
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-
 #include "TRandom.h"
 #include "TEveProjectionManager.h"
 
@@ -77,6 +72,7 @@ void TEveStraightLineSet::AddMarker(Int_t line, Float_t pos)
 
 /******************************************************************************/
 
+//______________________________________________________________________________
 void TEveStraightLineSet::CopyVizParams(const TEveElement* el)
 {
    // Copy visualization parameters from element el.
@@ -88,6 +84,7 @@ void TEveStraightLineSet::CopyVizParams(const TEveElement* el)
       TAttMarker::operator=(*m);
       fRnrMarkers = m->fRnrMarkers;
       fRnrLines   = m->fRnrLines;
+      fDepthTest  = m->fDepthTest;
    }
 
    TEveElement::CopyVizParams(el);
@@ -103,8 +100,9 @@ void TEveStraightLineSet::WriteVizParams(ostream& out, const TString& var)
    TString t = "   " + var + "->";
    TAttMarker::SaveMarkerAttributes(out, var);
    TAttLine  ::SaveLineAttributes  (out, var);
-   out << t << "SetRnrMarkers(" << fRnrMarkers << ");\n";
-   out << t << "SetRnrLines("   << fRnrLines   << ");\n";
+   out << t << "SetRnrMarkers(" << ToString(fRnrMarkers) << ");\n";
+   out << t << "SetRnrLines("   << ToString(fRnrLines)   << ");\n";
+   out << t << "SetDepthTest("  << ToString(fDepthTest)  << ");\n";
 }
 
 /******************************************************************************/
@@ -144,25 +142,11 @@ void TEveStraightLineSet::ComputeBBox()
 /******************************************************************************/
 
 //______________________________________________________________________________
-void TEveStraightLineSet::Paint(Option_t* /*option*/)
+void TEveStraightLineSet::Paint(Option_t*)
 {
    // Paint the line-set.
 
-   static const TEveException eH("TEveStraightLineSet::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   buff.fLocalFrame   = kFALSE;
-   RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 
@@ -224,6 +208,8 @@ void TEveStraightLineSetProjected::UpdateProjection()
    TEveProjection&      proj = * fManager->GetProjection();
    TEveStraightLineSet& orig = * dynamic_cast<TEveStraightLineSet*>(fProjectable);
 
+   TEveTrans *trans = orig.PtrMainTrans(kFALSE);
+
    BBoxClear();
 
    // Lines
@@ -243,14 +229,10 @@ void TEveStraightLineSetProjected::UpdateProjection()
    while (li.next())
    {
       Line_t* l = (Line_t*) li();
-      p1[0] = l->fV1[0]; p1[1] = l->fV1[1]; p1[2] = l->fV1[2];
-      p2[0] = l->fV2[0]; p2[1] = l->fV2[1]; p2[2] = l->fV2[2];
-      mx.MultiplyIP(p1);
-      mx.MultiplyIP(p2);
-      p1[0] += x; p1[1] += y; p1[2] += z;
-      p2[0] += x; p2[1] += y; p2[2] += z;
-      proj.ProjectPointfv(p1, fDepth);
-      proj.ProjectPointfv(p2, fDepth);
+
+      proj.ProjectPointfv(trans, l->fV1, p1, fDepth);
+      proj.ProjectPointfv(trans, l->fV2, p2, fDepth);
+
       AddLine(p1[0], p1[1], p1[2], p2[0], p2[1], p2[2]);
    }
 
@@ -266,7 +248,7 @@ void TEveStraightLineSetProjected::UpdateProjection()
       TEveVector t1, d, xx;
 
       t1.Set(lo->fV1); xx.Set(lo->fV2); xx -= t1; xx *= m->fPos; xx += t1;
-      proj.ProjectVector(xx, 0);
+      proj.ProjectVector(trans, xx, 0);
       t1.Set(lp->fV1); d.Set(lp->fV2); d -= t1; xx -= t1;
 
       AddMarker(m->fLineID, d.Dot(xx) / d.Mag2());
diff --git a/graf3d/eve/src/TEveText.cxx b/graf3d/eve/src/TEveText.cxx
index 26fc47a..e51432a 100644
--- a/graf3d/eve/src/TEveText.cxx
+++ b/graf3d/eve/src/TEveText.cxx
@@ -16,10 +16,6 @@
 #include "TObjArray.h"
 #include "TObjString.h"
 #include "TString.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
 #include "TMath.h"
 
 //==============================================================================
@@ -118,25 +114,11 @@ void TEveText::SetPolygonOffset(Float_t factor, Float_t units)
 }
 
 //______________________________________________________________________________
-void TEveText::Paint(Option_t* )
+void TEveText::Paint(Option_t*)
 {
    // Paint this object. Only direct rendering is supported.
 
-   static const TEveException eH("TEveText::Paint ");
-
-   TBuffer3D buff(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buff.fID           = this;
-   buff.fColor        = GetMainColor();
-   buff.fTransparency = GetMainTransparency();
-   if (HasMainTrans())
-      RefMainTrans().SetBuffer3D(buff);
-   buff.SetSectionsValid(TBuffer3D::kCore);
-
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buff);
-   if (reqSections != TBuffer3D::kNone)
-      Error(eH, "only direct GL rendering supported.");
+   PaintStandard(this);
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveTrack.cxx b/graf3d/eve/src/TEveTrack.cxx
index 49d3ccd..380a171 100644
--- a/graf3d/eve/src/TEveTrack.cxx
+++ b/graf3d/eve/src/TEveTrack.cxx
@@ -12,6 +12,7 @@
 #include "TEveTrack.h"
 #include "TEveTrackPropagator.h"
 #include "TEvePointSet.h"
+#include "TEveVSDStructs.h"
 
 #include "TPolyLine3D.h"
 #include "TMarker.h"
@@ -23,10 +24,11 @@
 #include "TEveBrowser.h"
 #include "TEveTrackProjected.h"
 
+#include "Riostream.h"
+
 #include <vector>
 #include <algorithm>
 #include <functional>
-#include <iostream>
 
 //==============================================================================
 //==============================================================================
@@ -57,6 +59,7 @@ TEveTrack::TEveTrack() :
    fStatus(0),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -78,6 +81,7 @@ TEveTrack::TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop):
    fStatus(t->GetStatusCode()),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -110,6 +114,7 @@ TEveTrack::TEveTrack(TEveMCTrack* t, TEveTrackPropagator* prop):
    fStatus(t->GetStatusCode()),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -142,6 +147,7 @@ TEveTrack::TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop) :
    fStatus(t->fStatus),
    fLockPoints(kFALSE),
    fPathMarks(),
+   fLastPMIdx(0),
    fPropagator(0),
    fBreakProjectedTracks(kBPTDefault)
 {
@@ -167,6 +173,7 @@ TEveTrack::TEveTrack(const TEveTrack& t) :
    fStatus(t.fStatus),
    fLockPoints(t.fLockPoints),
    fPathMarks(),
+   fLastPMIdx(t.fLastPMIdx),
    fPropagator(0),
    fBreakProjectedTracks(t.fBreakProjectedTracks)
 {
@@ -226,7 +233,7 @@ void TEveTrack::SetStdTitle()
 //______________________________________________________________________________
 void TEveTrack::SetTrackParams(const TEveTrack& t)
 {
-   // Copy track parameters from t.
+   // Copy track parameters from t. Track-propagator is set, too.
    // PathMarks are cleared - you can copy them via SetPathMarks(t).
    // If track 't' is locked, you should probably clone its points
    // over - use TEvePointSet::ClonePoints(t);
@@ -310,18 +317,19 @@ void TEveTrack::MakeTrack(Bool_t recurse)
    if (!fLockPoints)
    {
       Reset(0);
+      fLastPMIdx = 0;
 
       TEveTrackPropagator& rTP((fPropagator != 0) ? *fPropagator : TEveTrackPropagator::fgDefault);
 
       const Float_t maxRsq = rTP.GetMaxR() * rTP.GetMaxR();
       const Float_t maxZ   = rTP.GetMaxZ();
 
-      if (TMath::Abs(fV.fZ) < maxZ && fV.fX*fV.fX + fV.fY*fV.fY < maxRsq)
+      if ( ! TEveTrackPropagator::IsOutsideBounds(fV, maxRsq, maxZ))
       {
          TEveVector currP = fP;
          Bool_t decay = kFALSE;
          fPropagator->InitTrack(fV, fCharge);
-         for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
+         for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm, ++fLastPMIdx)
          {
             if (rTP.GetFitReferences() && pm->fType == TEvePathMark::kReference)
             {
@@ -355,12 +363,12 @@ void TEveTrack::MakeTrack(Bool_t recurse)
                   break;
                // printf("%s fit decay \n", fName.Data());
                fPropagator->GoToVertex(pm->fV, currP);
-               decay = true;
+               decay = kTRUE;
+               ++fLastPMIdx;
                break;
             }
             else if (rTP.GetFitCluster2Ds() && pm->fType == TEvePathMark::kCluster2D)
             {
-               // This if should actually be done for corrected point.
                TEveVector itsect;
                if (fPropagator->IntersectPlane(currP, pm->fV, pm->fP, itsect))
                {
@@ -368,17 +376,22 @@ void TEveTrack::MakeTrack(Bool_t recurse)
                   TEveVector vtopass = pm->fV + pm->fE*(pm->fE.Dot(delta));
                   if (TEveTrackPropagator::IsOutsideBounds(vtopass, maxRsq, maxZ))
                      break;
-                  fPropagator->GoToVertex(vtopass, currP);
+                  if ( ! fPropagator->GoToVertex(vtopass, currP))
+                     break;
                }
                else
                {
                   Warning("TEveTrack::MakeTrack", "Failed to intersect plane for Cluster2D. Ignoring path-mark.");
                }
-               break;
             }
+            else
+            {
+               if (TEveTrackPropagator::IsOutsideBounds(pm->fV, maxRsq, maxZ))
+                  break;
+            }            
          } // loop path-marks
 
-         if (!decay || rTP.GetFitDecay() == kFALSE)
+         if (!decay)
          {
             // printf("%s loop to bounds  \n",fName.Data() );
             fPropagator->GoToBounds(currP);
@@ -491,7 +504,7 @@ void TEveTrack::PrintPathMarks()
    }
 }
 
-/******************************************************************************/
+//------------------------------------------------------------------------------
 
 //______________________________________________________________________________
 void TEveTrack::SecSelected(TEveTrack* track)
@@ -502,24 +515,27 @@ void TEveTrack::SecSelected(TEveTrack* track)
    Emit("SecSelected(TEveTrack*)", (Long_t)track);
 }
 
+//------------------------------------------------------------------------------
+
 //______________________________________________________________________________
-void TEveTrack::SetLineStyle(Style_t lstyle)
+Bool_t TEveTrack::GetDefaultBreakProjectedTracks()
 {
-   // Set line-style of the track.
-   // The style is propagated to projected tracks.
+   // Return true if tracks get broken into several segments when the
+   // projected space consists of separate domains (like Rho-Z).
+   // Static function.
 
-   TAttLine::SetLineStyle(lstyle);
-   std::list<TEveProjected*>::iterator pi = fProjectedList.begin();
-   while (pi != fProjectedList.end())
-   {
-      TEveTrack* pt = dynamic_cast<TEveTrack*>(*pi);
-      if (pt)
-      {
-         pt->SetLineStyle(lstyle);
-         pt->ElementChanged();
-      }
-      ++pi;
-   }
+   return fgDefaultBreakProjectedTracks;
+}
+
+//______________________________________________________________________________
+void TEveTrack::SetDefaultBreakProjectedTracks(Bool_t bt)
+{
+   // Specify whether 2D projected tracks get broken into several
+   // segments when the projected space consists of separate domains
+   // (like Rho-Z). This is true by default.
+   // Static function.
+
+   fgDefaultBreakProjectedTracks = bt;
 }
 
 
@@ -825,7 +841,7 @@ void TEveTrackList::SetLineWidth(Width_t width)
       if (fRecurse)
          SetLineWidth(width, *i);
    }
-   fLineWidth=width;
+   fLineWidth = width;
 }
 
 //______________________________________________________________________________
@@ -859,7 +875,7 @@ void TEveTrackList::SetLineStyle(Style_t style)
       if (fRecurse)
          SetLineStyle(style, *i);
    }
-   fLineStyle=style;
+   fLineStyle = style;
 }
 
 //______________________________________________________________________________
@@ -893,7 +909,7 @@ void TEveTrackList::SetMarkerStyle(Style_t style)
       if (fRecurse)
          SetMarkerStyle(style, *i);
    }
-   fMarkerStyle=style;
+   fMarkerStyle = style;
 }
 
 //______________________________________________________________________________
@@ -927,7 +943,7 @@ void TEveTrackList::SetMarkerColor(Color_t col)
       if (fRecurse)
          SetMarkerColor(col, *i);
    }
-   fMarkerColor=col;
+   fMarkerColor = col;
 }
 
 //______________________________________________________________________________
@@ -961,7 +977,7 @@ void TEveTrackList::SetMarkerSize(Size_t size)
       if (fRecurse)
          SetMarkerSize(size, *i);
    }
-   fMarkerSize=size;
+   fMarkerSize = size;
 }
 
 //______________________________________________________________________________
@@ -1134,6 +1150,7 @@ void TEveTrackList::CopyVizParams(const TEveElement* el)
       TAttLine::operator=(*m);
       fRecurse = m->fRecurse;
       fRnrLine = m->fRnrLine;
+      fRnrPoints = m->fRnrPoints;
       fMinPt   = m->fMinPt;
       fMaxPt   = m->fMaxPt;
       fLimPt   = m->fLimPt;
@@ -1155,14 +1172,16 @@ void TEveTrackList::WriteVizParams(ostream& out, const TString& var)
    TString t = "   " + var + "->";
    TAttMarker::SaveMarkerAttributes(out, var);
    TAttLine  ::SaveLineAttributes  (out, var);
-   out << t << "SetRecurse(" << fRecurse << ");\n";
-   out << t << "SetRnrLine(" << fRnrLine << ");\n";
-   out << t << "SetMinPt("   << fMinPt   << ");\n";
-   out << t << "SetMaxPt("   << fMaxPt   << ");\n";
-   out << t << "SetLimPt("   << fLimPt   << ");\n";
-   out << t << "SetMinP("    << fMinP    << ");\n";
-   out << t << "SetMaxP("    << fMaxP    << ");\n";
-   out << t << "SetLimP("    << fLimP    << ");\n";
+   out << t << "SetRecurse("   << ToString(fRecurse)   << ");\n";
+   out << t << "SetRnrLine("   << ToString(fRnrLine)   << ");\n";
+   out << t << "SetRnrPoints(" << ToString(fRnrPoints) << ");\n";
+   // These setters are not available -- need proper AND/OR mode.
+   // out << t << "SetMinPt(" << fMinPt << ");\n";
+   // out << t << "SetMaxPt(" << fMaxPt << ");\n";
+   // out << t << "SetLimPt(" << fLimPt << ");\n";
+   // out << t << "SetMinP("  << fMinP  << ");\n";
+   // out << t << "SetMaxP("  << fMaxP  << ");\n";
+   // out << t << "SetLimP("  << fLimP  << ");\n";
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveTrackGL.cxx b/graf3d/eve/src/TEveTrackGL.cxx
index fa1fe3e..32fa812 100644
--- a/graf3d/eve/src/TEveTrackGL.cxx
+++ b/graf3d/eve/src/TEveTrackGL.cxx
@@ -77,41 +77,32 @@ void TEveTrackGL::DirectDraw(TGLRnrCtx & rnrCtx) const
 
    TEveLineGL::DirectDraw(rnrCtx);
 
-   // path-marks
-   const TEveTrack::vPathMark_t& pms = fTrack->RefPathMarks();
-   TEveTrackPropagator& rTP = *fTrack->GetPropagator();
-   if (pms.size())
+   RenderPathMarksAndFirstVertex(rnrCtx);
+}
+
+//______________________________________________________________________________
+void TEveTrackGL::RenderPathMarksAndFirstVertex(TGLRnrCtx& rnrCtx) const
+{
+   // Render path-marks and the first vertex, if required.
+
+   TEveTrackPropagator          &rTP = *fTrack->GetPropagator();
+   const TEveTrack::vPathMark_t &pms =  fTrack->RefPathMarks();
+   if ( ! pms.empty())
    {
-      Float_t* pnts = new Float_t[3*pms.size()]; // maximum
-      Int_t n = 0;
-      Bool_t accept;
-      for (TEveTrack::vPathMark_ci pm = pms.begin(); pm != pms.end(); ++pm)
+      Float_t *pnts = new Float_t[3*pms.size()]; // maximum
+      Int_t    n    = 0;
+      for (Int_t i = 0; i < fTrack->fLastPMIdx; ++i)
       {
-         accept = kFALSE;
-         switch (pm->fType)
-         {
-            case TEvePathMark::kDaughter:
-               if (rTP.GetRnrDaughters())  accept = kTRUE;
-               break;
-            case TEvePathMark::kReference:
-               if (rTP.GetRnrReferences()) accept = kTRUE;
-               break;
-            case TEvePathMark::kDecay:
-               if (rTP.GetRnrDecay())      accept = kTRUE;
-               break;
-            case TEvePathMark::kCluster2D:
-               if (rTP.GetRnrCluster2Ds()) accept = kTRUE;
-               break;
-         }
-         if (accept)
+         const TEvePathMark &pm = pms[i];
+         if ((pm.fType == TEvePathMark::kDaughter  && rTP.GetRnrDaughters())  ||
+             (pm.fType == TEvePathMark::kReference && rTP.GetRnrReferences()) ||
+             (pm.fType == TEvePathMark::kDecay     && rTP.GetRnrDecay())      ||
+             (pm.fType == TEvePathMark::kCluster2D && rTP.GetRnrCluster2Ds()))
          {
-            if ((TMath::Abs(pm->fV.fZ) < rTP.GetMaxZ()) && (pm->fV.Perp() < rTP.GetMaxR()))
-            {
-               pnts[3*n  ] = pm->fV.fX;
-               pnts[3*n+1] = pm->fV.fY;
-               pnts[3*n+2] = pm->fV.fZ;
-               ++n;
-            }
+            pnts[3*n  ] = pm.fV.fX;
+            pnts[3*n+1] = pm.fV.fY;
+            pnts[3*n+2] = pm.fV.fZ;
+            ++n;
          }
       }
       TGLUtil::RenderPolyMarkers(rTP.RefPMAtt(), pnts, n,
diff --git a/graf3d/eve/src/TEveTrackProjected.cxx b/graf3d/eve/src/TEveTrackProjected.cxx
index 2980f4e..f24520f 100644
--- a/graf3d/eve/src/TEveTrackProjected.cxx
+++ b/graf3d/eve/src/TEveTrackProjected.cxx
@@ -12,7 +12,7 @@
 #include "TEveTrackProjected.h"
 #include "TEveTrackPropagator.h"
 #include "TEveProjectionManager.h"
-#include "TEveVSDStructs.h"
+#include "TEveTrans.h"
 
 //==============================================================================
 //==============================================================================
@@ -27,9 +27,8 @@ ClassImp(TEveTrackProjected);
 
 //______________________________________________________________________________
 TEveTrackProjected::TEveTrackProjected() :
-   TEveTrack  (),
-   fOrigPnts  (0),
-   fProjection(0)
+   TEveTrack (),
+   fOrigPnts (0)
 {
    // Default constructor.
 }
@@ -42,12 +41,10 @@ void TEveTrackProjected::SetProjection(TEveProjectionManager* mng, TEveProjectab
    // This is virtual method from base-class TEveProjected.
 
    TEveProjected::SetProjection(mng, model);
-   TEveTrack* origTrack = dynamic_cast<TEveTrack*>(fProjectable);
 
-   SetTrackParams(*origTrack);
-   SetPathMarks  (*origTrack);
-
-   SetLockPoints(origTrack->GetLockPoints());
+   TEveTrack* otrack = dynamic_cast<TEveTrack*>(fProjectable);
+   SetTrackParams(*otrack);
+   SetLockPoints(otrack->GetLockPoints());
 }
 
 /******************************************************************************/
@@ -62,9 +59,14 @@ void TEveTrackProjected::SetDepthLocal(Float_t d)
    Int_t    n = Size();
    Float_t *p = GetP() + 2;
    for (Int_t i = 0; i < n; ++i, p+=3)
+   {
       *p = fDepth;
+   }
 
-   // !!!! Missing path-marks move. But they are not projected anyway
+   for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
+   {
+      pm->fV.fZ = fDepth;
+   }
 }
 
 //______________________________________________________________________________
@@ -72,7 +74,6 @@ void TEveTrackProjected::UpdateProjection()
 {
    // Virtual method from base-class TEveProjected.
 
-   fProjection = fManager->GetProjection();
    MakeTrack(kFALSE); // TEveProjectionManager makes recursive calls
 }
 
@@ -82,15 +83,17 @@ void TEveTrackProjected::GetBreakPoint(Int_t idx, Bool_t back,
 {
    // With bisection calculate break-point vertex.
 
+   TEveProjection *projection = fManager->GetProjection();
+
    TEveVector vL = fOrigPnts[idx];
    TEveVector vR = fOrigPnts[idx+1];
    TEveVector vM, vLP, vMP;
    while ((vL-vR).Mag() > 0.01)
    {
       vM.Mult(vL+vR, 0.5f);
-      vLP.Set(vL); fProjection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
-      vMP.Set(vM); fProjection->ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
-      if (fProjection->AcceptSegment(vLP, vMP, 0.0f))
+      vLP.Set(vL); projection->ProjectPoint(vLP.fX, vLP.fY, vLP.fZ, 0);
+      vMP.Set(vM); projection->ProjectPoint(vMP.fX, vMP.fY, vMP.fZ, 0);
+      if (projection->AcceptSegment(vLP, vMP, 0.0f))
       {
          vL.Set(vM);
       }
@@ -105,7 +108,7 @@ void TEveTrackProjected::GetBreakPoint(Int_t idx, Bool_t back,
    } else {
       x = vR.fX; y = vR.fY; z = vR.fZ;
    }
-   fProjection->ProjectPoint(x, y, z, fDepth);
+   projection->ProjectPoint(x, y, z, fDepth);
 }
 
 //______________________________________________________________________________
@@ -116,6 +119,8 @@ Int_t TEveTrackProjected::GetBreakPointIdx(Int_t start)
    // For example, rho-z projection separates upper and lower hemisphere
    // and tracks break into two lines when crossing the y=0 plane.
 
+   TEveProjection *projection = fManager->GetProjection();
+
    Int_t val = fLastPoint;
 
    TEveVector v1, v2;
@@ -126,7 +131,7 @@ Int_t TEveTrackProjected::GetBreakPointIdx(Int_t start)
       {
          GetPoint(i,   v1.fX, v1.fY, v1.fZ);
          GetPoint(i+1, v2.fX, v2.fY, v2.fZ);
-         if(fProjection->AcceptSegment(v1, v2, fPropagator->GetDelta()) == kFALSE)
+         if(projection->AcceptSegment(v1, v2, fPropagator->GetDelta()) == kFALSE)
          {
             val = i;
             break;
@@ -146,11 +151,18 @@ void TEveTrackProjected::MakeTrack(Bool_t recurse)
    // Call base-class, project, find break-points and insert points
    // required for full representation.
 
+   TEveTrack      *otrack     = dynamic_cast<TEveTrack*>(fProjectable);
+   TEveTrans      *trans      = otrack->PtrMainTrans(kFALSE);
+   TEveProjection *projection = fManager->GetProjection();
+
    fBreakPoints.clear();
 
-   if (GetLockPoints())
+   fPathMarks.clear();
+   SetPathMarks(*otrack);
+   if (GetLockPoints() || otrack->Size() > 0)
    {
-      ClonePoints(*dynamic_cast<TEveTrack*>(fProjectable));
+      ClonePoints(*otrack);
+      fLastPMIdx = otrack->GetLastPMIdx();
    }
    else
    {
@@ -159,15 +171,16 @@ void TEveTrackProjected::MakeTrack(Bool_t recurse)
    if (Size() == 0) return; // All points can be outside of MaxR / MaxZ limits.
 
    // Break segments additionally if required by the projection.
-   ReduceSegmentLengths(fProjection->GetMaxTrackStep());
+   ReduceSegmentLengths(projection->GetMaxTrackStep());
 
    // Project points, store originals (needed for break-points).
    Float_t *p = GetP();
    fOrigPnts  = new TEveVector[Size()];
    for (Int_t i = 0; i < Size(); ++i, p+=3)
    {
+      if (trans) trans->MultiplyIP(p);
       fOrigPnts[i].Set(p);
-      fProjection->ProjectPoint(p[0], p[1], p[2], fDepth);
+      projection->ProjectPointfv(p, fDepth);
    }
 
    Float_t x, y, z;
@@ -202,8 +215,16 @@ void TEveTrackProjected::MakeTrack(Bool_t recurse)
 
    Reset((Int_t)vvec.size());
    for (std::vector<TEveVector>::iterator i=vvec.begin(); i!=vvec.end(); ++i)
+   {
       SetNextPoint((*i).fX, (*i).fY, (*i).fZ);
+   }
    delete [] fOrigPnts;
+
+   // Project path-marks
+   for (vPathMark_i pm = fPathMarks.begin(); pm != fPathMarks.end(); ++pm)
+   {
+      projection->ProjectVector(trans, pm->fV, fDepth);
+   }
 }
 
 /******************************************************************************/
diff --git a/graf3d/eve/src/TEveTrackProjectedGL.cxx b/graf3d/eve/src/TEveTrackProjectedGL.cxx
index be49379..0c490dd 100644
--- a/graf3d/eve/src/TEveTrackProjectedGL.cxx
+++ b/graf3d/eve/src/TEveTrackProjectedGL.cxx
@@ -88,55 +88,5 @@ void TEveTrackProjectedGL::DirectDraw(TGLRnrCtx& rnrCtx) const
                                  rnrCtx.Selection());
    }
 
-   // path-marks
-   const TEveTrack::vPathMark_t& pms = fTrack->RefPathMarks();
-   TEveTrackPropagator& rTP = *fM->GetPropagator();
-   if (pms.size())
-   {
-      Float_t* pnts = new Float_t[3*pms.size()]; // maximum
-      Float_t*  pnt = pnts;
-      Int_t   pntsN = 0;
-      Bool_t accept;
-      for (TEveTrack::vPathMark_ci pm = pms.begin(); pm != pms.end(); ++pm)
-      {
-         accept = kFALSE;
-         switch (pm->fType)
-         {
-            case TEvePathMark::kDaughter:
-               if (rTP.GetRnrDaughters())  accept = kTRUE;
-               break;
-            case TEvePathMark::kReference:
-               if (rTP.GetRnrReferences()) accept = kTRUE;
-               break;
-            case TEvePathMark::kDecay:
-               if (rTP.GetRnrDecay())      accept = kTRUE;
-               break;
-            case TEvePathMark::kCluster2D:
-               if (rTP.GetRnrCluster2Ds()) accept = kTRUE;
-               break;
-         }
-         if (accept)
-         {
-            if ((TMath::Abs(pm->fV.fZ) < rTP.GetMaxZ()) && (pm->fV.Perp() < rTP.GetMaxR()))
-            {
-               pnt[0] = pm->fV.fX;
-               pnt[1] = pm->fV.fY;
-               pnt[2] = pm->fV.fZ;
-               fM->fProjection->ProjectPointfv(pnt, fM->fDepth);
-               pnt += 3;
-               ++pntsN;
-            }
-         }
-      }
-      TGLUtil::RenderPolyMarkers(rTP.RefPMAtt(), pnts, pntsN,
-                                 rnrCtx.GetPickRadius(),
-                                 rnrCtx.Selection());
-      delete [] pnts;
-   }
-
-   // fist vertex
-   if (rTP.GetRnrFV() && fTrack->GetLastPoint())
-      TGLUtil::RenderPolyMarkers(rTP.RefFVAtt(), fTrack->GetP(), 1,
-                                 rnrCtx.GetPickRadius(),
-                                 rnrCtx.Selection());
+   RenderPathMarksAndFirstVertex(rnrCtx);
 }
diff --git a/graf3d/eve/src/TEveTrackPropagator.cxx b/graf3d/eve/src/TEveTrackPropagator.cxx
index 6fe3473..1306898 100644
--- a/graf3d/eve/src/TEveTrackPropagator.cxx
+++ b/graf3d/eve/src/TEveTrackPropagator.cxx
@@ -28,17 +28,18 @@ namespace
 
 //______________________________________________________________________________
 TEveTrackPropagator::Helix_t::Helix_t() :
-   fCharge(0), fMinAng(45), fDelta(0.1),
-   fMaxStep(20.f), fCurrentStep(20.f),
+   fCharge(0),
+   fMaxAng(45), fMaxStep(20.f), fDelta(0.1),
    fPhi(0), fValid(kFALSE),
    fLam(-1), fR(-1), fPhiStep(-1), fSin(-1), fCos(-1),
+   fRKStep(20.0f),
    fPtMag(-1), fPlMag(-1), fLStep(-1)
 {
    // Default constructor.
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVector & p, const TEveVector& b)
+void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVector& p, const TEveVector& b)
 {
    // Common update code for helix and RK propagation.
 
@@ -57,7 +58,8 @@ void TEveTrackPropagator::Helix_t::UpdateCommon(const TEveVector & p, const TEve
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b, Bool_t fullUpdate)
+void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVector& b,
+                                               Bool_t full_update, Bool_t enforce_max_step)
 {
    // Update helix parameters.
 
@@ -67,7 +69,7 @@ void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVe
    TMath::Cross(fE1.Arr(), fE2.Arr(), fE3.Arr());
    if (fCharge < 0) fE3.NegateXYZ();
 
-   if (fullUpdate)
+   if (full_update)
    {
       using namespace TMath;
       Float_t a = fgkB2C * b.Mag() * Abs(fCharge);
@@ -76,23 +78,23 @@ void TEveTrackPropagator::Helix_t::UpdateHelix(const TEveVector& p, const TEveVe
          fValid = kTRUE;
 
          fR   = Abs(fPtMag / a);
-         fLam = fPl.Mag() / fPtMag;
-         if (fPlMag < 0) fLam = - fLam;
+         fLam = fPlMag / fPtMag;
 
-         // get phi step, compare fMinAng with fDelta
-         fPhiStep = fMinAng * DegToRad();
-         if (fDelta < fR)
+         // get phi step, compare fMaxAng with fDelta
+         fPhiStep = fMaxAng * DegToRad();
+         if (fR > fDelta)
          {
-            Float_t ang  = 2*ACos(1 - fDelta/fR);
-            if (ang < fPhiStep) fPhiStep = ang;
+            Float_t ang  = 2.0 * ACos(1.0f - fDelta/fR);
+            if (ang < fPhiStep)
+               fPhiStep = ang;
          }
 
          // check max step size
-         fCurrentStep = fR*fPhiStep*(1 + fLam*fLam);
-         if (fCurrentStep > fMaxStep)
-            fPhiStep *= (fMaxStep/fCurrentStep);
+         Float_t curr_step = fR * fPhiStep * Sqrt(1.0f + fLam*fLam);
+         if (curr_step > fMaxStep || enforce_max_step)
+            fPhiStep *= fMaxStep / curr_step;
 
-         fLStep = fR*fPhiStep*fLam;
+         fLStep = fR * fPhiStep * fLam;
          fSin   = Sin(fPhiStep);
          fCos   = Cos(fPhiStep);
       }
@@ -174,6 +176,9 @@ Float_t             TEveTrackPropagator::fgDefMagField = 0.5;
 const Float_t       TEveTrackPropagator::fgkB2C        = 0.299792458e-2;
 TEveTrackPropagator TEveTrackPropagator::fgDefault;
 
+Float_t             TEveTrackPropagator::fgEditorMaxR  = 2000;
+Float_t             TEveTrackPropagator::fgEditorMaxZ  = 4000;
+
 //______________________________________________________________________________
 TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
                                          TEveMagField *field) :
@@ -185,8 +190,8 @@ TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
    fMaxR    (350),
    fMaxZ    (450),
 
-   fNMax     (4096),
-   fMaxOrbs  (0.5),
+   fNMax    (4096),
+   fMaxOrbs (0.5),
 
    fEditPathMarks (kTRUE),
    fFitDaughters  (kTRUE),
@@ -197,6 +202,7 @@ TEveTrackPropagator::TEveTrackPropagator(const char* n, const char* t,
    fRnrDaughters  (kFALSE),
    fRnrReferences (kFALSE),
    fRnrDecay      (kFALSE),
+   fRnrCluster2Ds (kFALSE),
    fRnrFV         (kFALSE),
 
    fPMAtt(),
@@ -299,10 +305,7 @@ Bool_t TEveTrackPropagator::GoToVertex(TEveVector& v, TEveVector& p)
 {
    // Propagate particle with momentum p to vertex v.
 
-   if (fStepper == kHelix)
-      fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
-   else
-      fH.UpdateRK(p, fMagFieldObj->GetField(fV));
+   Update(fV, p, kTRUE);
 
    if ((v-fV).Mag() < kStepEps)
    {
@@ -319,26 +322,49 @@ void TEveTrackPropagator::GoToBounds(TEveVector& p)
    // Propagate particle to bounds.
    // Return TRUE if hit bounds.
 
-   if (fStepper == kHelix)
-      fH.UpdateHelix(p, fMagFieldObj->GetField(fV), kTRUE);
-   else
-      fH.UpdateRK(p, fMagFieldObj->GetField(fV));
+   Update(fV, p, kTRUE);
 
    fH.fValid ? LoopToBounds(p): LineToBounds(p);
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::Update(const TEveVector4& v, const TEveVector& p, Bool_t full_update)
+void TEveTrackPropagator::Update(const TEveVector4& v, const TEveVector& p,
+                                 Bool_t full_update, Bool_t enforce_max_step)
 {
    // Update helix / B-field projection state.
 
    if (fStepper == kHelix)
    {
-      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst() || full_update);
+      fH.UpdateHelix(p, fMagFieldObj->GetField(v), !fMagFieldObj->IsConst() || full_update, enforce_max_step);
    }
    else
    {
       fH.UpdateRK(p, fMagFieldObj->GetField(v));
+
+      if (full_update)
+      {
+         using namespace TMath;
+
+         Float_t a = fgkB2C * fMagFieldObj->GetMaxFieldMag() * Abs(fH.fCharge);
+         fH.fR = p.Mag() / a;
+
+         // get phi step, compare fDelta with MaxAng
+         fH.fPhiStep = fH.fMaxAng * DegToRad();
+         if (fH.fR > fH.fDelta )
+         {
+            Float_t ang  = 2.0 * ACos(1.0f - fH.fDelta/fH.fR);
+            if (ang < fH.fPhiStep)
+               fH.fPhiStep = ang;
+         }
+
+         // check against maximum step-size
+         fH.fRKStep = fH.fR * fH.fPhiStep * Sqrt(1 + fH.fLam*fH.fLam);
+         if (fH.fRKStep > fH.fMaxStep || enforce_max_step)
+         {
+            fH.fPhiStep *= fH.fMaxStep / fH.fRKStep;
+            fH.fRKStep   = fH.fMaxStep;
+         }
+      }
    }
 }
 
@@ -357,20 +383,21 @@ void TEveTrackPropagator::Step(const TEveVector4 &v, const TEveVector &p, TEveVe
       vecRKIn[0] = v.fX;
       vecRKIn[1] = v.fY;
       vecRKIn[2] = v.fZ;
-      Float_t nm = 1/p.Mag();
+      Double_t pm = p.Mag();
+      Double_t nm = 1.0 / pm;
       vecRKIn[3] = p.fX*nm;
       vecRKIn[4] = p.fY*nm;
       vecRKIn[5] = p.fZ*nm;
       vecRKIn[6] = p.Mag();
 
       Double_t vecRKOut[7];
-      OneStepRungeKutta(fH.fCharge, fH.fMaxStep, vecRKIn, vecRKOut);
+      StepRungeKutta(fH.fRKStep, vecRKIn, vecRKOut);
 
       vOut.fX = vecRKOut[0];
       vOut.fY = vecRKOut[1];
       vOut.fZ = vecRKOut[2];
-      vOut.fT = v.fT + fH.fMaxStep;
-      Double_t pm = vecRKOut[6];
+      vOut.fT = v.fT + fH.fRKStep;
+      pm = vecRKOut[6];
       pOut.fX = vecRKOut[3]*pm;
       pOut.fY = vecRKOut[4]*pm;
       pOut.fZ = vecRKOut[5]*pm;
@@ -381,6 +408,7 @@ void TEveTrackPropagator::Step(const TEveVector4 &v, const TEveVector &p, TEveVe
 void TEveTrackPropagator::LoopToBounds(TEveVector& p)
 {
    // Propagate charged particle with momentum p to bounds.
+   // It is expected that Update() with full-update was called before.
 
    const Float_t maxRsq = fMaxR*fMaxR;
 
@@ -393,7 +421,6 @@ void TEveTrackPropagator::LoopToBounds(TEveVector& p)
 
    while (fH.fPhi < maxPhi && np<fNMax)
    {
-      Update(currV, p);
       Step(currV, p, forwV, forwP);
 
       // cross R
@@ -402,10 +429,8 @@ void TEveTrackPropagator::LoopToBounds(TEveVector& p)
          Float_t t = (fMaxR - currV.R()) / (forwV.R() - currV.R());
          if (t < 0 || t > 1)
          {
-            Warning("TEveTrackPropagator::HelixToBounds",
-                    "In MaxR crossing expected t>=0 && t<=1: t=%f, r1=%f, r2=%f, MaxR=%f.",
+            Warning("HelixToBounds", "In MaxR crossing expected t>=0 && t<=1: t=%f, r1=%f, r2=%f, MaxR=%f.",
                     t, currV.R(), forwV.R(), fMaxR);
-
             return;
          }
          TEveVector d(forwV);
@@ -422,8 +447,7 @@ void TEveTrackPropagator::LoopToBounds(TEveVector& p)
          Float_t t = (fMaxZ - TMath::Abs(currV.fZ)) / TMath::Abs((forwV.fZ - currV.fZ));
          if (t < 0 || t > 1)
          {
-            Warning("TEveTrackPropagator::HelixToBounds",
-                    "In MaxZ crossing expected t>=0 && t<=1: t=%f, z1=%f, z2=%f, MaxZ=%f.",
+            Warning("HelixToBounds", "In MaxZ crossing expected t>=0 && t<=1: t=%f, z1=%f, z2=%f, MaxZ=%f.",
                     t, currV.fZ, forwV.fZ, fMaxZ);
             return;
          }
@@ -435,9 +459,11 @@ void TEveTrackPropagator::LoopToBounds(TEveVector& p)
       }
 
       currV = forwV;
-      p =  forwP;
+      p     = forwP;
+      Update(currV, p);
+
       fPoints.push_back(currV);
-      np++;
+      ++np;
    }
 }
 
@@ -445,6 +471,7 @@ void TEveTrackPropagator::LoopToBounds(TEveVector& p)
 Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
 {
    // Propagate charged particle with momentum p to vertex v.
+   // It is expected that Update() with full-update was called before.
 
    const Float_t maxRsq = fMaxR * fMaxR;
 
@@ -457,7 +484,6 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
 
    Float_t prod0=0, prod1;
 
-   Update(currV, p);
    do
    {
       Step(currV, p, forwV, forwP);
@@ -493,18 +519,16 @@ Bool_t TEveTrackPropagator::LoopToVertex(TEveVector& v, TEveVector& p)
          if (step_frac > 0)
          {
             // Step for fraction of previous step size.
-            // !!! This does not work well for helix stepper - need a way to
-            // !!! enforce it.
-            // !! Maybe special Update() method, taking fraction as argument.
-            Float_t origMaxStep = fH.fMaxStep;
+            // We pass 'enforce_max_step' flag to Update().
+            Float_t orig_max_step = fH.fMaxStep;
             fH.fMaxStep *= step_frac;
-            Update(currV, p, kTRUE);
+            Update(currV, p, kTRUE, kTRUE);
             Step(currV, p, forwV, forwP);
             p     = forwP;
             currV = forwV;
             fPoints.push_back(currV);
             ++np;
-            fH.fMaxStep = origMaxStep;
+            fH.fMaxStep = orig_max_step;
          }
 
          // Distribute offset to desired crossing point over all segment.
@@ -571,29 +595,27 @@ void TEveTrackPropagator::LineToBounds(TEveVector& p)
    Float_t tZ = 0, tR = 0, tB = 0;
 
    // time where particle intersect +/- fMaxZ
-   if (p.fZ > 0) {
-      tZ = (fMaxZ - fV.fZ)/p.fZ;
-   }
-   else  if (p.fZ < 0 ) {
-      tZ = (-1)*(fMaxZ + fV.fZ)/p.fZ;
-   }
+   if (p.fZ > 0)
+      tZ = (fMaxZ - fV.fZ) / p.fZ;
+   else if (p.fZ < 0)
+      tZ = - (fMaxZ + fV.fZ) / p.fZ;
 
    // time where particle intersects cylinder
    Double_t a = p.fX*p.fX + p.fY*p.fY;
-   Double_t b = 2*(fV.fX*p.fX + fV.fY*p.fY);
+   Double_t b = 2.0 * (fV.fX*p.fX + fV.fY*p.fY);
    Double_t c = fV.fX*fV.fX + fV.fY*fV.fY - fMaxR*fMaxR;
-   Double_t d = b*b - 4*a*c;
+   Double_t d = b*b - 4.0*a*c;
    if (d >= 0) {
-      Double_t sqrtD=TMath::Sqrt(d);
-      tR = ( -b - sqrtD )/(2*a);
+      Double_t sqrtD = TMath::Sqrt(d);
+      tR = (-b - sqrtD) / (2.0 * a);
       if (tR < 0) {
-         tR = ( -b + sqrtD )/(2*a);
+         tR = (-b + sqrtD) / (2.0 * a);
       }
       tB = tR < tZ ? tR : tZ; // compare the two times
    } else {
       tB = tZ;
    }
-   TEveVector nv(fV.fX + p.fX*tB, fV.fY + p.fY*tB, fV.fZ+ p.fZ*tB);
+   TEveVector nv(fV.fX + p.fX*tB, fV.fY + p.fY*tB, fV.fZ + p.fZ*tB);
    LineToVertex(nv);
 }
 
@@ -609,7 +631,7 @@ Bool_t TEveTrackPropagator::HelixIntersectPlane(const TEveVector& p,
    TEveVector pos(fV);
    TEveVector mom(p);
    if (fMagFieldObj->IsConst())
-      fH.UpdateHelix(mom, fMagFieldObj->GetField(pos), kFALSE);
+      fH.UpdateHelix(mom, fMagFieldObj->GetField(pos), kFALSE, kFALSE);
 
    TEveVector n(normal);
    TEveVector delta = pos - point;
@@ -630,7 +652,7 @@ Bool_t TEveTrackPropagator::HelixIntersectPlane(const TEveVector& p,
       if (new_d < d)
       {
          // We are going further away ... fail intersect.
-         Warning("TEveTrackPropagator::HelixIntersectPlane", "going away from the plane.");
+         Warning("HelixIntersectPlane", "going away from the plane.");
          return kFALSE;
       }
       if (new_d > 0)
@@ -784,9 +806,37 @@ void TEveTrackPropagator::SetMaxOrbs(Float_t x)
 //______________________________________________________________________________
 void TEveTrackPropagator::SetMinAng(Float_t x)
 {
-   // Set minimum step angle and rebuild tracks.
+   // Set maximum step angle and rebuild tracks.
+   // WARNING -- this method / variable was mis-named.
 
-   fH.fMinAng = x;
+   Warning("SetMinAng", "This method was mis-named, use SetMaxAng() instead!");
+   SetMaxAng(x);
+}
+//______________________________________________________________________________
+Float_t TEveTrackPropagator::GetMinAng() const
+{
+   // Get maximum step angle.
+   // WARNING -- this method / variable was mis-named.
+
+   Warning("GetMinAng", "This method was mis-named, use GetMaxAng() instead!");
+   return GetMaxAng();
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::SetMaxAng(Float_t x)
+{
+   // Set maximum step angle and rebuild tracks.
+
+   fH.fMaxAng = x;
+   RebuildTracks();
+}
+
+//______________________________________________________________________________
+void TEveTrackPropagator::SetMaxStep(Float_t x)
+{
+   // Set maximum step-size and rebuild tracks.
+
+   fH.fMaxStep = x;
    RebuildTracks();
 }
 
@@ -872,19 +922,9 @@ void TEveTrackPropagator::SetRnrReferences(Bool_t rnr)
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagator::SetMaxStep(Float_t x)
-{
-   // Set maximum radius and rebuild tracks.
-
-   fH.fMaxStep = x;
-   RebuildTracks();
-}
-
-//______________________________________________________________________________
-void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
-                                            Double_t* vect, Double_t* vout)
+void TEveTrackPropagator::StepRungeKutta(Double_t step,
+                                         Double_t* vect, Double_t* vout)
 {
-
   // Wrapper to step with method RungeKutta.
 
   ///	******************************************************************
@@ -953,9 +993,9 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
   for(Int_t j = 0; j < 7; j++)
     vout[j] = vect[j];
 
-  Double_t pinv   = kec * charge / vect[6];
-  Double_t tl = 0.;
-  Double_t h = step;
+  Double_t pinv   = kec * fH.fCharge / vect[6];
+  Double_t tl     = 0.;
+  Double_t h      = step;
   Double_t rest;
 
   do {
@@ -1085,7 +1125,12 @@ void TEveTrackPropagator::OneStepRungeKutta(Double_t charge, Double_t step,
     vout[5] = cba*c;
     rest = step - tl;
     if (step < 0.) rest = -rest;
-    if (rest < 1.e-5*TMath::Abs(step)) return;
+    if (rest < 1.e-5*TMath::Abs(step))
+    {
+       Float_t dot = (vout[3]*vect[3] + vout[4]*vect[4] + vout[5]*vect[5]);
+       fH.fPhi += TMath::ACos(dot);
+       return;
+    }
 
   } while(1);
 
diff --git a/graf3d/eve/src/TEveTrackPropagatorEditor.cxx b/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
index 3a0357a..b318e22 100644
--- a/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
+++ b/graf3d/eve/src/TEveTrackPropagatorEditor.cxx
@@ -43,7 +43,7 @@ TEveTrackPropagatorSubEditor::TEveTrackPropagatorSubEditor(const TGWindow *p):
    fMaxR(0),
    fMaxZ(0),
    fMaxOrbits(0),
-   fMinAng(0),
+   fMaxAng(0),
    fDelta(0),
 
    fRnrFV(0),
@@ -71,7 +71,7 @@ TEveTrackPropagatorSubEditor::TEveTrackPropagatorSubEditor(const TGWindow *p):
    fMaxR->SetLabelWidth(labelW);
    fMaxR->SetNELength(6);
    fMaxR->Build();
-   fMaxR->SetLimits(0.1, 1000, 101, TGNumberFormat::kNESRealOne);
+   fMaxR->SetLimits(0.1, TEveTrackPropagator::fgEditorMaxR, 101, TGNumberFormat::kNESRealOne);
    fMaxR->SetToolTip("Maximum radius to which the tracks will be drawn.");
    fMaxR->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMaxR()");
    AddFrame(fMaxR, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
@@ -80,7 +80,7 @@ TEveTrackPropagatorSubEditor::TEveTrackPropagatorSubEditor(const TGWindow *p):
    fMaxZ->SetLabelWidth(labelW);
    fMaxZ->SetNELength(6);
    fMaxZ->Build();
-   fMaxZ->SetLimits(0.1, 2000, 101, TGNumberFormat::kNESRealOne);
+   fMaxZ->SetLimits(0.1, TEveTrackPropagator::fgEditorMaxZ, 101, TGNumberFormat::kNESRealOne);
    fMaxZ->SetToolTip("Maximum z-coordinate to which the tracks will be drawn.");
    fMaxZ->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMaxZ()");
    AddFrame(fMaxZ, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
@@ -94,14 +94,14 @@ TEveTrackPropagatorSubEditor::TEveTrackPropagatorSubEditor(const TGWindow *p):
    fMaxOrbits->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMaxOrbits()");
    AddFrame(fMaxOrbits, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
 
-   fMinAng = new TEveGValuator(this, "Angle:", 90, 0);
-   fMinAng->SetLabelWidth(labelW);
-   fMinAng->SetNELength(6);
-   fMinAng->Build();
-   fMinAng->SetLimits(1, 160, 81, TGNumberFormat::kNESRealOne);
-   fMinAng->SetToolTip("Minimal angular step between two helix points.");
-   fMinAng->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMinAng()");
-   AddFrame(fMinAng, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
+   fMaxAng = new TEveGValuator(this, "Angle:", 90, 0);
+   fMaxAng->SetLabelWidth(labelW);
+   fMaxAng->SetNELength(6);
+   fMaxAng->Build();
+   fMaxAng->SetLimits(1, 160, 81, TGNumberFormat::kNESRealOne);
+   fMaxAng->SetToolTip("Maximal angular step between two helix points.");
+   fMaxAng->Connect("ValueSet(Double_t)", "TEveTrackPropagatorSubEditor", this, "DoMaxAng()");
+   AddFrame(fMaxAng, new TGLayoutHints(kLHintsTop, 1, 1, 1, 1));
 
    fDelta = new TEveGValuator(this, "Delta:", 90, 0);
    fDelta->SetLabelWidth(labelW);
@@ -215,7 +215,7 @@ void TEveTrackPropagatorSubEditor::SetModel(TEveTrackPropagator* m)
    fMaxR->SetValue(fM->fMaxR);
    fMaxZ->SetValue(fM->fMaxZ);
    fMaxOrbits->SetValue(fM->fMaxOrbs);
-   fMinAng->SetValue(fM->GetMinAng());
+   fMaxAng->SetValue(fM->GetMaxAng());
    fDelta->SetValue(fM->GetDelta());
 
    if(fM->fEditPathMarks)
@@ -282,11 +282,11 @@ void TEveTrackPropagatorSubEditor::DoMaxOrbits()
 }
 
 //______________________________________________________________________________
-void TEveTrackPropagatorSubEditor::DoMinAng()
+void TEveTrackPropagatorSubEditor::DoMaxAng()
 {
-   // Slot for MinAng.
+   // Slot for MaxAng.
 
-   fM->SetMinAng(fMinAng->GetValue());
+   fM->SetMaxAng(fMaxAng->GetValue());
    Changed();
 }
 
diff --git a/graf3d/eve/src/TEveTrans.cxx b/graf3d/eve/src/TEveTrans.cxx
index 7ec6451..15abe7b 100644
--- a/graf3d/eve/src/TEveTrans.cxx
+++ b/graf3d/eve/src/TEveTrans.cxx
@@ -11,12 +11,13 @@
 
 #include "TEveTrans.h"
 #include "TEveUtil.h"
-#include "TEveVSDStructs.h"
+#include "TEveVector.h"
 #include "TMath.h"
 #include "TClass.h"
 
-#include <ctype.h>
-#include <iostream>
+#include "Riostream.h"
+
+#include <cctype>
 
 #define F00  0
 #define F01  4
@@ -84,7 +85,9 @@ TEveTrans::TEveTrans(const TEveTrans& t) :
    TObject(),
    fA1(t.fA1), fA2(t.fA2), fA3(t.fA3), fAsOK(t.fAsOK),
    fUseTrans (t.fUseTrans),
-   fEditTrans(t.fEditTrans)
+   fEditTrans(t.fEditTrans),
+   fEditRotation(kTRUE),
+   fEditScale(kTRUE)
 {
    // Constructor.
 
@@ -96,7 +99,9 @@ TEveTrans::TEveTrans(const Double_t arr[16]) :
    TObject(),
    fA1(0), fA2(0), fA3(0), fAsOK(kFALSE),
    fUseTrans (kTRUE),
-   fEditTrans(kFALSE)
+   fEditTrans(kFALSE),
+   fEditRotation(kTRUE),
+   fEditScale(kTRUE)
 {
    // Constructor.
 
@@ -108,7 +113,9 @@ TEveTrans::TEveTrans(const Float_t arr[16]) :
    TObject(),
    fA1(0), fA2(0), fA3(0), fAsOK(kFALSE),
    fUseTrans (kTRUE),
-   fEditTrans(kFALSE)
+   fEditTrans(kFALSE),
+   fEditRotation(kTRUE),
+   fEditScale(kTRUE)
 {
    // Constructor.
 
@@ -825,15 +832,15 @@ void TEveTrans::RotateIP(Double_t* v) const
 }
 
 //______________________________________________________________________________
-void TEveTrans::RotateIP(TEveVector& v) const
+void TEveTrans::RotateIP(Float_t* v) const
 {
    // Rotate vector in-place. Translation is NOT applied.
 
-   Double_t t[3] = { v.fX, v.fY, v.fZ };
+   Double_t t[3] = { v[0], v[1], v[2] };
 
-   v.Set(fM[F00]*t[0] + fM[F01]*t[1] + fM[F02]*t[2],
-         fM[F10]*t[0] + fM[F11]*t[1] + fM[F12]*t[2],
-         fM[F20]*t[0] + fM[F21]*t[1] + fM[F22]*t[2]);
+   v[0] = fM[F00]*t[0] + fM[F01]*t[1] + fM[F02]*t[2];
+   v[1] = fM[F10]*t[0] + fM[F11]*t[1] + fM[F12]*t[2];
+   v[2] = fM[F20]*t[0] + fM[F21]*t[1] + fM[F22]*t[2];
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveTriangleSet.cxx b/graf3d/eve/src/TEveTriangleSet.cxx
index 6e78b79..76584e3 100644
--- a/graf3d/eve/src/TEveTriangleSet.cxx
+++ b/graf3d/eve/src/TEveTriangleSet.cxx
@@ -16,10 +16,7 @@
 #include "TMath.h"
 #include "TVector3.h"
 #include "TRandom3.h"
-#include "TVirtualPad.h"
-#include "TVirtualViewer3D.h"
-#include "TBuffer3D.h"
-#include "TBuffer3DTypes.h"
+
 
 //______________________________________________________________________________
 //
@@ -35,11 +32,9 @@ ClassImp(TEveTriangleSet);
 
 //______________________________________________________________________________
 TEveTriangleSet::TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms, Bool_t cols) :
-   TEveElement(fColor),
-   TNamed("TEveTriangleSet", 0),
+   TEveElementList("TEveTriangleSet", "", kTRUE),
    fNVerts  (nv), fVerts(0),
-   fNTrings (nt), fTrings(0), fTringNorms(0), fTringCols(0),
-   fColor   (2),  fTransp(0)
+   fNTrings (nt), fTrings(0), fTringNorms(0), fTringCols(0)
 {
    // Constructor.
 
@@ -146,26 +141,11 @@ void TEveTriangleSet::ComputeBBox()
 }
 
 //______________________________________________________________________________
-void TEveTriangleSet::Paint(Option_t* )
+void TEveTriangleSet::Paint(Option_t*)
 {
-   // Paint the object.
-
-   TBuffer3D buffer(TBuffer3DTypes::kGeneric);
-
-   // Section kCore
-   buffer.fID           = this;
-   buffer.fColor        = GetMainColor();
-   buffer.fTransparency = GetMainTransparency();
-   RefMainTrans().SetBuffer3D(buffer);
-   buffer.SetSectionsValid(TBuffer3D::kCore);
-
-   // We fill kCore on first pass and try with viewer
-   Int_t reqSections = gPad->GetViewer3D()->AddObject(buffer);
-   if (reqSections == TBuffer3D::kNone) {
-      return;
-   }
+   // Paint this object. Only direct rendering is supported.
 
-   Error("TEveTriangleSet::Paint", "only direct OpenGL rendering supported.");
+   PaintStandard(this);
 }
 
 /******************************************************************************/
diff --git a/graf3d/eve/src/TEveUtil.cxx b/graf3d/eve/src/TEveUtil.cxx
index 0c360e3..98cd01c 100644
--- a/graf3d/eve/src/TEveUtil.cxx
+++ b/graf3d/eve/src/TEveUtil.cxx
@@ -28,9 +28,10 @@
 #include "TGClient.h"
 #include "TGMimeTypes.h"
 
+#include "Riostream.h"
+
 #include <list>
 #include <algorithm>
-#include <iostream>
 #include <string>
 
 //==============================================================================
@@ -110,6 +111,7 @@ void TEveUtil::SetupGUI()
    TEveElement::fgListTreeIcons[5] = gClient->GetPicture("eve_text.gif");
    TEveElement::fgListTreeIcons[6] = gClient->GetPicture("eve_axes.xpm");
    TEveElement::fgListTreeIcons[7] = gClient->GetPicture("ofolder_t.xpm");
+   TEveElement::fgListTreeIcons[8] = gClient->GetPicture("eve_line.xpm");
 
    gClient->GetMimeTypeList()->AddType("root/tmacro", "TEveMacro",
                                        "tmacro_s.xpm", "tmacro_t.xpm", "");
@@ -120,14 +122,19 @@ void TEveUtil::SetupGUI()
 namespace
 {
 //______________________________________________________________________________
-void ChompTail(TString& s, char c='.')
+void ChompTailAndDir(TString& s, char c='.')
 {
    // Remove last part of string 's', starting from the last
    // occurrence of character 'c'.
+   // Remove directory part -- everything until the last '/'.
 
    Ssiz_t p = s.Last(c);
    if (p != kNPOS)
       s.Remove(p);
+
+   Ssiz_t ls = s.Last('/');
+   if (ls != kNPOS)
+      s.Remove(0, ls + 1);
 }
 }
 
@@ -142,14 +149,7 @@ Bool_t TEveUtil::CheckMacro(const char* mac)
    // Previous version expected function with same name and used ROOT's
    // list of global functions.
 
-   TString foo(mac); ChompTail(foo);
-   /*
-     if(recreate) {
-     TCollection* logf = gROOT->GetListOfGlobalFunctions(kFALSE);
-     logf->SetOwner();
-     logf->Clear();
-     }
-   */
+   TString foo(mac); ChompTailAndDir(foo);
    if (gROOT->GetGlobalFunction(foo.Data(), 0, kFALSE) != 0)
       return kTRUE;
    else
@@ -174,7 +174,7 @@ void TEveUtil::Macro(const char* mac)
    if (CheckMacro(mac) == kFALSE) {
       gROOT->LoadMacro(mac);
    }
-   TString foo(mac); ChompTail(foo); foo += "()";
+   TString foo(mac); ChompTailAndDir(foo); foo += "()";
    gROOT->ProcessLine(foo.Data());
 }
 
diff --git a/graf3d/eve/src/TEveVSD.cxx b/graf3d/eve/src/TEveVSD.cxx
index a6e4919..bd9c7c5 100644
--- a/graf3d/eve/src/TEveVSD.cxx
+++ b/graf3d/eve/src/TEveVSD.cxx
@@ -24,13 +24,13 @@
 ClassImp(TEveVSD);
 
 //______________________________________________________________________________
-TEveVSD::TEveVSD(const char* , const char* ) :
+TEveVSD::TEveVSD(const char* , const char*) :
    TObject(),
 
-   fBuffSize  (128*1024),
-
    fFile      (0),
    fDirectory (0),
+   fBuffSize  (32000),
+   fVerbose   (0),
 
    fTreeK  (0),
    fTreeH  (0),
@@ -53,12 +53,19 @@ TEveVSD::TEveVSD(const char* , const char* ) :
    // Constructor.
 }
 
+//______________________________________________________________________________
+TEveVSD::~TEveVSD()
+{
+   // Destructor.
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
 void TEveVSD::SetDirectory(TDirectory* dir)
 {
    // Set directory in which the trees are (or will be) created.
+
    fDirectory = dir;
 }
 
@@ -77,7 +84,7 @@ void TEveVSD::CreateTrees()
    fTreeKK = new TTree("RecKinks",   "Reconstructed kinks.");
    fTreeV0 = new TTree("RecV0s",     "Reconstructed V0s.");
    fTreeCC = new TTree("RecCascades","Reconstructed cascades.");
-   fTreeGI = new TTree("TEveMCRecCrossRef",    "Objects prepared for cross query.");
+   fTreeGI = new TTree("TEveMCRecCrossRef", "Objects prepared for cross query.");
 }
 
 //______________________________________________________________________________
@@ -85,13 +92,13 @@ void TEveVSD::DeleteTrees()
 {
    // Delete interal trees.
 
-   delete fTreeK;      fTreeK      = 0;
-   delete fTreeH;      fTreeH      = 0;
-   delete fTreeC;      fTreeC      = 0;
-   delete fTreeR;      fTreeR      = 0;
-   delete fTreeV0;     fTreeV0     = 0;
-   delete fTreeKK;     fTreeKK     = 0;
-   delete fTreeGI;     fTreeGI     = 0;
+   delete fTreeK;  fTreeK  = 0;
+   delete fTreeH;  fTreeH  = 0;
+   delete fTreeC;  fTreeC  = 0;
+   delete fTreeR;  fTreeR  = 0;
+   delete fTreeV0; fTreeV0 = 0;
+   delete fTreeKK; fTreeKK = 0;
+   delete fTreeGI; fTreeGI = 0;
 }
 
 //______________________________________________________________________________
@@ -99,21 +106,16 @@ void TEveVSD::CreateBranches()
 {
    // Create internal VSD branches.
 
-   if(fTreeK)
-      fTreeK ->Branch("K",  "TEveMCTrack",  &fpK,  fBuffSize);
-   if(fTreeH)
-      fTreeH ->Branch("H",  "TEveHit",      &fpH,  fBuffSize);
-   if(fTreeC)
-      fTreeC ->Branch("C",  "TEveCluster",  &fpC,  fBuffSize);
-   if(fTreeR)
-      fTreeR ->Branch("R",  "TEveRecTrack", &fpR,  fBuffSize);
-   if(fTreeKK)
-      fTreeKK->Branch("KK", "TEveRecKink",  &fpKK, fBuffSize);
-   if(fTreeV0)
-      fTreeV0->Branch("V0", "TEveRecV0",    &fpV0, fBuffSize);
-
-   if(fTreeGI) {
-      fTreeGI->Branch("GI", "TEveMCRecCrossRef",  &fpGI, fBuffSize);
+   if (fTreeK)  fTreeK ->Branch("K",  "TEveMCTrack",  &fpK);
+   if (fTreeH)  fTreeH ->Branch("H",  "TEveHit",      &fpH);
+   if (fTreeC)  fTreeC ->Branch("C",  "TEveCluster",  &fpC);
+   if (fTreeR)  fTreeR ->Branch("R",  "TEveRecTrack", &fpR);
+   if (fTreeKK) fTreeKK->Branch("KK", "TEveRecKink",  &fpKK);
+   if (fTreeV0) fTreeV0->Branch("V0", "TEveRecV0",    &fpV0);
+
+   if (fTreeGI)
+   {
+      fTreeGI->Branch("GI", "TEveMCRecCrossRef",  &fpGI);
       fTreeGI->Branch("K.", "TEveMCTrack",  &fpK);
       fTreeGI->Branch("R.", "TEveRecTrack", &fpR);
    }
@@ -124,20 +126,15 @@ void TEveVSD::SetBranchAddresses()
 {
    // Set branche addresses of internal trees.
 
-   if(fTreeK)
-      fTreeK ->SetBranchAddress("K",  &fpK);
-   if(fTreeH)
-      fTreeH ->SetBranchAddress("H",  &fpH);
-   if(fTreeC)
-      fTreeC ->SetBranchAddress("C",  &fpC);
-   if(fTreeR)
-      fTreeR ->SetBranchAddress("R",  &fpR);
-   if(fTreeKK)
-      fTreeKK->SetBranchAddress("KK", &fpKK);
-   if(fTreeV0)
-      fTreeV0->SetBranchAddress("V0", &fpV0);
-
-   if(fTreeGI) {
+   if (fTreeK)  fTreeK ->SetBranchAddress("K",  &fpK);
+   if (fTreeH)  fTreeH ->SetBranchAddress("H",  &fpH);
+   if (fTreeC)  fTreeC ->SetBranchAddress("C",  &fpC);
+   if (fTreeR)  fTreeR ->SetBranchAddress("R",  &fpR);
+   if (fTreeKK) fTreeKK->SetBranchAddress("KK", &fpKK);
+   if (fTreeV0) fTreeV0->SetBranchAddress("V0", &fpV0);
+
+   if (fTreeGI)
+   {
       fTreeGI->SetBranchAddress("GI", &fpGI);
       fTreeGI->SetBranchAddress("K.", &fpK);
       fTreeGI->SetBranchAddress("R.", &fpR);
@@ -159,79 +156,53 @@ void TEveVSD::LoadTrees()
 
    static const TEveException eH("TEveVSD::LoadTrees ");
 
-   if(fDirectory == 0)
-      throw(eH + "directory not set.");
+   if (fDirectory == 0)
+      throw eH + "directory not set.";
 
-   printf("Reading kinematics.\n");
    fTreeK = (TTree*) fDirectory->Get("Kinematics");
-   if(fTreeK == 0) {
+   if (fTreeK == 0 && fVerbose) {
       printf("%s Kinematics not available in fDirectory %s.\n",
              eH.Data(), fDirectory->GetName());
    }
 
-   printf("Reading hits.\n");
    fTreeH = (TTree*) fDirectory->Get("Hits");
-   if(fTreeH == 0) {
+   if (fTreeH == 0 && fVerbose) {
       printf("%s Hits not available in fDirectory %s.\n",
              eH.Data(), fDirectory->GetName());
    }
 
-   printf("Reading clusters.\n");
    fTreeC = (TTree*) fDirectory->Get("Clusters");
-   if(fTreeC == 0) {
+   if (fTreeC == 0 && fVerbose) {
       printf("%s Clusters not available in fDirectory %s.\n",
              eH.Data(), fDirectory->GetName());
    }
 
-   printf("Reading reconstructed tracks.\n");
    fTreeR = (TTree*) fDirectory->Get("RecTracks");
-   if(fTreeR == 0) {
+   if (fTreeR == 0 && fVerbose) {
       printf("%s RecTracks not available in fDirectory %s.\n",
              eH.Data(), fDirectory->GetName());
    }
 
-   printf("Reading reconstructed kinks. \n");
    fTreeKK =  (TTree*) fDirectory->Get("RecKinks");
-   if(fTreeKK == 0) {
+   if (fTreeKK == 0 && fVerbose) {
       printf("%s Kinks not available in fDirectory %s.\n",
              eH.Data(), fDirectory->GetName());
    }
 
-   printf("Reading Reconstructed V0s.\n");
    fTreeV0 =  (TTree*) fDirectory->Get("RecV0s");
-   if(fTreeV0 == 0) {
+   if (fTreeV0 == 0 && fVerbose) {
       printf("%s V0 not available in fDirectory %s.\n",
              eH.Data(), fDirectory->GetName());
    }
 
-   printf("Reading TEveMCRecCrossRef.\n");
    fTreeGI = (TTree*)fDirectory->Get("TEveMCRecCrossRef");
-   if(fTreeGI == 0) {
+   if(fTreeGI == 0 && fVerbose) {
       printf("%s TEveMCRecCrossRef not available in fDirectory %s.\n",
              eH.Data(), fDirectory->GetName());
    }
 
 }
 
-//______________________________________________________________________________
-void TEveVSD::LoadVSD(const char* vsd_file_name, const char* dir_name)
-{
-   // Load VSD data from given file and directory.
-
-   static const TEveException eH("TEveVSD::LoadVSD ");
-
-   fFile = TFile::Open(vsd_file_name);
-   if( fFile == 0)
-      throw(eH + "can not open TEveVSD file '" + vsd_file_name + "'.");
-
-   fDirectory = (TDirectory*) fFile->Get(dir_name);
-   if (fDirectory == 0)
-      throw(eH + "directory '" + dir_name + "' not found in TEveVSD file '" + vsd_file_name + "'.");
-   printf("%p\n", (void*)fDirectory);
-   LoadTrees();
-   SetBranchAddresses();
-}
-
 /******************************************************************************/
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveVSDStructs.cxx b/graf3d/eve/src/TEveVSDStructs.cxx
index c7e19ae..d4da0fe 100644
--- a/graf3d/eve/src/TEveVSDStructs.cxx
+++ b/graf3d/eve/src/TEveVSDStructs.cxx
@@ -11,161 +11,12 @@
 
 #include "TEveVSDStructs.h"
 
-//==============================================================================
-// TEveVector
-//==============================================================================
-
-//______________________________________________________________________________
-//
-// Float three-vector; a inimal Float_t copy of TVector3 used to
-// represent points and momenta (also used in VSD).
-
-ClassImp(TEveVector);
-
-//______________________________________________________________________________
-void TEveVector::Dump() const
-{
-   // Dump to stdout as "(x, y, z)\n".
-
-   printf("(%f, %f, %f)\n", fX, fY, fZ);
-}
-
-//______________________________________________________________________________
-Float_t TEveVector::Eta() const
-{
-   // Calculate eta of the point, pretending it's a momentum vector.
-
-   Float_t cosTheta = CosTheta();
-   if (cosTheta*cosTheta < 1) return -0.5* TMath::Log( (1.0-cosTheta)/(1.0+cosTheta) );
-   Warning("Eta","transverse momentum = 0, returning +/- 1e10");
-   return (fZ >= 0) ? 1e10 : -1e10;
-}
-
-//______________________________________________________________________________
-void TEveVector::Normalize(Float_t length)
-{
-   // Normalize the vector to length if current length is non-zero.
-
-   Float_t m = Mag();
-   if (m != 0)
-   {
-      m = length / m;
-      fX *= m; fY *= m; fZ *= m;
-   }
-}
-
-//______________________________________________________________________________
-TEveVector TEveVector::Orthogonal() const
-{
-   // Returns an orthogonal vector (not normalized).
-
-   Float_t xx = fX < 0 ? -fX : fX;
-   Float_t yy = fY < 0 ? -fY : fY;
-   Float_t zz = fZ < 0 ? -fZ : fZ;
-   if (xx < yy) {
-      return xx < zz ? TEveVector(0,fZ,-fY) : TEveVector(fY,-fX,0);
-   } else {
-      return yy < zz ? TEveVector(-fZ,0,fX) : TEveVector(fY,-fX,0);
-   }
-}
-
-//______________________________________________________________________________
-void TEveVector::OrthoNormBase(TEveVector& a, TEveVector& b) const
-{
-   // Set vectors a and b to be normal to this and among themselves,
-   // both of length 1.
-
-   a = Orthogonal();
-   TMath::Cross(this->Arr(), a.Arr(), b.Arr());
-   a.Normalize();
-   b.Normalize();
-}
-
-//______________________________________________________________________________
-TEveVector TEveVector::operator + (const TEveVector & b) const
-{
-   // Vector addition.
-
-   return TEveVector(fX + b.fX, fY + b.fY, fZ + b.fZ);
-}
-
-//______________________________________________________________________________
-TEveVector TEveVector::operator - (const TEveVector & b) const
-{
-   // Vector subtraction.
-
-   return TEveVector(fX - b.fX, fY - b.fY, fZ - b.fZ);
-}
-
-//______________________________________________________________________________
-TEveVector TEveVector::operator * (Float_t a) const
-{
-   // Multiplication with scalar.
-
-   return TEveVector(a*fX, a*fY, a*fZ);
-}
-
-
-//==============================================================================
-// TEveVector4
-//==============================================================================
-
-//______________________________________________________________________________
-//
-// Float four-vector.
-
-ClassImp(TEveVector4);
-
-//______________________________________________________________________________
-void TEveVector4::Dump() const
-{
-   // Dump to stdout as "(x, y, z; t)\n".
-
-   printf("(%f, %f, %f; %f)\n", fX, fY, fZ, fT);
-}
-
-
-//==============================================================================
-// TEvePathMark
-//==============================================================================
-
-//______________________________________________________________________________
-//
-// Special-point on track:
-//  kDaughter  - daughter creation; fP is momentum of the daughter, it is subtracted from
-//               momentum of the track
-//  kReference - position/momentum reference
-//  kDecay     - decay point, fP not used
-//  kCluster2D - measurement with large error in one direction (like strip detectors):
-//               fP - normal to detector plane,
-//               fE - large error direction, must be normalized.
-//               Track is propagated to plane and correction in fE direction is discarded.
-
-
-ClassImp(TEvePathMark);
-
-//______________________________________________________________________________
-const char* TEvePathMark::TypeName()
-{
-   // Return the name of path-mark type.
-
-   switch (fType)
-   {
-      case kDaughter:  return "Daughter";
-      case kReference: return "Reference";
-      case kDecay:     return "Decay";
-      case kCluster2D: return "Cluster2D";
-      default:         return "Unknown";
-   }
-}
-
 
 //______________________________________________________________________________
 //
 // Not documented.
 //
 
-ClassImp(TEveVector4);
 ClassImp(TEveMCTrack);
 ClassImp(TEveHit);
 ClassImp(TEveCluster);
diff --git a/graf3d/eve/src/TEveVector.cxx b/graf3d/eve/src/TEveVector.cxx
new file mode 100644
index 0000000..b94bf5b
--- /dev/null
+++ b/graf3d/eve/src/TEveVector.cxx
@@ -0,0 +1,224 @@
+// @(#)root/eve:$Id: TEveVector.cxx 32549 2010-03-11 11:44:29Z matevz $
+// Author: Matevz Tadel 2007
+
+/*************************************************************************
+ * Copyright (C) 1995-2007, Rene Brun and Fons Rademakers.               *
+ * All rights reserved.                                                  *
+ *                                                                       *
+ * For the licensing terms see $ROOTSYS/LICENSE.                         *
+ * For the list of contributors see $ROOTSYS/README/CREDITS.             *
+ *************************************************************************/
+
+#include "TEveVector.h"
+#include "TVector3.h"
+
+//==============================================================================
+// TEveVector
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Float three-vector; a inimal Float_t copy of TVector3 used to
+// represent points and momenta (also used in VSD).
+
+ClassImp(TEveVector);
+
+//______________________________________________________________________________
+void TEveVector::Set(const TVector3& v)
+{
+   // Set from TVector3.
+
+   fX = v.x(); fY = v.y(); fZ = v.z();
+}
+
+//______________________________________________________________________________
+void TEveVector::Dump() const
+{
+   // Dump to stdout as "(x, y, z)\n".
+
+   printf("(%f, %f, %f)\n", fX, fY, fZ);
+}
+
+//______________________________________________________________________________
+Float_t TEveVector::Eta() const
+{
+   // Calculate eta of the point, pretending it's a momentum vector.
+
+   Float_t cosTheta = CosTheta();
+   if (cosTheta*cosTheta < 1) return -0.5* TMath::Log( (1.0-cosTheta)/(1.0+cosTheta) );
+   Warning("Eta","transverse momentum = 0, returning +/- 1e10");
+   return (fZ >= 0) ? 1e10 : -1e10;
+}
+
+//______________________________________________________________________________
+void TEveVector::Normalize(Float_t length)
+{
+   // Normalize the vector to length if current length is non-zero.
+
+   Float_t m = Mag();
+   if (m != 0)
+   {
+      m = length / m;
+      fX *= m; fY *= m; fZ *= m;
+   }
+}
+
+//______________________________________________________________________________
+TEveVector TEveVector::Orthogonal() const
+{
+   // Returns an orthogonal vector (not normalized).
+
+   Float_t xx = fX < 0 ? -fX : fX;
+   Float_t yy = fY < 0 ? -fY : fY;
+   Float_t zz = fZ < 0 ? -fZ : fZ;
+   if (xx < yy) {
+      return xx < zz ? TEveVector(0,fZ,-fY) : TEveVector(fY,-fX,0);
+   } else {
+      return yy < zz ? TEveVector(-fZ,0,fX) : TEveVector(fY,-fX,0);
+   }
+}
+
+//______________________________________________________________________________
+void TEveVector::OrthoNormBase(TEveVector& a, TEveVector& b) const
+{
+   // Set vectors a and b to be normal to this and among themselves,
+   // both of length 1.
+
+   a = Orthogonal();
+   TMath::Cross(this->Arr(), a.Arr(), b.Arr());
+   a.Normalize();
+   b.Normalize();
+}
+
+//______________________________________________________________________________
+TEveVector TEveVector::operator + (const TEveVector & b) const
+{
+   // Vector addition.
+
+   return TEveVector(fX + b.fX, fY + b.fY, fZ + b.fZ);
+}
+
+//______________________________________________________________________________
+TEveVector TEveVector::operator - (const TEveVector & b) const
+{
+   // Vector subtraction.
+
+   return TEveVector(fX - b.fX, fY - b.fY, fZ - b.fZ);
+}
+
+//______________________________________________________________________________
+TEveVector TEveVector::operator * (Float_t a) const
+{
+   // Multiplication with scalar.
+
+   return TEveVector(a*fX, a*fY, a*fZ);
+}
+
+
+//==============================================================================
+// TEveVector4
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Float four-vector.
+
+ClassImp(TEveVector4);
+
+//______________________________________________________________________________
+void TEveVector4::Dump() const
+{
+   // Dump to stdout as "(x, y, z; t)\n".
+
+   printf("(%f, %f, %f; %f)\n", fX, fY, fZ, fT);
+}
+
+
+//==============================================================================
+// TEvePoint
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Float two-vector.
+
+ClassImp(TEvePoint);
+
+//______________________________________________________________________________
+void TEvePoint::Normalize(Float_t length)
+{
+   // Normalize the vector to length if current length is non-zero.
+
+   Float_t m = Mag();
+   if (m != 0)
+   {
+      m = length / m;
+      fX *= m; fY *= m;
+   }
+}
+
+//______________________________________________________________________________
+TEvePoint TEvePoint::operator + (const TEvePoint & b) const
+{
+   // Vector addition.
+
+   return TEvePoint(fX + b.fX, fY + b.fY);
+}
+
+//______________________________________________________________________________
+TEvePoint TEvePoint::operator - (const TEvePoint & b) const
+{
+   // Vector subtraction.
+
+   return TEvePoint(fX - b.fX, fY - b.fY);
+}
+
+//______________________________________________________________________________
+TEvePoint TEvePoint::operator * (Float_t a) const
+{
+   // Multiplication with scalar.
+
+   return TEvePoint(a*fX, a*fY);
+}
+
+//______________________________________________________________________________
+void TEvePoint::Dump() const
+{
+   // Dump to stdout as "(x, y)\n".
+
+   printf("(%f, %f)\n", fX, fY);
+}
+
+
+//==============================================================================
+// TEvePathMark
+//==============================================================================
+
+//______________________________________________________________________________
+//
+// Special-point on track:
+//  kDaughter  - daughter creation; fP is momentum of the daughter, it is subtracted from
+//               momentum of the track
+//  kReference - position/momentum reference
+//  kDecay     - decay point, fP not used
+//  kCluster2D - measurement with large error in one direction (like strip detectors):
+//               fP - normal to detector plane,
+//               fE - large error direction, must be normalized.
+//               Track is propagated to plane and correction in fE direction is discarded.
+
+ClassImp(TEvePathMark);
+
+//______________________________________________________________________________
+const char* TEvePathMark::TypeName()
+{
+   // Return the name of path-mark type.
+
+   switch (fType)
+   {
+      case kDaughter:  return "Daughter";
+      case kReference: return "Reference";
+      case kDecay:     return "Decay";
+      case kCluster2D: return "Cluster2D";
+      default:         return "Unknown";
+   }
+}
diff --git a/graf3d/eve/src/TEveViewer.cxx b/graf3d/eve/src/TEveViewer.cxx
index 5c7406a..6f8b371 100644
--- a/graf3d/eve/src/TEveViewer.cxx
+++ b/graf3d/eve/src/TEveViewer.cxx
@@ -16,6 +16,7 @@
 #include "TEveManager.h"
 #include "TEveSelection.h"
 
+#include "TGLFormat.h"
 #include "TGLSAViewer.h"
 #include "TGLEmbeddedViewer.h"
 #include "TGLScenePad.h"
@@ -24,6 +25,7 @@
 #include "TGLLogicalShape.h"  // For handling OnMouseIdle signal
 #include "TGLEventHandler.h"
 
+#include "TApplication.h"
 #include "TSystem.h"
 namespace
 {
@@ -117,14 +119,8 @@ void TEveViewer::InitInternal()
    // Initialize static data-members according to running conditions.
 
    // Determine if display is running on a mac.
-   // This is also works for ssh connection mac->linux.
-#ifndef WIN32
-   TString s = gSystem_GetFromPipe("xdpyinfo");
-   if (s.Index("Apple-WM") != kNPOS)
-   {
-      fgRecreateGlOnDockOps = kTRUE;
-   }
-#endif
+   // This also works for ssh connection mac->linux.
+   fgRecreateGlOnDockOps = (gVirtualX->SupportsExtension("Apple-WM") == 1);
 
    fgInitInternal = kTRUE;
 }
@@ -180,11 +176,10 @@ void TEveViewer::SetGLViewer(TGLViewer* viewer, TGFrame* frame)
    fGLViewerFrame = frame;
 
    fGLViewer->SetSmartRefresh(kTRUE);
-   fGLViewer->SetResetCameraOnDoubleClick(kFALSE);
 }
 
 //______________________________________________________________________________
-TGLSAViewer* TEveViewer::SpawnGLViewer(TGedEditor* ged)
+TGLSAViewer* TEveViewer::SpawnGLViewer(TGedEditor* ged, Bool_t stereo)
 {
    // Spawn new GLViewer and adopt it.
 
@@ -192,12 +187,33 @@ TGLSAViewer* TEveViewer::SpawnGLViewer(TGedEditor* ged)
 
    TGCompositeFrame* cf = GetGUICompositeFrame();
 
+   TGLFormat *form = 0;
+   if (stereo)
+   {
+      form = new TGLFormat;
+      form->SetStereo(kTRUE);
+   }
+
    cf->SetEditable(kTRUE);
-   TGLSAViewer* v = new TGLSAViewer(cf, 0, ged);
+   TGLSAViewer* v = 0;
+   try
+   {
+      v = new TGLSAViewer(cf, 0, ged, form);
+   }
+   catch (std::exception&)
+   {
+      Error("SpawnGLViewer", "Insufficient support from the graphics hardware. Aborting.");
+      gApplication->Terminate(1);
+   }
    cf->SetEditable(kFALSE);
    v->ToggleEditObject();
+   v->DisableCloseMenuEntries();
+   v->EnableMenuBarHiding();
    SetGLViewer(v, v->GetFrame());
 
+   if (stereo)
+      v->SetStereo(kTRUE);
+
    if (fEveFrame == 0)
       PreUndock();
 
@@ -205,7 +221,7 @@ TGLSAViewer* TEveViewer::SpawnGLViewer(TGedEditor* ged)
 }
 
 //______________________________________________________________________________
-TGLEmbeddedViewer* TEveViewer::SpawnGLEmbeddedViewer(Int_t border)
+TGLEmbeddedViewer* TEveViewer::SpawnGLEmbeddedViewer(TGedEditor* ged, Int_t border)
 {
    // Spawn new GLViewer and adopt it.
 
@@ -213,7 +229,7 @@ TGLEmbeddedViewer* TEveViewer::SpawnGLEmbeddedViewer(Int_t border)
 
    TGCompositeFrame* cf = GetGUICompositeFrame();
 
-   TGLEmbeddedViewer* v = new TGLEmbeddedViewer(cf, 0, border);
+   TGLEmbeddedViewer* v = new TGLEmbeddedViewer(cf, 0, ged, border);
    SetGLViewer(v, v->GetFrame());
 
    cf->AddFrame(fGLViewerFrame, new TGLayoutHints(kLHintsNormal | kLHintsExpandX | kLHintsExpandY));
@@ -235,6 +251,36 @@ void TEveViewer::Redraw(Bool_t resetCameras)
    fGLViewer->RequestDraw(TGLRnrCtx::kLODHigh);
 }
 
+//______________________________________________________________________________
+void TEveViewer::SwitchStereo()
+{
+   // Switch stereo mode.
+   // This only works TGLSAViewers and, of course, with stereo support
+   // provided by the OpenGL driver.
+
+   TGLSAViewer *v = dynamic_cast<TGLSAViewer*>(fGLViewer);
+
+   if (!v) {
+      Warning("SwitchStereo", "Only supported for TGLSAViewer.");
+      return;
+   }
+
+   v->DestroyGLWidget();
+   TGLFormat *f = v->GetFormat();
+switch_stereo:
+   f->SetStereo(!f->IsStereo());
+   v->SetStereo(f->IsStereo());
+   try
+   {
+      v->CreateGLWidget();
+   }
+   catch (std::exception&)
+   {
+      Error("SwitchStereo", "Insufficient support from the graphics hardware. Reverting.");
+      goto switch_stereo;
+   }
+}
+
 /******************************************************************************/
 
 //______________________________________________________________________________
diff --git a/graf3d/eve/src/TEveWindow.cxx b/graf3d/eve/src/TEveWindow.cxx
index 51949c5..34c6e40 100644
--- a/graf3d/eve/src/TEveWindow.cxx
+++ b/graf3d/eve/src/TEveWindow.cxx
@@ -37,7 +37,7 @@
 //==============================================================================
 
 //______________________________________________________________________________
-// 
+//
 // Abstract base-class for frame-slots that encompass EVE-windows
 // (sub-classes of TEveWindow).
 //
@@ -510,11 +510,12 @@ void TEveCompositeFrameInMainFrame::MainFrameClosed()
          TEveWindow::SwapWindows(fEveWindow, swapCandidate);
          gEve->GetWindowManager()->WindowDocked(fEveWindow );
       }
-
    }
 
    fMainFrame->DontCallClose();
-   fEveWindow->DestroyWindowAndSlot();
+
+   if (fEveWindow != 0)
+      fEveWindow->DestroyWindowAndSlot();
 
    if (gDebug > 0)
       Info("TEveCompositeFrameInMainFrame::MainFrameClosed()",
@@ -682,7 +683,7 @@ void TEveCompositeFrameInTab::SetCurrent(Bool_t curr)
 // Abstract base-class for representing eve-windows.
 // Sub-classes define a particular GUI frame that gets show
 // in the window.
-// 
+//
 
 ClassImp(TEveWindow);
 
@@ -1110,6 +1111,72 @@ void TEveWindow::SwapWindows(TEveWindow* w1, TEveWindow* w2)
    f1->Layout(); f2->Layout();
 }
 
+//==============================================================================
+
+//______________________________________________________________________________
+UInt_t TEveWindow::GetMainFrameDefWidth()
+{
+   // Get default width for new main-frame windows. Static.
+
+   return fgMainFrameDefWidth;
+}
+
+//______________________________________________________________________________
+UInt_t TEveWindow::GetMainFrameDefHeight()
+{
+   // Get default heigth for new main-frame windows. Static.
+
+   return fgMainFrameDefHeight;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetMainFrameDefWidth (UInt_t x)
+{
+   // Set default width for new main-frame windows. Static.
+
+   fgMainFrameDefWidth  = x;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetMainFrameDefHeight(UInt_t x)
+{
+   // Set default height for new main-frame windows. Static.
+
+   fgMainFrameDefHeight = x;
+}
+
+//______________________________________________________________________________
+Pixel_t TEveWindow::GetCurrentBackgroundColor()
+{
+   // Get background-color for marking the title-bar of current window. Static.
+
+   return fgCurrentBackgroundColor;
+}
+
+//______________________________________________________________________________
+Pixel_t TEveWindow::GetMiniBarBackgroundColor()
+{
+   // Get background-color for mini-bar (collapsed title-bar). Static.
+
+   return fgMiniBarBackgroundColor;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetCurrentBackgroundColor(Pixel_t p)
+{
+   // Set background-color for marking the title-bar of current window. Static.
+
+   fgCurrentBackgroundColor = p;
+}
+
+//______________________________________________________________________________
+void TEveWindow::SetMiniBarBackgroundColor(Pixel_t p)
+{
+   // Set background-color for mini-bar (collapsed title-bar). Static.
+
+   fgMiniBarBackgroundColor = p;
+}
+
 
 //==============================================================================
 // TEveWindowSlot
diff --git a/graf3d/ftgl/inc/FTFont.h b/graf3d/ftgl/inc/FTFont.h
index f67867d..550da7a 100755
--- a/graf3d/ftgl/inc/FTFont.h
+++ b/graf3d/ftgl/inc/FTFont.h
@@ -195,6 +195,16 @@ class FTGL_EXPORT FTFont
          */
         float Advance( const char* string);
 
+	/**
+         * Prepare for rendering
+         */
+        virtual void PreRender() { preRenderCalled = true; }
+
+	/**
+         * Cleanup after rendering
+         */
+        virtual void PostRender() { preRenderCalled = false; }
+
         /**
          * Render a string of characters
          * 
@@ -205,6 +215,15 @@ class FTGL_EXPORT FTFont
         /**
          * Render a string of characters
          * 
+         * @param string    'C' style string to be output.   
+	 * @param w_max     maximum width of text
+	 * @param w_fade    width at which text starts to fade
+         */
+        virtual void Render( const char* string, float w_max, float w_fade );
+
+        /**
+         * Render a string of characters
+         * 
          * @param string    wchar_t string to be output.     
          */
         virtual void Render( const wchar_t* string );
@@ -260,6 +279,13 @@ class FTGL_EXPORT FTFont
         inline bool CheckGlyph( const unsigned int chr);
 
         /**
+         * PreRender() was called from outside. Do not call it again
+         * from Render(), nor call PostRender().
+         * User has to call it himself.
+         */
+        bool preRenderCalled;
+
+        /**
          * An object that holds a list of glyphs
          */
         FTGlyphContainer* glyphList;
@@ -268,7 +294,6 @@ class FTGL_EXPORT FTFont
          * Current pen or cursor position;
          */
         FTPoint pen;
-        
 };
 
 
diff --git a/graf3d/ftgl/inc/FTGLBitmapFont.h b/graf3d/ftgl/inc/FTGLBitmapFont.h
index 3e6aa32..4e71b90 100755
--- a/graf3d/ftgl/inc/FTGLBitmapFont.h
+++ b/graf3d/ftgl/inc/FTGLBitmapFont.h
@@ -36,22 +36,16 @@ class FTGL_EXPORT FTGLBitmapFont : public FTFont
          */
         ~FTGLBitmapFont();
         
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        void Render( const char* string);
+        virtual void PreRender();
 
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style wide string to be output.  
+	/**
+         * Cleanup after rendering
          */
-        void Render( const wchar_t* string);
+        virtual void PostRender();
 
-        // attributes
-        
     private:
         /**
          * Construct a FTBitmapGlyph.
diff --git a/graf3d/ftgl/inc/FTGLOutlineFont.h b/graf3d/ftgl/inc/FTGLOutlineFont.h
index fce7cf5..6690350 100755
--- a/graf3d/ftgl/inc/FTGLOutlineFont.h
+++ b/graf3d/ftgl/inc/FTGLOutlineFont.h
@@ -37,19 +37,15 @@ class FTGL_EXPORT FTGLOutlineFont : public FTFont
          */
         ~FTGLOutlineFont();
         
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        void Render( const char* string);
-        
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    wchar_t string to be output.     
+        virtual void PreRender();
+
+	/**
+         * Cleanup after rendering
          */
-        void Render( const wchar_t* string);
+        virtual void PostRender();
 
     private:
         /**
diff --git a/graf3d/ftgl/inc/FTGLPixmapFont.h b/graf3d/ftgl/inc/FTGLPixmapFont.h
index 053427b..4705e94 100755
--- a/graf3d/ftgl/inc/FTGLPixmapFont.h
+++ b/graf3d/ftgl/inc/FTGLPixmapFont.h
@@ -38,19 +38,15 @@ class FTGL_EXPORT FTGLPixmapFont : public FTFont
          */
         ~FTGLPixmapFont();
         
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        void Render( const char* string);
-        
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    wchar_t string to be output.     
+        virtual void PreRender();
+
+	/**
+         * Cleanup after rendering
          */
-        void Render( const wchar_t* string);
+        virtual void PostRender();
 
     private:
         /**
diff --git a/graf3d/ftgl/inc/FTGLTextureFont.h b/graf3d/ftgl/inc/FTGLTextureFont.h
index 7e97d6c..c0b1c77 100755
--- a/graf3d/ftgl/inc/FTGLTextureFont.h
+++ b/graf3d/ftgl/inc/FTGLTextureFont.h
@@ -46,20 +46,15 @@ class  FTGL_EXPORT FTGLTextureFont : public FTFont
          */
         virtual bool FaceSize( const unsigned int size, const unsigned int res = 72);
 
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    'C' style string to be output.   
+	/**
+         * Prepare for rendering
          */
-        virtual void Render( const char* string);
-        
-        /**
-         * Renders a string of characters
-         * 
-         * @param string    wchar_t string to be output.     
-         */
-        virtual void Render( const wchar_t* string);
+        virtual void PreRender();
 
+	/**
+         * Cleanup after rendering
+         */
+        virtual void PostRender();
         
     private:
         /**
diff --git a/graf3d/ftgl/src/FTFont.cxx b/graf3d/ftgl/src/FTFont.cxx
index f519f33..241d06b 100644
--- a/graf3d/ftgl/src/FTFont.cxx
+++ b/graf3d/ftgl/src/FTFont.cxx
@@ -7,6 +7,7 @@
 FTFont::FTFont( const char* fontFilePath)
 :   face( fontFilePath),
     useDisplayLists(true),
+    preRenderCalled(false),
     glyphList(0)
 {
     err = face.Error();
@@ -244,6 +245,35 @@ float FTFont::Advance( const char* string)
 
 void FTFont::Render( const char* string )
 {
+    bool pre_post = ! preRenderCalled;
+    if (pre_post) PreRender();
+
+    const unsigned char* c = (unsigned char*)string;
+    pen.X(0); pen.Y(0);
+
+    while( *c)
+    {
+        if(CheckGlyph( *c))
+        {
+            pen = glyphList->Render( *c, *(c + 1), pen);
+        }
+        ++c;
+    }
+
+    if (pre_post) PostRender();
+}
+
+
+void FTFont::Render( const char* string, float w_max, float w_fade )
+{
+    bool pre_post = ! preRenderCalled;
+    if (pre_post) PreRender();
+
+    float col[4];
+    glGetFloatv(GL_CURRENT_COLOR, col);
+    float alpha_fac = col[3] / (w_max - w_fade);
+    float w = 0;
+
     const unsigned char* c = (unsigned char*)string;
     pen.X(0); pen.Y(0);
 
@@ -252,14 +282,27 @@ void FTFont::Render( const char* string )
         if(CheckGlyph( *c))
         {
             pen = glyphList->Render( *c, *(c + 1), pen);
+            w += pen.X();
+	    if(w > w_max)
+	        break;
+	    if(w > w_fade)
+	    {
+	        col[3] = alpha_fac * (w_max - w);
+	        glColor4fv(col);
+	    }
         }
         ++c;
     }
+
+    if (pre_post) PostRender();
 }
 
 
 void FTFont::Render( const wchar_t* string )
 {
+    bool pre_post = ! preRenderCalled;
+    if (pre_post) PreRender();
+
     const wchar_t* c = string;
     pen.X(0); pen.Y(0);
 
@@ -271,6 +314,8 @@ void FTFont::Render( const wchar_t* string )
         }
         ++c;
     }
+
+    if (pre_post) PostRender();
 }
 
 
diff --git a/graf3d/ftgl/src/FTGLBitmapFont.cxx b/graf3d/ftgl/src/FTGLBitmapFont.cxx
index 5844427..0eca8cf 100644
--- a/graf3d/ftgl/src/FTGLBitmapFont.cxx
+++ b/graf3d/ftgl/src/FTGLBitmapFont.cxx
@@ -31,8 +31,9 @@ FTGlyph* FTGLBitmapFont::MakeGlyph( unsigned int g)
 }
 
 
-void FTGLBitmapFont::Render( const char* string)
-{   
+void FTGLBitmapFont::PreRender()
+{
+    FTFont::PreRender();
     glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
     glPushAttrib( GL_ENABLE_BIT);
     
@@ -40,27 +41,12 @@ void FTGLBitmapFont::Render( const char* string)
     glPixelStorei( GL_UNPACK_ALIGNMENT, 1);
 
     glDisable( GL_BLEND);
-
-    FTFont::Render( string);
-
-    glPopAttrib();
-    glPopClientAttrib();
 }
 
 
-void FTGLBitmapFont::Render( const wchar_t* string)
-{   
-    glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
-    glPushAttrib( GL_ENABLE_BIT);
-    
-    glPixelStorei( GL_UNPACK_LSB_FIRST, GL_FALSE);
-    glPixelStorei( GL_UNPACK_ALIGNMENT, 1);
-    
-    glDisable( GL_BLEND);
-
-    FTFont::Render( string);
-
+void FTGLBitmapFont::PostRender()
+{
     glPopAttrib();
     glPopClientAttrib();
+    FTFont::PostRender();
 }
-
diff --git a/graf3d/ftgl/src/FTGLOutlineFont.cxx b/graf3d/ftgl/src/FTGLOutlineFont.cxx
index 182eca0..93afdd1 100644
--- a/graf3d/ftgl/src/FTGLOutlineFont.cxx
+++ b/graf3d/ftgl/src/FTGLOutlineFont.cxx
@@ -31,8 +31,9 @@ FTGlyph* FTGLOutlineFont::MakeGlyph( unsigned int g)
 }
 
 
-void FTGLOutlineFont::Render( const char* string)
-{   
+void FTGLOutlineFont::PreRender()
+{
+    FTFont::PreRender();
     glPushAttrib( GL_ENABLE_BIT | GL_HINT_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT);
     
     glDisable( GL_TEXTURE_2D);
@@ -41,26 +42,11 @@ void FTGLOutlineFont::Render( const char* string)
     glHint( GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
     glEnable(GL_BLEND);
     glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
-
-    FTFont::Render( string);
-
-    glPopAttrib();
 }
 
 
-void FTGLOutlineFont::Render( const wchar_t* string)
-{   
-    glPushAttrib( GL_ENABLE_BIT | GL_HINT_BIT | GL_LINE_BIT | GL_COLOR_BUFFER_BIT);
-    
-    glDisable( GL_TEXTURE_2D);
-    
-    glEnable( GL_LINE_SMOOTH);
-    glHint( GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
-    glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
-
-    FTFont::Render( string);
-
+void FTGLOutlineFont::PostRender()
+{
     glPopAttrib();
+    FTFont::PostRender();
 }
-
diff --git a/graf3d/ftgl/src/FTGLPixmapFont.cxx b/graf3d/ftgl/src/FTGLPixmapFont.cxx
index cdb9908..605a68a 100644
--- a/graf3d/ftgl/src/FTGLPixmapFont.cxx
+++ b/graf3d/ftgl/src/FTGLPixmapFont.cxx
@@ -31,15 +31,18 @@ FTGlyph* FTGLPixmapFont::MakeGlyph( unsigned int g)
 }
 
 
-void FTGLPixmapFont::Render( const char* string)
-{   
+void FTGLPixmapFont::PreRender()
+{
+    FTFont::PreRender();
     glPushAttrib( GL_ENABLE_BIT | GL_PIXEL_MODE_BIT | GL_COLOR_BUFFER_BIT);
     glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
 
     glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glEnable(GL_ALPHA_TEST);
+    glAlphaFunc(GL_GEQUAL, 0.0625);
 
-    glDisable( GL_TEXTURE_2D);
+    glDisable(GL_TEXTURE_2D);
 
     GLfloat ftglColour[4];
     glGetFloatv( GL_CURRENT_RASTER_COLOR, ftglColour);
@@ -48,36 +51,12 @@ void FTGLPixmapFont::Render( const char* string)
     glPixelTransferf(GL_GREEN_SCALE, ftglColour[1]);
     glPixelTransferf(GL_BLUE_SCALE, ftglColour[2]);
     glPixelTransferf(GL_ALPHA_SCALE, ftglColour[3]);
-
-    FTFont::Render( string);
-
-    glPopClientAttrib();
-    glPopAttrib();
 }
 
 
-void FTGLPixmapFont::Render( const wchar_t* string)
-{   
-    glPushAttrib( GL_ENABLE_BIT | GL_PIXEL_MODE_BIT | GL_COLOR_BUFFER_BIT);
-    glPushClientAttrib( GL_CLIENT_PIXEL_STORE_BIT);
-        
-    glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    
-    glDisable( GL_TEXTURE_2D);
-
-    GLfloat ftglColour[4];
-    glGetFloatv( GL_CURRENT_RASTER_COLOR, ftglColour);
-
-    glPixelTransferf(GL_RED_SCALE, ftglColour[0]);
-    glPixelTransferf(GL_GREEN_SCALE, ftglColour[1]);
-    glPixelTransferf(GL_BLUE_SCALE, ftglColour[2]);
-    glPixelTransferf(GL_ALPHA_SCALE, ftglColour[3]);
-
-    FTFont::Render( string);
-
+void FTGLPixmapFont::PostRender()
+{
     glPopClientAttrib();
     glPopAttrib();
+    FTFont::PostRender();
 }
-
-
diff --git a/graf3d/ftgl/src/FTGLTextureFont.cxx b/graf3d/ftgl/src/FTGLTextureFont.cxx
index 3b8836e..c1af5e6 100644
--- a/graf3d/ftgl/src/FTGLTextureFont.cxx
+++ b/graf3d/ftgl/src/FTGLTextureFont.cxx
@@ -151,32 +151,22 @@ bool FTGLTextureFont::FaceSize( const unsigned int size, const unsigned int res)
 }
 
 
-void FTGLTextureFont::Render( const char* string)
-{   
+void FTGLTextureFont::PreRender()
+{
+    FTFont::PreRender();
     glPushAttrib( GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT);
     
     glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
+    glEnable(GL_ALPHA_TEST);
+    glAlphaFunc(GL_GEQUAL, 0.0625);
 
     FTTextureGlyph::ResetActiveTexture();
-    
-    FTFont::Render( string);
-
-    glPopAttrib();
 }
 
 
-void FTGLTextureFont::Render( const wchar_t* string)
-{   
-    glPushAttrib( GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT);
-    
-    glEnable(GL_BLEND);
-    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // GL_ONE
-    
-    FTTextureGlyph::ResetActiveTexture();
-    
-    FTFont::Render( string);
-    
+void FTGLTextureFont::PostRender()
+{
     glPopAttrib();
+    FTFont::PostRender();
 }
-
diff --git a/graf3d/gl/inc/TGLAnnotation.h b/graf3d/gl/inc/TGLAnnotation.h
index 997e056..ec4c814 100644
--- a/graf3d/gl/inc/TGLAnnotation.h
+++ b/graf3d/gl/inc/TGLAnnotation.h
@@ -28,16 +28,22 @@ private:
    TGLAnnotation(const TGLAnnotation&);            // Not implemented
    TGLAnnotation& operator=(const TGLAnnotation&); // Not implemented
 
-   void MakeEditor();
+protected:
+   enum EDrag        { kMove, kResize, kNone };
+   enum ENameStack   { kMoveID, kEditID, kDeleteID, kResizeID };
 
+   void MakeEditor();
+   Char_t GetLineTransparency() const;
 
    Float_t           fPosX;           // x position [0, 1]
    Float_t           fPosY;           // y position [0, 1]
+   Float_t           fWidth;
+   Float_t           fHeight;
 
    Int_t             fMouseX, fMouseY; //! last mouse position
-   Bool_t            fInDrag;          //!
-   Float_t           fDrawW, fDrawH;   //! width/height of drawn annotation
-   Float_t           fDrawY;           //! y-position of annotation box
+   EDrag             fDrag;            //!
+   Float_t           fDrawW,  fDrawH;  //! width and height when drawing
+   Float_t           fTextSizeDrag;    //! text-size at start of drag
 
    TGLVector3        fPointer;         // picked location in 3D space
    Bool_t            fActive;          // active item identifier
@@ -48,7 +54,6 @@ private:
    static Color_t    fgBackColor;
    static Color_t    fgTextColor;
 
-protected:
    TGLViewer        *fParent;
 
    TString           fText;           // annotation text
@@ -63,22 +68,25 @@ protected:
 
    Bool_t            fDrawRefLine;    // draw 3D refrence line
    Bool_t            fUseColorSet;    // use color set from rnrCtx
+   Bool_t            fAllowClose;     // allow closing via 'X' button
 
 public:
    TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy);
    TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t posx, Float_t posy, TGLVector3 ref);
    virtual ~TGLAnnotation();
 
-   void SetTransparency(Char_t x) { fTransparency = x;}
-   Char_t GetTransparency() const { return fTransparency;}
+   void SetTransparency(Char_t x) { fTransparency = x; }
+   Char_t GetTransparency() const { return fTransparency; }
    void SetUseColorSet(Bool_t x)  { fUseColorSet = x; }
-   Bool_t GetUseColorSet() const  { return fUseColorSet;}
-   void SetBackColor(Color_t x)   { fBackColor = x;}
-   Color_t GetBackColor() const   { return fBackColor;}
-   void SetTextColor(Color_t x)   { fTextColor = x;   }
-   Color_t GetTextColor() const   { return fTextColor;}
-   void SetTextSize(Float_t x)    { fTextSize = x;   }
-   Float_t GetTextSize() const    { return fTextSize;}
+   Bool_t GetUseColorSet() const  { return fUseColorSet; }
+   void SetBackColor(Color_t x)   { fBackColor = x; }
+   Color_t GetBackColor() const   { return fBackColor; }
+   void SetTextColor(Color_t x)   { fTextColor = x; }
+   Color_t GetTextColor() const   { return fTextColor; }
+   void SetTextSize(Float_t x)    { fTextSize = x; }
+   Float_t GetTextSize() const    { return fTextSize; }
+   void SetAllowClose(Bool_t x)   { fAllowClose = x; }
+   Bool_t GetAllowClose() const   { return fAllowClose;}
    TGLFont::ETextAlignH_e GetTextAlign() const { return fTextAlign; }
    void SetTextAlign(TGLFont::ETextAlignH_e a) { fTextAlign = a; }
 
diff --git a/graf3d/gl/inc/TGLAxisPainter.h b/graf3d/gl/inc/TGLAxisPainter.h
index 0037aec..c8571aa 100644
--- a/graf3d/gl/inc/TGLAxisPainter.h
+++ b/graf3d/gl/inc/TGLAxisPainter.h
@@ -18,6 +18,7 @@
 class TAttAxis;
 class TAxis;
 class TH1;
+class TPMERegexp;
 class TGLRnrCtx;
 
 
@@ -41,7 +42,7 @@ private:
    Int_t fExp;
    Int_t fMaxDigits;
    Int_t fDecimals;
-   char  fFormat[8];
+   TString fFormat;
 
    // Font derived from axis attributes.
    TGLFont fLabelFont;
@@ -75,7 +76,8 @@ protected:
    // Labels options. Allready exist in TAttAxis, but can't be set.
    TGLFont::ETextAlignH_e fLabelAlignH;
    TGLFont::ETextAlignV_e fLabelAlignV;
-   TGLVector3 fTitlePos;
+   TGLVector3  fTitlePos;
+   TPMERegexp *fAllZeroesRE;
 
 public:
    TGLAxisPainter();
diff --git a/graf3d/gl/inc/TGLCameraOverlay.h b/graf3d/gl/inc/TGLCameraOverlay.h
index c58256b..35cc36a 100644
--- a/graf3d/gl/inc/TGLCameraOverlay.h
+++ b/graf3d/gl/inc/TGLCameraOverlay.h
@@ -31,8 +31,6 @@ private:
    TGLCameraOverlay(const TGLCameraOverlay&);            // Not implemented
    TGLCameraOverlay& operator=(const TGLCameraOverlay&); // Not implemented
 
-   Double_t       fFrustum[4];
-
 protected:
    Bool_t         fShowOrthographic;
    Bool_t         fShowPerspective;
@@ -48,6 +46,9 @@ protected:
    TGLPlane       fExternalRefPlane;
    Bool_t         fUseExternalRefPlane;
 
+   Double_t       fFrustum[4];
+
+
    void    RenderPlaneIntersect(TGLRnrCtx& rnrCtx);
    void    RenderAxis(TGLRnrCtx& rnrCtx, Bool_t drawGrid);
    void    RenderGrid(TGLRnrCtx& rnrCtx);
@@ -73,6 +74,8 @@ public:
    Bool_t   GetShowPerspective() const { return fShowPerspective; }
    void     SetShowPerspective(Bool_t x) {fShowPerspective =x;}
 
+   void     SetFrustum(TGLCamera& cam);
+
    TAttAxis* GetAttAxis();
 
    ClassDef(TGLCameraOverlay, 1); // Show coorinates of current camera frustum.
diff --git a/graf3d/gl/inc/TGLClip.h b/graf3d/gl/inc/TGLClip.h
index 3da512a..8ab4199 100644
--- a/graf3d/gl/inc/TGLClip.h
+++ b/graf3d/gl/inc/TGLClip.h
@@ -47,6 +47,7 @@ public:
    virtual void Modified() { TGLPhysicalShape::Modified(); IncTimeStamp(); }
 
    virtual void Setup(const TGLBoundingBox & bbox) = 0;
+   virtual void Setup(const TGLVector3&, const TGLVector3&);
 
    EMode GetMode() const      { return fMode; }
    void  SetMode(EMode mode)  { if (mode != fMode) { fMode = mode; ++fTimeStamp; } }
@@ -83,6 +84,7 @@ public:
    virtual ~TGLClipPlane();
 
    virtual void Setup(const TGLBoundingBox & bbox);
+   virtual void Setup(const TGLVector3& point, const TGLVector3& normal);
 
    void Set(const TGLPlane & plane);
 
@@ -110,6 +112,7 @@ public:
    virtual ~TGLClipBox();
 
    virtual void Setup(const TGLBoundingBox & bbox);
+   virtual void Setup(const TGLVector3& min_point, const TGLVector3& max_point);
 
    virtual void PlaneSet(TGLPlaneSet_t & set) const;
 
@@ -127,11 +130,16 @@ public:
 
 class TGLClipSet : public TGLOverlayElement
 {
+private:
+   TGLClipSet(const TGLClipSet&);            // Not implemented
+   TGLClipSet& operator=(const TGLClipSet&); // Not implemented
+
 protected:
    TGLClipPlane          *fClipPlane;
    TGLClipBox            *fClipBox;
    TGLClip               *fCurrentClip;  //! the current clipping shape
 
+   Bool_t                 fAutoUpdate;
    Bool_t                 fShowClip;
    Bool_t                 fShowManip;
    TGLManipSet           *fManip;
@@ -168,7 +176,9 @@ public:
    EClipType GetClipType() const;
    void      SetClipType(EClipType type);
 
-   // Editor only supports combined flag so far.
+   // Clip control flags
+   Bool_t GetAutoUpdate()     const { return fAutoUpdate; }
+   void   SetAutoUpdate(Bool_t aup) { fAutoUpdate = aup;  }
    Bool_t GetShowManip()      const { return fShowManip; }
    void   SetShowManip(Bool_t show) { fShowManip = show; }
    Bool_t GetShowClip()       const { return fShowClip; }
diff --git a/graf3d/gl/inc/TGLClipSetEditor.h b/graf3d/gl/inc/TGLClipSetEditor.h
index 04483fb..145cc48 100644
--- a/graf3d/gl/inc/TGLClipSetEditor.h
+++ b/graf3d/gl/inc/TGLClipSetEditor.h
@@ -44,6 +44,7 @@ protected:
    TGCompositeFrame *fBoxPropFrame;
    TGNumberEntry    *fBoxProp[6];
    TGCheckButton    *fClipInside;
+   TGCheckButton    *fAutoUpdate;
    TGCheckButton    *fClipEdit;
    TGCheckButton    *fClipShow;
    TGButton         *fApplyButton;
diff --git a/graf3d/gl/inc/TGLEmbeddedViewer.h b/graf3d/gl/inc/TGLEmbeddedViewer.h
index f74fe37..f0cb65a 100644
--- a/graf3d/gl/inc/TGLEmbeddedViewer.h
+++ b/graf3d/gl/inc/TGLEmbeddedViewer.h
@@ -22,6 +22,7 @@
 
 class TGLRenderArea;
 class TGLEventHandler;
+class TGedEditor;
 
 class TGLEmbeddedViewer : public TGLViewer
 {
@@ -30,6 +31,7 @@ private:
    TGCompositeFrame  *fFrame;
    Int_t              fBorder;
 
+   void Init(const TGWindow *parent);
    void CreateFrames();
 
    TGLEmbeddedViewer(const TGLEmbeddedViewer&); // Not implemented
@@ -37,6 +39,7 @@ private:
 
 public:
    TGLEmbeddedViewer(const TGWindow *parent, TVirtualPad *pad=0, Int_t border=2);
+   TGLEmbeddedViewer(const TGWindow *parent, TVirtualPad *pad, TGedEditor *ged, Int_t border=2);
    ~TGLEmbeddedViewer();
 
    virtual void CreateGLWidget();
diff --git a/graf3d/gl/inc/TGLEventHandler.h b/graf3d/gl/inc/TGLEventHandler.h
index 3552534..62f5556 100644
--- a/graf3d/gl/inc/TGLEventHandler.h
+++ b/graf3d/gl/inc/TGLEventHandler.h
@@ -35,6 +35,7 @@ class TGLEventHandler : public TGEventHandler
 protected:
    TGLViewer        *fGLViewer;
    TTimer           *fMouseTimer;     // mouse delay timer
+   TPoint            fButtonPushPos;
    TPoint            fLastPos;
    TPoint            fLastMouseOverPos;
    TGLPhysicalShape *fLastMouseOverShape;
@@ -52,6 +53,9 @@ protected:
 
    virtual Bool_t Rotate(Int_t xDelta, Int_t yDelta, Bool_t mod1, Bool_t mod2);
 
+   virtual void   GrabMouse();
+   virtual void   UnGrabMouse();
+
 public:
    TGLEventHandler(TGWindow *w, TObject *obj);
    virtual ~TGLEventHandler();
diff --git a/graf3d/gl/inc/TGLFormat.h b/graf3d/gl/inc/TGLFormat.h
index 4a20662..7850b85 100644
--- a/graf3d/gl/inc/TGLFormat.h
+++ b/graf3d/gl/inc/TGLFormat.h
@@ -37,14 +37,17 @@ public:
       kDoubleBuffer = 1,
       kDepth        = 2,
       kAccum        = 4,
-      kStencil      = 8
+      kStencil      = 8,
+      kStereo       = 16
    };
 
 private:
    Bool_t fDoubleBuffered;
+   Bool_t fStereo;
    UInt_t fDepthSize;
    UInt_t fAccumSize;
    UInt_t fStencilSize;
+   
 
 public:
    TGLFormat();
@@ -72,6 +75,9 @@ public:
    Bool_t IsDoubleBuffered()const;
    void   SetDoubleBuffered(Bool_t db);
 
+   Bool_t IsStereo()const;
+   void   SetStereo(Bool_t db);
+
    ClassDef(TGLFormat, 0) // Describes GL buffer format.
 };
 
diff --git a/graf3d/gl/inc/TGLLockable.h b/graf3d/gl/inc/TGLLockable.h
index c70362f..64edb5c 100644
--- a/graf3d/gl/inc/TGLLockable.h
+++ b/graf3d/gl/inc/TGLLockable.h
@@ -31,6 +31,24 @@ protected:
    // Locking - can take/release via const handle
    mutable ELock     fLock;        // Lock state.
 
+   // Ensures unlocking in view of exceptions.
+   class TUnlocker
+   {
+   private:
+      TUnlocker(const TUnlocker&);            // Not implemented
+      TUnlocker& operator=(const TUnlocker&); // Not implemented
+
+      const TGLLockable *fLockable;
+
+   public:
+      TUnlocker(const TGLLockable* l) : fLockable(l) {}
+      ~TUnlocker()
+      {
+         if (fLockable->IsLocked())
+            fLockable->ReleaseLock(fLockable->CurrentLock());
+      }
+   };
+
 public:
    TGLLockable();
    virtual ~TGLLockable() {}
@@ -47,7 +65,7 @@ public:
    static const char * LockName(ELock lock);
    static Bool_t       LockValid(ELock lock);
 
-   ClassDef(TGLLockable, 0) // Lock for viewers and scenes.
+   ClassDef(TGLLockable, 0); // Lock for viewers and scenes.
 }; // endclass TGLLockable
 
 #endif
diff --git a/graf3d/gl/inc/TGLMarchingCubes.h b/graf3d/gl/inc/TGLMarchingCubes.h
index ee82f29..bae8197 100644
--- a/graf3d/gl/inc/TGLMarchingCubes.h
+++ b/graf3d/gl/inc/TGLMarchingCubes.h
@@ -402,7 +402,8 @@ private:
    using DataSourceBase_t::GetH;
    using DataSourceBase_t::GetD;
    using DataSourceBase_t::GetData;
-   
+   using SplitterBase_t::SplitEdge;
+
    typedef typename DataSourceBase_t::ElementType_t ElementType_t;
 
    typedef TCell<ElementType_t>  CellType_t;
diff --git a/graf3d/gl/inc/TGLPerspectiveCamera.h b/graf3d/gl/inc/TGLPerspectiveCamera.h
index ee19330..98bfd36 100644
--- a/graf3d/gl/inc/TGLPerspectiveCamera.h
+++ b/graf3d/gl/inc/TGLPerspectiveCamera.h
@@ -42,6 +42,8 @@ public:
 
    virtual Bool_t IsPerspective() const { return kTRUE; }
 
+   Double_t GetFOV() const { return fFOV; }
+
    virtual void   Setup(const TGLBoundingBox & box, Bool_t reset=kTRUE);
    virtual void   Reset();
    virtual Bool_t Zoom (Int_t delta, Bool_t mod1, Bool_t mod2);
diff --git a/graf3d/gl/inc/TGLPhysicalShape.h b/graf3d/gl/inc/TGLPhysicalShape.h
index 104c996..a515892 100644
--- a/graf3d/gl/inc/TGLPhysicalShape.h
+++ b/graf3d/gl/inc/TGLPhysicalShape.h
@@ -34,6 +34,10 @@ class TGLPhysicalShape
 {
    friend class TGLLogicalShape; // for replica-list management
 
+private:
+   TGLPhysicalShape(const TGLPhysicalShape&);            // Not implemented
+   TGLPhysicalShape& operator=(const TGLPhysicalShape&); // Not implemented
+
 public:
    // Flags for permitted manipulation of object
    enum EManip  { kTranslateX   = 1 << 0,
diff --git a/graf3d/gl/inc/TGLRnrCtx.h b/graf3d/gl/inc/TGLRnrCtx.h
index 166c0a6..16154af 100644
--- a/graf3d/gl/inc/TGLRnrCtx.h
+++ b/graf3d/gl/inc/TGLRnrCtx.h
@@ -94,8 +94,9 @@ protected:
 
    Short_t         fViewerLOD;
    Short_t         fSceneLOD;
-   Short_t         fCombiLOD; // Combined viewer/scene lod
-   Short_t         fShapeLOD;
+   Short_t         fCombiLOD;     // Combined viewer/scene lod.
+   Short_t         fShapeLOD;     // LOD calculated for current shape.
+   Float_t         fShapePixSize; // Only relevant when not using display lists.
 
    Short_t         fViewerStyle;
    Short_t         fSceneStyle;
@@ -172,6 +173,8 @@ public:
    void    SetCombiLOD(Short_t LOD)    { fCombiLOD = LOD;  }
    Short_t ShapeLOD()    const         { return fShapeLOD; }
    void    SetShapeLOD(Short_t LOD)    { fShapeLOD = LOD;  }
+   Float_t ShapePixSize() const        { return fShapePixSize; }
+   void    SetShapePixSize(Float_t ps) { fShapePixSize = ps; }
 
    Short_t ViewerStyle() const         { return fViewerStyle; }
    void    SetViewerStyle(Short_t sty) { fViewerStyle = sty;  }
diff --git a/graf3d/gl/inc/TGLSAViewer.h b/graf3d/gl/inc/TGLSAViewer.h
index 2bf7398..cbb778f 100644
--- a/graf3d/gl/inc/TGLSAViewer.h
+++ b/graf3d/gl/inc/TGLSAViewer.h
@@ -12,21 +12,18 @@
 #ifndef ROOT_TGLSAViewer
 #define ROOT_TGLSAViewer
 
-#ifndef ROOT_TGLViewer
 #include "TGLViewer.h"
-#endif
-
-#ifndef ROOT_TString
 #include "TString.h"
-#endif
 
+class TGLSAFrame;
+class TGLFormat;
 class TGWindow;
 class TGFrame;
 class TGCompositeFrame;
 class TGPopupMenu;
+class TGButton;
 
 class TGedEditor;
-class TGLPShapeObj;
 class TGLEventHandler;
 class TGMenuBar;
 
@@ -52,7 +49,8 @@ public:
 
 private:
    // GUI components
-   TGCompositeFrame  *fFrame;
+   TGLSAFrame        *fFrame;
+   TGLFormat         *fFormat;
    TGPopupMenu       *fFileMenu;
    TGPopupMenu       *fFileSaveMenu;
    TGPopupMenu       *fCameraMenu;
@@ -60,8 +58,6 @@ private:
 
    // Ged
    TGCompositeFrame  *fLeftVerticalFrame;
-   TGedEditor        *fGedEditor;
-   TGLPShapeObj      *fPShapeWrap;
 
    TGCompositeFrame  *fRightVerticalFrame;
 
@@ -69,8 +65,17 @@ private:
    Int_t              fTypeIdx;
    Bool_t             fOverwrite;
    TGMenuBar         *fMenuBar;
+   TGButton          *fMenuBut;
+   Bool_t             fHideMenuBar;
+   TTimer            *fMenuHidingTimer;
+   Bool_t             fMenuHidingShowMenu;
+
    Bool_t             fDeleteMenuBar;
 
+   static Long_t      fgMenuHidingTimeout;
+
+   void ResetMenuHidingTimer(Bool_t show_menu);
+
    // Initial window positioning
    static const Int_t fgInitX;
    static const Int_t fgInitY;
@@ -88,8 +93,9 @@ private:
    TGLSAViewer & operator = (const TGLSAViewer &);
 
 public:
-   TGLSAViewer(TVirtualPad *pad);
-   TGLSAViewer(const TGWindow *parent, TVirtualPad *pad, TGedEditor *ged = 0);
+   TGLSAViewer(TVirtualPad* pad, TGLFormat* format=0);
+   TGLSAViewer(const TGWindow* parent, TVirtualPad *pad, TGedEditor *ged=0,
+               TGLFormat* format=0);
    ~TGLSAViewer();
 
    virtual void CreateGLWidget();
@@ -97,26 +103,32 @@ public:
 
    virtual const char* GetName() const { return "GLViewer"; }
 
-   virtual void SelectionChanged();     // *SIGNAL*
-   virtual void OverlayDragFinished(); // *SIGNAL*
-
-   virtual void RefreshPadEditor(TObject* changed=0);
+   virtual void SelectionChanged();
 
    void   Show();
    void   Close();
    void   DeleteMenuBar();
+   void   DisableCloseMenuEntries();
+   void   EnableMenuBarHiding();
+   void   DisableMenuBarHiding();
+   void   MenuHidingTimeout();
+
+   void   HandleMenuBarHiding(Event_t* ev);
 
    // GUI events - editors, frame etc
    Bool_t ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t);
 
-   TGCompositeFrame* GetFrame() const { return fFrame; }
+   TGCompositeFrame* GetFrame() const;
    TGCompositeFrame* GetLeftVerticalFrame() const { return fLeftVerticalFrame; }
-   TGedEditor*       GetGedEditor() const { return fGedEditor; }
+
+   TGLFormat*        GetFormat() const { return fFormat; }
 
    void ToggleEditObject();
    void ToggleOrthoRotate();
    void ToggleOrthoDolly();
 
+   static void SetMenuHidingTimeout(Long_t timeout);
+
    ClassDef(TGLSAViewer, 0); // Standalone GL viewer.
 };
 
diff --git a/graf3d/gl/inc/TGLScene.h b/graf3d/gl/inc/TGLScene.h
index b83d35e..8b3d42a 100644
--- a/graf3d/gl/inc/TGLScene.h
+++ b/graf3d/gl/inc/TGLScene.h
@@ -189,7 +189,7 @@ public:
    // Basic physical shape management
    virtual void              AdoptPhysical(TGLPhysicalShape& shape);
    virtual Bool_t            DestroyPhysical(UInt_t phid);
-   virtual Int_t             DestroyPhysicals(Bool_t incModified, const TGLCamera* camera=0);
+   virtual Int_t             DestroyPhysicals();
    virtual TGLPhysicalShape* FindPhysical(UInt_t phid) const;
 
    virtual UInt_t            GetMaxPhysicalID();
diff --git a/graf3d/gl/inc/TGLSurfacePainter.h b/graf3d/gl/inc/TGLSurfacePainter.h
index fe3719b..26a9647 100644
--- a/graf3d/gl/inc/TGLSurfacePainter.h
+++ b/graf3d/gl/inc/TGLSurfacePainter.h
@@ -14,6 +14,8 @@
 #include "TGLUtil.h"
 #endif
 
+class TRandom;
+
 class TGLSurfacePainter : public TGLPlotPainter {
 private:
    enum ESurfaceType {
@@ -97,6 +99,8 @@ private:
    void   DrawPalette()const;
    void   DrawPaletteAxis()const;
 
+   static TRandom *fgRandom;
+
    ClassDef(TGLSurfacePainter, 0)//Surface painter.
 };
 
diff --git a/graf3d/gl/inc/TGLUtil.h b/graf3d/gl/inc/TGLUtil.h
index 9b5c5bf..7827393 100644
--- a/graf3d/gl/inc/TGLUtil.h
+++ b/graf3d/gl/inc/TGLUtil.h
@@ -507,41 +507,9 @@ inline void TGLRect::Offset(Int_t dX, Int_t dY)
 }
 
 //______________________________________________________________________________
-inline void TGLRect::Expand(Int_t x, Int_t y)
-{
-   // Expand the rect to encompass point (x,y)
-   Int_t delX = x - fX;
-   Int_t delY = y - fY;
-
-   if (delX>static_cast<Int_t>(fWidth)) {
-      fWidth = delX;
-   }
-   if (delY>static_cast<Int_t>(fHeight)) {
-      fHeight = delY;
-   }
-
-   if (delX<0) {
-      fX = x;
-      fWidth += -delX;
-   }
-   if (delY<0) {
-      fY = y;
-      fHeight += -delY;
-   }
-}
-
-//______________________________________________________________________________
-inline Int_t TGLRect::Diagonal() const
-{
-   const Double_t w = static_cast<Double_t>(fWidth);
-   const Double_t h = static_cast<Double_t>(fHeight);
-   return static_cast<Int_t>(sqrt(w*w + h*h));
-}
-
-//______________________________________________________________________________
 inline Int_t TGLRect::Longest() const
 {
-   return fWidth > fHeight ? fWidth:fHeight;
+   return fWidth > fHeight ? fWidth : fHeight;
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/gl/inc/TGLViewer.h b/graf3d/gl/inc/TGLViewer.h
index 68f68f7..8414e3d 100644
--- a/graf3d/gl/inc/TGLViewer.h
+++ b/graf3d/gl/inc/TGLViewer.h
@@ -21,6 +21,7 @@
 
 #include "TGLPerspectiveCamera.h"
 #include "TGLOrthoCamera.h"
+#include "TGLClip.h"
 
 #include "TTimer.h"
 #include "TPoint.h"
@@ -44,7 +45,8 @@ class TGLContextIdentity;
 class TTimer;
 
 class TContextMenu;
-
+class TGedEditor;
+class TGLPShapeObj;
 
 class TGLViewer : public TVirtualViewer3D,
                   public TGLViewerBase,
@@ -82,16 +84,21 @@ protected:
    TGLOrthoCamera       fOrthoXOYCamera;       //!
    TGLOrthoCamera       fOrthoXOZCamera;       //!
    TGLOrthoCamera       fOrthoZOYCamera;       //!
-   TGLOrthoCamera       fOrthoXnOYCamera;       //!
-   TGLOrthoCamera       fOrthoXnOZCamera;       //!
-   TGLOrthoCamera       fOrthoZnOYCamera;       //!
+   TGLOrthoCamera       fOrthoXnOYCamera;      //!
+   TGLOrthoCamera       fOrthoXnOZCamera;      //!
+   TGLOrthoCamera       fOrthoZnOYCamera;      //!
    TGLCamera           *fCurrentCamera;        //!
 
+   // Stereo
+   Bool_t               fStereo;               //! use stereo rendering
+   Float_t              fStereoZeroParallax;   //! position of zero-parallax plane: 0 - near clipping plane, 1 - far clipping plane
+   Float_t              fStereoEyeOffsetFac;   //!
+   Float_t              fStereoFrustumAsymFac; //!
+
    // Lights
    TGLLightSet         *fLightSet;             //!
    // Clipping
    TGLClipSet          *fClipSet;              //!
-   Bool_t               fClipAutoUpdate;       //!
    // Selected physical
    TGLSelectRecord      fCurrentSelRec;        //! select record in use as selected
    TGLSelectRecord      fSelRec;               //! select record from last select (should go to context)
@@ -102,6 +109,8 @@ protected:
    TGLOvlSelectRecord   fOvlSelRec;            //! select record from last overlay select
 
    TGEventHandler      *fEventHandler;         //! event handler
+   TGedEditor          *fGedEditor;            //! GED editor
+   TGLPShapeObj        *fPShapeWrap;
 
    // Mouse ineraction
 public:
@@ -149,6 +158,9 @@ protected:
    ///////////////////////////////////////////////////////////////////////
    // Methods
    ///////////////////////////////////////////////////////////////////////
+
+   virtual void SetupClipObject();
+
    // Drawing - can tidy up/remove lots when TGLManager added
    void InitGL();
    void PreDraw();
@@ -171,7 +183,6 @@ protected:
    Bool_t           fIgnoreSizesOnUpdate;      // ignore sizes of bounding-boxes on update
    Bool_t           fResetCamerasOnUpdate;     // reposition camera on each update
    Bool_t           fResetCamerasOnNextUpdate; // reposition camera on next update
-   Bool_t           fResetCameraOnDoubleClick; // reposition camera on double-click
 
 public:
    TGLViewer(TVirtualPad* pad, Int_t x, Int_t y, Int_t width, Int_t height);
@@ -204,8 +215,6 @@ public:
    virtual void   ResetCameras()                { SetupCameras(kTRUE); }
    virtual void   ResetCamerasAfterNextUpdate() { fResetCamerasOnNextUpdate = kTRUE; }
 
-   virtual void   RefreshPadEditor(TObject* = 0) {}
-
    TGLWidget* GetGLWidget() { return fGLWidget; }
 
    virtual void  CreateGLWidget()  {}
@@ -232,6 +241,9 @@ public:
    static void         UseDefaultColorSetForNewViewers(Bool_t x);
    static Bool_t       IsUsingDefaultColorSetForNewViewers();
 
+   const TGLRect& RefViewport()      const { return fViewport; }
+   Int_t          ViewportDiagonal() const { return fViewport.Diagonal(); }
+
    Float_t GetPointScale()    const { return fPointScale; }
    Float_t GetLineScale()     const { return fLineScale; }
    void    SetPointScale(Float_t s) { fPointScale = s; }
@@ -243,8 +255,8 @@ public:
 
    TGLLightSet* GetLightSet() const { return fLightSet; }
    TGLClipSet * GetClipSet()  const { return fClipSet; }
-   Bool_t GetClipAutoUpdate() const   { return fClipAutoUpdate; }
-   void   SetClipAutoUpdate(Bool_t x) { fClipAutoUpdate = x; }
+   Bool_t GetClipAutoUpdate() const   { return fClipSet->GetAutoUpdate(); }
+   void   SetClipAutoUpdate(Bool_t x) { fClipSet->SetAutoUpdate(x); }
 
    // External GUI component interface
    TGLCamera & CurrentCamera() const { return *fCurrentCamera; }
@@ -263,6 +275,18 @@ public:
    TGLCameraOverlay* GetCameraOverlay() const { return fCameraOverlay; }
    void SetCameraOverlay(TGLCameraOverlay* m) { fCameraOverlay = m; }
 
+   // Stereo
+   Bool_t  GetStereo()               const { return fStereo; }
+   Float_t GetStereoZeroParallax()   const { return fStereoZeroParallax;   }
+   Float_t GetStereoEyeOffsetFac()   const { return fStereoEyeOffsetFac;   }
+   Float_t GetStereoFrustumAsymFac() const { return fStereoFrustumAsymFac; }
+
+   void SetStereo(Bool_t s)                { fStereo = s; }
+   void SetStereoZeroParallax(Float_t f)   { fStereoZeroParallax   = f; }
+   void SetStereoEyeOffsetFac(Float_t f)   { fStereoEyeOffsetFac   = f; }
+   void SetStereoFrustumAsymFac(Float_t f) { fStereoFrustumAsymFac = f; }
+
+   // Push / drag action
    EPushAction GetPushAction() const { return fPushAction; }
    EDragAction GetDragAction() const { return fDragAction; }
 
@@ -282,6 +306,8 @@ public:
    virtual void PreRender();
    virtual void PostRender();
    void DoDraw();
+   void DoDrawMono();
+   void DoDrawStereo();
 
    void DrawGuides();
    void DrawDebugInfo();
@@ -317,13 +343,9 @@ public:
    void   ResetCurrentCamera();
    Bool_t GetResetCamerasOnUpdate() const       { return fResetCamerasOnUpdate; }
    void   SetResetCamerasOnUpdate(Bool_t v)     { fResetCamerasOnUpdate = v; }
-   Bool_t GetResetCameraOnDoubleClick() const   { return fResetCameraOnDoubleClick; }
-   void   SetResetCameraOnDoubleClick(Bool_t v) { fResetCameraOnDoubleClick = v; }
 
    virtual void PostSceneBuildSetup(Bool_t resetCameras);
 
-   virtual void SelectionChanged();    // *SIGNAL*
-   virtual void OverlayDragFinished(); // *SIGNAL*
    virtual void MouseIdle(TGLPhysicalShape*,UInt_t,UInt_t); // *SIGNAL*
    virtual void MouseOver(TGLPhysicalShape*); // *SIGNAL*
    virtual void MouseOver(TGLPhysicalShape*, UInt_t state); // *SIGNAL*
@@ -337,6 +359,13 @@ public:
    TGEventHandler *GetEventHandler() const { return fEventHandler; }
    virtual void    SetEventHandler(TGEventHandler *handler);
 
+   TGedEditor*  GetGedEditor() const { return fGedEditor; }
+   virtual void SetGedEditor(TGedEditor* ed) { fGedEditor = ed; }
+
+   virtual void SelectionChanged();
+   virtual void OverlayDragFinished();
+   virtual void RefreshPadEditor(TObject* obj=0);
+
    virtual void RemoveOverlayElement(TGLOverlayElement* el);
 
    TGLSelectRecord&    GetSelRec()    { return fSelRec; }
diff --git a/graf3d/gl/inc/TGLViewerBase.h b/graf3d/gl/inc/TGLViewerBase.h
index d285b8f..98d0836 100644
--- a/graf3d/gl/inc/TGLViewerBase.h
+++ b/graf3d/gl/inc/TGLViewerBase.h
@@ -54,6 +54,8 @@ protected:
 
    void SubRenderScenes(SubRender_foo render_foo);
 
+   virtual void SetupClipObject();
+
    // Members
 
    TGLRnrCtx         *fRnrCtx;
diff --git a/graf3d/gl/inc/TGLViewerEditor.h b/graf3d/gl/inc/TGLViewerEditor.h
index c409b78..2064b7e 100644
--- a/graf3d/gl/inc/TGLViewerEditor.h
+++ b/graf3d/gl/inc/TGLViewerEditor.h
@@ -31,13 +31,13 @@ private:
    //Pointers to manipulate with tabs
    TGCompositeFrame *fGuidesFrame;
    TGCompositeFrame *fClipFrame;
+   TGCompositeFrame *fStereoFrame;
 
    TGLLightSetSubEditor *fLightSet;
 
    TGColorSelect    *fClearColor;
    TGCheckButton    *fIgnoreSizesOnUpdate;
    TGCheckButton    *fResetCamerasOnUpdate;
-   TGCheckButton    *fResetCameraOnDoubleClick;
    TGTextButton     *fUpdateScene;
    TGTextButton     *fCameraHome;
 
@@ -80,6 +80,10 @@ private:
 
    TGLClipSetSubEditor *fClipSet;
 
+   TGNumberEntry    *fStereoZeroParallax;
+   TGNumberEntry    *fStereoEyeOffsetFac;
+   TGNumberEntry    *fStereoFrustumAsymFac;
+
    //Model
    TGLViewer        *fViewer;
    Bool_t	     fIsInPad;
@@ -92,6 +96,7 @@ private:
    void CreateStyleTab();
    void CreateGuidesTab();
    void CreateClippingTab();
+   void CreateStereoTab();
 
    void UpdateReferencePosState();
 
@@ -108,7 +113,6 @@ public:
    void DoClearColor(Pixel_t color);
    void DoIgnoreSizesOnUpdate();
    void DoResetCamerasOnUpdate();
-   void DoResetCameraOnDoubleClick();
    void DoUpdateScene();
    void DoCameraHome();
    void UpdateMaxDrawTimes();
@@ -122,6 +126,8 @@ public:
    void UpdateViewerAxes(Int_t id);
    void UpdateViewerReference();
    void DoCameraOverlay();
+   // Stereo
+   void UpdateStereo();
 
    void DetachFromPad(){fIsInPad = kFALSE;}
 
diff --git a/graf3d/gl/src/CsgOps.cxx b/graf3d/gl/src/CsgOps.cxx
index 6d09a10..433d08e 100644
--- a/graf3d/gl/src/CsgOps.cxx
+++ b/graf3d/gl/src/CsgOps.cxx
@@ -107,7 +107,7 @@ namespace RootCsg {
       Double_t fCo[2];
 
    public:
-      Tuple2(){}
+      Tuple2(){SetValue(0, 0);}
       Tuple2(const Double_t *vv){SetValue(vv);}
       Tuple2(Double_t xx, Double_t yy){SetValue(xx, yy);}
 
@@ -448,7 +448,7 @@ namespace RootCsg {
    protected:
       Double_t fCo[3];
    public:
-      Tuple3(){}
+      Tuple3(){SetValue(0, 0, 0);}
       Tuple3(const Double_t *v){SetValue(v);}
       Tuple3(Double_t xx, Double_t yy, Double_t zz){SetValue(xx, yy, zz);}
 
@@ -852,7 +852,7 @@ namespace RootCsg {
       Double_t fCo[4];
 
    public:
-      Tuple4(){}
+      Tuple4(){SetValue(0, 0, 0, 0);}
       Tuple4(const Double_t *v){SetValue(v);}
       Tuple4(Double_t xx, Double_t yy, Double_t zz, Double_t ww)
       {
@@ -1383,7 +1383,7 @@ namespace RootCsg {
    public:
       Int_t fPolyIndex;
 
-      TBBoxLeaf() {}
+      TBBoxLeaf() : fPolyIndex(0) {}
       TBBoxLeaf(Int_t polyIndex, const TBBox &bbox) : fPolyIndex(polyIndex)
       {
          fBBox = bbox;
@@ -1398,7 +1398,7 @@ namespace RootCsg {
    public:
       NodePtr_t fLeftSon;
       NodePtr_t fRightSon;
-      TBBoxInternal() {}
+      TBBoxInternal() : fLeftSon(0) ,fRightSon(0) {}
       TBBoxInternal(Int_t n, LeafPtr_t leafIt);
    };
 
@@ -1412,7 +1412,7 @@ namespace RootCsg {
       Int_t         fNumLeaves;
 
    public :
-      TBBoxTree(){}
+      TBBoxTree() : fBranch(0), fLeaves(0), fInternals(0), fNumLeaves(0) {}
       NodePtr_t RootNode()const{return fInternals;}
       ~TBBoxTree()
       {
@@ -1426,7 +1426,8 @@ namespace RootCsg {
    };
 
    //______________________________________________________________________________
-   TBBoxInternal::TBBoxInternal(Int_t n, LeafPtr_t leafIt)
+   TBBoxInternal::TBBoxInternal(Int_t n, LeafPtr_t leafIt) :
+      fLeftSon(0) ,fRightSon(0)
    {
       //
       fTag = kInternal;
@@ -1494,7 +1495,7 @@ namespace RootCsg {
       {
          fVertexIndex = vIndex;
       }
-      TBlenderVProp(){}
+      TBlenderVProp() : fVertexIndex(-1){}
       operator Int_t()const
       {
          return fVertexIndex;
diff --git a/graf3d/gl/src/TGLAnnotation.cxx b/graf3d/gl/src/TGLAnnotation.cxx
index 637209d..3aa0512 100644
--- a/graf3d/gl/src/TGLAnnotation.cxx
+++ b/graf3d/gl/src/TGLAnnotation.cxx
@@ -47,20 +47,22 @@ TGLAnnotation::TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t po
 
    fPosX(posx), fPosY(posy),
    fMouseX(0),  fMouseY(0),
-   fInDrag(kFALSE),
+   fDrag(kNone),
+   fDrawW(0), fDrawH(0), fTextSizeDrag(0),
    fActive(kFALSE),
    fMainFrame(0), fTextEdit(0),
 
    fParent(0),
 
    fText(text),
-   fTextSize(0.02),
+   fTextSize(0.03),
    fTextAlign(TGLFont::kLeft),
    fBackColor(fgBackColor),
    fTextColor(fgTextColor),
    fTransparency(100),
    fDrawRefLine(kFALSE),
-   fUseColorSet(kTRUE)
+   fUseColorSet(kTRUE),
+   fAllowClose(kTRUE)
 {
    // Constructor.
    // Create annotation as plain text
@@ -74,20 +76,22 @@ TGLAnnotation::TGLAnnotation(TGLViewerBase *parent, const char *text, Float_t po
    TGLOverlayElement(TGLOverlayElement::kAnnotation),
    fPosX(posx), fPosY(posy),
    fMouseX(0),  fMouseY(0),
-   fInDrag(kFALSE),
+   fDrag(kNone),
+   fDrawW(0), fDrawH(0), fTextSizeDrag(0),
    fActive(kFALSE),
    fMainFrame(0), fTextEdit(0),
 
    fParent(0),
 
    fText(text),
-   fTextSize(0.02),
+   fTextSize(0.03),
    fTextAlign(TGLFont::kLeft),
    fBackColor(fgBackColor),
    fTextColor(fgTextColor),
    fTransparency(40),
    fDrawRefLine(kTRUE),
-   fUseColorSet(kFALSE)
+   fUseColorSet(kTRUE),
+   fAllowClose(kTRUE)
 {
    // Constructor.
    // Create annotaton by picking an object.
@@ -116,38 +120,38 @@ Bool_t TGLAnnotation::Handle(TGLRnrCtx&          rnrCtx,
 
    if (selRec.GetN() < 2) return kFALSE;
    Int_t recID = selRec.GetItem(1);
-
    switch (event->fType)
    {
       case kButtonPress:
       {
          fMouseX = event->fX;
          fMouseY = event->fY;
-         fInDrag = kTRUE;
-
+         fDrag = (recID == kResizeID) ? kResize : kMove;
+         fTextSizeDrag = fTextSize;
          return kTRUE;
       }
       case kButtonRelease:
       {
-         fInDrag = kFALSE;
-
-         if (recID == 2)
+         fDrag = kNone;
+         if (recID == kDeleteID)
          {
+            TGLViewer *v = fParent;
             delete this;
-            fParent->RequestDraw(rnrCtx.ViewerLOD());
+            v->RequestDraw(rnrCtx.ViewerLOD());
          }
-         else if (recID == 3)
+         else if (recID == kEditID)
          {
             MakeEditor();
          }
-
          return kTRUE;
       }
       case kMotionNotify:
       {
-         if (fInDrag)
+         const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+         if (vp.Width() == 0 || vp.Height() == 0) return kFALSE;
+
+         if (fDrag == kMove)
          {
-            const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
             fPosX += (Float_t)(event->fX - fMouseX) / vp.Width();
             fPosY -= (Float_t)(event->fY - fMouseY) / vp.Height();
             fMouseX = event->fX;
@@ -157,10 +161,23 @@ Bool_t TGLAnnotation::Handle(TGLRnrCtx&          rnrCtx,
                fPosX = 0;
             else if (fPosX + fDrawW > 1.0f)
                fPosX = 1.0f - fDrawW;
-            if (fPosY - fDrawH + fDrawY < 0)
-               fPosY = fDrawH - fDrawY;
-            else if (fPosY + fDrawY > 1.0f)
-               fPosY = 1.0f - fDrawY;
+            if (fPosY < fDrawH)
+               fPosY = fDrawH;
+            else if (fPosY > 1.0f)
+               fPosY = 1.0f;
+         }
+         else if (fDrag == kResize)
+         {
+            using namespace TMath;
+            Float_t oovpw = 1.0f / vp.Width(), oovph = 1.0f / vp.Height();
+
+            Float_t xw = oovpw * Min(Max(0, event->fX), vp.Width());
+            Float_t yw = oovph * Min(Max(0, vp.Height() - event->fY), vp.Height());
+
+            Float_t rx = Max((xw - fPosX) / (oovpw * fMouseX - fPosX), 0.0f);
+            Float_t ry = Max((yw - fPosY) / (oovph*(vp.Height() - fMouseY) - fPosY), 0.0f);
+
+            fTextSize  = Max(fTextSizeDrag * Min(rx, ry), 0.01f);
          }
          return kTRUE;
       }
@@ -193,19 +210,22 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
 {
    // Render the annotation.
 
+   const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
+   if (vp.Width() == 0 && vp.Height() == 0)
+      return;
+
    Float_t old_depth_range[2];
    glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
    glDepthRange(0, 0.001);
 
-   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT );
+
+   glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT | GL_POLYGON_BIT);
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glDisable(GL_CULL_FACE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
-   const TGLRect& vp = rnrCtx.RefCamera().RefViewport();
-
    // prepare colors
    Color_t bgCol, fgCol;
    if (fUseColorSet)
@@ -219,22 +239,12 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
                                c1->GetGreen()*f1  + c2->GetGreen()*f2,
                                c1->GetBlue() *f1  + c2->GetBlue() *f2);
    }
-   else {
+   else
+   {
       fgCol = fTextColor;
       bgCol = fBackColor;
    }
 
-   if (fDrawRefLine)
-   {
-      TGLUtil::ColorTransparency(bgCol, fTransparency);
-      TGLUtil::LineWidth(2);
-      glBegin(GL_LINES);
-      TGLVertex3 v = rnrCtx.RefCamera().ViewportToWorld(TGLVertex3(fPosX*vp.Width(), fPosY*vp.Height(), 0));
-      glVertex3dv(v.Arr());
-      glVertex3dv(fPointer.Arr());
-      glEnd();
-   }
-
    // reset matrix
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
@@ -246,153 +256,219 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
       gluPickMatrix(rect.X(), rect.Y(), rect.Width(), rect.Height(),
                     (Int_t*) rnrCtx.GetCamera()->RefViewport().CArr());
    }
-   glOrtho(vp.X(), vp.Width(), vp.Y(), vp.Height(), 0, 1);
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
+   // set ortho camera to [0,1] [0.1]
    glLoadIdentity();
+   glTranslatef(-1.0f, -1.0f, 0.0f);
+   glScalef(2.0f, 2.0f, 1.0f);
 
    glEnable(GL_POLYGON_OFFSET_FILL);
-   glPolygonOffset(0.1, 1);
+   glPolygonOffset(0.1f, 1.0f);
 
-   TGLUtil::LineWidth(1);
-
-   // move to pos
-   Float_t posX = vp.Width()  * fPosX;
-   Float_t posY = vp.Height() * fPosY;
-   glTranslatef(posX, posY, -0.99);
-
-
-   // get size of bg area, look at font attributes
-   rnrCtx.RegisterFontNoScale(TMath::Nint(fTextSize*vp.Width()), "arial",  TGLFont::kPixmap, fFont);
-   Float_t ascent, descent, line_height;
-   fFont.MeasureBaseLineParams(ascent, descent, line_height);
-   TObjArray* lines = fText.Tokenize("\n");
-   Float_t width  = 0;
-   Float_t height = 0;
-   TIter  lit(lines);
-   TObjString* osl;
-   Float_t llx, lly, llz, urx, ury, urz;
-   while ((osl = (TObjString*) lit()) != 0)
-   {
-      fFont.BBox(osl->GetString().Data(), llx, lly, llz, urx, ury, urz);
-      width = TMath::Max(width, urx);
-      height -= (line_height + descent);
-   }
-   width  += 2 * descent;
-   height -= 2 * descent;
+   glPushMatrix();
 
-   // Store variables needed for border check when box is dragged.
-   fDrawW = (Float_t) width / vp.Width();
-   fDrawH = (Float_t) - height / vp.Height();
-   fDrawY = line_height / vp.Height();
+   TGLUtil::LineWidth(1.0f);
 
-   // polygon background
-   Float_t padT =  2;
-   Int_t   padF = 10;
-   Float_t padM = padF + 2 * padT;
+   // move to pos
+   glTranslatef(fPosX, fPosY, 0.0f);
 
-   glPushName(0);
+   TObjArray  *lines = fText.Tokenize("\n");
+   TIter       line_iter(lines);
+   TObjString *osl;
 
-   // bg plain
-   Float_t y = line_height;
-   Float_t x = 0;
-   glLoadName(1);
+   Float_t widthTxt, heightTxt, sx, sy, descent, line_height;
+   {
+      // get unscaled text size
+      Int_t fs = TGLFontManager::GetFontSize(TMath::Nint(vp.Height()*fTextSize), 12, 64);
+      rnrCtx.RegisterFontNoScale(fs, "arial", TGLFont::kTexture, fFont);
+      descent     = fFont.GetDescent();
+      line_height = fFont.GetLineHeight();
+
+      Float_t llx, lly, llz, urx, ury, urz;
+      widthTxt = heightTxt = 0;
+      while ((osl = (TObjString*) line_iter()) != 0)
+      {
+         fFont.BBox(osl->GetString().Data(), llx, lly, llz, urx, ury, urz);
+         widthTxt   = TMath::Max(widthTxt, urx);
+         heightTxt += line_height;
+      }
+      widthTxt  += 2.0f * descent;
+      heightTxt += 2.0f * descent;
+
+      // keep proportions
+      sy = fTextSize / (line_height + descent);
+      sx = sy / vp.Aspect();
+      fDrawW = sx*widthTxt;
+      fDrawH = sy*heightTxt;
+   }
+   glScalef(sx, sy, 1.0f);
+
+   glPushName(kMoveID);
+
+   Float_t x1, x2, y1, y2;
+   Float_t z3 =  0.0f;  // main background
+   Float_t z2 = -0.01f; // outlines and text
+   Float_t z1 = -0.02f; // button on top of text
+   Float_t z0 = -0.03f; // button on top of text
+
+   // main background
+   glLoadName(kMoveID);
+   x1 =  0.0f;
+   x2 =  widthTxt;
+   y1 = -heightTxt;
+   y2 =  0.0f;
    TGLUtil::ColorTransparency(bgCol, fTransparency);
    glBegin(GL_QUADS);
-   glVertex2f(x, y);
-   glVertex2f(x, y + height);
-   glVertex2f(x+width, y + height);
-   glVertex2f(x+width, y);
+   glVertex3f(x1, y1, z3);
+   glVertex3f(x2, y1, z3);
+   glVertex3f(x2, y2, z3);
+   glVertex3f(x1, y2, z3);
    glEnd();
-
-   // outline
-   TGLUtil::ColorTransparency(fgCol, fTransparency);
+   // main polygon outline
+   TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
    glBegin(GL_LINE_LOOP);
-   glVertex2f(x, y);
-   glVertex2f(x, y + height);
-   glVertex2f(x+width, y + height);
-   glVertex2f(x+width, y);
+   glVertex3f(x1, y1, z2);
+   glVertex3f(x2, y1, z2);
+   glVertex3f(x2, y2, z2);
+   glVertex3f(x1, y2, z2);
    glEnd();
 
-   if (fActive && fTransparency < 100)
-   {  // edit area
-
-      TGLUtil::ColorTransparency(bgCol, fTransparency);
-      // edit button
-      glLoadName(2);
-      glBegin(GL_QUADS);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd();
-      // close button
-      glLoadName(3);
-      x = padM;
-      glBegin(GL_QUADS);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd();
-
-      // outlines
-      TGLUtil::ColorTransparency(fgCol, fTransparency);
-      x = 0; // left
-      glBegin(GL_LINE_LOOP);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd(); // right
-      x = padM;
-      glBegin(GL_LINE_LOOP);
-      glVertex2f(x + padM, y);
-      glVertex2f(x,        y);
-      glVertex2f(x,        y + padM);
-      glVertex2f(x + padM, y + padM);
-      glEnd();
-   }
-   glPopName();
-
-   // text
-   Float_t zOff = 0.2; // more than 0, else not rendered
-   fFont.PreRender();
+   // annotation text
    TGLUtil::Color(fgCol);
-   TIter  next_base(lines);
-   TObjString* os;
+   fFont.PreRender();
    glPushMatrix();
-   glTranslatef(descent, line_height, zOff);
    Float_t tx = 0;
-   while ((os = (TObjString*) next_base()) != 0)
+   line_iter.Reset();
+   while ((osl = (TObjString*) line_iter()) != 0)
    {
-      glTranslatef(0, -(line_height + descent), 0);
       if (fTextAlign == TGLFont::kLeft) {
          tx = 0;
       }
       else if  (fTextAlign == TGLFont::kCenterH) {
-         tx = 0.5 * width - descent ;
+         tx = 0.5f * widthTxt - descent ;
       }
       else {
-         tx = width - 2*descent;
+         tx = widthTxt - 2.0f * descent;
       }
-      fFont.Render(os->GetString(), tx, 0, 0, fTextAlign, TGLFont::kTop);
+      glTranslatef(0.0f, -line_height, 0.0f);
+      fFont.Render(osl->GetString(), tx+descent, 0, z2, fTextAlign, TGLFont::kTop) ;
    }
    glPopMatrix();
    fFont.PostRender();
 
-   // menu
+   delete lines;
 
-   if (fActive && fTransparency < 100)
+   // buttons
+   if (fActive)
    {
-      x = padT;
-      y = padT + 0.5*padF + line_height;
-      rnrCtx.RegisterFontNoScale(padF, "arial",  TGLFont::kPixmap, fMenuFont);
-      fMenuFont.PreRender();
-      fMenuFont.Render("X", x, y, zOff, TGLFont::kLeft, TGLFont::kCenterV);
-      x += padM + padT;
-      fMenuFont.Render("E", x, y, zOff, TGLFont::kLeft, TGLFont::kCenterV);
-      fMenuFont.PostRender();
+      Float_t bbox[6];
+      fFont.PreRender();
+      fFont.BBox("X", bbox[0], bbox[1], bbox[2], bbox[3], bbox[4], bbox[5]);
+      glLoadName(kEditID);
+      fFont.Render("E", descent, descent, z2, fTextAlign, TGLFont::kTop);
+      x2 = bbox[3] + 2.0f * descent;
+      if (fAllowClose)
+      {
+         glLoadName(kDeleteID);
+         fFont.Render("X", x2 + descent, descent, z2, fTextAlign, TGLFont::kTop);
+      }
+      fFont.PostRender();
+
+      x1 = 0.0f;
+      y1 = 0.0f;
+      y2 = line_height + descent;
+      {
+         // edit button
+         glLoadName(kEditID);
+         // polygon
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         glBegin(GL_QUADS);
+         glVertex3f(x1, y1, z3);
+         glVertex3f(x2, y1, z3);
+         glVertex3f(x2, y2, z3);
+         glVertex3f(x1, y2, z3);
+         glEnd();
+         //  outline
+         TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
+         glBegin(GL_LINE_LOOP);
+         glVertex3f(x1, y1, z0);
+         glVertex3f(x2, y1, z0);
+         glVertex3f(x2, y2, z0);
+         glVertex3f(x1, y2, z0);
+         glEnd();
+      }
+      x1 += x2;
+      x2 += x2;
+      if (fAllowClose)
+      {
+         // close button
+         glLoadName(kDeleteID);
+         // polygon
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         glBegin(GL_QUADS);
+         glVertex3f(x1, y1, z3);
+         glVertex3f(x2, y1, z3);
+         glVertex3f(x2, y2, z3);
+         glVertex3f(x1, y2, z3);
+         glEnd();
+         //  outline
+         TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
+         glBegin(GL_LINE_LOOP);
+         glVertex3f(x1, y1, z0);
+         glVertex3f(x2, y1, z0);
+         glVertex3f(x2, y2, z0);
+         glVertex3f(x1, y2, z0);
+         glEnd();
+      }
+      {
+         // resize button
+         glLoadName(kResizeID);
+         // polygon
+         x1 =  widthTxt - line_height;
+         x2 =  widthTxt;
+         y1 = -heightTxt;
+         y2 = -heightTxt + line_height;
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         glBegin(GL_QUADS);
+         glVertex3f(x1, y1, z1);
+         glVertex3f(x2, y1, z1);
+         glVertex3f(x2, y2, z1);
+         glVertex3f(x1, y2, z1);
+         glEnd();
+         // draw resize corner lines
+         TGLUtil::ColorTransparency(fgCol, GetLineTransparency());
+         glBegin(GL_LINES);
+         Float_t aOff = 0.25*line_height;
+         glVertex3f(x1+aOff, y1+aOff, z0);
+         glVertex3f(x2-aOff, y1+aOff, z0);
+         glVertex3f(x2-aOff, y1+aOff, z0);
+         glVertex3f(x2-aOff, y2-aOff, z0);
+         glEnd();
+      }
+   }
+
+   glPopName();
+
+   glPopMatrix();
+
+   if (fDrawRefLine)
+   {
+      TGLVertex3 op = rnrCtx.RefCamera().WorldToViewport(fPointer);
+      op[0] /= vp.Width();  op[1] /= vp.Height();
+
+      Float_t fx = op[0] < fPosX ? 0.0f : (op[0] > fPosX + fDrawW ? 1.0f : 0.5f);
+      Float_t fy = op[1] < fPosY-fDrawH ? 1.0f : (op[1] > fPosY ? 0.0f : 0.5f);
+
+      if (fx != 0.5f || fy != 0.5f)
+      {
+         TGLUtil::ColorTransparency(bgCol, fTransparency);
+         TGLUtil::LineWidth(2);
+         glBegin(GL_LINES);
+         glVertex3f(fPosX + fx*fDrawW, fPosY - fy*fDrawH, z3);
+         glVertex3f(op[0], op[1], z3);
+         glEnd();
+      }
    }
 
    glMatrixMode(GL_PROJECTION);
@@ -405,6 +481,18 @@ void TGLAnnotation::Render(TGLRnrCtx& rnrCtx)
 }
 
 //______________________________________________________________________________
+Char_t TGLAnnotation::GetLineTransparency() const
+{
+   // Returns transparecy of annotation outline.
+   // If annotation is selected enforce visiblity of outline.
+
+   if (fActive)
+      return TMath::Min(70, fTransparency);
+   else
+      return fTransparency;
+}
+
+//______________________________________________________________________________
 void TGLAnnotation::MakeEditor()
 {
    // Show the annotation editor.
diff --git a/graf3d/gl/src/TGLAxis.cxx b/graf3d/gl/src/TGLAxis.cxx
index 373e33d..a658f3d 100644
--- a/graf3d/gl/src/TGLAxis.cxx
+++ b/graf3d/gl/src/TGLAxis.cxx
@@ -42,6 +42,8 @@ void TGLAxis::Init()
 {
    // Default initialization.
 
+   fNDiv = fNDiv1 = fNDiv2 = fNDiv3 = 0;
+   fNTicks1 = fNTicks2 = 0;
    fTicks1          = 0;
    fTicks2          = 0;
    fLabels          = 0;
@@ -50,6 +52,7 @@ void TGLAxis::Init()
    fAngle2          = 0.;
    fAngle3          = 0.;
    fAxisLength      = 0.;
+   fWmin = fWmax    = 0.;
    fTickMarksLength = 0.04; // % of fAxisLength
    fTickMarksOrientation = 2; // can be 0, 1, 2, or 3
    fLabelsOffset    = 0.09; // % of fAxisLength
diff --git a/graf3d/gl/src/TGLAxisPainter.cxx b/graf3d/gl/src/TGLAxisPainter.cxx
index fb8a0da..67328c3 100644
--- a/graf3d/gl/src/TGLAxisPainter.cxx
+++ b/graf3d/gl/src/TGLAxisPainter.cxx
@@ -50,9 +50,12 @@ TGLAxisPainter::TGLAxisPainter():
    fTitlePixelFontSize(14),
 
    fLabelAlignH(TGLFont::kCenterH),
-   fLabelAlignV(TGLFont::kCenterV)
+   fLabelAlignV(TGLFont::kCenterV),
+   fAllZeroesRE(0)
 {
    // Constructor.
+
+   fAllZeroesRE = new TPMERegexp("[-+]?0\\.0*$", "o");
 }
 
 
@@ -61,6 +64,7 @@ TGLAxisPainter::~TGLAxisPainter()
 {
    // Destructor.
 
+   delete fAllZeroesRE;
 }
 
 //______________________________________________________________________________
@@ -92,10 +96,7 @@ void TGLAxisPainter::FormAxisValue(Double_t  val, TString &s) const
 {
    // Returns formatted text suitable for display of value.
 
-   static char label[256];
-
-   sprintf(label, &fFormat[0], val);
-   s = label;
+   s.Form(fFormat, val);
    s = s.Strip(TString::kLeading);
 
    if (s == "-." || s == "-0")
@@ -104,15 +105,15 @@ void TGLAxisPainter::FormAxisValue(Double_t  val, TString &s) const
       return;
    }
 
-   if (s.EndsWith("."))
-      s += '0';
-
-   Ssiz_t ld = s.Last('.');
+   Ssiz_t ld = s.Last('.') + 1;
    if (s.Length() - ld > fDecimals)
       s.Remove(ld + fDecimals);
 
-   TPMERegexp zeroes("[-+]?0\\.0*$");
-   zeroes.Substitute(s, "0");
+
+   if (fDecimals == 0 && s.EndsWith("."))
+      s.Remove(s.Length() -1);
+
+   fAllZeroesRE->Substitute(s, "0", kFALSE);
 }
 
 //______________________________________________________________________________
@@ -183,15 +184,15 @@ void TGLAxisPainter::SetTextFormat(Double_t min, Double_t max, Double_t bw1)
    }
    if (if1 > 14) if1 = 14;
    if (if2 > 14) if2 = 14;
-   if (if2) sprintf(fFormat, "%%%d.%df", if1, if2);
-   else     sprintf(fFormat, "%%%d.%df", if1 + 1, 1);
+   if (if2) fFormat.Form("%%%d.%df", if1, if2);
+   else     fFormat.Form("%%%d.%df", if1 + 1, 1);
 
    // get decimal number
-   char chtemp[8];
-   sprintf(chtemp, "%g", dwlabel);
+   TString chtemp;
+   chtemp.Form("%g", dwlabel);
    fDecimals = 0;
-   char *dot = strchr(chtemp, '.');
-   if (dot) fDecimals = chtemp + strlen(chtemp) - dot;
+   if (chtemp.First('.') != kNPOS)
+      fDecimals = chtemp.Length() - chtemp.First('.') - 1;
 }
 
 /**************************************************************************/
diff --git a/graf3d/gl/src/TGLCameraOverlay.cxx b/graf3d/gl/src/TGLCameraOverlay.cxx
index c84f5a8..73d325b 100644
--- a/graf3d/gl/src/TGLCameraOverlay.cxx
+++ b/graf3d/gl/src/TGLCameraOverlay.cxx
@@ -48,6 +48,8 @@ TGLCameraOverlay::TGLCameraOverlay(Bool_t showOrtho, Bool_t showPersp) :
 {
    // Constructor.
 
+   fFrustum[0] = fFrustum[1] = fFrustum[2] = fFrustum[3] = 0;
+
    fAxis = new TAxis();
    fAxis->SetNdivisions(710);
    fAxis->SetLabelSize(0.018);
@@ -72,13 +74,33 @@ TGLCameraOverlay::~TGLCameraOverlay()
 //______________________________________________________________________________
 TAttAxis* TGLCameraOverlay::GetAttAxis()
 {
+   // Get axis attributes.
+
    return dynamic_cast<TAttAxis*>(fAxis);
 }
 
 //______________________________________________________________________________
+void TGLCameraOverlay::SetFrustum(TGLCamera& cam)
+{
+   // Set frustum values from given camera.
+
+   TGLVector3 absRef(1., 1., 1.); // needed in case if orthographic camera is negative
+   Float_t l = -cam.FrustumPlane(TGLCamera::kLeft).D()  * Dot(cam.GetCamBase().GetBaseVec(2), absRef);
+   Float_t r =  cam.FrustumPlane(TGLCamera::kRight).D() * Dot(cam.GetCamBase().GetBaseVec(2), absRef);
+   Float_t t =  cam.FrustumPlane(TGLCamera::kTop).D();
+   Float_t b = -cam.FrustumPlane(TGLCamera::kBottom).D();
+
+   fFrustum[0] = l;
+   fFrustum[1] = b;
+   fFrustum[2] = r;
+   fFrustum[3] = t;
+}
+
+//______________________________________________________________________________
 void TGLCameraOverlay::RenderPlaneIntersect(TGLRnrCtx& rnrCtx)
 {
-   // Print corss section coordinates in top right corner of screen.
+   // Draw cross section coordinates in top right corner of screen.
+
    TGLCamera &cam = rnrCtx.RefCamera();
    // get eye line
    const TGLMatrix& mx =  cam.GetCamBase() * cam.GetCamTrans();
@@ -156,20 +178,34 @@ void TGLCameraOverlay::RenderAxis(TGLRnrCtx& rnrCtx, Bool_t grid)
    Float_t tlY = 0.015*rl/(vp[2]-vp[0]);
    Float_t tlX = 0.015*rl/(vp[3]-vp[1]);
    // corner vectors
+   Float_t minX, maxX;
    TGLVector3 xdir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(2); xdir.Normalise(); // left
+   if (fFrustum[2] > fFrustum[0] )
+   {   
+      minX =  fFrustum[0];
+      maxX =  fFrustum[2];
+   }
+   else {
+      xdir = -xdir;
+      minX =  fFrustum[2];
+      maxX =  fFrustum[0];
+   }
+
    TGLVector3 ydir = rnrCtx.RefCamera().GetCamBase().GetBaseVec(3); ydir.Normalise(); // up
    TGLVector3 vy1 = ydir * fFrustum[1];
    TGLVector3 vy2 = ydir * fFrustum[3];
-   TGLVector3 vx1 = xdir * fFrustum[0];
-   TGLVector3 vx2 = xdir * fFrustum[2];
+
+   TGLVector3 vx1 = xdir * minX;
+   TGLVector3 vx2 = xdir * maxX;
    // range
    Double_t rngY = fFrustum[3] - fFrustum[1];
-   Double_t rngX = fFrustum[2] - fFrustum[0];
-   Double_t off = TMath::Sqrt((rngX*rngY)+(rngX*rngY)) * 0.03;
-   Double_t minX = fFrustum[0] + off;
-   Double_t maxX = fFrustum[2] - off ;
+   Double_t rngX = maxX - minX;
+   Double_t off =  TMath::Sqrt((rngX*rngX)+(rngY*rngY)) * 0.03;
    Double_t minY = fFrustum[1] + off;
    Double_t maxY = fFrustum[3] - off;
+   minX += off;
+   maxX -= off;
+
    // grid lines
    Char_t alpha = 80; //primary
    Char_t alpha2 = 90; //seconndary
@@ -342,7 +378,7 @@ void TGLCameraOverlay::RenderBar(TGLRnrCtx&  rnrCtx)
    // Show frustum size with fixed screen line length and printed value.
 
    // factors 10, 5 and 2 are allowed
-   Double_t wfrust     = fFrustum[2]-fFrustum[0];
+   Double_t wfrust     = TMath::Abs(fFrustum[2]-fFrustum[0]);
    Float_t barsize= 0.14* wfrust;
    Int_t exp = (Int_t) TMath::Floor(TMath::Log10(barsize));
    Double_t fact = barsize/TMath::Power(10, exp);
@@ -426,32 +462,24 @@ void TGLCameraOverlay::Render(TGLRnrCtx& rnrCtx)
    // Display coodinates info of current frustum.
 
    TGLCamera &cam = rnrCtx.RefCamera();
-   if ( rnrCtx.Selection() || (cam.IsPerspective()  && ! fShowPerspective) ||
-        (cam.IsOrthographic() && ! fShowOrthographic))
-      return;
 
-
-   // Frustum size.
-   TGLCamera &camera = rnrCtx.RefCamera();
-   Float_t l = -camera.FrustumPlane(TGLCamera::kLeft).D();
-   Float_t r =  camera.FrustumPlane(TGLCamera::kRight).D();
-   Float_t t =  camera.FrustumPlane(TGLCamera::kTop).D();
-   Float_t b = -camera.FrustumPlane(TGLCamera::kBottom).D();
-
-   fFrustum[0] = l;
-   fFrustum[1] = b;
-   fFrustum[2] = r;
-   fFrustum[3] = t;
+   if (rnrCtx.Selection() ||
+       (cam.IsPerspective()  && ! fShowPerspective) ||
+       (cam.IsOrthographic() && ! fShowOrthographic))
+   {
+      return;
+   }
 
    glPushAttrib(GL_ENABLE_BIT | GL_LINE_BIT);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
 
+   TGLUtil::Color(rnrCtx.ColorSet().Markup());
    TGLCapabilitySwitch lights_off(GL_LIGHTING, kFALSE);
    Float_t old_depth_range[2];
    glGetFloatv(GL_DEPTH_RANGE, old_depth_range);
 
-   TGLUtil::Color(rnrCtx.ColorSet().Markup());
+   SetFrustum(cam);
 
    if (cam.IsOrthographic())
    {
diff --git a/graf3d/gl/src/TGLClip.cxx b/graf3d/gl/src/TGLClip.cxx
index 13e926b..d473a76 100644
--- a/graf3d/gl/src/TGLClip.cxx
+++ b/graf3d/gl/src/TGLClip.cxx
@@ -104,6 +104,17 @@ TGLClip::~TGLClip()
 }
 
 //______________________________________________________________________________
+void TGLClip::Setup(const TGLVector3&, const TGLVector3&)
+{
+   // Setup the clipping object with two vectors.
+   // The interpretation of the two is different for plane and box
+   // clipping objects.
+
+   Warning("TGLClip::Setup", "Called on base-class -- should be re-implemented in derived class.");
+   
+}
+
+//______________________________________________________________________________
 void TGLClip::Draw(TGLRnrCtx & rnrCtx) const
 {
    // Draw out clipping object with blending and back + front filling.
@@ -183,6 +194,37 @@ void TGLClipPlane::Setup(const TGLBoundingBox & bbox)
 }
 
 //______________________________________________________________________________
+void TGLClipPlane::Setup(const TGLVector3& point, const TGLVector3& normal)
+{
+   // Setup the clipping plane by point and normal.
+   // Length of the normal determines the size of the plane drawn in
+   // GL viewer. The normal points into the direction of visible half-plane.
+   //
+   // This only makes sense if you disable auto-update of the
+   // clip-object:
+   //   gl_viewer->SetClipAutoUpdate(kFALSE).
+   // After calling this also call gl_viewer->RefreshPadEditor(gl_viewer)
+   // and gl_viewer->RequestDraw().
+
+   TGLVector3 n(normal);
+   Double_t extents = n.Mag();
+   if (extents > 0)
+   {
+      n /= extents;
+      TGLClipPlaneLogical* cpl = (TGLClipPlaneLogical*) GetLogical();
+      cpl->Resize(extents);
+      SetTransform(TGLMatrix(point, n));
+
+      IncTimeStamp();
+      fValid = kTRUE;
+   }
+   else
+   {
+      Warning("TGLClipPlane::Setup", "Normal with zero length passed.");
+   }
+}
+
+//______________________________________________________________________________
 void TGLClipPlane::Set(const TGLPlane& plane)
 {
    // Update clip plane object to follow passed 'plane' equation. Center pivot
@@ -249,6 +291,24 @@ void TGLClipBox::Setup(const TGLBoundingBox& bbox)
 }
 
 //______________________________________________________________________________
+void TGLClipBox::Setup(const TGLVector3& min_point, const TGLVector3& max_point)
+{
+   // Setup the clip box with min/max points directly.
+   //
+   // This only makes sense if you disable auto-update of the
+   // clip-object:
+   //   gl_viewer->SetClipAutoUpdate(kFALSE).
+   // After calling this also call gl_viewer->RefreshPadEditor(gl_viewer)
+   // and gl_viewer->RequestDraw().
+
+   TGLClipBoxLogical* cbl = (TGLClipBoxLogical*) GetLogical();
+   cbl->Resize(min_point, max_point);
+
+   IncTimeStamp();
+   fValid = kTRUE; 
+}
+
+//______________________________________________________________________________
 void TGLClipBox::PlaneSet(TGLPlaneSet_t& set) const
 {
    // Return set of 6 planes describing faces of the box but invert them
@@ -279,6 +339,7 @@ TGLClipSet::TGLClipSet() :
    fClipPlane   (new TGLClipPlane),
    fClipBox     (new TGLClipBox),
    fCurrentClip (0),
+   fAutoUpdate  (kTRUE),
    fShowClip    (kFALSE),
    fShowManip   (kFALSE),
    fManip       (new TGLManipSet)
diff --git a/graf3d/gl/src/TGLClipSetEditor.cxx b/graf3d/gl/src/TGLClipSetEditor.cxx
index 7d708dc..e1ccd37 100644
--- a/graf3d/gl/src/TGLClipSetEditor.cxx
+++ b/graf3d/gl/src/TGLClipSetEditor.cxx
@@ -38,6 +38,7 @@ TGLClipSetSubEditor::TGLClipSetSubEditor(const TGWindow *p) :
    fBoxPropFrame(0),
    fBoxProp(),
    fClipInside(0),
+   fAutoUpdate(0),
    fClipEdit(0),
    fClipShow(0),
    fApplyButton(0),
@@ -45,15 +46,17 @@ TGLClipSetSubEditor::TGLClipSetSubEditor(const TGWindow *p) :
 {
    // Constructor.
 
-   fTypeButtons = new TGButtonGroup(this, "Clip Type");
-   new TGRadioButton(fTypeButtons, "None");
-   new TGRadioButton(fTypeButtons, "Plane");
+   fTypeButtons = new TGButtonGroup(this, "Clip Type", kChildFrame|kHorizontalFrame);
+   new TGRadioButton(fTypeButtons, "None    ");
+   new TGRadioButton(fTypeButtons, "Plane    ");
    new TGRadioButton(fTypeButtons, "Box");
-
+   fTypeButtons->SetLayoutHints(new TGLayoutHints(kLHintsLeft|kLHintsBottom, 0, 0, 2, -10));
    AddFrame(fTypeButtons, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
    // Clip inside / edit
    fClipInside = new TGCheckButton(this, "Clip away inside");
    AddFrame(fClipInside, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
+   fAutoUpdate = new TGCheckButton(this, "Auto update clip");
+   AddFrame(fAutoUpdate, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
    fClipEdit   = new TGCheckButton(this, "Edit In Viewer");
    AddFrame(fClipEdit, new TGLayoutHints(kLHintsTop | kLHintsCenterX | kLHintsExpandX, 2, 3, 2, 2));
    fClipShow   = new TGCheckButton(this, "Show In Viewer");
@@ -86,6 +89,7 @@ TGLClipSetSubEditor::TGLClipSetSubEditor(const TGWindow *p) :
 
    fTypeButtons->Connect("Clicked(Int_t)", "TGLClipSetSubEditor", this, "ClipTypeChanged(Int_t)");
    fClipInside->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
+   fAutoUpdate->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
    fClipEdit->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
    fClipShow->Connect("Clicked()", "TGLClipSetSubEditor", this, "UpdateViewerClip()");
 
@@ -122,12 +126,14 @@ void TGLClipSetSubEditor::SetModel(TGLClipSet* m)
    }
    Bool_t active = (fCurrentClip != kClipNone);
    fClipInside->SetEnabled(active);
+   fAutoUpdate->SetEnabled(active);
    fClipEdit  ->SetEnabled(active);
    fClipShow  ->SetEnabled(active);
    if (active) {
       fClipEdit->SetDown(fM->GetShowManip());
       fClipShow->SetDown(fM->GetShowClip());
       fClipInside->SetDown(fM->GetCurrentClip()->GetMode() == TGLClip::kInside);
+      fAutoUpdate->SetDown(fM->GetAutoUpdate());
 
       if (fCurrentClip == kClipPlane) {
          HideFrame(fBoxPropFrame);
@@ -208,6 +214,7 @@ void TGLClipSetSubEditor::UpdateViewerClip()
    fM->SetShowClip (fClipShow->IsDown());
    if (fCurrentClip != kClipNone)
       fM->GetCurrentClip()->SetMode(fClipInside->IsDown() ? TGLClip::kInside : TGLClip::kOutside);
+   fM->SetAutoUpdate(fAutoUpdate->IsDown());
 
    Changed();
 }
diff --git a/graf3d/gl/src/TGLCylinder.cxx b/graf3d/gl/src/TGLCylinder.cxx
index fbaf490..4ebc843 100644
--- a/graf3d/gl/src/TGLCylinder.cxx
+++ b/graf3d/gl/src/TGLCylinder.cxx
@@ -525,12 +525,20 @@ TGLCylinder::TGLCylinder(const TBuffer3DTube &buffer) :
    fLowPlaneNorm = gLowNormalDefault;
    fHighPlaneNorm = gHighNormalDefault;
 
-   switch (buffer.Type()) {
+   switch (buffer.Type())
+   {
+      default:
       case TBuffer3DTypes::kTube:
+      {
          fSegMesh = kFALSE;
+         fPhi1 = 0;
+         fPhi2 = 360;
          break;
+      }
+
       case TBuffer3DTypes::kTubeSeg:
       case TBuffer3DTypes::kCutTube:
+      {
          fSegMesh = kTRUE;
 
          const TBuffer3DTubeSeg * segBuffer = dynamic_cast<const TBuffer3DTubeSeg *>(&buffer);
@@ -557,6 +565,8 @@ TGLCylinder::TGLCylinder(const TBuffer3DTube &buffer) :
                fHighPlaneNorm[i] = cutBuffer->fHighPlaneNorm[i];
             }
          }
+         break;
+      }
    }
 }
 
diff --git a/graf3d/gl/src/TGLEmbeddedViewer.cxx b/graf3d/gl/src/TGLEmbeddedViewer.cxx
index 57173f6..5c57a61 100644
--- a/graf3d/gl/src/TGLEmbeddedViewer.cxx
+++ b/graf3d/gl/src/TGLEmbeddedViewer.cxx
@@ -31,7 +31,8 @@
 ClassImp(TGLEmbeddedViewer);
 
 //______________________________________________________________________________
-TGLEmbeddedViewer::TGLEmbeddedViewer(const TGWindow *parent, TVirtualPad *pad, Int_t border) :
+TGLEmbeddedViewer::TGLEmbeddedViewer(const TGWindow *parent, TVirtualPad *pad,
+                                     Int_t border) :
    TGLViewer(pad, 0, 0, 400, 300),
    fFrame(0),
    fBorder(border)
@@ -40,13 +41,22 @@ TGLEmbeddedViewer::TGLEmbeddedViewer(const TGWindow *parent, TVirtualPad *pad, I
    // Argument 'border' specifies how many pixels to pad on each side of the
    // viewer. This area can be used for highlightning of the active viewer.
 
-   fFrame = new TGCompositeFrame(parent);
+   Init(parent);
+}
 
-   CreateFrames();
+//______________________________________________________________________________
+TGLEmbeddedViewer::TGLEmbeddedViewer(const TGWindow *parent, TVirtualPad *pad,
+                                     TGedEditor *ged, Int_t border) :
+   TGLViewer(pad, 0, 0, 400, 300),
+   fFrame(0),
+   fBorder(border)
+{
+   // Constructor allowing to also specify an GED editor to use.
+   // Argument 'border' specifies how many pixels to pad on each side of the
+   // viewer. This area can be used for highlightning of the active viewer.
 
-   fFrame->MapSubwindows();
-   fFrame->Resize(fFrame->GetDefaultSize());
-   fFrame->Resize(400, 300);
+   fGedEditor = ged;
+   Init(parent);
 }
 
 //______________________________________________________________________________
@@ -59,6 +69,35 @@ TGLEmbeddedViewer::~TGLEmbeddedViewer()
 }
 
 //______________________________________________________________________________
+void TGLEmbeddedViewer::Init(const TGWindow *parent)
+{
+   // Common initialization from all constructors.
+
+   fFrame = new TGCompositeFrame(parent);
+
+   CreateFrames();
+
+   fFrame->MapSubwindows();
+   fFrame->Resize(fFrame->GetDefaultSize());
+   fFrame->Resize(400, 300);
+}
+ 
+//______________________________________________________________________________
+void TGLEmbeddedViewer::CreateFrames()
+{
+   // Internal frames creation.
+
+   fGLWidget = TGLWidget::Create(fFrame, kTRUE, kTRUE, 0, 10, 10);
+
+   // Direct events from the TGWindow directly to the base viewer
+   fEventHandler = new TGLEventHandler(0, this);
+   fGLWidget->SetEventHandler(fEventHandler);
+
+   fFrame->AddFrame(fGLWidget, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY,
+                                                 fBorder, fBorder, fBorder, fBorder));
+}
+
+//______________________________________________________________________________
 void TGLEmbeddedViewer::CreateGLWidget()
 {
    // Create a GLwidget, it is an error if it is already created.
@@ -101,18 +140,3 @@ void TGLEmbeddedViewer::DestroyGLWidget()
    fGLWidget->DeleteWindow();
    fGLWidget = 0;
 }
-
-//______________________________________________________________________________
-void TGLEmbeddedViewer::CreateFrames()
-{
-   // Internal frames creation.
-
-   fGLWidget = TGLWidget::Create(fFrame, kTRUE, kTRUE, 0, 10, 10);
-
-   // Direct events from the TGWindow directly to the base viewer
-   fEventHandler = new TGLEventHandler(0, this);
-   fGLWidget->SetEventHandler(fEventHandler);
-
-   fFrame->AddFrame(fGLWidget, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY,
-                                                 fBorder, fBorder, fBorder, fBorder));
-}
diff --git a/graf3d/gl/src/TGLEventHandler.cxx b/graf3d/gl/src/TGLEventHandler.cxx
index 613155c..f029823 100644
--- a/graf3d/gl/src/TGLEventHandler.cxx
+++ b/graf3d/gl/src/TGLEventHandler.cxx
@@ -84,6 +84,32 @@ TGLEventHandler::~TGLEventHandler()
 }
 
 //______________________________________________________________________________
+void TGLEventHandler::GrabMouse()
+{
+   // Acquire mouse grab.
+
+   if (!fInPointerGrab)
+   {
+      gVirtualX->GrabPointer(fGLViewer->GetGLWidget()->GetId(),
+                             kButtonPressMask | kButtonReleaseMask | kPointerMotionMask,
+                             kNone, kNone, kTRUE, kFALSE);
+      fInPointerGrab = kTRUE;
+   }
+}
+
+//______________________________________________________________________________
+void TGLEventHandler::UnGrabMouse()
+{
+   // Release mouse grab.
+
+   if (fInPointerGrab)
+   {
+      gVirtualX->GrabPointer(0, 0, 0, 0, kFALSE);
+      fInPointerGrab = kFALSE;
+   }
+}
+
+//______________________________________________________________________________
 void TGLEventHandler::ExecuteEvent(Int_t event, Int_t px, Int_t py)
 {
    // Process event of type 'event' - one of EEventType types,
@@ -301,7 +327,6 @@ Bool_t TGLEventHandler::HandleCrossing(Event_t *event)
 Bool_t TGLEventHandler::HandleButton(Event_t * event)
 {
    // Handle mouse button 'event'.
-   static Event_t eventSt = {kOtherEvent, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, kFALSE, 0, 0, {0,0,0,0,0}};
 
    if (fGLViewer->IsLocked()) {
       if (gDebug>2) {
@@ -311,19 +336,62 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
       return kFALSE;
    }
 
+   // Handle mouse-wheel events first.
+   if (event->fCode > kButton3)
+   {
+      // On Win32 only button release events come for mouse wheel.
+      // Note: Modifiers (ctrl/shift) disabled as fState doesn't seem to
+      // have correct modifier flags with mouse wheel under Windows.
+      // TODO: Put '50' into some static const.
+
+      if (event->fType == kButtonRelease)
+      {
+         Bool_t redraw = kFALSE;
+
+         switch(event->fCode)
+         {
+            case kButton5: // Zoom out (dolly or adjust camera FOV).
+               redraw = fGLViewer->CurrentCamera().Zoom(50, kFALSE, kFALSE);
+               break;
+
+            case kButton4: // Zoom in (dolly or adjust camera FOV).
+               redraw = fGLViewer->CurrentCamera().Zoom(-50, kFALSE, kFALSE);
+               break;
+
+            case kButton6:
+            case kButton7: // Ignore for now.
+               break;
+         }
+
+         if (redraw)
+            fGLViewer->fRedrawTimer->RequestDraw(10, TGLRnrCtx::kLODMed);
+      }
+      return kTRUE;
+   }
+
+   // Now we know we have Button 1 -> 3.
+   // Allow a single action/button down/up pairing - block others
+   if (fActiveButtonID && event->fCode != fActiveButtonID)
+   {
+      return kTRUE;
+   }
+   else
+   {
+      fActiveButtonID = event->fCode;
+   }
+
+
    // Button DOWN
-   if (event->fType == kButtonPress && event->fCode <= kButton3)
+   if (event->fType == kButtonPress)
    {
-      // Allow a single action/button down/up pairing - block others
+      GrabMouse();
+
       fGLViewer->MouseIdle(0, 0, 0);
-      fGLViewer->Activated();
-      if (fGLViewer->fDragAction != TGLViewer::kDragNone)
-         return kFALSE;
-      eventSt.fX = event->fX;
-      eventSt.fY = event->fY;
-      eventSt.fCode = event->fCode;
 
-      if ( fGLViewer->GetPushAction() != TGLViewer::kPushStd )
+      fButtonPushPos.fX = event->fX;
+      fButtonPushPos.fY = event->fY;
+
+      if (fGLViewer->GetPushAction() != TGLViewer::kPushStd)
       {
          fGLViewer->RequestSelect(event->fX, event->fY);
          if (fGLViewer->fSelRec.GetN() > 0)
@@ -341,7 +409,9 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
                TGLSelectRecord& rec = fGLViewer->GetSelRec();
                TObject* obj = rec.GetObject();
                TGLRect& vp = fGLViewer->CurrentCamera().RefViewport();
-               new TGLAnnotation(fGLViewer, obj->GetTitle(),  eventSt.fX*1.f/vp.Width(),  1 - eventSt.fY*1.f/vp.Height(), v);
+               new TGLAnnotation(fGLViewer, obj->GetTitle(),
+                                 event->fX * 1.0f/vp.Width(),
+                                 1 - event->fY * 1.0f/vp.Height(), v);
             }
 
             fGLViewer->RequestDraw();
@@ -349,18 +419,13 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
          return kTRUE;
       }
 
-      Bool_t grabPointer = kFALSE;
-      Bool_t handled     = kFALSE;
-
-      // Record active button for release
-      fActiveButtonID = event->fCode;
+      Bool_t handled = kFALSE;
 
       if (fGLViewer->fDragAction == TGLViewer::kDragNone && fGLViewer->fCurrentOvlElm)
       {
          if (fGLViewer->fCurrentOvlElm->Handle(*fGLViewer->fRnrCtx, fGLViewer->fOvlSelRec, event))
          {
             handled     = kTRUE;
-            grabPointer = kTRUE;
             fGLViewer->fDragAction = TGLViewer::kDragOverlay;
             fGLViewer->RequestDraw();
          }
@@ -372,31 +437,37 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
             // LEFT mouse button
             case kButton1:
             {
-               if (event->fState & kKeyShiftMask) {
-                  if (fGLViewer->RequestSelect(event->fX, event->fY)) {
+               if (event->fState & kKeyShiftMask)
+               {
+                  if (fGLViewer->RequestSelect(event->fX, event->fY))
+                  {
                      fGLViewer->ApplySelection();
                      handled = kTRUE;
-                  } else {
-                     fGLViewer->SelectionChanged(); // Just notify clients.
+                     fIgnoreButtonUp = kTRUE;
                   }
-                  fIgnoreButtonUp = kTRUE;
-               } else if ((fSecSelType == TGLViewer::kOnRequest || fSecSelType == TGLViewer::kOnKeyMod1) && (event->fState & kKeyMod1Mask)) {
+               }
+               else if ((fSecSelType == TGLViewer::kOnRequest ||
+                         fSecSelType == TGLViewer::kOnKeyMod1) &&
+                        event->fState & kKeyMod1Mask)
+               {
                   fGLViewer->RequestSelect(event->fX, event->fY);
                   fGLViewer->RequestSecondarySelect(event->fX, event->fY);
+
                   if (fGLViewer->fSecSelRec.GetPhysShape() != 0)
                   {
                      TGLLogicalShape& lshape = const_cast<TGLLogicalShape&>
                         (*fGLViewer->fSecSelRec.GetPhysShape()->GetLogical());
                      lshape.ProcessSelection(*fGLViewer->fRnrCtx, fGLViewer->fSecSelRec);
-                     handled = kTRUE;
                   }
+                  handled = kTRUE;
                   fIgnoreButtonUp = kTRUE;
                }
+
                if ( ! handled)
                {
                   fGLViewer->fDragAction = TGLViewer::kDragCameraRotate;
-                  grabPointer = kTRUE;
-                  if (fMouseTimer) {
+                  if (fMouseTimer)
+                  {
                      fMouseTimer->TurnOff();
                      fMouseTimer->Reset();
                   }
@@ -407,7 +478,6 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
             case kButton2:
             {
                fGLViewer->fDragAction = TGLViewer::kDragCameraTruck;
-               grabPointer = kTRUE;
                break;
             }
             // RIGHT mouse button
@@ -417,48 +487,55 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
                if (event->fState & kKeyShiftMask)
                {
                   fGLViewer->RequestSelect(event->fX, event->fY);
+                  if (!fGLViewer->fContextMenu) {
+                     fGLViewer->fContextMenu = new TContextMenu("glcm", "GL Viewer Context Menu");
+                  }
+                  Int_t    x, y;
+                  Window_t childdum;
+                  gVirtualX->TranslateCoordinates(fGLViewer->fGLWidget->GetId(),
+                                                  gClient->GetDefaultRoot()->GetId(),
+                                                  event->fX, event->fY, x, y, childdum);
                   const TGLPhysicalShape * selected = fGLViewer->fSelRec.GetPhysShape();
-                  if (selected) {
-                     if (!fGLViewer->fContextMenu) {
-                        fGLViewer->fContextMenu = new TContextMenu("glcm", "GL Viewer Context Menu");
-                     }
-                     Int_t    x, y;
-                     Window_t childdum;
-                     gVirtualX->TranslateCoordinates(fGLViewer->fGLWidget->GetId(),
-                                                     gClient->GetDefaultRoot()->GetId(),
-                                                     event->fX, event->fY, x, y, childdum);
+                  if (selected)
+                  {
+                     fActiveButtonID = 0;
+                     UnGrabMouse();
+
                      selected->InvokeContextMenu(*fGLViewer->fContextMenu, x, y);
                   }
-               } else {
+                  // This is dangerous ... should have special menu.
+                  // else 
+                  // {
+                  //    fGLViewer->fContextMenu->Popup(x, y, fGLViewer);
+                  // }
+               }
+               else
+               {
                   fGLViewer->fDragAction = TGLViewer::kDragCameraDolly;
-                  grabPointer = kTRUE;
                }
                break;
             }
          }
       }
-
-      if (grabPointer)
-      {
-         gVirtualX->GrabPointer(fGLViewer->GetGLWidget()->GetId(),
-                                kButtonPressMask | kButtonReleaseMask | kPointerMotionMask,
-                                kNone, kNone, kTRUE, kFALSE);
-         fInPointerGrab = kTRUE;
-      }
    }
    // Button UP
    else if (event->fType == kButtonRelease)
    {
-      if (fIgnoreButtonUp)
+      fActiveButtonID = 0;
+
+      if (fInPointerGrab)
       {
-         fIgnoreButtonUp = kFALSE;
-         return kTRUE;
+         UnGrabMouse();
+      }
+      else
+      {
+         Warning("TGLEventHandler::HandleButton", "Unexpected button-release.");
       }
 
-      if (fInPointerGrab)
+      if (fIgnoreButtonUp)
       {
-         gVirtualX->GrabPointer(0, 0, 0, 0, kFALSE);
-         fInPointerGrab = kFALSE;
+         fIgnoreButtonUp = kFALSE;
+         return kTRUE;
       }
 
       if (fGLViewer->GetPushAction() != TGLViewer::kPushStd)
@@ -481,35 +558,14 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
          fGLViewer->RequestDraw(TGLRnrCtx::kLODHigh);
       }
 
-      // TODO: Check on Linux - on Win32 only see button release events
-      // for mouse wheel
-      switch(event->fCode) {
-         // Buttons 4/5 are mouse wheel
-         // Note: Modifiers (ctrl/shift) disabled as fState doesn't seem to
-         // have correct modifier flags with mouse wheel under Windows.
-         case kButton5: {
-            // Zoom out (dolly or adjust camera FOV). TODO : val static const somewhere
-            if (fGLViewer->CurrentCamera().Zoom(50, kFALSE, kFALSE))
-               fGLViewer->fRedrawTimer->RequestDraw(10, TGLRnrCtx::kLODMed);
-            return kTRUE;
-            break;
-         }
-         case kButton4: {
-            // Zoom in - adjust camera FOV. TODO : val static const somewhere
-            if (fGLViewer->CurrentCamera().Zoom(-50, kFALSE, kFALSE))
-               fGLViewer->fRedrawTimer->RequestDraw(10, TGLRnrCtx::kLODMed);
-            return kTRUE;
-            break;
-         }
-      }
       fGLViewer->fDragAction = TGLViewer::kDragNone;
+
       if (fGLViewer->fGLDevice != -1)
       {
          gGLManager->MarkForDirectCopy(fGLViewer->fGLDevice, kFALSE);
       }
-      if ((event->fX == eventSt.fX) &&
-          (event->fY == eventSt.fY) &&
-          (eventSt.fCode == event->fCode))
+
+      if (event->fX == fButtonPushPos.fX && event->fY == fButtonPushPos.fY)
       {
          TObject *obj = 0;
          fGLViewer->RequestSelect(fLastPos.fX, fLastPos.fY);
@@ -518,8 +574,8 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
          if (phys_shape) obj = phys_shape->GetLogical()->GetExternal();
       
          // secondary selection
-         if (phys_shape && fSecSelType == TGLViewer::kOnRequest
-             && phys_shape->GetLogical()->AlwaysSecondarySelect())
+         if (phys_shape && fSecSelType == TGLViewer::kOnRequest &&
+             phys_shape->GetLogical()->AlwaysSecondarySelect())
          {
             fGLViewer->RequestSecondarySelect(fLastPos.fX, fLastPos.fY);
             fGLViewer->fSecSelRec.SetMultiple(event->fState & kKeyControlMask);
@@ -551,11 +607,6 @@ Bool_t TGLEventHandler::HandleButton(Event_t * event)
             fGLViewer->Clicked(obj);
             fGLViewer->Clicked(obj, event->fCode, event->fState);
          }
-
-         eventSt.fX = 0;
-         eventSt.fY = 0;
-         eventSt.fCode = 0;
-         eventSt.fState = 0;
       }
       if (event->fCode == kButton1 && fMouseTimer)
       {
@@ -579,15 +630,21 @@ Bool_t TGLEventHandler::HandleDoubleClick(Event_t *event)
       return kFALSE;
    }
 
+   if (event->fCode > 3)
+      return kTRUE;
+
+   if (fActiveButtonID)
+      return kTRUE;
+
+   fActiveButtonID = event->fCode;
+   GrabMouse();
+
    fGLViewer->MouseIdle(0, 0, 0);
-   // Reset interactive camera mode on button double
-   // click (unless mouse wheel)
-   if (event->fCode != kButton4 && event->fCode != kButton5) {
-      if (fGLViewer->fResetCameraOnDoubleClick) {
-         fGLViewer->ResetCurrentCamera();
-         fGLViewer->RequestDraw();
-      }
+   if (event->fCode == kButton1)
+   {
       fGLViewer->DoubleClicked();
+      if (fGLViewer->GetSelected() == 0)
+         fGLViewer->SelectionChanged();
    }
    return kTRUE;
 }
@@ -806,7 +863,7 @@ Bool_t TGLEventHandler::HandleMotion(Event_t * event)
    }
    else if (fGLViewer->fDragAction == TGLViewer::kDragCameraDolly)
    {
-      processed = fGLViewer->CurrentCamera().Dolly(xDelta, mod1, mod2);
+      processed = fGLViewer->CurrentCamera().Dolly(xDelta - yDelta, mod1, mod2);
    }
    else if (fGLViewer->fDragAction == TGLViewer::kDragOverlay)
    {
diff --git a/graf3d/gl/src/TGLFaceSet.cxx b/graf3d/gl/src/TGLFaceSet.cxx
index 78d8277..d25fc11 100644
--- a/graf3d/gl/src/TGLFaceSet.cxx
+++ b/graf3d/gl/src/TGLFaceSet.cxx
@@ -142,6 +142,8 @@ void TGLFaceSet::DirectDraw(TGLRnrCtx & rnrCtx) const
       Info("TGLFaceSet::DirectDraw", "this %d (class %s) LOD %d", this, IsA()->GetName(), rnrCtx.ShapeLOD());
    }
 
+   if (fNbPols == 0) return;
+
    GLUtesselator  *tessObj = TGLUtil::GetDrawTesselator3dv();
    const Double_t *pnts = &fVertices[0];
    const Double_t *normals = &fNormals[0];
@@ -217,6 +219,8 @@ Bool_t TGLFaceSet::Eq(const Double_t *p1, const Double_t *p2)
 void TGLFaceSet::CalculateNormals()
 {
    // CalculateNormals
+
+   if (fNbPols == 0) return;
    Double_t *pnts = &fVertices[0];
    for (UInt_t i = 0, j = 0; i < fNbPols; ++i) {
       Int_t polEnd = fPolyDesc[j] + j + 1;
diff --git a/graf3d/gl/src/TGLFontManager.cxx b/graf3d/gl/src/TGLFontManager.cxx
index a9d9764..305b4d9 100644
--- a/graf3d/gl/src/TGLFontManager.cxx
+++ b/graf3d/gl/src/TGLFontManager.cxx
@@ -323,7 +323,7 @@ void TGLFontManager::RegisterFont(Int_t sizeIn, Int_t fileID, TGLFont::EMode mod
       ttpath = gEnv->GetValue("Root.TTGLFontPath", "$(ROOTSYS)/fonts");
 # endif
       TObjString* name = (TObjString*)fgFontFileArray[fileID];
-      const char *file = gSystem->Which(ttpath.Data(), Form("%s.ttf", name->GetString().Data()));
+      TString file = gSystem->Which(ttpath.Data(), Form("%s.ttf", name->GetString().Data()));
 
       FTFont* ftfont = 0;
       switch (mode)
@@ -349,9 +349,9 @@ void TGLFontManager::RegisterFont(Int_t sizeIn, Int_t fileID, TGLFont::EMode mod
             break;
          default:
             Error("TGLFontManager::GetFont", "invalid FTGL type");
+            return;
             break;
       }
-      delete [] file;
       ftfont->FaceSize(size);
       const TGLFont &mf = fFontMap.insert(std::make_pair(TGLFont(size, fileID, mode, ftfont, 0), 1)).first->first;
       out.CopyAttributes(mf);
diff --git a/graf3d/gl/src/TGLFormat.cxx b/graf3d/gl/src/TGLFormat.cxx
index fecb0d2..5e9594d 100644
--- a/graf3d/gl/src/TGLFormat.cxx
+++ b/graf3d/gl/src/TGLFormat.cxx
@@ -22,6 +22,7 @@ ClassImp(TGLFormat)
 //______________________________________________________________________________
 TGLFormat::TGLFormat() :
    fDoubleBuffered(kTRUE),
+   fStereo(kFALSE),
 #ifdef WIN32
    fDepthSize(32),
 #else
@@ -39,6 +40,7 @@ TGLFormat::TGLFormat() :
 //______________________________________________________________________________
 TGLFormat::TGLFormat(EFormatOptions opt) :
    fDoubleBuffered(opt & kDoubleBuffer),
+   fStereo(kFALSE),
 #ifdef WIN32
    fDepthSize(opt & kDepth ? 32 : 0),
 #else
@@ -150,3 +152,17 @@ void TGLFormat::SetDoubleBuffered(Bool_t db)
    //Set the surface as double/single buffered.
    fDoubleBuffered = db;
 }
+
+//______________________________________________________________________________
+Bool_t TGLFormat::IsStereo()const
+{
+   //Check, if the surface is stereo buffered.
+   return fStereo;
+}
+
+//______________________________________________________________________________
+void TGLFormat::SetStereo(Bool_t db)
+{
+   //Set the surface as stereo/non-stereo buffered.
+   fStereo = db;
+}
diff --git a/graf3d/gl/src/TGLLockable.cxx b/graf3d/gl/src/TGLLockable.cxx
index 4844407..08d6404 100644
--- a/graf3d/gl/src/TGLLockable.cxx
+++ b/graf3d/gl/src/TGLLockable.cxx
@@ -18,7 +18,7 @@
 // Simple locking interface used by viewer and scene.
 
 
-ClassImp(TGLLockable)
+ClassImp(TGLLockable);
 
 TGLLockable::TGLLockable() :
    fLock      (kUnlocked)
diff --git a/graf3d/gl/src/TGLLogicalShape.cxx b/graf3d/gl/src/TGLLogicalShape.cxx
index f93a82a..d0a89a1 100644
--- a/graf3d/gl/src/TGLLogicalShape.cxx
+++ b/graf3d/gl/src/TGLLogicalShape.cxx
@@ -138,7 +138,7 @@ TGLLogicalShape::~TGLLogicalShape()
    // Physicals should have been cleared elsewhere as they are managed
    // by the scene. But this could change.
    if (fRef > 0) {
-      Warning("TGLLogicalShape::Destroy", "some physicals still lurking around.");
+      Warning("TGLLogicalShape::~TGLLogicalShape", "some physicals still lurking around.");
       DestroyPhysicals();
    }
    DLCachePurge();
@@ -211,6 +211,7 @@ void TGLLogicalShape::DestroyPhysicals()
       curr = next;
    }
    assert (fRef == 0);
+   fFirstPhysical = 0;
 }
 
 //______________________________________________________________________________
diff --git a/graf3d/gl/src/TGLPlotPainter.cxx b/graf3d/gl/src/TGLPlotPainter.cxx
index 28fd73c..81ae308 100644
--- a/graf3d/gl/src/TGLPlotPainter.cxx
+++ b/graf3d/gl/src/TGLPlotPainter.cxx
@@ -511,7 +511,8 @@ TGLPlotCoordinates::TGLPlotCoordinates()
                           fXLog(kFALSE),
                           fYLog(kFALSE),
                           fZLog(kFALSE),
-                          fModified(kFALSE)
+                          fModified(kFALSE),
+                          fFactor(1.)
 {
    //Constructor.
 }
diff --git a/graf3d/gl/src/TGLRnrCtx.cxx b/graf3d/gl/src/TGLRnrCtx.cxx
index d5fc671..d5b0072 100644
--- a/graf3d/gl/src/TGLRnrCtx.cxx
+++ b/graf3d/gl/src/TGLRnrCtx.cxx
@@ -61,6 +61,7 @@ TGLRnrCtx::TGLRnrCtx(TGLViewerBase* viewer) :
    fSceneLOD     (kLODUndef),
    fCombiLOD     (kLODUndef),
    fShapeLOD     (kLODUndef),
+   fShapePixSize (0),
 
    fViewerStyle  (kStyleUndef),
    fSceneStyle   (kStyleUndef),
@@ -89,6 +90,8 @@ TGLRnrCtx::TGLRnrCtx(TGLViewerBase* viewer) :
    fColorSetStack(0),
    fRenderScale  (1),
 
+   fEventKeySym  (0),
+
    fDLCaptureOpen (kFALSE),
    fGLCtxIdentity (0),
    fQuadric       (0),
diff --git a/graf3d/gl/src/TGLSAViewer.cxx b/graf3d/gl/src/TGLSAViewer.cxx
index 6a233b9..1126553 100644
--- a/graf3d/gl/src/TGLSAViewer.cxx
+++ b/graf3d/gl/src/TGLSAViewer.cxx
@@ -23,6 +23,7 @@
 #include "TGFrame.h"
 #include "TGLabel.h"
 #include "TGMenu.h"
+#include "TGButton.h"
 #include "TGSplitter.h"
 #include "TColor.h"
 
@@ -33,6 +34,7 @@
 #include "TGFileDialog.h"
 
 #include "TGLOutput.h"
+#include "TGLFormat.h"
 
 #include "TGLLogicalShape.h"
 #include "TGLPhysicalShape.h"
@@ -51,6 +53,7 @@
 #include "TGLOutput.h"
 #include "TGLEventHandler.h"
 
+
 const char * TGLSAViewer::fgHelpText1 = "\
 DIRECT SCENE INTERACTIONS\n\n\
    Press:\n\
@@ -61,65 +64,103 @@ DIRECT SCENE INTERACTIONS\n\n\
    \tj          --- ZOOM in\n\
    \tk          --- ZOOM out\n\
    \tArrow Keys --- PAN (TRUCK) across scene\n\
-   \tHome       --- reset current camera\n\n\
-   You can ROTATE (ORBIT) the scene by holding the left mouse button and moving\n\
-   the mouse (perspective camera, needs to be enabled for orthograpic camers).\n\
+   \tHome       --- reset current camera\n\
+\n\
+   LEFT mouse button -- ROTATE (ORBIT) the scene by holding the mouse button and moving\n\
+   the mouse (perspective camera, needs to be enabled in menu for orthograpic cameras).\n\
    By default, the scene will be rotated about its center. To select arbitrary center\n\
-   bring up the viewer-editor and use 'Camera center' controls in the 'Guides' tab.\n\n\
-   You can PAN (TRUCK) the camera using the middle mouse button or arrow keys.\n\n\
-   You can ZOOM the camera by dragging side to side holding the right\n\
-   mouse button (in perspective mode the camera is translated along viewing axis).\n\n\
-   Mouse wheel action depends on the camera type:\n\
+   bring up the viewer-editor (e.g., shift-click into empty background) and use\n\
+   'Camera center' controls in the 'Guides' tab.\n\
+\n\
+   MIDDLE mouse button or arrow keys --  PAN (TRUCK) the camera.\n\
+\n\
+   RIGHT mouse button action depends on camera type:\n\
+     orthographic -- zoom,\n\
+     perspective  -- move camera forwards / backwards\n\
+\n\
+   By pressing Ctrl and Shift keys the mouse precision can be changed:\n\
+     Shift      -- 10 times less precise\n\
+     Ctrl       -- 10 times more precise\n\
+     Ctrl Shift -- 100 times more precise\n\
+\n\
+   Mouse wheel action depends on camera type:\n\
      orthographic -- zoom,\n\
-     perspective  -- change field-of-view (focal length)\n\n\
-   RESET the camera via the button in viewer-editor or Home key.\n\n\
-   SELECT a shape with Shift+Left mouse button click.\n\n\
-   SELECT the viewer with Shift+Left mouse button click on a free space.\n\n\
-   MOVE a selected shape using Shift+Mid mouse drag.\n\n\
+     perspective  -- change field-of-view (focal length)\n\
+\n\
+   Double clik will show GUI editor of the viewer (if assigned).\n\
+\n\
+   RESET the camera via the button in viewer-editor or Home key.\n\
+\n\
+   SELECT a shape with Shift+Left mouse button click.\n\
+\n\
+   SELECT the viewer with Shift+Left mouse button click on a free space.\n\
+\n\
+   MOVE a selected shape using Shift+Mid mouse drag.\n\
+\n\
    Invoke the CONTEXT menu with Shift+Right mouse click.\n\n"
    "Secondary selection and direct render object interaction is initiated\n\
-   by Alt+Left mouse click (Mod1, actually). Only few classes support this option.\n\n\
-CAMERA\n\n\
+   by Alt+Left mouse click (Mod1, actually). Only few classes support this option.\n\
+   When 'Alt' is taken by window manager, try Alt-Ctrl-Left.\n\
+\n\
+CAMERA\n\
+\n\
    The \"Camera\" menu is used to select the different projections from \n\
-   the 3D world onto the 2D viewport. There are three perspective cameras:\n\n\
+   the 3D world onto the 2D viewport. There are three perspective cameras:\n\
+\n\
    \tPerspective (Floor XOZ)\n\
    \tPerspective (Floor YOZ)\n\
-   \tPerspective (Floor XOY)\n\n\
-   In each case the floor plane (defined by two axes) is kept level.\n\n\
-   There are also three orthographic cameras:\n\n\
+   \tPerspective (Floor XOY)\n\
+\n\
+   In each case the floor plane (defined by two axes) is kept level.\n\
+\n\
+   There are also three orthographic cameras:\n\
+\n\
    \tOrthographic (XOY)\n\
    \tOrthographic (XOZ)\n\
-   \tOrthographic (ZOY)\n\n\
+   \tOrthographic (ZOY)\n\
+\n\
    In each case the first axis is placed horizontal, the second vertical e.g.\n\
    XOY means X horizontal, Y vertical.\n\n";
 
 const char * TGLSAViewer::fgHelpText2 = "\
-SHAPES COLOR AND MATERIAL\n\n\
+SHAPES COLOR AND MATERIAL\n\
+\n\
    The selected shape's color can be modified in the Shapes-Color tabs.\n\
    Shape's color is specified by the percentage of red, green, blue light\n\
    it reflects. A surface can reflect DIFFUSE, AMBIENT and SPECULAR light.\n\
    A surface can also emit light. The EMISSIVE parameter allows to define it.\n\
-   The surface SHININESS can also be modified.\n\n\
-SHAPES GEOMETRY\n\n\
+   The surface SHININESS can also be modified.\n\
+\n\
+SHAPES GEOMETRY\n\
+\n\
    The selected shape's location and geometry can be modified in the Shapes-Geom\n\
-   tabs by entering desired values in respective number entry controls.\n\n\
-SCENE CLIPPING\n\n\
-   In the Scene-Clipping tabs select a 'Clip Type': None, Plane, Box\n\n\
-   For 'Plane' and 'Box' the lower pane shows the relevant parameters:\n\n\
+   tabs by entering desired values in respective number entry controls.\n\
+\n\
+SCENE CLIPPING\n\
+\n\
+   In the Scene-Clipping tabs select a 'Clip Type': None, Plane, Box\n\
+\n\
+   For 'Plane' and 'Box' the lower pane shows the relevant parameters:\n\
+\n\
 \tPlane: Equation coefficients of form aX + bY + cZ + d = 0\n\
 \tBox: Center X/Y/Z and Length X/Y/Z\n\n"
    "For Box checking the 'Show / Edit' checkbox shows the clip box (in light blue)\n\
    in viewer. It also attaches the current manipulator to the box - enabling\n\
-   direct editing in viewer.\n\n\
-MANIPULATORS\n\n\
+   direct editing in viewer.\n\
+\n\
+MANIPULATORS\n\
+\n\
    A widget attached to the selected object - allowing direct manipulation\n\
-   of the object with respect to its local axes.\n\n\
-   There are three modes, toggled with keys while manipulator is active:\n\
+   of the object with respect to its local axes.\n\
+\n\
+   There are three modes, toggled with keys while manipulator is active, that is,\n\
+   mouse pointer is above it (switches color to yellow):\n\
    \tMode\t\tWidget Component Style\t\tKey\n\
    \t----\t\t----------------------\t\t---\n\
    \tTranslation\tLocal axes with arrows\t\tv\n\
    \tScale\t\tLocal axes with boxes\t\tx\n\
-   \tRotate\t\tLocal axes rings\t\tc\n\n\
+   \tRotate\t\tLocal axes rings\t\tc\n\
+\n\
    Each widget has three axis components - red (X), green (Y) and blue (Z).\n\
    The component turns yellow, indicating an active state, when the mouse is moved\n\
    over it. Left click and drag on the active component to adjust the objects\n\
@@ -140,6 +181,8 @@ MANIPULATORS\n\n\
 
 ClassImp(TGLSAViewer);
 
+Long_t TGLSAViewer::fgMenuHidingTimeout = 400;
+
 const Int_t TGLSAViewer::fgInitX = 0;
 const Int_t TGLSAViewer::fgInitY = 0;
 const Int_t TGLSAViewer::fgInitW = 780;
@@ -157,41 +200,42 @@ const char *gGLSaveAsTypes[] = {"Encapsulated PostScript", "*.eps",
                                 0, 0};
 
 //______________________________________________________________________________
-TGLSAViewer::TGLSAViewer(TVirtualPad *pad) :
+TGLSAViewer::TGLSAViewer(TVirtualPad *pad, TGLFormat* format) :
    TGLViewer(pad, fgInitX, fgInitY, fgInitW, fgInitH),
    fFrame(0),
+   fFormat(format),
    fFileMenu(0),
    fFileSaveMenu(0),
    fCameraMenu(0),
    fHelpMenu(0),
    fLeftVerticalFrame(0),
-   fGedEditor(0),
-   fPShapeWrap(0),
    fRightVerticalFrame(0),
    fDirName("."),
    fTypeIdx(0),
    fOverwrite(kFALSE),
    fMenuBar(0),
+   fMenuBut(0),
+   fHideMenuBar(kFALSE),
+   fMenuHidingTimer(0),
+   fMenuHidingShowMenu(kTRUE),
    fDeleteMenuBar(kFALSE)
 {
    // Construct a standalone viewer, bound to supplied 'pad'.
 
-   TGLSAFrame* gl_frame = new TGLSAFrame(*this);
-   fFrame = gl_frame;
+   fFrame = new TGLSAFrame(*this);
 
    CreateMenus();
    CreateFrames();
 
-   gl_frame->SetWindowName("ROOT's GL viewer");
-   gl_frame->SetClassHints("GLViewer", "GLViewer");
-   gl_frame->SetMWMHints(kMWMDecorAll, kMWMFuncAll, kMWMInputModeless);
-   gl_frame->MapSubwindows();
-
-   gl_frame->Resize(fFrame->GetDefaultSize());
-   gl_frame->MoveResize(fgInitX, fgInitY, fgInitW, fgInitH);
-   gl_frame->SetWMPosition(fgInitX, fgInitY);
+   fFrame->SetWindowName("ROOT's GL viewer");
+   fFrame->SetClassHints("GLViewer", "GLViewer");
+   fFrame->SetMWMHints(kMWMDecorAll, kMWMFuncAll, kMWMInputModeless);
+   fFrame->MapSubwindows();
+   fFrame->HideFrame(fMenuBut);
 
-   fPShapeWrap = new TGLPShapeObj(0, this);
+   fFrame->Resize(fFrame->GetDefaultSize());
+   fFrame->MoveResize(fgInitX, fgInitY, fgInitW, fgInitH);
+   fFrame->SetWMPosition(fgInitX, fgInitY);
 
    // set recursive cleanup, but exclude fGedEditor
    // destructor of fGedEditor has own way of handling child nodes
@@ -204,36 +248,42 @@ TGLSAViewer::TGLSAViewer(TVirtualPad *pad) :
 }
 
 //______________________________________________________________________________
-TGLSAViewer::TGLSAViewer(const TGWindow *parent, TVirtualPad *pad, TGedEditor *ged) :
+TGLSAViewer::TGLSAViewer(const TGWindow *parent, TVirtualPad *pad, TGedEditor *ged,
+                         TGLFormat* format) :
    TGLViewer(pad, fgInitX, fgInitY, fgInitW, fgInitH),
    fFrame(0),
+   fFormat(format),
    fFileMenu(0),
    fCameraMenu(0),
    fHelpMenu(0),
    fLeftVerticalFrame(0),
-   fGedEditor(ged),
-   fPShapeWrap(0),
    fRightVerticalFrame(0),
    fTypeIdx(0),
    fMenuBar(0),
+   fMenuBut(0),
+   fHideMenuBar(kFALSE),
+   fMenuHidingTimer(0),
+   fMenuHidingShowMenu(kTRUE),
    fDeleteMenuBar(kFALSE)
 {
    // Construct an embedded standalone viewer, bound to supplied 'pad'.
+   // If format is passed, it gets adopted by the viewer as it might
+   // need to be reused several times when recreating the GL-widget.
    //
    // Modified version of the previous constructor for embedding the
    // viewer into another frame (parent).
 
+   fGedEditor = ged;
    fFrame = new TGLSAFrame(parent, *this);
 
    CreateMenus();
    CreateFrames();
 
    fFrame->MapSubwindows();
+   fFrame->HideFrame(fMenuBut);
    fFrame->Resize(fFrame->GetDefaultSize());
    fFrame->Resize(fgInitW, fgInitH);
 
-   fPShapeWrap = new TGLPShapeObj(0, this);
-
    // set recursive cleanup, but exclude fGedEditor
    // destructor of fGedEditor has own way of handling child nodes
    if (fLeftVerticalFrame)
@@ -254,6 +304,8 @@ TGLSAViewer::~TGLSAViewer()
 
    fGedEditor->DisconnectFromCanvas();
 
+   DisableMenuBarHiding();
+
    delete fHelpMenu;
    delete fCameraMenu;
    delete fFileSaveMenu;
@@ -261,11 +313,20 @@ TGLSAViewer::~TGLSAViewer()
    if(fDeleteMenuBar) {
       delete fMenuBar;
    }
+   delete fFormat;
    delete fFrame;
    fGLWidget = 0;
 }
 
 //______________________________________________________________________________
+TGCompositeFrame* TGLSAViewer::GetFrame() const
+{
+   // Return the main-frame.
+
+   return fFrame;
+}
+
+//______________________________________________________________________________
 void TGLSAViewer::CreateGLWidget()
 {
    // Create a GLwidget, it is an error if it is already created.
@@ -276,9 +337,12 @@ void TGLSAViewer::CreateGLWidget()
       return;
    }
 
+   if (fFormat == 0)
+      fFormat = new TGLFormat;
+
    ResetInitGL();
 
-   fGLWidget = TGLWidget::Create(fRightVerticalFrame, kTRUE, kTRUE, 0, 10, 10);
+   fGLWidget = TGLWidget::Create(*fFormat, fRightVerticalFrame, kTRUE, kTRUE, 0, 10, 10);
    fGLWidget->SetEventHandler(fEventHandler);
 
    fRightVerticalFrame->AddFrame(fGLWidget, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));
@@ -309,16 +373,6 @@ void TGLSAViewer::DestroyGLWidget()
 }
 
 //______________________________________________________________________________
-void TGLSAViewer::RefreshPadEditor(TObject* changed)
-{
-   // Refresh pad editor.
-
-   if (changed == 0 || fGedEditor->GetModel() == changed) {
-      fGedEditor->SetModel(fPad, fGedEditor->GetModel(), kButton1Down);
-   }
-}
-
-//______________________________________________________________________________
 void TGLSAViewer::CreateMenus()
 {
    //File/Camera/Help menus.
@@ -363,12 +417,21 @@ void TGLSAViewer::CreateMenus()
    fHelpMenu->Associate(fFrame);
 
    // Create menubar
-   fMenuBar = new TGMenuBar(fFrame, 1, 1, kHorizontalFrame);
+   fMenuBar = new TGMenuBar(fFrame);
    fMenuBar->AddPopup("&File", fFileMenu, new TGLayoutHints(kLHintsTop | kLHintsLeft, 0, 4, 0, 0));
    fMenuBar->AddPopup("&Camera", fCameraMenu, new TGLayoutHints(kLHintsTop | kLHintsLeft, 0, 4, 0, 0));
    fMenuBar->AddPopup("&Help",    fHelpMenu,    new TGLayoutHints(kLHintsTop | kLHintsRight));
    fFrame->AddFrame(fMenuBar, new TGLayoutHints(kLHintsTop | kLHintsLeft | kLHintsExpandX, 0, 0, 1, 1));
-
+   gVirtualX->SelectInput(fMenuBar->GetId(),
+                          kKeyPressMask | kExposureMask | kPointerMotionMask
+                          | kStructureNotifyMask | kFocusChangeMask
+                          | kEnterWindowMask | kLeaveWindowMask);
+
+   fMenuBut = new TGButton(fFrame);
+   fMenuBut->ChangeOptions(kRaisedFrame | kFixedHeight);
+   fMenuBut->Resize(20, 4);
+   fMenuBut->SetBackgroundColor(0x80A0C0);
+   fFrame->AddFrame(fMenuBut, new TGLayoutHints(kLHintsNormal | kLHintsExpandX, 0, 0, 1, 1));
 }
 
 //______________________________________________________________________________
@@ -407,13 +470,29 @@ void TGLSAViewer::CreateFrames()
    fRightVerticalFrame = new TGVerticalFrame(compositeFrame, 10, 10);
    compositeFrame->AddFrame(fRightVerticalFrame, new TGLayoutHints(kLHintsRight | kLHintsExpandX | kLHintsExpandY));
 
-   fGLWidget = TGLWidget::Create(fRightVerticalFrame, kTRUE, kTRUE, 0, 10, 10);
+   fEventHandler = new TGLEventHandler(0, this);
+   CreateGLWidget();
+}
 
-   SetEventHandler(new TGLEventHandler(0, this));
+//______________________________________________________________________________
+void TGLSAViewer::SelectionChanged()
+{
+   // Update GUI components for embedded viewer selection change.
+   // Override from TGLViewer.
 
-   fRightVerticalFrame->AddFrame(fGLWidget, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));
-}
+   TGLPhysicalShape *selected = const_cast<TGLPhysicalShape*>(GetSelected());
 
+   if (selected) {
+      fPShapeWrap->fPShape = selected;
+      if (fFileMenu->IsEntryChecked(kGLEditObject))
+         fGedEditor->SetModel(fPad, selected->GetLogical()->GetExternal(), kButton1Down);
+      else
+         fGedEditor->SetModel(fPad, fPShapeWrap, kButton1Down);
+   } else {
+      fPShapeWrap->fPShape = 0;
+      fGedEditor->SetModel(fPad, this, kButton1Down);
+   }
+}
 
 //______________________________________________________________________________
 void TGLSAViewer::Show()
@@ -441,6 +520,133 @@ void TGLSAViewer::DeleteMenuBar()
 }
 
 //______________________________________________________________________________
+void TGLSAViewer::DisableCloseMenuEntries()
+{
+   // Deactivate menu entries for closing the GL window and exiting ROOT.
+
+   fFileMenu->DeleteEntry(kGLCloseViewer);
+   fFileMenu->DeleteEntry(kGLQuitROOT);
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::EnableMenuBarHiding()
+{
+   // Enable hiding of menu bar.
+
+   if (fHideMenuBar)
+      return;
+
+   fHideMenuBar = kTRUE;
+
+   fMenuBar->Connect("ProcessedEvent(Event_t*)", "TGLSAViewer", this, "HandleMenuBarHiding(Event_t*)");
+   fMenuBut->Connect("ProcessedEvent(Event_t*)", "TGLSAViewer", this, "HandleMenuBarHiding(Event_t*)");
+
+   fFrame->HideFrame(fMenuBar);
+   fFrame->ShowFrame(fMenuBut);
+   fFrame->Layout();
+
+   fMenuHidingTimer = new TTimer;
+   fMenuHidingTimer->Connect("Timeout()", "TGLSAViewer", this, "MenuHidingTimeout()");
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::DisableMenuBarHiding()
+{
+   // Disable hiding of menu bar.
+
+   if (!fHideMenuBar)
+      return;
+
+   fHideMenuBar = kFALSE;
+
+   fMenuBar->Disconnect("ProcessedEvent(Event_t*)", this, "HandleMenuBarHiding(Event_t*)");
+   fMenuBut->Disconnect("ProcessedEvent(Event_t*)", this, "HandleMenuBarHiding(Event_t*)");
+
+   fFrame->ShowFrame(fMenuBar);
+   fFrame->HideFrame(fMenuBut);
+   fFrame->Layout();
+
+   delete fMenuHidingTimer;
+   fMenuHidingTimer = 0;
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::HandleMenuBarHiding(Event_t* ev)
+{
+   // Maybe switch menu-bar / menu-button.
+
+   TGFrame *f = (TGFrame*) gTQSender;
+
+   if (f == fMenuBut)
+   {
+      if (ev->fType == kEnterNotify)
+         ResetMenuHidingTimer(kTRUE);
+      else
+         fMenuHidingTimer->TurnOff();
+   }
+   else if (f == fMenuBar)
+   {
+      if (ev->fType == kLeaveNotify &&
+          (ev->fX < 0 || ev->fX >= (Int_t) f->GetWidth() ||
+           ev->fY < 0 || ev->fY >= (Int_t) f->GetHeight()))
+      {
+         if (fMenuBar->GetCurrent() == 0)
+            ResetMenuHidingTimer(kFALSE);
+         else
+            fMenuBar->GetCurrent()->Connect("ProcessedEvent(Event_t*)", "TGLSAViewer", this, "HandleMenuBarHiding(Event_t*)");
+      }
+      else
+      {
+         fMenuHidingTimer->TurnOff();
+      }
+   }
+   else
+   {
+      f->Disconnect("ProcessedEvent(Event_t*)", this);
+      ResetMenuHidingTimer(kFALSE);
+   }
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::ResetMenuHidingTimer(Bool_t show_menu)
+{
+   // Reset the timer for menu-bar hiding.
+
+   fMenuHidingTimer->TurnOff();
+
+   fMenuHidingShowMenu = show_menu;
+
+   fMenuHidingTimer->SetTime(fgMenuHidingTimeout);
+   fMenuHidingTimer->Reset();
+   fMenuHidingTimer->TurnOn();
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::MenuHidingTimeout()
+{
+   // Action for menu-hiding timeout.
+
+   fMenuHidingTimer->TurnOff();
+   if (fMenuHidingShowMenu) {
+      fFrame->HideFrame(fMenuBut);
+      fFrame->ShowFrame(fMenuBar);
+   } else {
+      fFrame->HideFrame(fMenuBar);
+      fFrame->ShowFrame(fMenuBut);
+   }
+   fFrame->Layout();
+}
+
+//______________________________________________________________________________
+void TGLSAViewer::SetMenuHidingTimeout(Long_t timeout)
+{
+   // Set global timeout for menu-hiding in mili-seconds.
+   // Static function.
+
+   fgMenuHidingTimeout = timeout;
+}
+
+//______________________________________________________________________________
 Bool_t TGLSAViewer::ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t)
 {
    // Process GUI message capture by the main GUI frame (TGLSAFrame).
@@ -476,7 +682,7 @@ Bool_t TGLSAViewer::ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t)
             break;
          }
          case kGLHelpViewer: {
-            TRootHelpDialog * hd = new TRootHelpDialog(fFrame, "Help on GL Viewer...", 600, 400);
+            TRootHelpDialog * hd = new TRootHelpDialog(fFrame, "Help on GL Viewer...", 660, 400);
             hd->AddText(fgHelpText1);
             hd->AddText(fgHelpText2);
             hd->Popup();
@@ -572,18 +778,18 @@ Bool_t TGLSAViewer::ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t)
          case kGLCloseViewer:
             // Exit needs to be delayed to avoid bad drawable X ids - GUI
             // will all be changed in future anyway
-
             TTimer::SingleShot(50, "TGLSAFrame", fFrame, "SendCloseMessage()");
             break;
          case kGLQuitROOT:
             if (!gApplication->ReturnFromRun())
                delete this;
             gApplication->Terminate(0);
-            default:
             break;
-            }
-            default:
+         default:
             break;
+         }
+      default:
+         break;
       }
    default:
       break;
@@ -593,40 +799,6 @@ Bool_t TGLSAViewer::ProcessFrameMessage(Long_t msg, Long_t parm1, Long_t)
 }
 
 //______________________________________________________________________________
-void TGLSAViewer::SelectionChanged()
-{
-   // Update GUI components for embedded viewer selection change.
-
-   // !!! MT this whole selection-signal-stuff is verrrry strange.
-   // At least, shouldn't we emit a signal here?
-   //
-   // I misuse this function after overlay-mouse-drag as well.
-   // Need something like refresh-viewer-gui which also does ged update.
-
-   TGLPhysicalShape *selected = const_cast<TGLPhysicalShape*>(GetSelected());
-
-   if (selected) {
-      fPShapeWrap->fPShape = selected;
-      if (fFileMenu->IsEntryChecked(kGLEditObject))
-         fGedEditor->SetModel(fPad, selected->GetLogical()->GetExternal(), kButton1Down);
-      else
-         fGedEditor->SetModel(fPad, fPShapeWrap, kButton1Down);
-   } else {
-      fPShapeWrap->fPShape = 0;
-      fGedEditor->SetModel(fPad, this, kButton1Down);
-   }
-}
-
-//______________________________________________________________________________
-void TGLSAViewer::OverlayDragFinished()
-{
-   // An overlay operation can result in change to an object.
-   // Refresh geditor.
-
-   fGedEditor->SetModel(fPad, fGedEditor->GetModel(), kButton1Down);
-}
-
-//______________________________________________________________________________
 void TGLSAViewer::ToggleEditObject()
 {
    // Toggle state of the 'Edit Object' menu entry.
diff --git a/graf3d/gl/src/TGLScene.cxx b/graf3d/gl/src/TGLScene.cxx
index 8e87682..69c1b68 100644
--- a/graf3d/gl/src/TGLScene.cxx
+++ b/graf3d/gl/src/TGLScene.cxx
@@ -288,7 +288,7 @@ TGLScene::~TGLScene()
    // Destroy scene objects
    TakeLock(kModifyLock);
    ReleaseGLCtxIdentity();
-   DestroyPhysicals(kTRUE); // including modified
+   DestroyPhysicals();
    DestroyLogicals();
    if (fGLCtxIdentity)
       fGLCtxIdentity->ReleaseClient();
@@ -853,6 +853,7 @@ void TGLScene::RenderElements(TGLRnrCtx&           rnrCtx,
       if (drawNeeded)
       {
          rnrCtx.SetShapeLOD((*i)->fFinalLOD);
+         rnrCtx.SetShapePixSize((*i)->fPixelSize);
          glPushName(drawShape->ID());
          drawShape->Draw(rnrCtx);
          glPopName();
@@ -1114,46 +1115,34 @@ Bool_t TGLScene::DestroyPhysical(UInt_t phid)
 }
 
 //______________________________________________________________________________
-Int_t TGLScene::DestroyPhysicals(Bool_t incModified, const TGLCamera* camera)
+Int_t TGLScene::DestroyPhysicals()
 {
-   // Destroy physical shapes that are no longer of interest to camera.
-   // If 'incModified' is true also the modified ones are deleted.
-   // Return count of number destroyed.
-
-   // !!! MT this whole concept is strange. Why should i keep
-   // physicals that are modified? There is no working update
-   // mechanism so they'll be wiped on pad-update.
-   // Maybe should rename the method, or what?
+   // Destroy physical shapes.
 
    if (fLock != kModifyLock) {
       Error("TGLScene::DestroyPhysicals", "expected ModifyLock");
       return 0;
    }
 
-   Int_t count = 0;
-   PhysicalShapeMapIt_t pit = fPhysicalShapes.begin();
-   while (pit != fPhysicalShapes.end())
+   // Loop over logicals -- it is much more efficient that way.
+   
+   UInt_t count = 0;
+
+   LogicalShapeMapIt_t lit = fLogicalShapes.begin();
+   while (lit != fLogicalShapes.end())
    {
-      const TGLPhysicalShape * physical = pit->second;
-      if (physical) {
-         // If modified options allow this physical to be destoyed
-         if (incModified || (!incModified && !physical->IsModified())) {
-            // and no camera is passed, or it is no longer of interest
-            // to camera
-            Bool_t ignoreSize = physical->GetLogical()->IgnoreSizeForOfInterest();
-            if (!camera || (camera && !camera->OfInterest(physical->BoundingBox(), ignoreSize)))
-            {
-               DestroyPhysicalInternal(pit++);
-               ++count;
-               continue; // Incremented the iterator during erase()
-            }
-         }
-      } else {
-         assert(kFALSE);
+      TGLLogicalShape *lshp = lit->second;
+      if (lshp && lshp->Ref() != 0)
+      {
+         count += lshp->Ref();
+         lshp->DestroyPhysicals();
       }
-      ++pit;
+      ++lit;
    }
 
+   assert (count == fPhysicalShapes.size());
+   fPhysicalShapes.clear();
+
    if (count > 0) {
       InvalidateBoundingBox();
       IncTimeStamp();
diff --git a/graf3d/gl/src/TGLSceneBase.cxx b/graf3d/gl/src/TGLSceneBase.cxx
index 879844d..8d74c89 100644
--- a/graf3d/gl/src/TGLSceneBase.cxx
+++ b/graf3d/gl/src/TGLSceneBase.cxx
@@ -408,7 +408,6 @@ void TGLSceneBase::PreRender(TGLRnrCtx & rnrCtx)
    TGLSceneInfo& sInfo = * rnrCtx.GetSceneInfo();
 
    rnrCtx.SetClip         (sInfo.LastClip());
-   rnrCtx.SetCamera       (sInfo.LastCamera());
    rnrCtx.SetCombiLOD     (sInfo.LastLOD());
    rnrCtx.SetSceneStyle   (sInfo.LastStyle());
    rnrCtx.SetSceneWFLineW (sInfo.LastWFLineW());
diff --git a/graf3d/gl/src/TGLScenePad.cxx b/graf3d/gl/src/TGLScenePad.cxx
index 83bb7e4..8d300fe 100644
--- a/graf3d/gl/src/TGLScenePad.cxx
+++ b/graf3d/gl/src/TGLScenePad.cxx
@@ -237,9 +237,9 @@ void TGLScenePad::BeginScene()
    }
 
    // Rebuilds can potentially invalidate all logical and
-   // physical shapes - including any modified physicals.
+   // physical shapes.
    // Physicals must be removed first.
-   destroyedPhysicals = DestroyPhysicals(kTRUE); // include modified
+   destroyedPhysicals = DestroyPhysicals();
    if (fSmartRefresh) {
       destroyedLogicals = BeginSmartRefresh();
    } else {
diff --git a/graf3d/gl/src/TGLSurfacePainter.cxx b/graf3d/gl/src/TGLSurfacePainter.cxx
index 6c05ce1..70ccfeb 100644
--- a/graf3d/gl/src/TGLSurfacePainter.cxx
+++ b/graf3d/gl/src/TGLSurfacePainter.cxx
@@ -16,6 +16,7 @@
 #include "TMath.h"
 #include "TAxis.h"
 #include "TH1.h"
+#include "TRandom.h"
 
 #include "TGLSurfacePainter.h"
 #include "TGLPlotCamera.h"
@@ -27,6 +28,8 @@
 
 ClassImp(TGLSurfacePainter)
 
+TRandom *TGLSurfacePainter::fgRandom = new TRandom(0);
+
 //______________________________________________________________________________
 void TGLSurfacePainter::Projection_t::Swap(Projection_t &rhs)
 {
@@ -846,9 +849,9 @@ void TGLSurfacePainter::DrawSectionXOZ()const
             fProj.fVertices.push_back(Intersection(profilePlane, TGLLine3(fMesh[i][binY], fMesh[i][binY + 1]), kFALSE).second);
          }
          if (fProj.fVertices.size()) {
-            fProj.fRGBA[0] = rand() % 200 + 56;
-            fProj.fRGBA[1] = rand() % 100;
-            fProj.fRGBA[2] = rand() % 100;
+            fProj.fRGBA[0] = (UChar_t) (50 + fgRandom->Integer(206));
+            fProj.fRGBA[1] = (UChar_t) fgRandom->Integer(150);
+            fProj.fRGBA[2] = (UChar_t) fgRandom->Integer(150);
             fProj.fRGBA[3] = 150;
             static Projection_t dummy;
             fXOZProj.push_back(dummy);
@@ -896,9 +899,9 @@ void TGLSurfacePainter::DrawSectionYOZ()const
             fProj.fVertices.push_back(Intersection(profilePlane, TGLLine3(fMesh[binX][j], fMesh[binX + 1][j]), kFALSE).second);
          }
          if (fProj.fVertices.size()) {
-            fProj.fRGBA[0] = rand() % 200 + 56;
-            fProj.fRGBA[1] = rand() % 100;
-            fProj.fRGBA[2] = rand() % 100;
+            fProj.fRGBA[0] = (UChar_t) (50 + fgRandom->Integer(206));
+            fProj.fRGBA[1] = (UChar_t) fgRandom->Integer(150);
+            fProj.fRGBA[2] = (UChar_t) fgRandom->Integer(150);
             fProj.fRGBA[3] = 150;
             static Projection_t dummy;
             fYOZProj.push_back(dummy);
@@ -993,9 +996,9 @@ void TGLSurfacePainter::DrawSectionXOY()const
    }
 
    if (fSectionPass && fProj.fVertices.size()) {
-      fProj.fRGBA[0] = rand() % 150;
-      fProj.fRGBA[1] = rand() % 150;
-      fProj.fRGBA[2] = rand() % 206 + 50;
+      fProj.fRGBA[0] = (UChar_t) fgRandom->Integer(150);
+      fProj.fRGBA[1] = (UChar_t) fgRandom->Integer(150);
+      fProj.fRGBA[2] = (UChar_t) (50 + fgRandom->Integer(206));
       fProj.fRGBA[3] = 150;
       static Projection_t dummy;
       fXOYProj.push_back(dummy);
diff --git a/graf3d/gl/src/TGLUtil.cxx b/graf3d/gl/src/TGLUtil.cxx
index c699e5c..5febcf3 100644
--- a/graf3d/gl/src/TGLUtil.cxx
+++ b/graf3d/gl/src/TGLUtil.cxx
@@ -270,12 +270,46 @@ TGLRect::~TGLRect()
 }
 
 //______________________________________________________________________________
+void TGLRect::Expand(Int_t x, Int_t y)
+{
+   // Expand the rect to encompass point (x,y)
+   Int_t delX = x - fX;
+   Int_t delY = y - fY;
+
+   if (delX > fWidth) {
+      fWidth = delX;
+   }
+   if (delY > fHeight) {
+      fHeight = delY;
+   }
+
+   if (delX < 0) {
+      fX = x;
+      fWidth += -delX;
+   }
+   if (delY < 0) {
+      fY = y;
+      fHeight += -delY;
+   }
+}
+
+//______________________________________________________________________________
+Int_t TGLRect::Diagonal() const
+{
+   // Return the diagonal of the rectangle.
+
+   const Double_t w = static_cast<Double_t>(fWidth);
+   const Double_t h = static_cast<Double_t>(fHeight);
+   return TMath::Nint(TMath::Sqrt(w*w + h*h));
+}
+
+//______________________________________________________________________________
 EOverlap TGLRect::Overlap(const TGLRect & other) const
 {
    // Return overlap result (kInside, kOutside, kPartial) of this
    // rect with 'other'
    if ((fX <= other.fX) && (fX + fWidth >= other.fX + other.fWidth) &&
-        (fY <= other.fY) && (fY +fHeight >= other.fY + other.fHeight)) {
+       (fY <= other.fY) && (fY +fHeight >= other.fY + other.fHeight)) {
       return kInside;
    }
    else if ((fX >= other.fX + static_cast<Int_t>(other.fWidth)) ||
@@ -1837,11 +1871,12 @@ void TGLUtil::RenderCrosses(const TAttMarker& marker, Float_t* op, Int_t n,
    {
       glEnable(GL_BLEND);
       glEnable(GL_LINE_SMOOTH);
-      LineWidth(2);
+      TGLUtil::LineWidth(2);
    }
    else
    {
       glDisable(GL_LINE_SMOOTH);
+      TGLUtil::LineWidth(1);
    }
 
    // cross dim
@@ -1872,6 +1907,30 @@ void TGLUtil::RenderCrosses(const TAttMarker& marker, Float_t* op, Int_t n,
       }
       glEnd();
    }
+
+   // Anti-flickering -- when crosses get too small they
+   // appear / disappear randomly.
+   {
+      glDisable(GL_POINT_SMOOTH);
+      TGLUtil::PointSize(1);
+
+      glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
+      glVertexPointer(3, GL_FLOAT, 0, op);
+      glEnableClientState(GL_VERTEX_ARRAY);
+      { // Circumvent bug in ATI's linux drivers.
+         Int_t nleft = n;
+         Int_t ndone = 0;
+         const Int_t maxChunk = 8192;
+         while (nleft > maxChunk)
+         {
+            glDrawArrays(GL_POINTS, ndone, maxChunk);
+            nleft -= maxChunk;
+            ndone += maxChunk;
+         }
+         glDrawArrays(GL_POINTS, ndone, nleft);
+      }
+      glPopClientAttrib();
+   }
 }
 
 //______________________________________________________________________________
@@ -2379,7 +2438,7 @@ ClassImp(TGLSelectionBuffer);
 
 //______________________________________________________________________________
 TGLSelectionBuffer::TGLSelectionBuffer()
-                        : fWidth(0)
+                        : fWidth(0), fHeight(0)
 {
    // TGLSelectionBuffer constructor.
 }
diff --git a/graf3d/gl/src/TGLViewer.cxx b/graf3d/gl/src/TGLViewer.cxx
index f1c5780..f144111 100644
--- a/graf3d/gl/src/TGLViewer.cxx
+++ b/graf3d/gl/src/TGLViewer.cxx
@@ -15,7 +15,6 @@
 #include "TGLRnrCtx.h"
 #include "TGLSelectBuffer.h"
 #include "TGLLightSet.h"
-#include "TGLClip.h"
 #include "TGLManipSet.h"
 #include "TGLCameraOverlay.h"
 
@@ -48,6 +47,8 @@
 #include "TGLWidget.h"
 // #include "TGLFBO.h"
 #include "TGLViewerEditor.h"
+#include "TGedEditor.h"
+#include "TGLPShapeObj.h"
 
 #include "KeySymbols.h"
 #include "TContextMenu.h"
@@ -110,13 +111,19 @@ TGLViewer::TGLViewer(TVirtualPad * pad, Int_t x, Int_t y,
    fOrthoZnOYCamera(TGLOrthoCamera::kZnOY, TGLVector3( 1.0, 0.0, 0.0), TGLVector3(0.0, 1.0, 0.0)), // Looking down  X axis, -Z horz, Y vert
    fCurrentCamera(&fPerspectiveCameraXOZ),
 
+   fStereo               (kFALSE),
+   fStereoZeroParallax   (0.03f),
+   fStereoEyeOffsetFac   (1.0f),
+   fStereoFrustumAsymFac (1.0f),
+
    fLightSet          (0),
    fClipSet           (0),
-   fClipAutoUpdate    (kTRUE),
    fSelectedPShapeRef (0),
    fCurrentOvlElm     (0),
 
    fEventHandler(0),
+   fGedEditor(0),
+   fPShapeWrap(0),
    fPushAction(kPushStd), fDragAction(kDragNone),
    fRedrawTimer(0),
    fMaxSceneDrawTimeHQ(5000),
@@ -139,8 +146,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad, Int_t x, Int_t y,
    fGLCtxId(0),
    fIgnoreSizesOnUpdate(kFALSE),
    fResetCamerasOnUpdate(kTRUE),
-   fResetCamerasOnNextUpdate(kFALSE),
-   fResetCameraOnDoubleClick(kTRUE)
+   fResetCamerasOnNextUpdate(kFALSE)
 {
    // Construct the viewer object, with following arguments:
    //    'pad' - external pad viewer is bound to
@@ -167,13 +173,19 @@ TGLViewer::TGLViewer(TVirtualPad * pad) :
    fOrthoZnOYCamera(TGLOrthoCamera::kZnOY, TGLVector3( 1.0, 0.0, 0.0), TGLVector3(0.0, 1.0, 0.0)), // Looking down  X axis, -Z horz, Y vert
    fCurrentCamera(&fPerspectiveCameraXOZ),
 
+   fStereo               (kFALSE),
+   fStereoZeroParallax   (0.03f),
+   fStereoEyeOffsetFac   (1.0f),
+   fStereoFrustumAsymFac (1.0f),
+
    fLightSet          (0),
    fClipSet           (0),
-   fClipAutoUpdate    (kTRUE),
    fSelectedPShapeRef (0),
    fCurrentOvlElm     (0),
 
    fEventHandler(0),
+   fGedEditor(0),
+   fPShapeWrap(0),
    fPushAction(kPushStd), fDragAction(kDragNone),
    fRedrawTimer(0),
    fMaxSceneDrawTimeHQ(5000),
@@ -196,8 +208,7 @@ TGLViewer::TGLViewer(TVirtualPad * pad) :
    fGLCtxId(0),
    fIgnoreSizesOnUpdate(kFALSE),
    fResetCamerasOnUpdate(kTRUE),
-   fResetCamerasOnNextUpdate(kFALSE),
-   fResetCameraOnDoubleClick(kTRUE)
+   fResetCamerasOnNextUpdate(kFALSE)
 {
    //gl-embedded viewer's ctor
    // Construct the viewer object, with following arguments:
@@ -230,6 +241,8 @@ void TGLViewer::InitSecondaryObjects()
    fSelectedPShapeRef->SetDrawBBox(kTRUE);
    AddOverlayElement(fSelectedPShapeRef);
 
+   fPShapeWrap = new TGLPShapeObj(0, this);
+
    fLightColorSet.StdLightBackground();
    if (fgUseDefaultColorSetForNewViewers) {
       fRnrCtx->ChangeBaseColorSet(&fgDefaultColorSet);
@@ -455,6 +468,20 @@ void TGLViewer::RequestDraw(Short_t LODInput)
 }
 
 //______________________________________________________________________________
+void TGLViewer::SetupClipObject()
+{
+   // Setup clip-object. Protected virtual method.
+
+   if (GetClipAutoUpdate())
+   {
+      fClipSet->SetupCurrentClip(fOverallBoundingBox);
+   }
+   else
+   {
+      fClipSet->SetupCurrentClipIfInvalid(fOverallBoundingBox);
+   }
+}
+//______________________________________________________________________________
 void TGLViewer::PreRender()
 {
    // Initialize objects that influence rendering.
@@ -478,11 +505,6 @@ void TGLViewer::PreRender()
 
    // Setup lighting
    fLightSet->StdSetupLights(fOverallBoundingBox, *fCamera, fDebugMode);
-   // Setup clip object.
-   if (fClipAutoUpdate)
-      fClipSet->SetupCurrentClip(fOverallBoundingBox);
-   else
-      fClipSet->SetupCurrentClipIfInvalid(fOverallBoundingBox);
 }
 
 //______________________________________________________________________________
@@ -500,7 +522,7 @@ void TGLViewer::PostRender()
 //______________________________________________________________________________
 void TGLViewer::DoDraw()
 {
-   // Draw out the the current viewer/scene
+   // Draw out the viewer.
 
    // Locking mainly for Win32 multi thread safety - but no harm in all using it
    // During normal draws a draw lock is taken in other thread (Win32) in RequestDraw()
@@ -516,8 +538,9 @@ void TGLViewer::DoDraw()
       }
    }
 
+   TUnlocker ulck(this);
+
    if (fGLDevice == -1 && (fViewport.Width() <= 1 || fViewport.Height() <= 1)) {
-      ReleaseLock(kDrawLock);
       if (gDebug > 2) {
 	 Info("TGLViewer::DoDraw()", "zero surface area, draw skipped.");
       }
@@ -539,13 +562,50 @@ void TGLViewer::DoDraw()
    fRnrCtx->SetRenderTimeOut(fLOD == TGLRnrCtx::kLODHigh ?
                              fMaxSceneDrawTimeHQ :
                              fMaxSceneDrawTimeLQ);
-   fRnrCtx->StartStopwatch();
 
-   // GL pre draw setup
-   if (!fIsPrinting) PreDraw();
+   if (fStereo && fCurrentCamera->IsPerspective() && !fRnrCtx->GetGrabImage() &&
+       !fIsPrinting)
+   {
+      DoDrawStereo();
+   }
+   else
+   {
+      DoDrawMono();
+   }
+
+   ReleaseLock(kDrawLock);
+
+   if (gDebug>2) {
+      Info("TGLViewer::DoDraw()", "Took %f msec", timer.End());
+   }
+
+   // Check if further redraws are needed and schedule them.
+
+   if (CurrentCamera().UpdateInterest(kFALSE)) {
+      // Reset major view-dependant cache.
+      ResetSceneInfos();
+      fRedrawTimer->RequestDraw(0, fLOD);
+   }
+
+   if (fLOD != TGLRnrCtx::kLODHigh &&
+       (fDragAction < kDragCameraRotate || fDragAction > kDragCameraDolly))
+   {
+      // Request final draw pass.
+      fRedrawTimer->RequestDraw(100, TGLRnrCtx::kLODHigh);
+   }
+}
 
+//______________________________________________________________________________
+void TGLViewer::DoDrawMono()
+{
+   // Draw out in monoscopic mode.
+
+   MakeCurrent();
+
+   if (!fIsPrinting) PreDraw();
    PreRender();
 
+   fRnrCtx->StartStopwatch();
    if (fFader < 1)
    {
       RenderNonSelected();
@@ -560,6 +620,7 @@ void TGLViewer::DoDraw()
       glClear(GL_DEPTH_BUFFER_BIT);
       DrawDebugInfo();
    }
+   fRnrCtx->StopStopwatch();
 
    PostRender();
 
@@ -570,28 +631,119 @@ void TGLViewer::DoDraw()
 
    PostDraw();
 
+   SwapBuffers();
+}
+
+//______________________________________________________________________________
+void TGLViewer::DoDrawStereo()
+{
+   // Draw out in stereoscopic mode.
+
+   TGLPerspectiveCamera &c = *dynamic_cast<TGLPerspectiveCamera*>(fCurrentCamera);
+
+   Float_t gl_near, gl_far, zero_p_dist;
+   Float_t h_half, w_half;
+   Float_t x_len_at_zero_parallax;
+   Float_t stereo_offset;
+   Float_t frustum_asym;
+
+   MakeCurrent();
+
+   // Draw left
+   glDrawBuffer(GL_BACK_LEFT);
+   PreDraw();
+   PreRender();
+
+   gl_near = c.GetNearClip();
+   gl_far  = c.GetFarClip();
+   zero_p_dist = gl_near + fStereoZeroParallax*(gl_far-gl_near);
+
+   h_half = TMath::Tan(0.5*TMath::DegToRad()*c.GetFOV()) * gl_near;
+   w_half = h_half * fViewport.Aspect();
+
+   x_len_at_zero_parallax = 2.0f * w_half * zero_p_dist / gl_near;
+   stereo_offset = 0.035f * x_len_at_zero_parallax * fStereoEyeOffsetFac;
+
+   frustum_asym = stereo_offset * gl_near / zero_p_dist * fStereoFrustumAsymFac;
+
+   TGLMatrix  abs_trans(c.RefCamBase());
+   abs_trans *= c.RefCamTrans();
+   TGLVector3 left_vec = abs_trans.GetBaseVec(2);
+
+   glTranslatef(stereo_offset*left_vec[0], stereo_offset*left_vec[1], stereo_offset*left_vec[2]);
+
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glFrustum(-w_half + frustum_asym, w_half + frustum_asym,
+             -h_half, h_half, gl_near, gl_far);
+   glMatrixMode(GL_MODELVIEW);
+
+   fRnrCtx->StartStopwatch();
+   if (fFader < 1)
+   {
+      RenderNonSelected();
+      RenderSelected();
+      DrawGuides();
+      RenderOverlay();
+
+      glClear(GL_DEPTH_BUFFER_BIT);
+      fRnrCtx->SetHighlight(kTRUE);
+      RenderSelected();
+      fRnrCtx->SetHighlight(kFALSE);
+      glClear(GL_DEPTH_BUFFER_BIT);
+      DrawDebugInfo();
+   }
    fRnrCtx->StopStopwatch();
 
-   ReleaseLock(kDrawLock);
+   PostRender();
 
-   if (gDebug>2) {
-      Info("TGLViewer::DoDraw()", "Took %f msec", timer.End());
+   if (fFader > 0)
+   {
+      FadeView(fFader);
    }
+   PostDraw();
 
-   // Check if further redraws are needed and schedule them.
+   // Draw right
+   glDrawBuffer(GL_BACK_RIGHT);
+   PreDraw();
+   PreRender();
 
-   if (CurrentCamera().UpdateInterest(kFALSE)) {
-      // Reset major view-dependant cache.
-      ResetSceneInfos();
-      fRedrawTimer->RequestDraw(0, fLOD);
+   glTranslatef(-stereo_offset*left_vec[0], -stereo_offset*left_vec[1], -stereo_offset*left_vec[2]);
+
+   glMatrixMode(GL_PROJECTION);
+   glLoadIdentity();
+   glFrustum(-w_half - frustum_asym, w_half - frustum_asym,
+             -h_half, h_half, gl_near, gl_far);
+   glMatrixMode(GL_MODELVIEW);
+
+   fRnrCtx->StartStopwatch();
+   if (fFader < 1)
+   {
+      RenderNonSelected();
+      RenderSelected();
+      DrawGuides();
+      RenderOverlay();
+
+      glClear(GL_DEPTH_BUFFER_BIT);
+      fRnrCtx->SetHighlight(kTRUE);
+      RenderSelected();
+      fRnrCtx->SetHighlight(kFALSE);
+      glClear(GL_DEPTH_BUFFER_BIT);
+      DrawDebugInfo();
    }
+   fRnrCtx->StopStopwatch();
 
-   if (fLOD != TGLRnrCtx::kLODHigh &&
-       (fDragAction < kDragCameraRotate || fDragAction > kDragCameraDolly))
+   PostRender();
+
+   if (fFader > 0)
    {
-      // Request final draw pass.
-      fRedrawTimer->RequestDraw(100, TGLRnrCtx::kLODHigh);
+      FadeView(fFader);
    }
+   PostDraw();
+
+   // End
+   SwapBuffers();
+   glDrawBuffer(GL_BACK);
 }
 
 //______________________________________________________________________________
@@ -662,6 +814,8 @@ Bool_t TGLViewer::SavePictureUsingBB(const TString &fileName)
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    std::auto_ptr<TImage> image(TImage::Create());
 
    fRnrCtx->SetGrabImage(kTRUE, GL_BACK);
@@ -720,6 +874,8 @@ Bool_t TGLViewer::SavePictureUsingFBO(const TString &, Int_t, Int_t, Float_t)
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    std::auto_ptr<TImage> image(TImage::Create());
 
    MakeCurrent();
@@ -886,8 +1042,8 @@ void TGLViewer::DrawDebugInfo()
 //______________________________________________________________________________
 void TGLViewer::PreDraw()
 {
-   // Perform GL work which must be done before each draw of scene
-   MakeCurrent();
+   // Perform GL work which must be done before each draw.
+
    // Initialise GL if not done
    if (!fInitGL) {
       InitGL();
@@ -914,7 +1070,8 @@ void TGLViewer::PreDraw()
 //______________________________________________________________________________
 void TGLViewer::PostDraw()
 {
-   // Perform GL work which must be done after each draw of scene
+   // Perform GL work which must be done after each draw.
+
    glFlush();
    if (fRnrCtx->GetGrabImage())
    {
@@ -929,7 +1086,6 @@ void TGLViewer::PostDraw()
 
       fRnrCtx->SetGrabbedImage(xx);
    }
-   SwapBuffers();
 
    TGLUtil::CheckError("TGLViewer::PostDraw");
 }
@@ -1019,6 +1175,8 @@ Bool_t TGLViewer::DoSelect(Int_t x, Int_t y)
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    MakeCurrent();
 
    fRnrCtx->BeginSelection(x, y, 3);
@@ -1058,7 +1216,12 @@ Bool_t TGLViewer::DoSelect(Int_t x, Int_t y)
 //______________________________________________________________________________
 Bool_t TGLViewer::RequestSecondarySelect(Int_t x, Int_t y)
 {
-   // 
+   // Request secondary select.
+
+   if ( ! TakeLock(kSelectLock)) {
+      return kFALSE;
+   }
+
    if (!gVirtualX->IsCmdThread())
       return Bool_t(gROOT->ProcessLineFast(Form("((TGLViewer *)0x%lx)->DoSecondarySelect(%d, %d, %s)", this, x, y)));
    else
@@ -1070,20 +1233,25 @@ Bool_t TGLViewer::DoSecondarySelect(Int_t x, Int_t y)
 {
    // Secondary selection.
 
-   GLint nHits = 1;
-   //glGetIntegerv(GL_RENDER, &nHits);
-   if ( nHits < 1 || ! fSelRec.GetSceneInfo() || ! fSelRec.GetPhysShape() ||
-         ! fSelRec.GetPhysShape()->GetLogical()->SupportsSecondarySelect())
+   if (CurrentLock() != kSelectLock) {
+      Error("TGLViewer::DoSecondarySelect", "expected kSelectLock, found %s", LockName(CurrentLock()));
+      return kFALSE;
+   }
+
+   TUnlocker ulck(this);
+
+   if (! fSelRec.GetSceneInfo() || ! fSelRec.GetPhysShape() ||
+       ! fSelRec.GetPhysShape()->GetLogical()->SupportsSecondarySelect())
    {
       if (gDebug > 0)
          Info("TGLViewer::SecondarySelect", "Skipping secondary selection "
-              "(nPrimHits=%d, sinfo=0x%lx, pshape=0x%lx).\n",
-              nHits, fSelRec.GetSceneInfo(), fSelRec.GetPhysShape());
+              "(sinfo=0x%lx, pshape=0x%lx).\n",
+              fSelRec.GetSceneInfo(), fSelRec.GetPhysShape());
       fSecSelRec.Reset();
       return kFALSE;
    }
 
-   TakeLock(kSelectLock);
+   MakeCurrent();
 
    TGLSceneInfo*    sinfo = fSelRec.GetSceneInfo();
    TGLSceneBase*    scene = sinfo->GetScene();
@@ -1177,6 +1345,8 @@ Bool_t TGLViewer::DoOverlaySelect(Int_t x, Int_t y)
       return kFALSE;
    }
 
+   TUnlocker ulck(this);
+
    MakeCurrent();
 
    fRnrCtx->BeginSelection(x, y, 3);
@@ -1654,22 +1824,6 @@ const TGLPhysicalShape * TGLViewer::GetSelected() const
 /**************************************************************************/
 
 //______________________________________________________________________________
-void TGLViewer::SelectionChanged()
-{
-   // Emit signal indicating selection has changed.
-
-   Emit("SelectionChanged()");
-}
-
-//______________________________________________________________________________
-void TGLViewer::OverlayDragFinished()
-{
-   // Emit signal indicating that an overlay drag has finished.
-
-   Emit("OverlayDragFinished()");
-}
-
-//______________________________________________________________________________
 void TGLViewer::MouseOver(TGLPhysicalShape *shape)
 {
    // Emit MouseOver signal.
@@ -1786,6 +1940,48 @@ void TGLViewer::PrintObjects()
 }
 
 //______________________________________________________________________________
+void TGLViewer::SelectionChanged()
+{
+   // Update GUI components for embedded viewer selection change.
+
+   if (!fGedEditor)
+      return;
+
+   TGLPhysicalShape *selected = const_cast<TGLPhysicalShape*>(GetSelected());
+
+   if (selected) {
+      fPShapeWrap->fPShape = selected;
+      fGedEditor->SetModel(fPad, fPShapeWrap, kButton1Down);
+   } else {
+      fPShapeWrap->fPShape = 0;
+      fGedEditor->SetModel(fPad, this, kButton1Down);
+   }
+}
+
+//______________________________________________________________________________
+void TGLViewer::OverlayDragFinished()
+{
+   // An overlay operation can result in change to an object.
+   // Refresh geditor.
+
+   if (fGedEditor)
+   {
+      fGedEditor->SetModel(fPad, fGedEditor->GetModel(), kButton1Down);
+   }
+}
+
+//______________________________________________________________________________
+void TGLViewer::RefreshPadEditor(TObject* obj)
+{
+   // Update GED editor if it is set.
+
+   if (fGedEditor && (obj == 0 || fGedEditor->GetModel() == obj))
+   {
+      fGedEditor->SetModel(fPad, fGedEditor->GetModel(), kButton1Down);
+   }
+}
+
+//______________________________________________________________________________
 void TGLViewer::SetEventHandler(TGEventHandler *handler)
 {
    // Set the event-handler. The event-handler is owned by the viewer.
diff --git a/graf3d/gl/src/TGLViewerBase.cxx b/graf3d/gl/src/TGLViewerBase.cxx
index 1f0f446..ad0c1ed 100644
--- a/graf3d/gl/src/TGLViewerBase.cxx
+++ b/graf3d/gl/src/TGLViewerBase.cxx
@@ -16,6 +16,7 @@
 
 #include "TGLRnrCtx.h"
 #include "TGLCamera.h"
+#include "TGLClip.h"
 #include "TGLOverlay.h"
 #include "TGLSelectBuffer.h"
 #include "TGLSelectRecord.h"
@@ -270,6 +271,17 @@ void TGLViewerBase::MergeSceneBBoxes(TGLBoundingBox& bbox)
 // Rendering / selection virtuals
 /**************************************************************************/
 
+//______________________________________________________________________________
+void TGLViewerBase::SetupClipObject()
+{
+   // Setup clip-object. Protected virtual method.
+
+   if (fClip)
+   {
+      fClip->Setup(fOverallBoundingBox);
+   }
+}
+
 //______________________________________________________________________
 void TGLViewerBase::PreRender()
 {
@@ -331,6 +343,7 @@ void TGLViewerBase::PreRender()
    }
 
    fCamera->Apply(fOverallBoundingBox, fRnrCtx->GetPickRectangle());
+   SetupClipObject();
 
    // Make precursory selection of visible scenes.
    // Only scene bounding-box .vs. camera frustum check performed.
diff --git a/graf3d/gl/src/TGLViewerEditor.cxx b/graf3d/gl/src/TGLViewerEditor.cxx
index fac0a64..df522d4 100644
--- a/graf3d/gl/src/TGLViewerEditor.cxx
+++ b/graf3d/gl/src/TGLViewerEditor.cxx
@@ -35,7 +35,6 @@ TGLViewerEditor::TGLViewerEditor(const TGWindow *p,  Int_t width, Int_t height,
    fClearColor(0),
    fIgnoreSizesOnUpdate(0),
    fResetCamerasOnUpdate(0),
-   fResetCameraOnDoubleClick(0),
    fUpdateScene(0),
    fCameraHome(0),
    fMaxSceneDrawTimeHQ(0),
@@ -64,6 +63,10 @@ TGLViewerEditor::TGLViewerEditor(const TGWindow *p,  Int_t width, Int_t height,
    fCamContainer(0),
    fCamMode(0),
    fCamOverlayOn(0),
+   fClipSet(0),
+   fStereoZeroParallax(0),
+   fStereoEyeOffsetFac(0),
+   fStereoFrustumAsymFac(0),
    fViewer(0),
    fIsInPad(kTRUE)
 {
@@ -72,6 +75,7 @@ TGLViewerEditor::TGLViewerEditor(const TGWindow *p,  Int_t width, Int_t height,
    CreateStyleTab();
    CreateGuidesTab();
    CreateClippingTab();
+   CreateStereoTab();
 }
 
 //______________________________________________________________________________
@@ -90,7 +94,6 @@ void TGLViewerEditor::ConnectSignals2Slots()
    fClearColor->Connect("ColorSelected(Pixel_t)", "TGLViewerEditor", this, "DoClearColor(Pixel_t)");
    fIgnoreSizesOnUpdate->Connect("Toggled(Bool_t)", "TGLViewerEditor", this, "DoIgnoreSizesOnUpdate()");
    fResetCamerasOnUpdate->Connect("Toggled(Bool_t)", "TGLViewerEditor", this, "DoResetCamerasOnUpdate()");
-   fResetCameraOnDoubleClick->Connect("Toggled(Bool_t)", "TGLViewerEditor", this, "DoResetCameraOnDoubleClick()");
    fUpdateScene->Connect("Pressed()", "TGLViewerEditor", this, "DoUpdateScene()");
    fCameraHome->Connect("Pressed()", "TGLViewerEditor", this, "DoCameraHome()");
    fMaxSceneDrawTimeHQ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateMaxDrawTimes()");
@@ -121,6 +124,13 @@ void TGLViewerEditor::ConnectSignals2Slots()
    fCamMode->Connect("Selected(Int_t)", "TGLViewerEditor", this, "DoCameraOverlay()");
    fCamOverlayOn->Connect("Clicked()", "TGLViewerEditor", this, "DoCameraOverlay()");
 
+   fStereoZeroParallax  ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
+   fStereoEyeOffsetFac  ->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
+   fStereoFrustumAsymFac->Connect("ValueSet(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
+   fStereoZeroParallax  ->Connect("ValueChanged(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
+   fStereoEyeOffsetFac  ->Connect("ValueChanged(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
+   fStereoFrustumAsymFac->Connect("ValueChanged(Long_t)", "TGLViewerEditor", this, "UpdateStereo()");
+
    fInit = kFALSE;
 }
 
@@ -157,7 +167,6 @@ void TGLViewerEditor::SetModel(TObject* obj)
    fClearColor->Enable(!fViewer->IsUsingDefaultColorSet());
    fIgnoreSizesOnUpdate->SetState(fViewer->GetIgnoreSizesOnUpdate() ? kButtonDown : kButtonUp);
    fResetCamerasOnUpdate->SetState(fViewer->GetResetCamerasOnUpdate() ? kButtonDown : kButtonUp);
-   fResetCameraOnDoubleClick->SetState(fViewer->GetResetCameraOnDoubleClick() ? kButtonDown : kButtonUp);
    fMaxSceneDrawTimeHQ->SetNumber(fViewer->GetMaxSceneDrawTimeHQ());
    fMaxSceneDrawTimeLQ->SetNumber(fViewer->GetMaxSceneDrawTimeLQ());
    fPointSizeScale->SetNumber(fViewer->GetPointScale());
@@ -181,6 +190,18 @@ void TGLViewerEditor::SetModel(TObject* obj)
    // push action
    fCaptureCenter->SetTextColor((fViewer->GetPushAction() == TGLViewer::kPushCamCenter) ? 0xa03060 : 0x000000);
    fCaptureAnnotate->SetDown( (fViewer->GetPushAction() == TGLViewer::kPushAnnotate), kFALSE);
+
+   if (fViewer->GetStereo())
+   {
+      fStereoZeroParallax  ->SetNumber(fViewer->GetStereoZeroParallax());
+      fStereoEyeOffsetFac  ->SetNumber(fViewer->GetStereoEyeOffsetFac());
+      fStereoFrustumAsymFac->SetNumber(fViewer->GetStereoFrustumAsymFac());
+      fStereoFrame->MapWindow();
+   }
+   else
+   {
+      fStereoFrame->UnmapWindow();
+   }
 }
 
 //______________________________________________________________________________
@@ -211,17 +232,9 @@ void TGLViewerEditor::DoResetCamerasOnUpdate()
 }
 
 //______________________________________________________________________________
-void TGLViewerEditor::DoResetCameraOnDoubleClick()
-{
-   // ResetCameraOnDoubleClick was toggled.
-
-   fViewer->SetResetCameraOnDoubleClick(fResetCameraOnDoubleClick->IsOn());
-}
-
-//______________________________________________________________________________
 void TGLViewerEditor::DoUpdateScene()
 {
-   // ResetCameraOnDoubleClick was toggled.
+   // UpdateScene was clicked.
 
    fViewer->UpdateScene();
 }
@@ -229,7 +242,7 @@ void TGLViewerEditor::DoUpdateScene()
 //______________________________________________________________________________
 void TGLViewerEditor::DoCameraHome()
 {
-   // ResetCameraOnDoubleClick was toggled.
+   // CameraHome was clicked.
 
    fViewer->ResetCurrentCamera();
    ViewerRedraw();
@@ -392,9 +405,6 @@ void TGLViewerEditor::CreateStyleTab()
    fResetCamerasOnUpdate = new TGCheckButton(this, "Reset on update");
    fResetCamerasOnUpdate->SetToolTipText("Reset camera on scene update");
    AddFrame(fResetCamerasOnUpdate, new TGLayoutHints(kLHintsLeft, 4, 1, 1, 1));
-   fResetCameraOnDoubleClick = new TGCheckButton(this, "Reset on dbl-click");
-   fResetCameraOnDoubleClick->SetToolTipText("Reset cameras on double-click");
-   AddFrame(fResetCameraOnDoubleClick, new TGLayoutHints(kLHintsLeft, 4, 1, 1, 1));
 
    TGCompositeFrame* af = this;
    fUpdateScene = new TGTextButton(af, "Update Scene", 130);
@@ -518,6 +528,27 @@ void TGLViewerEditor::CreateClippingTab()
 }
 
 //______________________________________________________________________________
+void TGLViewerEditor::CreateStereoTab()
+{
+   // Create GUI controls - clip type (none/plane/box) and plane/box properties.
+
+   fStereoFrame = CreateEditorTabSubFrame("Stereo");
+
+   Int_t labw = 80;
+   TGCompositeFrame *p = fStereoFrame;
+
+   fStereoZeroParallax = MakeLabeledNEntry(p, "Zero parallax:", labw, 5, TGNumberFormat::kNESRealThree);
+   fStereoZeroParallax->SetLimits(TGNumberFormat::kNELLimitMinMax, 0, 1);
+
+   fStereoEyeOffsetFac = MakeLabeledNEntry(p, "Eye offset:", labw, 5, TGNumberFormat::kNESRealTwo);
+   fStereoEyeOffsetFac->SetLimits(TGNumberFormat::kNELLimitMinMax, 0, 2);
+
+   fStereoFrustumAsymFac = MakeLabeledNEntry(p, "Asymetry:", labw, 5, TGNumberFormat::kNESRealTwo);
+   fStereoFrustumAsymFac->SetLimits(TGNumberFormat::kNELLimitMinMax, 0, 2);
+}
+
+
+//______________________________________________________________________________
 void TGLViewerEditor::UpdateReferencePosState()
 {
    // Enable/disable reference position (x/y/z) number edits based on
@@ -582,3 +613,14 @@ void TGLViewerEditor::SetGuides()
          fr->UnmapWindow();
    }
 }
+
+//______________________________________________________________________________
+void TGLViewerEditor::UpdateStereo()
+{
+   // Update stereo related variables.
+
+   fViewer->SetStereoZeroParallax  (fStereoZeroParallax->GetNumber());
+   fViewer->SetStereoEyeOffsetFac  (fStereoEyeOffsetFac->GetNumber());
+   fViewer->SetStereoFrustumAsymFac(fStereoFrustumAsymFac->GetNumber());
+   ViewerRedraw(); 
+}
diff --git a/graf3d/gl/src/TGLWidget.cxx b/graf3d/gl/src/TGLWidget.cxx
index d263adc..3dc41f5 100644
--- a/graf3d/gl/src/TGLWidget.cxx
+++ b/graf3d/gl/src/TGLWidget.cxx
@@ -409,6 +409,9 @@ namespace {
          format.push_back(1);
       }
 
+      if (request.IsStereo())
+        format.push_back(GLX_STEREO);
+
       format.push_back(None);
    }
 }
diff --git a/gui/ged/inc/TGedEditor.h b/gui/ged/inc/TGedEditor.h
index 5964ffb..0b0d64a 100644
--- a/gui/ged/inc/TGedEditor.h
+++ b/gui/ged/inc/TGedEditor.h
@@ -72,10 +72,12 @@ protected:
 
    void              ConfigureGedFrames(Bool_t objChaged);
 
+   virtual TGedFrame* CreateNameFrame(const TGWindow* parent, const char* tab_name); 
+
    static TGedEditor *fgFrameCreator; 
 
 public:
-   TGedEditor(TCanvas* canvas = 0);
+   TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20);
    virtual ~TGedEditor();
 
    void          PrintFrameStat();
diff --git a/gui/ged/src/TGedEditor.cxx b/gui/ged/src/TGedEditor.cxx
index c410950..9486d73 100644
--- a/gui/ged/src/TGedEditor.cxx
+++ b/gui/ged/src/TGedEditor.cxx
@@ -96,8 +96,8 @@ void TGedEditor::SetFrameCreator(TGedEditor* e)
 }
 
 //______________________________________________________________________________
-TGedEditor::TGedEditor(TCanvas* canvas) :
-   TGMainFrame(gClient->GetRoot(), 175, 20),
+TGedEditor::TGedEditor(TCanvas* canvas, UInt_t width, UInt_t height) :
+   TGMainFrame(gClient->GetRoot(), width, height),
    fCan          (0),
    fTab          (0),
    fTabContainer (0),
@@ -129,7 +129,7 @@ TGedEditor::TGedEditor(TCanvas* canvas) :
       else
          Resize(GetWidth(), fCanvas->GetWh()<450 ? 450 : fCanvas->GetWh() + 4);
    } else {
-      Resize(GetDefaultSize());
+      Resize(width, height);
    }
 
    MapSubwindows();
@@ -214,7 +214,7 @@ TGedTabInfo* TGedEditor::GetEditorTabInfo(const char* name)
    fTab->RemoveFrame(te);
 
    // create a title frame for each tab
-   TGedNameFrame* nf = new TGedNameFrame(tc);
+   TGedFrame* nf = CreateNameFrame(tc, name);
    nf->SetGedEditor(this);
    nf->SetModelClass(0);
    tc->AddFrame(nf, nf->GetLayoutHints());
@@ -649,6 +649,14 @@ void TGedEditor::ConfigureGedFrames(Bool_t objChanged)
 }
 
 //______________________________________________________________________________
+TGedFrame* TGedEditor::CreateNameFrame(const TGWindow* parent, const char* /*tab_name*/)
+{
+   // Virtual function for creation of top name-frame in each tab.
+
+   return new TGedNameFrame(parent);
+}
+
+//______________________________________________________________________________
 void TGedEditor::PrintFrameStat()
 {
    // Print contents of fFrameMap.
diff --git a/gui/gui/inc/TGMenu.h b/gui/gui/inc/TGMenu.h
index 25641f0..85cdf88 100644
--- a/gui/gui/inc/TGMenu.h
+++ b/gui/gui/inc/TGMenu.h
@@ -352,6 +352,7 @@ public:
    virtual TGPopupMenu *GetPopup(const char *s);
    virtual TGPopupMenu *RemovePopup(const char *s);
 
+   virtual TGMenuTitle *GetCurrent() const { return fCurrent; }
    virtual TList  *GetTitles() const { return fTitles; }
    virtual Bool_t  HandleButton(Event_t *event);
    virtual Bool_t  HandleMotion(Event_t *event);
diff --git a/gui/gui/inc/TGShutter.h b/gui/gui/inc/TGShutter.h
index 5b147ab..29c92a3 100644
--- a/gui/gui/inc/TGShutter.h
+++ b/gui/gui/inc/TGShutter.h
@@ -82,6 +82,8 @@ protected:
    Int_t           fHeightIncrement;        // Height delta
    Int_t           fClosingHeight;          // Closing items current height
    Int_t           fClosingHadScrollbar;    // Closing item had a scroll bar
+   UInt_t          fDefWidth;               // Default width
+   UInt_t          fDefHeight;              // Default height
 
 private:
    TGShutter(const TGShutter&);             // not implemented
@@ -105,6 +107,9 @@ public:
    virtual void   SetSelectedItem(const char *name);
    virtual void   EnableItem(const char *name, Bool_t on = kTRUE);
 
+   virtual TGDimension GetDefaultSize() const;
+   virtual void        SetDefaultSize(UInt_t w, UInt_t h);
+
    virtual void   SavePrimitive(ostream &out, Option_t *option = "");
 
    virtual Bool_t ProcessMessage(Long_t cmd, Long_t parm1, Long_t parm2);
diff --git a/gui/gui/inc/TGTextEntry.h b/gui/gui/inc/TGTextEntry.h
index 03258ca..86d8d4d 100644
--- a/gui/gui/inc/TGTextEntry.h
+++ b/gui/gui/inc/TGTextEntry.h
@@ -73,6 +73,8 @@ protected:
    EInsertMode       fInsertMode;        // *OPTION={GetMethod="GetInsertMode";SetMethod="SetInsertMode";Items=(kInsert="Insert",kReplace="Replace")}*
    ETextJustification fAlignment;        // *OPTION={GetMethod="GetAlignment";SetMethod="SetAlignment";Items=(kTextLeft="Left",kTextCenterX="Center",kTextRight="Right")}*
    Bool_t            fHasOwnFont;        // kTRUE - font defined locally,  kFALSE - globally
+   UInt_t            fDefWidth;          // default width
+   UInt_t            fDefHeight;         // default height
 
             void        CopyText() const;
    virtual  void        DoRedraw();
@@ -112,6 +114,9 @@ public:
 
    virtual ~TGTextEntry();
 
+   virtual  TGDimension GetDefaultSize() const;
+   virtual  void        SetDefaultSize(UInt_t w, UInt_t h);
+
    virtual  void        AppendText(const char *text);
             void        Backspace();
             void        Clear(Option_t *option="");
diff --git a/gui/gui/inc/TRootContextMenu.h b/gui/gui/inc/TRootContextMenu.h
index 4f61b8b..cbe95f4 100644
--- a/gui/gui/inc/TRootContextMenu.h
+++ b/gui/gui/inc/TRootContextMenu.h
@@ -51,6 +51,7 @@ public:
    virtual void Dialog(TObject *object, TMethod *method);
    virtual void Dialog(TObject *object, TFunction *function);
    TRootDialog *GetDialog() const { return fDialog; };
+   virtual void   RecursiveRemove(TObject *obj);
 
    Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2);
 
diff --git a/gui/gui/src/TGFileDialog.cxx b/gui/gui/src/TGFileDialog.cxx
index 9321a4e..b015cae 100644
--- a/gui/gui/src/TGFileDialog.cxx
+++ b/gui/gui/src/TGFileDialog.cxx
@@ -600,17 +600,29 @@ Bool_t TGFileDialog::ProcessMessage(Long_t msg, Long_t parm1, Long_t)
                                "Missing File Name", txt2, kMBIconExclamation,
                                kMBOk);
                   return kTRUE;
-               } else if (!gSystem->AccessPathName(fTbfname->GetString(), kFileExists) &&
-                          !strcmp(fOk->GetTitle(), "Save") &&
-                          (!(fCheckB->GetState() == kButtonDown))) {
-                  Int_t ret;
-                  txt = TString::Format("File name %s already exists, OK to overwrite it?",
-                                        fTbfname->GetString());
-                  new TGMsgBox(fClient->GetRoot(), GetMainFrame(),
-                               "File Name Exist", txt.Data(), kMBIconExclamation,
-                               kMBYes | kMBNo, &ret);
-                  if (ret == kMBNo)
+               } else if (!gSystem->AccessPathName(fTbfname->GetString(), kFileExists)) {
+                  FileStat_t buf;
+                  gSystem->GetPathInfo(fTbfname->GetString(), buf);
+                  if (R_ISDIR(buf.fMode)) {
+                     fFc->ChangeDirectory(fTbfname->GetString());
+                     fTreeLB->Update(fFc->GetDirectory());
+                     if (strcmp(gSystem->WorkingDirectory(), fFc->GetDirectory())) {
+                        gSystem->cd(fFc->GetDirectory());
+                     }
+                     fName->SetText("", kFALSE);
                      return kTRUE;
+                  }
+                  else if (!strcmp(fOk->GetTitle(), "Save") && 
+                          (!(fCheckB->GetState() == kButtonDown))) {
+                     Int_t ret;
+                     txt = TString::Format("File name %s already exists, OK to overwrite it?",
+                                           fTbfname->GetString());
+                     new TGMsgBox(fClient->GetRoot(), GetMainFrame(),
+                                  "File Name Exist", txt.Data(), kMBIconExclamation,
+                                  kMBYes | kMBNo, &ret);
+                     if (ret == kMBNo)
+                        return kTRUE;
+                  }
                }
                fFileInfo->fFilename = gSystem->ConcatFileName(fFc->GetDirectory(),
                                                               fTbfname->GetString());
diff --git a/gui/gui/src/TGFont.cxx b/gui/gui/src/TGFont.cxx
index cb16edb..6c5d1c8 100644
--- a/gui/gui/src/TGFont.cxx
+++ b/gui/gui/src/TGFont.cxx
@@ -2610,7 +2610,8 @@ TGFont *TGFontPool::MakeFont(TGFont *font, FontStruct_t fontStruct,
    lastChar = 0xff; //fontStruct->max_char_or_byte2;
 
    for (i = 0; i < 256; i++) {
-      if ((i == 0177) || (i < firstChar) || (i > lastChar)) {
+      if ((i == 160) || (i == 173) || (i == 177) || 
+          (i < firstChar) || (i > lastChar)) {
          newFont->fTypes[i] = kCharReplace;
       } else {
          newFont->fTypes[i] = kCharNormal;
diff --git a/gui/gui/src/TGPack.cxx b/gui/gui/src/TGPack.cxx
index 3763b1f..016b913 100644
--- a/gui/gui/src/TGPack.cxx
+++ b/gui/gui/src/TGPack.cxx
@@ -208,6 +208,9 @@ void TGPack::FindFrames(TGFrame* splitter, TGFrameElementPack*& f0, TGFrameEleme
 
    while ((el = (TGFrameElementPack *) next()))
    {
+      if ( ! el->fState & kIsVisible)
+         continue;
+
       if (el->fFrame == splitter)
          break;
       f0 = el;
@@ -289,9 +292,9 @@ void TGPack::RemoveFrameInternal(TGFrame* f)
 
    TGFrameElementPack *el = (TGFrameElementPack*)FindFrameElement(f);
 
-   if (!el || el->fState == 0 ) return;
+   if (!el) return;
 
-   if (fUseSplitters )
+   if (fUseSplitters)
    {
       TGFrame* splitter = el->fSplitFE->fFrame;
       splitter->UnmapWindow();
@@ -300,10 +303,12 @@ void TGPack::RemoveFrameInternal(TGFrame* f)
       splitter->ReparentWindow(fClient->GetDefaultRoot());
       delete splitter;
    }
-   f->UnmapWindow();
-
-   fWeightSum -= el->fWeight;
-   fNVisible --;
+   if (el->fState & kIsVisible)
+   {
+      f->UnmapWindow();
+      fWeightSum -= el->fWeight;
+      --fNVisible;
+   }
    TGCompositeFrame::RemoveFrame(f);
 
    CheckSplitterVisibility();
@@ -594,7 +599,10 @@ void TGPack::SetVertical(Bool_t x)
    TList list;
    while ( ! fList->IsEmpty())
    {
-      TGFrame* f = ((TGFrameElement*) fList->First())->fFrame;
+      TGFrameElement *el = (TGFrameElement*) fList->At(1);
+      TGFrame        *f  = el->fFrame;
+      if ( ! el->fState & kIsVisible)
+         f->SetBit(kTempFrame);
       RemoveFrameInternal(f);
       list.Add(f);
    }
@@ -603,6 +611,10 @@ void TGPack::SetVertical(Bool_t x)
    {
       TGFrame* f = (TGFrame*) list.First();
       AddFrameInternal(f);
+      if (f->TestBit(kTempFrame)) {
+         f->ResetBit(kTempFrame);
+         HideFrame(f);
+      }
       list.RemoveFirst();
    }
    Layout();
diff --git a/gui/gui/src/TGShutter.cxx b/gui/gui/src/TGShutter.cxx
index bf23f0e..a5ea734 100644
--- a/gui/gui/src/TGShutter.cxx
+++ b/gui/gui/src/TGShutter.cxx
@@ -44,6 +44,8 @@ TGShutter::TGShutter(const TGWindow *p, UInt_t options) :
    fTimer               = 0;
    fTrash               = new TList;
 
+   fDefWidth = fDefHeight = 0;
+
    // layout manager is not used
    delete fLayoutManager;
    fLayoutManager = 0;
@@ -312,6 +314,25 @@ TGShutterItem *TGShutter::GetItem(const char *name)
    return item;
 }
 
+//______________________________________________________________________________
+TGDimension TGShutter::GetDefaultSize() const
+{
+   // Return the default / minimal size of the widget.
+
+   UInt_t w = (GetOptions() & kFixedWidth)  || (fDefWidth  == 0) ? fWidth  : fDefWidth;
+   UInt_t h = (GetOptions() & kFixedHeight) || (fDefHeight == 0) ? fHeight : fDefHeight;
+   return TGDimension(w, h);
+}
+
+//______________________________________________________________________________
+void TGShutter::SetDefaultSize(UInt_t w, UInt_t h)
+{
+   // Set the default / minimal size of the widget.
+
+   fDefWidth  = w;
+   fDefHeight = h;
+}
+
 
 //______________________________________________________________________________
 TGShutterItem::TGShutterItem(const TGWindow *p, TGHotString *s, Int_t id,
@@ -419,6 +440,11 @@ void TGShutter::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
    out << GetName() << " = new TGShutter(" << fParent->GetName() << ","
        << GetOptionString() << ");" << endl;
 
+   if ((fDefWidth > 0) || (fDefHeight > 0)) {
+      out << "   " << GetName() << "->SetDefaultSize(";
+      out << fDefWidth << "," << fDefHeight << ");" << endl;
+   }
+
    if (!fList) return;
 
    TGFrameElement *el;
diff --git a/gui/gui/src/TGTextEntry.cxx b/gui/gui/src/TGTextEntry.cxx
index 98b622f..4dbcbcc 100644
--- a/gui/gui/src/TGTextEntry.cxx
+++ b/gui/gui/src/TGTextEntry.cxx
@@ -335,6 +335,7 @@ void TGTextEntry::Init()
    fEchoMode = kNormal;
    fAlignment= kTextLeft;
    fInsertMode = kInsert;
+   fDefWidth = fDefHeight = 0;
 
    int tw, max_ascent, max_descent;
    tw = gVirtualX->TextWidth(fFontStruct, GetText(), fText->GetTextLength());
@@ -375,6 +376,25 @@ void TGTextEntry::Init()
 }
 
 //______________________________________________________________________________
+TGDimension TGTextEntry::GetDefaultSize() const
+{
+   // Return the default / minimal size of the widget.
+
+   UInt_t w = (GetOptions() & kFixedWidth)  || (fDefWidth  == 0) ? fWidth  : fDefWidth;
+   UInt_t h = (GetOptions() & kFixedHeight) || (fDefHeight == 0) ? fHeight : fDefHeight;
+   return TGDimension(w, h);
+}
+
+//______________________________________________________________________________
+void TGTextEntry::SetDefaultSize(UInt_t w, UInt_t h)
+{
+   // Set the default / minimal size of the widget.
+
+   fDefWidth  = w;
+   fDefHeight = h;
+}
+
+//______________________________________________________________________________
 void TGTextEntry::ReturnPressed()
 {
    // This signal is emitted when the return or enter key is pressed.
@@ -1851,6 +1871,11 @@ void TGTextEntry::SavePrimitive(ostream &out, Option_t *option /*= ""*/)
    out << "   " << GetName() << "->Resize("<< GetWidth() << "," << GetName()
        << "->GetDefaultHeight());" << endl;
 
+   if ((fDefWidth > 0) || (fDefHeight > 0)) {
+      out << "   " << GetName() << "->SetDefaultSize(";
+      out << fDefWidth << "," << fDefHeight << ");" << endl;
+   }
+
    if (fTip) {
       TString tiptext = fTip->GetText()->GetString();
       tiptext.ReplaceAll("\n", "\\n");
diff --git a/gui/gui/src/TRootContextMenu.cxx b/gui/gui/src/TRootContextMenu.cxx
index 54d48ee..59e5de5 100644
--- a/gui/gui/src/TRootContextMenu.cxx
+++ b/gui/gui/src/TRootContextMenu.cxx
@@ -65,6 +65,7 @@ TRootContextMenu::TRootContextMenu(TContextMenu *c, const char *)
    fDialog  = 0;
    fTrash = new TList;
 
+   gROOT->GetListOfCleanups()->Add(this);
    // Context menu handles its own messages
    Associate(this);
 }
@@ -74,6 +75,7 @@ TRootContextMenu::~TRootContextMenu()
 {
    // Delete a context menu.
 
+   gROOT->GetListOfCleanups()->Remove(this);
    delete fDialog;
    if (fTrash) fTrash->Delete();
    delete fTrash;
@@ -387,7 +389,7 @@ void TRootContextMenu::Dialog(TObject *object, TFunction *function)
 
    Int_t selfobjpos;
 
-   if (!function) return;
+   if (!function || !object) return;
 
    // Position, if it exists, of the argument that correspond to the object itself
    if (fContextMenu->GetSelectedMenuItem())
@@ -598,3 +600,25 @@ Bool_t TRootContextMenu::ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2)
 
    return kTRUE;
 }
+
+//______________________________________________________________________________
+void TRootContextMenu::RecursiveRemove(TObject *obj)
+{
+   // Close the context menu if the object is deleted in the
+   // RecursiveRemove() operation.
+
+   void *ud;
+   if (obj == fContextMenu->GetSelectedCanvas())
+      fContextMenu->SetCanvas(0);
+   if (obj == fContextMenu->GetSelectedPad())
+      fContextMenu->SetPad(0);
+   if (obj == fContextMenu->GetSelectedObject()) {
+      // if the object being deleted is the one selected,
+      // ungrab the mouse pointer and terminate (close) the menu
+      fContextMenu->SetObject(0);
+      if (fHasGrab) 
+         gVirtualX->GrabPointer(0, 0, 0, 0, kFALSE);
+      EndMenu(ud);
+   }
+}
+
diff --git a/icons/eve_line.xpm b/icons/eve_line.xpm
new file mode 100644
index 0000000..c14aa2e
--- /dev/null
+++ b/icons/eve_line.xpm
@@ -0,0 +1,33 @@
+/* XPM */
+static char * eve_line_xpm[] = {
+"16 16 14 1",
+" 	c None",
+".	c #FFFFFF",
+"+	c #655D85",
+"@	c #7D7698",
+"#	c #D9D7E1",
+"$	c #A8A3BA",
+"%	c #70688E",
+"&	c #EBEAEF",
+"*	c #908AA7",
+"=	c #BEBBCC",
+"-	c #908AA8",
+";	c #817A9B",
+">	c #CECBD8",
+",	c #6B638A",
+".............+..",
+"............@#..",
+"...........$$...",
+"..........$$....",
+".........#@.....",
+".........%&.....",
+"........*=......",
+".......$$.......",
+"......=-........",
+".....&%.........",
+".....;>.........",
+"....*=..........",
+"...=-...........",
+"..>;............",
+".&@&............",
+".,$............."};
