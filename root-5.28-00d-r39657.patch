
Property changes on: proof/proofplayer/src/TEventIter.cxx
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/proof/proofplayer/src/TEventIter.cxx:r38055

Index: proof/proofplayer/src/TPerfStats.cxx
===================================================================
--- proof/proofplayer/src/TPerfStats.cxx	(revision 39642)
+++ proof/proofplayer/src/TPerfStats.cxx	(revision 39657)
@@ -520,6 +520,18 @@
 }
 
 //______________________________________________________________________________
+void TPerfStats::FileUnzipEvent(TFile * /* file */, Long64_t /* pos */, Double_t /* start */, Int_t /* complen */, Int_t /* objlen */)
+{
+   // Record TTree file unzip event.
+   // start is the TimeStamp before unzip
+   // pos is where in the file the compressed buffer came from
+   // complen is the length of the compressed buffer
+   // objlen is the length of the de-compressed buffer
+
+   // Do nothing for now.
+}
+
+//______________________________________________________________________________
 void TPerfStats::RateEvent(Double_t proctime, Double_t deltatime,
                            Long64_t eventsprocessed, Long64_t bytesRead)
 {
Index: proof/proofplayer/inc/TPerfStats.h
===================================================================
--- proof/proofplayer/inc/TPerfStats.h	(revision 39642)
+++ proof/proofplayer/inc/TPerfStats.h	(revision 39657)
@@ -128,6 +128,7 @@
 
    void FileOpenEvent(TFile *file, const char *filename, Double_t start);
    void FileReadEvent(TFile *file, Int_t len, Double_t start);
+   void FileUnzipEvent(TFile *file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen);
    void RateEvent(Double_t proctime, Double_t deltatime,
                   Long64_t eventsprocessed, Long64_t bytesRead);
    void SetBytesRead(Long64_t num);

Property changes on: proof/proofplayer
___________________________________________________________________
Added: svn:mergeinfo
   Merged /trunk/proof/proofplayer:r37618,37641,37836,37906,37985,38055,39134,39136


Property changes on: core/utils/src
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/core/utils/src:r38055,39551


Property changes on: core/utils
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/core/utils:r38055,39551


Property changes on: core/cont/src
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/core/cont/src:r38055,39551


Property changes on: core/metautils
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/core/metautils:r38055,39551

Index: core/base/src/TBuffer.cxx
===================================================================
--- core/base/src/TBuffer.cxx	(revision 39642)
+++ core/base/src/TBuffer.cxx	(revision 39657)
@@ -180,17 +180,19 @@
 }
 
 //______________________________________________________________________________
-void TBuffer::Expand(Int_t newsize)
+void TBuffer::Expand(Int_t newsize, Bool_t copy)
 {
    // Expand the I/O buffer to newsize bytes.
+   // If copy is true (the default), the existing content of the
+   // buffer is preserved, otherwise the buffer is returned zero-ed out.
 
    Int_t l  = Length();
    if ( (fMode&kWrite)!=0 ) {
       fBuffer  = fReAllocFunc(fBuffer, newsize+kExtraSpace,
-                              fBufSize+kExtraSpace);
+                              copy ? fBufSize+kExtraSpace : 0);
    } else {
       fBuffer  = fReAllocFunc(fBuffer, newsize,
-                              fBufSize);
+                              copy ? fBufSize : 0);
    }
    if (fBuffer == 0) {
       if (fReAllocFunc == TStorage::ReAllocChar) {
Index: core/base/inc/TBuffer.h
===================================================================
--- core/base/inc/TBuffer.h	(revision 39642)
+++ core/base/inc/TBuffer.h	(revision 39657)
@@ -92,7 +92,7 @@
    Int_t    BufferSize() const { return fBufSize; }
    void     DetachBuffer() { fBuffer = 0; }
    Int_t    Length()     const { return (Int_t)(fBufCur - fBuffer); }
-   void     Expand(Int_t newsize);  // expand buffer to newsize
+   void     Expand(Int_t newsize, Bool_t copy = kTRUE);  // expand buffer to newsize
 
    virtual Bool_t     CheckObject(const TObject *obj) = 0;
    virtual Bool_t     CheckObject(const void *obj, const TClass *ptrClass) = 0;
Index: core/base/inc/TVirtualPerfStats.h
===================================================================
--- core/base/inc/TVirtualPerfStats.h	(revision 39642)
+++ core/base/inc/TVirtualPerfStats.h	(revision 39657)
@@ -61,6 +61,8 @@
 
    virtual void FileReadEvent(TFile *file, Int_t len, Double_t start) = 0;
 
+   virtual void FileUnzipEvent(TFile *file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) = 0;
+
    virtual void RateEvent(Double_t proctime, Double_t deltatime,
                           Long64_t eventsprocessed, Long64_t bytesRead) = 0;
 

Property changes on: core/editline
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/core/editline:r38055,39551


Property changes on: core
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/core:r38055,39551

Index: tree/tree/src/TLeafS.cxx
===================================================================
--- tree/tree/src/TLeafS.cxx	(revision 39642)
+++ tree/tree/src/TLeafS.cxx	(revision 39657)
@@ -153,7 +153,7 @@
 //*-*                  ===========================================
 
    if (!fLeafCount && fNdata == 1) {
-      b >> fValue[0];
+      b.ReadShort(fValue[0]);
    }else {
       if (fLeafCount) {
          Long64_t entry = fBranch->GetReadEntry();
Index: tree/tree/src/TTree.cxx
===================================================================
--- tree/tree/src/TTree.cxx	(revision 39642)
+++ tree/tree/src/TTree.cxx	(revision 39657)
@@ -515,6 +515,7 @@
 , fClones(0)
 , fBranchRef(0)
 , fFriendLockStatus(0)
+, fTransientBuffer(0)
 {
    // Default constructor and I/O constructor.
    //
@@ -577,6 +578,7 @@
 , fClones(0)
 , fBranchRef(0)
 , fFriendLockStatus(0)
+, fTransientBuffer(0)
 {
    // Normal tree constructor.
    //
@@ -715,9 +717,28 @@
    // Must be done after the destruction of friends.
    // Note: We do *not* own our directory.
    fDirectory = 0;
+
+   if (fTransientBuffer) {
+      delete fTransientBuffer;
+      fTransientBuffer = 0;
+   }
 }
 
 //______________________________________________________________________________
+TBuffer* TTree::GetTransientBuffer(Int_t size)
+{
+    // Returns the transient buffer currently used by this TTree for reading/writing baskets
+    if (fTransientBuffer) {
+       if (fTransientBuffer->BufferSize() < size) {
+          fTransientBuffer->Expand(size);
+       }
+       return fTransientBuffer;
+    }
+    fTransientBuffer = new TBufferFile(TBuffer::kRead, size);
+    return fTransientBuffer;
+}
+
+//______________________________________________________________________________
 void TTree::AddBranchToCache(const char*bname, Bool_t subbranches)
 {
    // Add branch with name bname to the Tree cache.

Property changes on: tree/tree/src/TBranchElement.cxx
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/tree/tree/src/TBranchElement.cxx:r38055,38403-38404,38462,38801,38803,39551,39642,39644

Index: tree/tree/src/TBranch.cxx
===================================================================
--- tree/tree/src/TBranch.cxx	(revision 39642)
+++ tree/tree/src/TBranch.cxx	(revision 39657)
@@ -46,6 +46,18 @@
 Int_t TBranch::fgCount = 0;
 
 
+#if (__GNUC__ >= 3) || defined(__INTEL_COMPILER)
+#if !defined(R__unlikely)
+  #define R__unlikely(expr) __builtin_expect(!!(expr), 0)
+#endif
+#if !defined(R__likely)
+  #define R__likely(expr) __builtin_expect(!!(expr), 1)
+#endif
+#else
+  #define R__unlikely(expr) expr
+  #define R__likely(expr) expr
+#endif
+
 //////////////////////////////////////////////////////////////////////////
 //                                                                      //
 // A TTree is a list of TBranches                                       //
@@ -79,6 +91,9 @@
 , fNleaves(0)
 , fReadBasket(0)
 , fReadEntry(-1)
+, fFirstBasketEntry(-1)
+, fNextBasketEntry(-1)
+, fCurrentBasket(0)
 , fEntries(0)
 , fFirstEntry(0)
 , fTotBytes(0)
@@ -102,6 +117,7 @@
 {
    // Default constructor.  Used for I/O by default.
 
+   SetBit(TBranch::kDoNotUseBufferMap);
 }
 
 //______________________________________________________________________________
@@ -120,6 +136,9 @@
 , fNleaves(0)
 , fReadBasket(0)
 , fReadEntry(-1)
+, fFirstBasketEntry(-1)
+, fNextBasketEntry(-1)
+, fCurrentBasket(0)
 , fEntries(0)
 , fFirstEntry(0)
 , fTotBytes(0)
@@ -213,6 +232,9 @@
 , fNleaves(0)
 , fReadBasket(0)
 , fReadEntry(-1)
+, fFirstBasketEntry(-1)
+, fNextBasketEntry(-1)
+, fCurrentBasket(0)
 , fEntries(0)
 , fFirstEntry(0)
 , fTotBytes(0)
@@ -283,6 +305,7 @@
 {
    // Initialization routine called from the constructor.  This should NOT be made virtual.
 
+   SetBit(TBranch::kDoNotUseBufferMap);
    if ((compress == -1) && fTree->GetDirectory()) {
       TFile* bfile = fTree->GetDirectory()->GetFile();
       if (bfile) {
@@ -433,6 +456,9 @@
 
    fBaskets.Delete();
    fNBaskets = 0;
+   fCurrentBasket = 0;
+   fFirstBasketEntry = -1;
+   fNextBasketEntry = -1;
 
    // Remove our leaves from our tree's list of leaves.
    if (fTree) {
@@ -648,6 +674,11 @@
          basket->DropBuffers();
          --fNBaskets;
          fBaskets.RemoveAt(i);
+         if (basket == fCurrentBasket) {
+            fCurrentBasket    = 0;
+            fFirstBasketEntry = -1;
+            fNextBasketEntry  = -1;
+         }
          delete basket;
       }
 
@@ -668,6 +699,11 @@
          basket = (TBasket*)fBaskets.UncheckedAt(i);
          if (basket && fBasketBytes[i]!=0) {
             basket->DropBuffers();
+            if (basket == fCurrentBasket) {
+               fCurrentBasket    = 0;
+               fFirstBasketEntry = -1;
+               fNextBasketEntry  = -1;
+            }            
             delete basket;
             fBaskets.AddAt(0,i);
             fBaskets.SetLast(-1);
@@ -832,6 +868,10 @@
       ++fEntries;
       ++fEntryNumber;
       FillLeaves(*buf);
+      if (buf->GetMapCount()) {
+         // The map is used.
+         ResetBit(TBranch::kDoNotUseBufferMap);
+      }
       lnew = buf->Length();
       nbytes = lnew - lold;
    }
@@ -1051,6 +1091,11 @@
                // Nothing to do.
             } else {
                basket->DropBuffers();
+               if (basket == fCurrentBasket) {
+                  fCurrentBasket    = 0;
+                  fFirstBasketEntry = -1;
+                  fNextBasketEntry  = -1;
+               }               
                delete basket;
                --fNBaskets;
                fBaskets[ibasket] = 0;
@@ -1181,70 +1226,86 @@
    // See IMPORTANT REMARKS in TTree::GetEntry.
    //
 
-   if (TestBit(kDoNotProcess) && !getall) {
-      return 0;
-   }
-   if ((entry < fFirstEntry) || (entry >= fEntryNumber)) {
-      return 0;
-   }
-   Int_t nbytes = 0;
-   Long64_t first = fBasketEntry[fReadBasket];
-   Long64_t last = 0;
-   if (fReadBasket == fWriteBasket) {
-      last = fEntryNumber - 1;
+   Bool_t enabled = !TestBit(kDoNotProcess) || getall;
+   TBasket *basket; // will be initialized in the if/then clauses.
+   Long64_t first;
+   if (0 && R__likely(enabled && fFirstBasketEntry <= entry && entry < fNextBasketEntry)) {
+      // We have found the basket containing this entry.
+      // make sure basket buffers are in memory.
+      basket = fCurrentBasket;
+      first = fFirstBasketEntry;
    } else {
-      last = fBasketEntry[fReadBasket+1] - 1;
-   }
-   // Are we still in the same ReadBasket?
-   if ((entry < first) || (entry > last)) {
-      fReadBasket = TMath::BinarySearch(fWriteBasket + 1, fBasketEntry, entry);
-      if (fReadBasket < 0) {
-         Error("In the branch %s, no basket contains the entry %d\n", GetName(), entry);
-         return -1;
+      if (!enabled) {
+         return 0;
       }
-      first = fBasketEntry[fReadBasket];
-   }
-   // We have found the basket containing this entry.
-   // make sure basket buffers are in memory.
-   TBasket* basket = (TBasket*) fBaskets.UncheckedAt(fReadBasket);
-   if (!basket) {
-      basket = GetBasket(fReadBasket);
+      if ((entry < fFirstEntry) || (entry >= fEntryNumber)) {
+         return 0;
+      }
+      first = fFirstBasketEntry;
+      Long64_t last = fNextBasketEntry - 1;
+      // Are we still in the same ReadBasket?
+      if ((entry < first) || (entry > last)) {
+         fReadBasket = TMath::BinarySearch(fWriteBasket + 1, fBasketEntry, entry);
+         if (fReadBasket < 0) {
+            fNextBasketEntry = -1;
+            Error("In the branch %s, no basket contains the entry %d\n", GetName(), entry);
+            return -1;
+         }
+         if (fReadBasket == fWriteBasket) {
+            fNextBasketEntry = fEntryNumber;
+         } else {
+            fNextBasketEntry = fBasketEntry[fReadBasket+1];
+         }
+         first = fFirstBasketEntry = fBasketEntry[fReadBasket];
+      }
+      // We have found the basket containing this entry.
+      // make sure basket buffers are in memory.
+      basket = (TBasket*) fBaskets.UncheckedAt(fReadBasket);
       if (!basket) {
-         return -1;
+         basket = GetBasket(fReadBasket);
+         if (!basket) {
+            fCurrentBasket = 0;
+            fFirstBasketEntry = -1; 
+            fNextBasketEntry = -1;
+            return -1;
+         }
       }
+      fCurrentBasket = basket;
    }
    basket->PrepareBasket(entry);
    TBuffer* buf = basket->GetBufferRef();
+   
    // This test necessary to read very old Root files (NvE).
-   if (!buf) {
+   if (R__unlikely(!buf)) {
       TFile* file = GetFile(0);
       basket->ReadBasketBuffers(fBasketSeek[fReadBasket], fBasketBytes[fReadBasket], file);
       buf = basket->GetBufferRef();
    }
-   // Set entry offset in buffer and read data from all leaves.
-   buf->ResetMap();
-   if (!buf->IsReading()) {
+   // Set entry offset in buffer.
+   if (!TestBit(kDoNotUseBufferMap)) {
+      buf->ResetMap();
+   }
+   if (R__unlikely(!buf->IsReading())) {
       basket->SetReadMode();
    }
    Int_t* entryOffset = basket->GetEntryOffset();
    Int_t bufbegin = 0;
    if (entryOffset) {
       bufbegin = entryOffset[entry-first];
+      Int_t* displacement = basket->GetDisplacement();
+      if (R__unlikely(displacement)) {
+         buf->SetBufferDisplacement(displacement[entry-first]);
+      }
    } else {
-      bufbegin = basket->GetKeylen() + ((entry - first) * basket->GetNevBufSize());
+      bufbegin = basket->GetKeylen() + ((entry-first) * basket->GetNevBufSize());
    }
    buf->SetBufferOffset(bufbegin);
-   Int_t* displacement = basket->GetDisplacement();
-   if (displacement) {
-      buf->SetBufferDisplacement(displacement[entry-first]);
-   } else {
-      buf->SetBufferDisplacement();
-   }
+   
+   // Int_t bufbegin = buf->Length();
    // Remember which entry we are reading.
    fReadEntry = entry;
    (this->*fReadLeaves)(*buf);
-   nbytes = buf->Length() - bufbegin;
-   return nbytes;
+   return buf->Length() - bufbegin;
 }
 
 //______________________________________________________________________________
@@ -1261,23 +1322,31 @@
       return 0;
    }
    Int_t nbytes = 0;
-   Long64_t first  = fBasketEntry[fReadBasket];
-   Long64_t last = 0;
-   if (fReadBasket == fWriteBasket) {
-      last = fEntryNumber - 1;
-   } else {
-      last = fBasketEntry[fReadBasket+1] - 1;
-   }
+   Long64_t first  = fFirstBasketEntry;
+   Long64_t last = fNextBasketEntry - 1;
    // Are we still in the same ReadBasket?
    if ((entry < first) || (entry > last)) {
       fReadBasket = TMath::BinarySearch(fWriteBasket + 1, fBasketEntry, entry);
-      first = fBasketEntry[fReadBasket];
+      if (fReadBasket < 0) {
+         fNextBasketEntry = -1;
+         Error("In the branch %s, no basket contains the entry %d\n", GetName(), entry);
+         return -1;
+      }
+      if (fReadBasket == fWriteBasket) {
+         fNextBasketEntry = fEntryNumber;
+      } else {
+         fNextBasketEntry = fBasketEntry[fReadBasket+1];
+      }
+      fFirstBasketEntry = first = fBasketEntry[fReadBasket];
    }
 
    // We have found the basket containing this entry.
    // Make sure basket buffers are in memory.
    TBasket* basket = GetBasket(fReadBasket);
+   fCurrentBasket = basket;
    if (!basket) {
+      fFirstBasketEntry = -1; 
+      fNextBasketEntry = -1;
       return 0;
    }
    TBuffer* buf = basket->GetBufferRef();
@@ -1377,6 +1446,11 @@
             basket = (TBasket*)fBaskets.UncheckedAt(oldindex);
          }
          if (basket && fBasketBytes[oldindex]!=0) {
+            if (basket == fCurrentBasket) {
+               fCurrentBasket    = 0;
+               fFirstBasketEntry = -1;
+               fNextBasketEntry  = -1;
+            }            
             fBaskets.AddAt(0,oldindex);
             fBaskets.SetLast(-1);
             fNBaskets = 0;
@@ -1766,7 +1840,7 @@
 void TBranch::ReadLeavesImpl(TBuffer& b)
 {
    // Loop on all leaves of this branch to read Basket buffer.
-
+   
    for (Int_t i = 0; i < fNleaves; ++i) {
       TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);
       leaf->ReadBasket(b);
@@ -1774,6 +1848,30 @@
 }
 
 //______________________________________________________________________________
+void TBranch::ReadLeaves0Impl(TBuffer&)
+{
+   // Loop on all leaves of this branch to read Basket buffer.
+   
+}
+
+//______________________________________________________________________________
+void TBranch::ReadLeaves1Impl(TBuffer& b)
+{
+   // Loop on all leaves of this branch to read Basket buffer.
+   
+   ((TLeaf*) fLeaves.UncheckedAt(0))->ReadBasket(b);
+}
+
+//______________________________________________________________________________
+void TBranch::ReadLeaves2Impl(TBuffer& b)
+{
+   // Loop on all leaves of this branch to read Basket buffer.
+   
+   ((TLeaf*) fLeaves.UncheckedAt(0))->ReadBasket(b);
+   ((TLeaf*) fLeaves.UncheckedAt(1))->ReadBasket(b);
+}
+
+//______________________________________________________________________________
 void TBranch::Refresh(TBranch* b)
 {
    //  refresh this branch using new information in b
@@ -1787,6 +1885,10 @@
    fTotBytes       = b->fTotBytes;
    fZipBytes       = b->fZipBytes;
    fReadBasket     = 0;
+   fReadEntry      = -1;
+   fFirstBasketEntry = -1;
+   fNextBasketEntry  = -1;
+   fCurrentBasket    =  0;
    delete [] fBasketBytes;
    delete [] fBasketEntry;
    delete [] fBasketSeek;
@@ -1825,6 +1927,9 @@
 
    fReadBasket = 0;
    fReadEntry = -1;
+   fFirstBasketEntry = -1;
+   fNextBasketEntry = -1;
+   fCurrentBasket   = 0;
    fWriteBasket = 0;
    fEntries = 0;
    fTotBytes = 0;
@@ -1862,6 +1967,8 @@
 
    //  Reset last read entry number, we have will had new user object now.
    fReadEntry = -1;
+   fFirstBasketEntry = -1;
+   fNextBasketEntry  = -1;
 
    for (Int_t i = 0; i < fNleaves; ++i) {
       TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);
@@ -1891,6 +1998,8 @@
       return;
    }
    fReadEntry = -1;
+   fFirstBasketEntry = -1;
+   fNextBasketEntry  = -1;
    fAddress = (char*) addr;
    for (Int_t i = 0; i < fNleaves; ++i) {
       TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);
@@ -1954,6 +2063,8 @@
       Error("TBranch::SetAddress","Filling from a TBuffer can only be done with a not split object branch.  Request ignored.");
    } else {
       fReadEntry = -1;
+      fNextBasketEntry  = -1;
+      fFirstBasketEntry = -1;
       // Note: We do not take ownership of the buffer.
       fEntryBuffer = buf;
    }
@@ -2117,6 +2228,13 @@
       fTree = gTree;
       fAddress = 0;
       gROOT->SetReadingObject(kTRUE);
+      
+      // Reset transients.
+      SetBit(TBranch::kDoNotUseBufferMap);
+      fCurrentBasket    = 0;
+      fFirstBasketEntry = -1;
+      fNextBasketEntry  = -1;
+
       Version_t v = b.ReadVersion(&R__s, &R__c);
       if (v > 9) {
          b.ReadClassBuffer(TBranch::Class(), this, v, R__s, R__c);
@@ -2150,6 +2268,17 @@
          }
          if (!fSplitLevel && fBranches.GetEntriesFast()) fSplitLevel = 1;
          gROOT->SetReadingObject(kFALSE);
+         if (IsA() == TBranch::Class()) {
+            if (fNleaves == 0) {
+               fReadLeaves = &TBranch::ReadLeaves0Impl;
+            } else if (fNleaves == 1) {
+               fReadLeaves = &TBranch::ReadLeaves1Impl;
+            } else if (fNleaves == 2) {
+               fReadLeaves = &TBranch::ReadLeaves2Impl;
+            } else {
+               fReadLeaves = &TBranch::ReadLeavesImpl;
+            }
+         }
          return;
       }
       //====process old versions before automatic schema evolution
@@ -2215,6 +2344,17 @@
          if (!fSplitLevel && fBranches.GetEntriesFast()) fSplitLevel = 1;
          gROOT->SetReadingObject(kFALSE);
          b.CheckByteCount(R__s, R__c, TBranch::IsA());
+         if (IsA() == TBranch::Class()) {
+            if (fNleaves == 0) {
+               fReadLeaves = &TBranch::ReadLeaves0Impl;
+            } else if (fNleaves == 1) {
+               fReadLeaves = &TBranch::ReadLeaves1Impl;
+            } else if (fNleaves == 2) {
+               fReadLeaves = &TBranch::ReadLeaves2Impl;
+            } else {
+               fReadLeaves = &TBranch::ReadLeavesImpl;
+            }
+         }
          return;
       }
       //====process very old versions
@@ -2279,7 +2419,17 @@
       gROOT->SetReadingObject(kFALSE);
       b.CheckByteCount(R__s, R__c, TBranch::IsA());
       //====end of old versions
-
+      if (IsA() == TBranch::Class()) {
+         if (fNleaves == 0) {
+            fReadLeaves = &TBranch::ReadLeaves0Impl;
+         } else if (fNleaves == 1) {
+            fReadLeaves = &TBranch::ReadLeaves1Impl;
+         } else if (fNleaves == 2) {
+            fReadLeaves = &TBranch::ReadLeaves2Impl;
+         } else {
+            fReadLeaves = &TBranch::ReadLeavesImpl;
+         }
+      }
    } else {
       Int_t maxBaskets = fMaxBaskets;
       fMaxBaskets = fWriteBasket+1;
@@ -2335,6 +2485,11 @@
       --fNBaskets;
       fBaskets[where] = 0;
       basket->DropBuffers();
+      if (basket == fCurrentBasket) {
+         fCurrentBasket    = 0;
+         fFirstBasketEntry = -1;
+         fNextBasketEntry  = -1;
+      }      
       delete basket;
    }
 
Index: tree/tree/src/TLeafB.cxx
===================================================================
--- tree/tree/src/TLeafB.cxx	(revision 39642)
+++ tree/tree/src/TLeafB.cxx	(revision 39657)
@@ -131,7 +131,7 @@
    // -- Read leaf elements from Basket input buffer.
 
    if (!fLeafCount && (fNdata == 1)) {
-      b >> fValue[0];
+      b.ReadChar(fValue[0]);
    } else {
       if (fLeafCount) {
          Long64_t entry = fBranch->GetReadEntry();
Index: tree/tree/src/TBasket.cxx
===================================================================
--- tree/tree/src/TBasket.cxx	(revision 39642)
+++ tree/tree/src/TBasket.cxx	(revision 39657)
@@ -17,7 +17,23 @@
 #include "TMath.h"
 #include "TTreeCache.h"
 #include "TTreeCacheUnzip.h"
+#include "TVirtualPerfStats.h"
+#include "TTimeStamp.h"
 
+// TODO: Copied from TBranch.cxx
+#if (__GNUC__ >= 3) || defined(__INTEL_COMPILER)
+#if !defined(R__unlikely)
+  #define R__unlikely(expr) __builtin_expect(!!(expr), 0)
+#endif
+#if !defined(R__likely)
+  #define R__likely(expr) __builtin_expect(!!(expr), 1)
+#endif
+#else
+  #define R__unlikely(expr) expr
+  #define R__likely(expr) expr
+#endif
+
+
 extern "C" void R__zip (Int_t cxlevel, Int_t *nin, char *bufin, Int_t *lout, char *bufout, Int_t *nout);
 extern "C" void R__unzip(Int_t *nin, UChar_t *bufin, Int_t *lout, char *bufout, Int_t *nout);
 extern "C" int R__unzip_header(Int_t *nin, UChar_t *bufin, Int_t *lout);
@@ -35,7 +51,7 @@
 //
 
 //_______________________________________________________________________
-TBasket::TBasket() : fCompressedSize(0),fCompressedBuffer(0)
+TBasket::TBasket() : fCompressedBufferRef(0), fLastWriteBufferSize(0)
 {
    // Default contructor.
 
@@ -52,10 +68,9 @@
 }
 
 //_______________________________________________________________________
-TBasket::TBasket(TDirectory *motherDir) : TKey(motherDir),fCompressedSize(0),fCompressedBuffer(0)
+TBasket::TBasket(TDirectory *motherDir) : TKey(motherDir),fCompressedBufferRef(0), fLastWriteBufferSize(0)
 {
    // Constructor used during reading.
-
    fDisplacement  = 0;
    fEntryOffset   = 0;
    fBufferRef     = 0;
@@ -70,7 +85,7 @@
 
 //_______________________________________________________________________
 TBasket::TBasket(const char *name, const char *title, TBranch *branch) : 
-   TKey(branch->GetDirectory()),fCompressedSize(0),fCompressedBuffer(0)
+   TKey(branch->GetDirectory()), fLastWriteBufferSize(0)
 {
    // Basket normal constructor, used during writing.
 
@@ -91,7 +106,14 @@
    }
    fHeaderOnly  = kTRUE;
    fLast        = 0; // Must initialize before calling Streamer()
-   
+   if (branch && branch->GetTree()) {
+      fCompressedBufferRef = branch->GetTree()->GetTransientBuffer(fBufferSize);
+      fOwnsCompressedBuffer = kFALSE;
+      if (!fCompressedBufferRef) {
+         fCompressedBufferRef = new TBufferFile(TBuffer::kRead, fBufferSize);
+         fOwnsCompressedBuffer = kTRUE;
+      }
+   }
    Streamer(*fBufferRef);
    fKeylen      = fBufferRef->Length();
    fObjlen      = fBufferSize - fKeylen;
@@ -113,12 +135,16 @@
 
    if (fDisplacement) delete [] fDisplacement;
    if (fEntryOffset)  delete [] fEntryOffset;
-   if (fBuffer == fCompressedBuffer) fBuffer = 0;
-   if (fCompressedBuffer) delete [] fCompressedBuffer;
+   if (fBufferRef) delete fBufferRef;
+   fBufferRef = 0;
+   fBuffer = 0;
    fDisplacement= 0;
    fEntryOffset = 0;
-   fCompressedSize = 0;
-   fCompressedBuffer = 0;
+   // Note we only delete the compressed buffer if we own it
+   if (fCompressedBufferRef && fOwnsCompressedBuffer) {
+       delete fCompressedBufferRef;
+       fCompressedBufferRef = 0;
+   }
 }
 
 //_______________________________________________________________________
@@ -172,19 +198,17 @@
 Int_t TBasket::DropBuffers()
 {
    // Drop buffers of this basket if it is not the current basket.
-
    if (!fBuffer && !fBufferRef) return 0;
 
    if (fDisplacement) delete [] fDisplacement;
    if (fEntryOffset)  delete [] fEntryOffset;
    if (fBufferRef)    delete fBufferRef;
-   if (fCompressedBuffer) delete [] fCompressedBuffer;
+   if (fCompressedBufferRef && fOwnsCompressedBuffer) delete fCompressedBufferRef;
    fBufferRef   = 0;
+   fCompressedBufferRef = 0;
    fBuffer      = 0;
    fDisplacement= 0;
    fEntryOffset = 0;
-   fCompressedSize = 0;
-   fCompressedBuffer = 0;
    fBranch->GetTree()->IncrementTotalBuffers(-fBufferSize);
    return fBufferSize;
 }
@@ -282,7 +306,92 @@
    fNevBuf -= dentries;
 }
 
+#define OLD_CASE_EXPRESSION fObjlen==fNbytes-fKeylen && GetBranch()->GetCompressionLevel()!=0 && file->GetVersion()<=30401
 //_______________________________________________________________________
+Int_t TBasket::ReadBasketBuffersUncompressedCase()
+{
+   // By-passing buffer unzipping has been requested and is
+   // possible (only 1 entry in this basket). 
+   fBuffer = fBufferRef->Buffer();
+            
+   // Make sure that the buffer is set at the END of the data
+   fBufferRef->SetBufferOffset(fNbytes);
+            
+   // Indicate that this buffer is weird.
+   fBufferRef->SetBit(TBufferFile::kNotDecompressed);
+            
+   // Usage of this mode assume the existance of only ONE
+   // entry in this basket.
+   delete [] fEntryOffset; fEntryOffset = 0;
+   delete [] fDisplacement; fDisplacement = 0;
+            
+   fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
+   return 0;
+}
+
+//_______________________________________________________________________
+Int_t TBasket::ReadBasketBuffersUnzip(char* buffer, Int_t size, Bool_t mustFree, TFile* file)
+{
+   // We always create the TBuffer for the basket but it hold the buffer from the cache.
+   if (fBufferRef) {
+      fBufferRef->SetBuffer(buffer, size, mustFree);
+      fBufferRef->SetReadMode();
+      fBufferRef->Reset();
+   } else {
+      fBufferRef = new TBufferFile(TBuffer::kRead, size, buffer, mustFree);
+   }
+   fBufferRef->SetParent(file);
+
+   Streamer(*fBufferRef);
+   
+   if (IsZombie()) {
+      return -1;
+   }
+   
+   Bool_t oldCase = OLD_CASE_EXPRESSION;
+
+   if ((fObjlen > fNbytes-fKeylen || oldCase) && TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1)) {
+      return TBasket::ReadBasketBuffersUncompressedCase();
+   }
+
+   fBuffer = fBufferRef->Buffer();
+   return fObjlen+fKeylen;
+}
+
+//_______________________________________________________________________
+static inline TBuffer* R__initializeReadBasketBuffer(TBuffer* bufferRef, Int_t len, TFile* file)
+{
+   // Initialize a buffer for reading if it is not already initialized
+   
+   TBuffer* result;
+   if (R__likely(bufferRef)) {
+      bufferRef->SetReadMode();
+      Int_t curBufferSize = bufferRef->BufferSize();
+      if (curBufferSize < len) {
+         // Experience shows that giving 5% "wiggle-room" decreases churn.
+         bufferRef->Expand(Int_t(len*1.05));
+      }
+      bufferRef->Reset();
+      result = bufferRef;
+   } else {
+      result = new TBufferFile(TBuffer::kRead, len);
+   }
+   result->SetParent(file);
+   return result;
+}
+
+//_______________________________________________________________________
+void TBasket::InitializeCompressedBuffer(Int_t len, TFile* file)
+{
+    // Initialize the compressed buffer; either from the TTree or create a local one.
+    Bool_t compressedBufferExists = fCompressedBufferRef != NULL;
+    fCompressedBufferRef = R__initializeReadBasketBuffer(fCompressedBufferRef, len, file);
+    if (!compressedBufferExists) {
+        fOwnsCompressedBuffer = kTRUE;
+    }
+}
+
+//_______________________________________________________________________
 Int_t TBasket::ReadBasketBuffers(Long64_t pos, Int_t len, TFile *file)
 {
    // Read basket buffers in memory and cleanup.
@@ -299,174 +408,119 @@
    // There is a lot of code duplication but it was necesary to assure
    // the expected behavior when there is no cache.
 
-
    if(!fBranch->GetDirectory()) {
       return -1;
-   }
-   Int_t badread= 0;
+   }  
+   
+   Bool_t oldCase;
+   char *rawUncompressedBuffer, *rawCompressedBuffer;
+   Int_t uncompressedBufferLen;
 
+   // See if the cache has already unzipped the buffer for us.
    TFileCacheRead *pf = file->GetCacheRead();
-   char *buffer = 0;
-   Bool_t free = kTRUE; // Must we free this buffer or does it make part of the cache? 
-   Int_t res = -1;
+   if (pf) {
+      Int_t res = -1;
+      Bool_t free = kTRUE;
+      char *buffer;
+      res = pf->GetUnzipBuffer(&buffer, pos, len, &free);
+      if (R__unlikely(res >= 0)) {
+         len = ReadBasketBuffersUnzip(buffer, res, free, file);
+         // Note that in the kNotDecompressed case, the above function will return 0;
+         // In such a case, we should stop processing
+         if (len <= 0) return -len;
+         goto AfterBuffer;
+      }
+   }
 
-   if (pf) res = pf->GetUnzipBuffer(&buffer, pos, len, &free);
+   // Initialize the buffer to hold the compressed data.
+   InitializeCompressedBuffer(len, file);
+   if (!fCompressedBufferRef) {
+       Error("ReadBasketBuffers", "Unable to allocate buffer.");
+       return 1;
+   }
+   rawCompressedBuffer = fCompressedBufferRef->Buffer();
 
-   if (res >= 0) {
+   // Read from the file and unstream the header information.
+   if (file->ReadBuffer(rawCompressedBuffer,pos,len)) {
+      return 1;
+   }
+   Streamer(*fCompressedBufferRef);
+   if (IsZombie()) {
+      return 1;
+   }
 
-      // We always create the TBuffer for the basket but it will be a shell only,
-      // since we pass the pointer to the low level buffer
-      if (fBufferRef) {
-         fBufferRef->SetBuffer(buffer, res, free);
-         fBufferRef->SetReadMode();
-         fBufferRef->Reset();
-      } else {
-         fBufferRef = new TBufferFile(TBuffer::kRead, res, buffer, free);
+   // Initialize buffer to hold the uncompressed data
+   // Note that in previous versions we didn't allocate buffers until we verified
+   // the zip headers; this is no longer beforehand as the buffer lifetime is scoped
+   // to the TBranch.
+   uncompressedBufferLen = len > fObjlen+fKeylen ? len : fObjlen+fKeylen;
+   fBufferRef = R__initializeReadBasketBuffer(fBufferRef, uncompressedBufferLen, file);
+   rawUncompressedBuffer = fBufferRef->Buffer();
+   fBuffer = rawUncompressedBuffer;
+
+   oldCase = OLD_CASE_EXPRESSION;
+   // Case where ROOT thinks the buffer is compressed.  Copy over the key and uncompress the object
+   if (fObjlen > fNbytes-fKeylen || oldCase) {
+      if (R__unlikely(TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1))) {
+         return ReadBasketBuffersUncompressedCase();
       }
-      fBufferRef->SetParent(file);
 
-      Streamer(*fBufferRef);
-   
-      if (IsZombie()) {
-         badread = 1;
-         return badread;         
+      // Optional monitor for zip time profiling.
+      Double_t start = 0;
+      if (R__unlikely(gPerfStats)) {
+         start = TTimeStamp();
       }
 
-      Bool_t oldCase = fObjlen==fNbytes-fKeylen
-         && GetBranch()->GetCompressionLevel()!=0
-         && file->GetVersion()<=30401;
-      if (fObjlen > fNbytes-fKeylen || oldCase) {
-         if (TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1)) {
-            // By-passing buffer unzipping has been requested and is
-            // possible (only 1 entry in this basket).
-            fBuffer = fBufferRef->Buffer();
+      memcpy(rawUncompressedBuffer, rawCompressedBuffer, fKeylen);
+      char *rawUncompressedObjectBuffer = rawUncompressedBuffer+fKeylen;
+      UChar_t *rawCompressedObjectBuffer = (UChar_t*)rawCompressedBuffer+fKeylen;
+      Int_t nin, nbuf;
+      Int_t nout = 0, noutot = 0, nintot = 0;
 
-            // Make sure that the buffer is set at the END of the data
-            fBufferRef->SetBufferOffset(fNbytes);
-
-            // Indicate that this buffer is weird.
-            fBufferRef->SetBit(TBufferFile::kNotDecompressed);
-
-            // Usage of this mode assume the existance of only ONE
-            // entry in this basket.
-            delete [] fEntryOffset; fEntryOffset = 0;
-            delete [] fDisplacement; fDisplacement = 0;
-
-            fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
-            return badread;
+      // Unzip all the compressed objects in the compressed object buffer.
+      while (1) {
+         // Check the header for errors.
+         if (R__unlikely(R__unzip_header(&nin, rawCompressedObjectBuffer, &nbuf) != 0)) {
+            Error("ReadBasketBuffers", "Inconsistency found in header (nin=%d, nbuf=%d)", nin, nbuf);
+            break;
          }
-      }
-
-      fBuffer = fBufferRef->Buffer();
-      len = fObjlen+fKeylen;
-   }
-   else{
-      if (fBufferRef) {
-         fBufferRef->SetReadMode();
-         if (fBufferRef->BufferSize() < len) {
-            fBufferRef->Expand(len);
+         if (R__unlikely(oldCase && (nin > fObjlen || nbuf > fObjlen))) {
+            //buffer was very likely not compressed in an old version
+            memcpy(rawUncompressedBuffer+fKeylen, rawCompressedObjectBuffer+fKeylen, fObjlen);
+            goto AfterBuffer;
          }
-         fBufferRef->Reset();
-      } else {
-         fBufferRef = new TBufferFile(TBuffer::kRead, len);
-      }
-      fBufferRef->SetParent(file);
 
-      buffer = fBufferRef->Buffer();
-      if (file->ReadBuffer(buffer,pos,len)) {
-         badread = 1;
-         return badread;
+         R__unzip(&nin, rawCompressedObjectBuffer, &nbuf, rawUncompressedObjectBuffer, &nout);
+         if (!nout) break;
+         noutot += nout;
+         nintot += nin;
+         if (noutot >= fObjlen) break;
+         rawCompressedObjectBuffer += nin;
+         rawUncompressedObjectBuffer += nout;
       }
 
-      Streamer(*fBufferRef);
-
-      if (IsZombie()) {
-         badread = 1;
-         return badread;         
+      // Make sure the uncompressed numbers are consistent with header.
+      if (R__unlikely(noutot != fObjlen)) {
+         Error("ReadBasketBuffers", "fNbytes = %d, fKeylen = %d, fObjlen = %d, noutot = %d, nout=%d, nin=%d, nbuf=%d", fNbytes,fKeylen,fObjlen, noutot,nout,nin,nbuf);
+         fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
+         return 1;
       }
-      
-      Bool_t oldCase = fObjlen==fNbytes-fKeylen
-         && GetBranch()->GetCompressionLevel()!=0
-         && file->GetVersion()<=30401;
-      if (fObjlen > fNbytes-fKeylen || oldCase) {
-         if (TestBit(TBufferFile::kNotDecompressed) && (fNevBuf==1)) {
-            // By-passing buffer unzipping has been requested and is
-            // possible (only 1 entry in this basket).
-            fBuffer = fBufferRef->Buffer();
-            
-            // Make sure that the buffer is set at the END of the data
-            fBufferRef->SetBufferOffset(fNbytes);
-            
-            // Indicate that this buffer is weird.
-            fBufferRef->SetBit(TBufferFile::kNotDecompressed);
-            
-            // Usage of this mode assume the existance of only ONE
-            // entry in this basket.
-            delete [] fEntryOffset; fEntryOffset = 0;
-            delete [] fDisplacement; fDisplacement = 0;
-            
-            fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
-            return badread;
-         }
-
-         if ((fObjlen+fKeylen) > fCompressedSize) {
-            /* early consistency check before potentially large memory is being allocated */
-            Int_t nin, nbuf;
-            UChar_t *bufcur = (UChar_t *)&buffer[fKeylen];
-            if (R__unzip_header(&nin, bufcur, &nbuf)!=0) {
-               Error("ReadBasketBuffers", "Inconsistency found in header (nin=%d, nbuf=%d)", nin, nbuf);
-               badread = 1;
-               return badread;
-            }
-            if (fCompressedSize) delete [] fCompressedBuffer;
-            fCompressedSize = fObjlen+fKeylen;
-            fCompressedBuffer = new char[fCompressedSize];
-         }
-         fBuffer = fCompressedBuffer;
-         memcpy(fBuffer,buffer,fKeylen);
-         char *objbuf = fBuffer + fKeylen;
-         UChar_t *bufcur = (UChar_t *)&buffer[fKeylen];
-         Int_t nin, nout, nbuf;
-         Int_t noutot = 0;
-         while (1) {
-            Int_t hc = R__unzip_header(&nin, bufcur, &nbuf);
-            if (hc!=0) break;
-            if (oldCase && (nin > fObjlen || nbuf > fObjlen)) {
-               //buffer was very likely not compressed in an old version
-               delete [] fBuffer;
-               fBuffer = fBufferRef->Buffer();
-               goto AfterBuffer;
-            }
-            R__unzip(&nin, bufcur, &nbuf, objbuf, &nout);
-            if (!nout) break;
-            noutot += nout;
-            if (noutot >= fObjlen) break;
-            bufcur += nin;
-            objbuf += nout;
-         }
-         if (noutot != fObjlen) {
-            Error("ReadBasketBuffers", "fNbytes = %d, fKeylen = %d, fObjlen = %d, noutot = %d, nout=%d, nin=%d, nbuf=%d", fNbytes,fKeylen,fObjlen, noutot,nout,nin,nbuf);
-            badread = 1;
-         }
-         // Switch the 2 buffers
-         char *temp = fBufferRef->Buffer();
-         Int_t templen = fBufferRef->BufferSize();
-         fBufferRef->ResetBit(TBuffer::kIsOwner);
-         fBufferRef->SetBuffer(fBuffer, fCompressedSize, kTRUE); // Do adopt the buffer.
-         fCompressedBuffer = temp;
-         fCompressedSize = templen;
-         len = fObjlen+fKeylen;
-      } else {
-         fBuffer = fBufferRef->Buffer();
+      len = fObjlen+fKeylen;
+      if (R__unlikely(gPerfStats)) {
+         gPerfStats->FileUnzipEvent(file,pos,start,nintot,fObjlen);
       }
+   } else {
+      // Nothing is compressed - copy over wholesale.
+      memcpy(rawUncompressedBuffer, rawCompressedBuffer, len);
    }
- AfterBuffer:
 
+AfterBuffer:
+
    fBranch->GetTree()->IncrementTotalBuffers(fBufferSize);
-
-   // read offsets table
-   if (badread || !fBranch->GetEntryOffsetLen()) {
-      return badread;
+   
+   // Read offsets table if needed.
+   if (!fBranch->GetEntryOffsetLen()) {
+      return 0;
    }
    delete [] fEntryOffset;
    fEntryOffset = 0;
@@ -476,19 +530,20 @@
       fEntryOffset = new Int_t[fNevBuf+1];
       fEntryOffset[0] = fKeylen;
       Warning("ReadBasketBuffers","basket:%s has fNevBuf=%d but fEntryOffset=0, pos=%lld, len=%d, fNbytes=%d, fObjlen=%d, trying to repair",GetName(),fNevBuf,pos,len,fNbytes,fObjlen);
-      return badread;
+      return 0;
    }
+   // Read the array of diplacement if any.
    delete [] fDisplacement;
-   fDisplacement = 0;
+   fDisplacement = 0; 
    if (fBufferRef->Length() != len) {
       // There is more data in the buffer!  It is the displacement
       // array.  If len is less than TBuffer::kMinimalSize the actual
       // size of the buffer is too large, so we can not use the
       // fBufferRef->BufferSize()
       fBufferRef->ReadArray(fDisplacement);
-   }
+   }        
 
-   return badread;
+   return 0;
 }
 
 //_______________________________________________________________________
@@ -520,13 +575,14 @@
    Int_t curSize = fBufferRef->BufferSize();
    // fBufferLen at this point is already reset, so use indirect measurements
    Int_t curLen = (GetObjlen() + GetKeylen());
+   Long_t newSize = -1;
    if (curSize > 2*curLen)
    {
-      Int_t curBsize = fBranch->GetBasketSize();      
+      Long_t curBsize = fBranch->GetBasketSize();      
       if (curSize > 2*curBsize ) {
-         Int_t avgSize = (fBranch->GetTotBytes() / (1+fBranch->GetWriteBasket())); // Average number of bytes per basket so far
+         Long_t avgSize = (Long_t)(fBranch->GetTotBytes() / (1+fBranch->GetWriteBasket())); // Average number of bytes per basket so far
          if (curSize > 2*avgSize) {
-            Int_t newSize = curBsize;
+            newSize = curBsize;
             if (curLen > newSize) {
                newSize = curLen;
             }
@@ -534,10 +590,22 @@
                newSize = avgSize;
             }
             newSize = newSize + 512 - newSize%512;  // Wiggle room and alignment (512 is same as in OptimizeBaskets)
-            fBufferRef->Expand(newSize);
          }
       }
    }
+   /*
+      Philippe has asked us to keep this turned off until we finish memory fragmentation studies.
+   // If fBufferRef grew since we last saw it, shrink it to 105% of the occupied size
+   if (curSize > fLastWriteBufferSize) {
+      if (newSize == -1) {
+         newSize = Int_t(1.05*Float_t(fBufferRef->Length()));
+      }
+      fLastWriteBufferSize = newSize;
+   }
+   */
+   if (newSize != -1) {
+       fBufferRef->Expand(newSize,kFALSE);     // Expand without copying the existing data.
+   }
 
    TKey::Reset();
 
@@ -620,7 +688,9 @@
       b >> fLast;
       b >> flag;
       if (fLast > fBufferSize) fBufferSize = fLast;
-      if (!flag) return;
+      if (!flag) {
+         return;
+      }
       if (flag%10 != 2) {
          delete [] fEntryOffset;
          fEntryOffset = new Int_t[fNevBufSize];
@@ -690,21 +760,25 @@
       b << fNevBufSize;
       b << fNevBuf;
       b << fLast;
-      flag = 1;
-      if (!fEntryOffset)  flag  = 2;
-      if (fBufferRef)     flag += 10;
-      if (fDisplacement)  flag += 40;
-      if (fHeaderOnly)    flag  = 0;
-      b << flag;
-      if (fHeaderOnly) return;
-      if (fEntryOffset && fNevBuf) {
-         b.WriteArray(fEntryOffset, fNevBuf);
-         if (fDisplacement) b.WriteArray(fDisplacement, fNevBuf);
+      if (fHeaderOnly) {
+         flag = 0;
+         b << flag;
+      } else {
+         flag = 1;
+         if (!fEntryOffset)  flag  = 2;
+         if (fBufferRef)     flag += 10;
+         if (fDisplacement)  flag += 40;
+         b << flag;
+
+         if (fEntryOffset && fNevBuf) {
+            b.WriteArray(fEntryOffset, fNevBuf);
+            if (fDisplacement) b.WriteArray(fDisplacement, fNevBuf);
+         }
+         if (fBufferRef) {
+            char *buf  = fBufferRef->Buffer();
+            b.WriteFastArray(buf, fLast);
+         }
       }
-      if (fBufferRef) {
-         char *buf  = fBufferRef->Buffer();
-         b.WriteFastArray(buf, fLast);
-      }
    }
 }
 
@@ -764,8 +838,8 @@
       return -1;
    }
    fMotherDir = file; // fBranch->GetDirectory();
-   
-   if (fBufferRef->TestBit(TBufferFile::kNotDecompressed)) {
+  
+   if (R__unlikely(fBufferRef->TestBit(TBufferFile::kNotDecompressed))) {
       // Read the basket information that was saved inside the buffer.
       Bool_t writing = fBufferRef->IsWriting();
       fBufferRef->SetReadMode();
@@ -787,10 +861,12 @@
       return nBytes>0 ? fKeylen+nout : -1;
    }
 
-//*-*- Transfer fEntryOffset table at the end of fBuffer. Offsets to fBuffer
-//     are transformed in entry length to optimize compression algorithm.
-   fLast      = fBufferRef->Length();
+   // Transfer fEntryOffset table at the end of fBuffer.
+   fLast = fBufferRef->Length();
    if (fEntryOffset) {
+      // Note: We might want to investigate the compression gain if we 
+      // transform the Offsets to fBuffer in entry length to optimize 
+      // compression algorithm.
       fBufferRef->WriteArray(fEntryOffset,fNevBuf+1);
       delete [] fEntryOffset; fEntryOffset = 0;
       if (fDisplacement) {
@@ -810,12 +886,13 @@
       //if (cxlevel == 2) cxlevel--; RB: I cannot remember why we had this!
       Int_t nbuffers = fObjlen/kMAXBUF;
       Int_t buflen = fKeylen + fObjlen + 28; //add 28 bytes in case object is placed in a deleted gap
-      if (buflen > fCompressedSize) {
-         if (fCompressedSize) delete [] fCompressedBuffer;
-         fCompressedSize = buflen;
-         fCompressedBuffer = new char[fCompressedSize];
+      InitializeCompressedBuffer(buflen, file);
+      if (!fCompressedBufferRef) {
+         Warning("WriteBuffer", "Unable to allocate the compressed buffer");
+         return -1;
       }
-      fBuffer = fCompressedBuffer;
+      fCompressedBufferRef->SetWriteMode();
+      fBuffer = fCompressedBufferRef->Buffer();
       char *objbuf = fBufferRef->Buffer() + fKeylen;
       char *bufcur = &fBuffer[fKeylen];
       noutot = 0;
@@ -831,9 +908,8 @@
          // buffer is larger than the input. In this case, we write the original uncompressed buffer
          if (nout == 0 || nout >= fObjlen) {
             nout = fObjlen;
-            // We use do delete fBuffer here, we no longer want to since
-            // the buffer (held by fCompressedBuffer) might be re-used later.
-            // delete [] fBuffer;
+            // We used to delete fBuffer here, we no longer want to since
+            // the buffer (held by fCompressedBufferRef) might be re-used later.
             fBuffer = fBufferRef->Buffer();
             Create(fObjlen,file);
             fBufferRef->SetBufferOffset(0);
Index: tree/tree/src/TTreeCacheUnzip.cxx
===================================================================
--- tree/tree/src/TTreeCacheUnzip.cxx	(revision 39642)
+++ tree/tree/src/TTreeCacheUnzip.cxx	(revision 39657)
@@ -989,7 +989,8 @@
 
       char *objbuf = *dest + keylen;
       UChar_t *bufcur = (UChar_t *) (src + keylen);
-      Int_t nin, nout, nbuf;
+      Int_t nin, nbuf;
+      Int_t nout = 0;
       Int_t noutot = 0;
 
       while (1) {
Index: tree/tree/src/TLeafD.cxx
===================================================================
--- tree/tree/src/TLeafD.cxx	(revision 39642)
+++ tree/tree/src/TLeafD.cxx	(revision 39657)
@@ -118,7 +118,7 @@
 //*-*                  ===========================================
 
    if (!fLeafCount && fNdata == 1) {
-      b >> fValue[0];
+      b.ReadDouble(fValue[0]);
    }else {
       if (fLeafCount) {
          Long64_t entry = fBranch->GetReadEntry();
Index: tree/tree/src/TLeafF.cxx
===================================================================
--- tree/tree/src/TLeafF.cxx	(revision 39642)
+++ tree/tree/src/TLeafF.cxx	(revision 39657)
@@ -122,7 +122,7 @@
 //*-*                  ===========================================
 
    if (!fLeafCount && fNdata == 1) {
-      b >> fValue[0];
+      b.ReadFloat(fValue[0]);
    }else {
       if (fLeafCount) {
          Long64_t entry = fBranch->GetReadEntry();
Index: tree/tree/src/TLeafI.cxx
===================================================================
--- tree/tree/src/TLeafI.cxx	(revision 39642)
+++ tree/tree/src/TLeafI.cxx	(revision 39657)
@@ -157,7 +157,7 @@
 //*-*                  ===========================================
 
    if (!fLeafCount && fNdata == 1) {
-      b >> fValue[0];
+      b.ReadInt(fValue[0]);
    } else {
       if (fLeafCount) {
          Long64_t entry = fBranch->GetReadEntry();
Index: tree/tree/src/TLeafL.cxx
===================================================================
--- tree/tree/src/TLeafL.cxx	(revision 39642)
+++ tree/tree/src/TLeafL.cxx	(revision 39657)
@@ -159,7 +159,7 @@
 //*-*                  ===========================================
 
    if (!fLeafCount && fNdata == 1) {
-      b >> fValue[0];
+      b.ReadLong64(fValue[0]);
    } else {
       if (fLeafCount) {
          Long64_t entry = fBranch->GetReadEntry();

Property changes on: tree/tree/src/TTreeCache.cxx
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/tree/tree/src/TTreeCache.cxx:r38055,38403-38404,38462,38801,38803,39551,39642,39644

Index: tree/tree/src/TLeafO.cxx
===================================================================
--- tree/tree/src/TLeafO.cxx	(revision 39642)
+++ tree/tree/src/TLeafO.cxx	(revision 39657)
@@ -125,7 +125,7 @@
 //*-*                  ===========================================
 
    if (!fLeafCount && fNdata == 1) {
-      b >> fValue[0];
+      b.ReadBool(fValue[0]);
    }else {
       if (fLeafCount) {
          Long64_t entry = fBranch->GetReadEntry();
Index: tree/tree/src/TBasketSQL.cxx
===================================================================
--- tree/tree/src/TBasketSQL.cxx	(revision 39642)
+++ tree/tree/src/TBasketSQL.cxx	(revision 39657)
@@ -38,7 +38,8 @@
 //_________________________________________________________________________
 TBasketSQL::TBasketSQL() : TBasket()
 {
-  // Default constructor
+   // Default constructor.
+
 }
 
 //_________________________________________________________________________
@@ -47,7 +48,7 @@
                          vector<Int_t> *vc, TSQLRow **r) :
   fResultPtr(rs),fRowPtr(r)
 { 
-   // Regular constructor
+   // Regular constructor.
 
    SetName(name);
    SetTitle(title);
@@ -76,6 +77,7 @@
       for (Int_t i=0;i<fNevBufSize;i++) fEntryOffset[i] = 0;
    }
    branch->GetTree()->IncrementTotalBuffers(fBufferSize);
+   
 }
 
 //_________________________________________________________________________

Property changes on: tree/tree/src
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/tree/tree/src:r38055,38403-38404,38462,38801,38803,39551,39642,39644

Index: tree/tree/inc/TBasket.h
===================================================================
--- tree/tree/inc/TBasket.h	(revision 39642)
+++ tree/tree/inc/TBasket.h	(revision 39657)
@@ -40,7 +40,14 @@
 private:
    TBasket(const TBasket&);            // TBasket objects are not copiable.
    TBasket& operator=(const TBasket&); // TBasket objects are not copiable.
-      
+
+   // Internal corner cases for ReadBasketBuffers
+   Int_t ReadBasketBuffersUnzip(char*, Int_t, Bool_t, TFile*);
+   Int_t ReadBasketBuffersUncompressedCase();
+
+   // Helper for managing the compressed buffer.
+   void InitializeCompressedBuffer(Int_t len, TFile* file);
+ 
 protected:
    Int_t       fBufferSize;      //fBuffer length in bytes
    Int_t       fNevBufSize;      //Length in Int_t of fEntryOffset OR fixed length of each entry if fEntryOffset is null!
@@ -50,9 +57,10 @@
    Int_t      *fDisplacement;    //![fNevBuf] Displacement of entries in fBuffer(TKey)
    Int_t      *fEntryOffset;     //[fNevBuf] Offset of entries in fBuffer(TKey)
    TBranch    *fBranch;          //Pointer to the basket support branch
-   Int_t       fCompressedSize;  //!Size of the allocated memroy in fCompressedBuffer
-   char       *fCompressedBuffer;//!Temporary place holder for the compressed buffer if needed.
-   
+   TBuffer    *fCompressedBufferRef; //! Compressed buffer.
+   Bool_t      fOwnsCompressedBuffer; //! Whether or not we own the compressed buffer.
+   Int_t       fLastWriteBufferSize; //! Size of the buffer last time we wrote it to disk
+
 public:
    
    TBasket();
Index: tree/tree/inc/TTree.h
===================================================================
--- tree/tree/inc/TTree.h	(revision 39642)
+++ tree/tree/inc/TTree.h	(revision 39657)
@@ -134,6 +134,7 @@
    TList         *fClones;            //! List of cloned trees which share our addresses
    TBranchRef    *fBranchRef;         //  Branch supporting the TRefTable (if any)
    UInt_t         fFriendLockStatus;  //! Record which method is locking the friend recursion
+   TBuffer       *fTransientBuffer;   //! Pointer to the current transient buffer.
 
    static Int_t     fgBranchStyle;      //  Old/New branch style
    static Long64_t  fgMaxTreeSize;      //  Maximum size of a file containg a Tree
@@ -354,6 +355,7 @@
    TTreeFormula           *GetSelect()    { return GetPlayer()->GetSelect(); }
    virtual Long64_t        GetSelectedRows() { return GetPlayer()->GetSelectedRows(); }
    virtual Int_t           GetTimerInterval() const { return fTimerInterval; }
+           TBuffer*        GetTransientBuffer(Int_t size);
    virtual Long64_t        GetTotBytes() const { return fTotBytes; }
    virtual TTree          *GetTree() const { return const_cast<TTree*>(this); }
    virtual TVirtualIndex  *GetTreeIndex() const { return fTreeIndex; }
Index: tree/tree/inc/TBranch.h
===================================================================
--- tree/tree/inc/TBranch.h	(revision 39642)
+++ tree/tree/inc/TBranch.h	(revision 39657)
@@ -58,7 +58,10 @@
 
 protected:
    // TBranch status bits
-   enum { kAutoDelete = BIT(15) };
+   enum EStatusBits {
+      kAutoDelete = BIT(15),
+      kDoNotUseBufferMap = BIT(22) // If set, at least one of the entry in the branch will use the buffer's map of classname and objects.
+   };
 
    static Int_t fgCount;          //! branch counter
    Int_t       fCompress;        //  (=1 branch is compressed, 0 otherwise)
@@ -73,6 +76,9 @@
    Int_t       fNleaves;         //! Number of leaves
    Int_t       fReadBasket;      //! Current basket number when reading
    Long64_t    fReadEntry;       //! Current entry number when reading
+   Long64_t    fFirstBasketEntry;//! First entry in the current basket.
+   Long64_t    fNextBasketEntry; //! Next entry that will requires us to go to the next basket
+   TBasket    *fCurrentBasket;   //! Pointer to the current basket.
    Long64_t    fEntries;         //  Number of entries
    Long64_t    fFirstEntry;      //  Number of the first entry in this branch
    Long64_t    fTotBytes;        //  Total number of bytes in all leaves before compression
@@ -97,7 +103,10 @@
    typedef void (TBranch::*ReadLeaves_t)(TBuffer &b); 
    ReadLeaves_t fReadLeaves;     //! Pointer to the ReadLeaves implementation to use. 
    void     ReadLeavesImpl(TBuffer &b);
-
+   void     ReadLeaves0Impl(TBuffer &b);
+   void     ReadLeaves1Impl(TBuffer &b);
+   void     ReadLeaves2Impl(TBuffer &b);
+   
    void     SetSkipZip(Bool_t skip = kTRUE) { fSkipZip = skip; }
    void     Init(const char *name, const char *leaflist, Int_t compress);
 

Property changes on: tree/tree
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/tree/tree:r38055,38403-38404,38462,38801,38803,39551,39642,39644

Index: tree/treeplayer/src/TTreePerfStats.cxx
===================================================================
--- tree/treeplayer/src/TTreePerfStats.cxx	(revision 39642)
+++ tree/treeplayer/src/TTreePerfStats.cxx	(revision 39657)
@@ -123,6 +123,7 @@
    fRealTime      = 0;
    fCpuTime       = 0;
    fDiskTime      = 0;
+   fUnzipTime     = 0;
    fCompress      = 0;
    fRealTimeAxis  = 0;
    fHostInfoText  = 0;
@@ -157,6 +158,7 @@
    fRealTime      = 0;
    fCpuTime       = 0;
    fDiskTime      = 0;
+   fUnzipTime     = 0;
    fRealTimeAxis  = 0;
    fCompress      = (T->GetTotBytes()+0.00001)/T->GetZipBytes();
    
@@ -287,7 +289,22 @@
    fGraphTime->SetPointError(np,0.001,dtime);
 }
 
+
 //______________________________________________________________________________
+void TTreePerfStats::FileUnzipEvent(TFile * /* file */, Long64_t /* pos */, Double_t start, Int_t /* complen */, Int_t /* objlen */)
+{
+   // Record TTree file unzip event.
+   // start is the TimeStamp before unzip
+   // pos is where in the file the compressed buffer came from
+   // complen is the length of the compressed buffer
+   // objlen is the length of the de-compressed buffer
+   
+   Double_t tnow = TTimeStamp();
+   Double_t dtime = tnow-start;
+   fUnzipTime += dtime;
+}
+
+//______________________________________________________________________________
 void TTreePerfStats::Finish()
 {
    // When the run is finished this function must be called
@@ -334,6 +351,10 @@
    fGraphIO->GetYaxis()->SetLabelSize(0.03);
    fGraphIO->Paint(option);
    
+   TString opts(option);
+   opts.ToLower();
+   Bool_t unzip = opts.Contains("unzip");
+   
    //superimpose the time info (max 10 points)
    if (fGraphTime) {
       fGraphTime->Paint("l");
@@ -376,6 +397,9 @@
       fPave->AddText(Form("Real Time = %7.3f s",fRealTime));
       fPave->AddText(Form("CPU  Time = %7.3f s",fCpuTime));
       fPave->AddText(Form("Disk Time = %7.3f s",fDiskTime));
+      if (unzip) { 
+         fPave->AddText(Form("UnzipTime = %7.3f s",fUnzipTime));
+      }
       fPave->AddText(Form("Disk IO   = %7.3f MB/s",1e-6*fBytesRead/fDiskTime));
       fPave->AddText(Form("ReadUZRT  = %7.3f MB/s",1e-6*fCompress*fBytesRead/fRealTime));
       fPave->AddText(Form("ReadUZCP  = %7.3f MB/s",1e-6*fCompress*fBytesRead/fCpuTime));
@@ -393,10 +417,13 @@
 }
 
 //______________________________________________________________________________
-void TTreePerfStats::Print(Option_t * /*option*/) const
+void TTreePerfStats::Print(Option_t * option) const
 {
    // Print the TTree I/O perf stats.
 
+   TString opts(option);
+   opts.ToLower();
+   Bool_t unzip = opts.Contains("unzip");
    TTreePerfStats *ps = (TTreePerfStats*)this;
    ps->Finish();
       
@@ -412,11 +439,19 @@
    printf("Real Time = %7.3f seconds\n",fRealTime);
    printf("CPU  Time = %7.3f seconds\n",fCpuTime);
    printf("Disk Time = %7.3f seconds\n",fDiskTime);
+   if (unzip) {
+      printf("Strm Time = %7.3f seconds\n",fCpuTime-fUnzipTime);
+      printf("UnzipTime = %7.3f seconds\n",fUnzipTime);
+   }      
    printf("Disk IO   = %7.3f MBytes/s\n",1e-6*fBytesRead/fDiskTime);
    printf("ReadUZRT  = %7.3f MBytes/s\n",1e-6*fCompress*fBytesRead/fRealTime);
    printf("ReadUZCP  = %7.3f MBytes/s\n",1e-6*fCompress*fBytesRead/fCpuTime);
    printf("ReadRT    = %7.3f MBytes/s\n",1e-6*fBytesRead/fRealTime);
    printf("ReadCP    = %7.3f MBytes/s\n",1e-6*fBytesRead/fCpuTime);
+   if (unzip) {
+      printf("ReadStrCP = %7.3f MBytes/s\n",1e-6*fCompress*fBytesRead/(fCpuTime-fUnzipTime));
+      printf("ReadZipCP = %7.3f MBytes/s\n",1e-6*fCompress*fBytesRead/fUnzipTime);
+   }      
 }
 
 //______________________________________________________________________________
@@ -454,6 +489,7 @@
    out<<"   ps->SetRealTime("<<fRealTime<<");"<<endl;
    out<<"   ps->SetCpuTime("<<fCpuTime<<");"<<endl;
    out<<"   ps->SetDiskTime("<<fDiskTime<<");"<<endl;
+   out<<"   ps->SetUnzipTime("<<fUnzipTime<<");"<<endl;
    out<<"   ps->SetCompress("<<fCompress<<");"<<endl;
 
    Int_t i, npoints = fGraphIO->GetN();
Index: tree/treeplayer/inc/TTreePerfStats.h
===================================================================
--- tree/treeplayer/inc/TTreePerfStats.h	(revision 39642)
+++ tree/treeplayer/inc/TTreePerfStats.h	(revision 39657)
@@ -50,6 +50,7 @@
    Double_t      fRealTime;      //Real time
    Double_t      fCpuTime;       //Cpu time
    Double_t      fDiskTime;      //Time spent in pure raw disk IO
+   Double_t      fUnzipTime;     //Time spent uncompressing the data.
    Double_t      fCompress;      //Tree compression factor      
    TString       fName;          //name of this TTreePerfStats
    TString       fHostInfo;      //name of the host system, ROOT version and date
@@ -87,6 +88,7 @@
    virtual Double_t GetRealTime()  const {return fRealTime;}
    TStopwatch      *GetStopwatch() const {return fWatch;}
    virtual Int_t    GetTreeCacheSize() const {return fTreeCacheSize;}
+   virtual Double_t GetUnzipTime() const {return fUnzipTime; }
    virtual void     Paint(Option_t *chopt="");
    virtual void     Print(Option_t *option="") const;
 
@@ -96,6 +98,7 @@
    virtual void     FileEvent(const char *, const char *, const char *, const char *, Bool_t) {}
    virtual void     FileOpenEvent(TFile *, const char *, Double_t) {}
    virtual void     FileReadEvent(TFile *file, Int_t len, Double_t start);
+   virtual void     FileUnzipEvent(TFile *file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen);
    virtual void     RateEvent(Double_t , Double_t , Long64_t , Long64_t) {}
 
    virtual void     SaveAs(const char *filename="",Option_t *option="") const;
@@ -116,6 +119,7 @@
    virtual void     SetRealNorm(Double_t rnorm) {fRealNorm = rnorm;}
    virtual void     SetRealTime(Double_t rtime) {fRealTime = rtime;}
    virtual void     SetTreeCacheSize(Int_t nbytes) {fTreeCacheSize = nbytes;}
+   virtual void     SetUnzipTime(Double_t uztime) {fUnzipTime = uztime;}
 
    ClassDef(TTreePerfStats,1)  // TTree I/O performance measurement
 };

Property changes on: tree/treeplayer
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /trunk/tree/treeplayer:r38055

